,file,flines,full_path,no_characters,no_lines,no_tokens,prog_lang,round,solution,task,username,year
0,D.py,"#!/usr/bin/env python
 
 def comb(a, b):
 	if a < b:
 		a, b = b, a
 	bin = 1
 	for i in xrange(1, b + 1):
 		bin = (bin * (a + i)) / i
 	return bin
 
 def solve():
 	H, W, R = [ int(n) for n in raw_input().split() ]
 	rocks = []
 	for r in range(R):
 		rocks.append([ int(n) for n in raw_input().split() ])
 	
 	def rec(x, y, w, h):
 		dx = w - x
 		dy = h - y
 		n = 0
 		for a in range(dx + 1):
 			b = dx - 2 * a
 			if 0 <= b <= dy and a + 2 * b == dy:
 				n = n + comb(a, b)
 		rocksLeft = [
 			( u, v ) for u, v in rocks
 			if x < u < w and y < v < h
 			]
 		for rx1, ry1 in rocksLeft:
 			for rx2, ry2 in rocksLeft:
 				if rx2 < rx1 and ry2 < ry1:
 					break
 			else:
 				n -= rec(x, y, rx1, ry1) * rec(rx1, ry1, w, h)
 
 		return n
 	
 	return rec(1, 1, W, H) % 10007
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32002/mth/24445/0/extracted/D.py,870,42,191,Python,32002,0,24445,mth,2008
1,A.py,"#!/usr/bin/env python
 
 import sys
 
 def solve():
 	numEngines = int(sys.stdin.readline())
 	engines = []
 	for _ in range(numEngines):
 		engine = sys.stdin.readline()
 		engines.append(engine)
 
 	numQueries = int(sys.stdin.readline())
 	queries = []
 	for _ in range(numQueries):
 		query = sys.stdin.readline()
 		queries.append(query)
 
 	remainingEngines = set(engines)
 	switches = 0
 	for query in queries:
 		remainingEngines.discard(query)
 		if not remainingEngines:
 			remainingEngines = set(engines)
 			remainingEngines.discard(query)
 			switches += 1
 
 	return switches
 
 cases = int(sys.stdin.readline())
 for case in range(cases):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32013/mth/24480/1/extracted/A.py,699,32,73,Python,32013,1,24480,mth,2008
2,C.py,"#!/usr/bin/env python
 
 import math, sys
 
 def solve():
 	flyRadius, racketRadius, racketBorder, stringRadius, gap = (
 		float(s) for s in sys.stdin.readline().split()
 		)
 
 	# Simplify by pretending the fly is a point.
 	racketBorder += flyRadius
 	stringRadius += flyRadius
 	gap -= 2 * flyRadius
 
 	# Because the racket is symmetric in two directions, we only have to
 	# look at one quarter.
 
 	missArea = 0.0
 	racketInner = racketRadius - racketBorder
 	racketInnerSq = racketInner ** 2
 	gridSpacing = 2 * stringRadius + gap
 	numStrings = int(racketInner / gridSpacing) + 1 # round up
 	for gridX in range(numStrings):
 		x0 = gridSpacing * gridX + stringRadius
 		x1 = x0 + gap
 		for gridY in range(numStrings):
 			y0 = gridSpacing * gridY + stringRadius
 			y1 = y0 + gap
 			d0 = x0 ** 2 + y0 ** 2
 			d1 = x1 ** 2 + y1 ** 2
 			if d0 > racketInnerSq:
 				# Grid cell is entirely outside.
 				pass
 			elif d1 < racketInnerSq:
 				# Grid cell is entirely inside.
 				missArea += gap ** 2
 			else:
 				# Grid cell is partially inside.
 				cx0 = math.sqrt(racketInnerSq - y0 ** 2)
 				cx1 = math.sqrt(max(racketInnerSq - y1 ** 2, 0.0))
 				cy0 = math.sqrt(racketInnerSq - x0 ** 2)
 				cy1 = math.sqrt(max(racketInnerSq - x1 ** 2, 0.0))
 				if cx1 > x0:
 					# Full grid height section.
 					missArea += (cx1 - x0) * gap
 				# Partial section.
 				# h(x) = sqrt(racketInnerSq - x ** 2) - y0
 				px0 = max(x0, cx1)
 				px1 = min(x1, cx0)
 				a = math.asin(px0 / racketInner) * 2
 				b = math.asin(px1 / racketInner) * 2
 				missArea += (racketInnerSq / 4) * (
 					(math.sin(b) + b) - (math.sin(a) + a)
 					) - y0 * (px1 - px0)
 				# Remaining section (if any) contributes 0.
 
 	totalArea = math.pi * racketRadius ** 2 / 4
 	return '%1.6f' % (1.0 - (missArea / totalArea))
 
 cases = int(sys.stdin.readline())
 for case in range(cases):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32013/mth/24479/0/extracted/C.py,1923,63,313,Python,32013,0,24479,mth,2008
3,B.py,"#!/usr/bin/env python
 
 import sys
 
 def parseTime(timeStr):
 	hours, minutes = ( int(s) for s in timeStr.split(':') )
 	return hours * 60 + minutes
 
 def parseTrips(numTrips):
 	departures = []
 	arrivals = []
 	for _ in range(numTrips):
 		depart, arrive = ( parseTime(s) for s in sys.stdin.readline().split() )
 		departures.append(depart)
 		arrivals.append(arrive)
 	return departures, arrivals
 
 def simulate(departures, arrivals, turnaround):
 	events = [ ( departure,  1 ) for departure in departures ] \
 		+ [ ( arrival + turnaround, -1 ) for arrival in arrivals ]
 	# Note: Sorting on second coordinate is important too.
 	events.sort()
 	trains = 0
 	worstShortage = 0
 	for time, delta in events:
 		trains -= delta
 		if trains < worstShortage:
 			worstShortage = trains
 	return -worstShortage
 
 def solve():
 	turnaround = int(sys.stdin.readline())
 	tripsA, tripsB = ( int(s) for s in sys.stdin.readline().split() )
 	departuresA, arrivalsB = parseTrips(tripsA)
 	departuresB, arrivalsA = parseTrips(tripsB)
 	return '%s %s' % (
 		simulate(departuresA, arrivalsA, turnaround),
 		simulate(departuresB, arrivalsB, turnaround)
 		)
 
 cases = int(sys.stdin.readline())
 for case in range(cases):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32013/mth/24481/1/extracted/B.py,1263,44,163,Python,32013,1,24481,mth,2008
4,A.py,"#!/usr/bin/env python
 
 inf = 1000000000
 
 class InnerNode(object):
 
 	def __init__(self, nodes, index, gate, change):
 		self.nodes = nodes
 		self.index = index
 		self.gate = gate
 		self.change = change
 
 	def produces(self):
 		left = self.nodes[self.index * 2].produces()
 		right = self.nodes[self.index * 2 + 1].produces()
 
 		orProd = (left[0] + right[0], min(left[1], right[1]))
 		andProd = (min(left[0], right[0]), left[1] + right[1])
 
 		if self.gate:
 			norm, alt = andProd, orProd
 		else:
 			norm, alt = orProd, andProd
 		if self.change:
 			return ( min(norm[0], alt[0] + 1), min(norm[1], alt[1] + 1) )
 		else:
 			return norm
 
 class LeafNode(object):
 
 	def __init__(self, value):
 		self.value = value
 
 	def produces(self):
 		return (inf, 0) if self.value else (0, inf)
 
 def solve():
 	M, V = [ int(i) for i in raw_input().split() ]
 	nodes = [ None ] * (M + 1)
 	for i in range(0, (M - 1) / 2):
 		G, C = [ int(j) for j in raw_input().split() ]
 		nodes[i + 1] = InnerNode(nodes, i + 1, G, bool(C))
 	for i in range(0, (M + 1) / 2):
 		nodes[(M - 1) / 2 + i + 1] = LeafNode(int(raw_input()))
 	minChange = nodes[1].produces()[V]
 	#for i in range((M - 1) / 2 + (M + 1) / 2):
 	#	print i + 1, nodes[i + 1].produces()
 	return 'IMPOSSIBLE' if minChange >= inf else minChange
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32001/mth/24439/1/extracted/A.py,1396,52,216,Python,32001,1,24439,mth,2008
5,D.py,"#!/usr/bin/env python
 
 def genperm(rem):
 	if rem:
 		for i in rem:
 			for perm in genperm(rem - set([i])):
 				yield [ i ] + perm
 	else:
 		yield []
 
 def permute(perm, s):
 	return ''.join(s[p] for p in perm)
 
 def compress(s):
 	prev = None
 	n = 0
 	for c in s:
 		if c != prev:
 			n += 1
 			prev = c
 	return n
 
 def solve():
 	permSize = int(raw_input())
 	data = raw_input()
 
 	permutations = list(genperm(set(range(permSize))))
 
 	clen = 1000000000
 	for perm in permutations:
 		permData = ''
 		for i in range(0, len(data), permSize):
 			permData += permute(perm, data[i : i + permSize])
 		clen = min(clen, compress(permData))
 
 	return clen
 
 import psyco
 psyco.full()
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32001/mth/24442/0/extracted/D.py,782,43,115,Python,32001,0,24442,mth,2008
6,B.py,"#!/usr/bin/env python
 
 def solve():
 	N, M, A = [ int(i) for i in raw_input().split() ]
 
 	for x in range(1, N + 1):
 		for y in range(1, M + 1):
 			if x * y < A:
 				continue
 			for a in range(0, x + 1):
 				for b in range(0, y + 1):
 					if x * y - a * b == A:
 						return ' '.join(str(i) for i in (
 							0, 0, x, b, a, y
 							))
 
 	return 'IMPOSSIBLE'
 
 import psyco
 psyco.full()
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32001/mth/24440/0/extracted/B.py,487,24,92,Python,32001,0,24440,mth,2008
7,C.py,"#!/usr/bin/env python
 
 def solve():
 	signs, genlen, X, Y, Z = [ int(i) for i in raw_input().split() ]
 	gen = []
 	for _ in range(genlen):
 		gen.append(int(raw_input()))
 
 	r = { -1: 1 }
 	for i in xrange(signs):
 		limit = gen[i % genlen]
 		gen[i % genlen] = (X * limit + Y * (i + 1)) % Z
 
 		s = {}
 		for j, n in r.iteritems():
 			s[j] = s.get(j, 0) + n
 			if limit > j:
 				s[limit] = s.get(limit, 0) + n
 		r = s
 
 	return (sum(s.itervalues()) - 1) % 1000000007
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32015/mth/24488/0/extracted/C.py,563,25,101,Python,32015,0,24488,mth,2008
8,B.py,"#!/usr/bin/env python
 
 def solve():
 	digits = raw_input()
 	numDigits = len(digits)
 
 	def numbers(start):
 		if start == numDigits:
 			assert False
 		s = {}
 		s[int(digits[start : ])] = 1
 		for i in range(start + 1, numDigits):
 			first = int(digits[start : i])
 			for n, f in numbers(i).iteritems():
 				s[first + n] = s.get(first + n, 0) + f
 				s[first - n] = s.get(first - n, 0) + f
 		return s
 	return sum(
 		f
 		for n, f in numbers(0).iteritems()
 		if n % 2 == 0 or n % 3 == 0 or n % 5 == 0 or n % 7 == 0
 		)
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32015/mth/24487/0/extracted/B.py,618,26,111,Python,32015,0,24487,mth,2008
9,A.py,"#!/usr/bin/env python
 
 def solve():
 	lpk, keys, alph = [ int(i) for i in raw_input().split() ]
 	freq = [ int(i) for i in raw_input().split() ]
 	assert len(freq) == alph
 	assert lpk * keys >= alph
 	freq.sort()
 	freq.reverse()
 	presses = 0
 	for repeat, index in enumerate(range(0, lpk * keys, keys)):
 		presses += sum(n for n in freq[index : index + keys]) * (repeat + 1)
 	return presses
 
 for case in range(int(raw_input())):
 	print 'Case #%d: %s' % (case + 1, solve())
",gcj/2008/32015/mth/24486/1/extracted/A.py,483,17,78,Python,32015,1,24486,mth,2008
10,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	n, k = (int(x) for x in inp.readline().split())
 	board = tuple(inp.readline().rstrip() for _ in xrange(n))
 	return board, k
 
 def rotate(board):
 	# Instead of rotating the board clockwise, we rotate gravity
 	# counter-clockwise.
 	n = len(board)
 	return tuple(
 		line.replace('.', '').zfill(n)
 		for line in board
 		)
 
 def findChain(board, length):
 	n = len(board)
 	winners = set()
 
 	def followVector(x, y, dx, dy):
 		prev = None
 		count = None
 		while 0 <= x < n and 0 <= y < n:
 			piece = board[y][x]
 			if piece == prev:
 				count += 1
 			else:
 				prev = piece
 				count = 1
 			if count == length:
 				winners.add(piece)
 			x += dx
 			y += dy
 
 	for x in xrange(n):
 		followVector(x, 0, 0, 1)
 		followVector(x, 0, 1, 1)
 		followVector(x, n - 1, 1, -1)
 	for y in xrange(n):
 		followVector(0, y, 1, 0)
 		followVector(0, y, 1, 1)
 		followVector(n - 1, y, -1, 1)
 
 	return winners
 
 def solve(board, k):
 	rotatedBoard = rotate(board)
 	if False:
 		for line in board:
 			print line
 		print
 		for line in rotatedBoard:
 			print line
 		print '---'
 	winners = findChain(rotatedBoard, k)
 	if 'R' in winners and 'B' in winners:
 		return 'Both'
 	elif 'R' not in winners and 'B' in winners:
 		return 'Blue'
 	elif 'R' in winners and 'B' not in winners:
 		return 'Red'
 	else:
 		return 'Neither'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/544101/mth/567116/1/extracted/A.py,2035,91,289,Python,544101,1,567116,mth,2010
11,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	n, k = (int(x) for x in inp.readline().split())
 	board = tuple(inp.readline().rstrip() for _ in xrange(n))
 	return board, k
 
 def rotate(board):
 	# Instead of rotating the board clockwise, we rotate gravity
 	# counter-clockwise.
 	n = len(board)
 	return tuple(
 		line.replace('.', '').zfill(n)
 		for line in board
 		)
 
 def findChain(board, length):
 	n = len(board)
 	winners = set()
 
 	def followVector(x, y, dx, dy):
 		prev = None
 		count = None
 		while 0 <= x < n and 0 <= y < n:
 			piece = board[y][x]
 			if piece == prev:
 				count += 1
 			else:
 				prev = piece
 				count = 1
 			if count == length:
 				winners.add(piece)
 			x += dx
 			y += dy
 
 	for x in xrange(n):
 		followVector(x, 0, 0, 1)
 		followVector(x, 0, 1, 1)
 		followVector(x, n - 1, 1, -1)
 	for y in xrange(n):
 		followVector(0, y, 1, 0)
 		followVector(0, y, 1, 1)
 		followVector(n - 1, y, -1, 1)
 
 	return winners
 
 def solve(board, k):
 	rotatedBoard = rotate(board)
 	if False:
 		for line in board:
 			print line
 		print
 		for line in rotatedBoard:
 			print line
 		print '---'
 	winners = findChain(rotatedBoard, k)
 	if 'R' in winners and 'B' in winners:
 		return 'Both'
 	elif 'R' not in winners and 'B' in winners:
 		return 'Blue'
 	elif 'R' in winners and 'B' not in winners:
 		return 'Red'
 	else:
 		return 'Neither'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/544101/mth/567116/0/extracted/A.py,2044,91,289,Python,544101,0,567116,mth,2010
12,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 
 from itertools import izip
 
 def parse(inp):
 	delCost, insCost, threshold, length = (
 		int(x) for x in inp.readline().split()
 		)
 	pixels = tuple(
 		int(x) for x in inp.readline().split()
 		)
 	assert len(pixels) == length
 	#pixelStr = ''.join(chr(pixel) for pixel in pixels)
 	return pixels, delCost, insCost, threshold
 
 def solve(pixels, delCost, insCost, threshold):
 	# Deleting everything is cheaper than this.
 	infinity = delCost * len(pixels) + 1
 	# best[i] = cumulative cost to get to previous pixel value i,
 	#           where the sequence up to now is smooth
 	best = [0] * 256
 	newBest = [None] * 256
 	for pixel in pixels:
 		#print pixel, best
 		for newValue in xrange(256):
 			# When using the previous value, the cost depends on the delta.
 			lo = max(0, newValue - threshold)
 			hi = min(255, newValue + threshold)
 			changeSum = min(best[lo : hi + 1]) + abs(newValue - pixel)
 
 			# When inserting we have to create a transition sequence that
 			# is smooth. The result value is the value of the input pixel.
 			# There is no point in using inserts if threshold is 0.
 			if newValue == pixel and threshold != 0:
 				insSum = min(
 					oldCost + insCost * max(
 						0, (abs(newValue - oldValue) - 1) / threshold
 						)
 					for oldValue, oldCost in enumerate(best)
 					)
 			else:
 				insSum = infinity
 
 			# When deleting we skip this pixel, so we're still at the same
 			# pixel value as before.
 			delSum = best[newValue] + delCost
 
 			newBest[newValue] = min(delSum, insSum, changeSum)
 		best, newBest = newBest, best
 	# End pixel value doesn't matter; pick cheapest.
 	return min(best)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/544101/mth/566101/1/extracted/B.py,2327,78,336,Python,544101,1,566101,mth,2010
13,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 
 from itertools import izip
 
 def parse(inp):
 	delCost, insCost, threshold, length = (
 		int(x) for x in inp.readline().split()
 		)
 	pixels = tuple(
 		int(x) for x in inp.readline().split()
 		)
 	assert len(pixels) == length
 	#pixelStr = ''.join(chr(pixel) for pixel in pixels)
 	return pixels, delCost, insCost, threshold
 
 def solve(pixels, delCost, insCost, threshold):
 	# Deleting everything is cheaper than this.
 	infinity = delCost * len(pixels) + 1
 	# best[i] = cumulative cost to get to previous pixel value i,
 	#           where the sequence up to now is smooth
 	best = [0] * 256
 	for pixel in pixels:
 		#print pixel, best
 		# When deleting we skip this pixel, so we're still at the same
 		# pixel value as before.
 		delBest = [cost + delCost for cost in best]
 		# When inserting we have to create a transition sequence that is smooth.
 		# The result value is the value of the input pixel.
 		insBest = [infinity] * 256
 		cost = infinity
 		for oldValue in xrange(256):
 			delta = abs(pixel - oldValue)
 			if threshold == 0:
 				if delta == 0:
 					numInserts = 0
 				else:
 					continue
 			else:
 				numInserts = max(0, (delta - 1) / threshold)
 			cost = min(cost, best[oldValue] + insCost * numInserts)
 		insBest[pixel] = cost
 		# When using the previous value, the cost depends on the delta.
 		changeBest = [None] * 256
 		for newValue in xrange(256):
 			cost = infinity
 			for oldValue in xrange(256):
 				if abs(oldValue - newValue) <= threshold:
 					# Transition is smooth.
 					cost = min(cost, best[oldValue] + abs(newValue - pixel))
 			changeBest[newValue] = cost
 		best = [ min(costs) for costs in izip(insBest, delBest, changeBest) ]
 	# End pixel value doesn't matter; pick cheapest.
 	return min(best)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/544101/mth/566101/0/extracted/B.py,2452,80,349,Python,544101,0,566101,mth,2010
14,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 
 def isPure(n, subset):
 	try:
 		while True:
 			n = subset.index(n) + 1
 	except ValueError:
 		return n == 1
 
 def precalc(n):
 	numPure = 0
 	for bits in xrange(1 << (n - 1)):
 		subset = []
 		for i in xrange(2, n + 1):
 			if (bits >> (i - 2)) & 1:
 				subset.append(i)
 		if isPure(n, subset):
 			numPure += 1
 	return numPure
 
 #numPure = tuple(precalc(n) for n in xrange(2, 25 + 1))
 numPure = (1, 2, 3, 5, 8, 14, 24, 43, 77, 140, 256, 472, 874, 1628, 3045, 5719, 10780, 20388, 38674, 73562, 140268, 268066, 513350, 984911)
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	return n,
 
 def solve(n):
 	return numPure[n - 2] % 100003
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635101/mth/598111/0/extracted/C.py,1352,56,195,Python,635101,0,598111,mth,2010
15,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 
 from collections import defaultdict
 
 def emptyTree():
 	return defaultdict(emptyTree)
 
 def insert(tree, path):
 	assert path[0] == ''
 	for name in path[1 : ]:
 		tree = tree[name]
 
 def parse(inp):
 	numExisting, numWanted = (int(x) for x in inp.readline().split())
 	existingTree = emptyTree()
 	for _ in xrange(numExisting):
 		path = inp.readline().rstrip().split('/')
 		insert(existingTree, path)
 	wantedTree = emptyTree()
 	for _ in xrange(numWanted):
 		path = inp.readline().rstrip().split('/')
 		insert(wantedTree, path)
 	return existingTree, wantedTree
 
 def countMissing(existingTree, wantedTree):
 	total = 0
 	for path in wantedTree.iterkeys():
 		if path not in existingTree:
 			total += 1
 		total += countMissing(existingTree[path], wantedTree[path])
 	return total
 
 def solve(existingTree, wantedTree):
 	return countMissing(existingTree, wantedTree)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635101/mth/563117/1/extracted/A.py,1559,61,174,Python,635101,1,563117,mth,2010
16,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 
 from collections import defaultdict
 
 def emptyTree():
 	return defaultdict(emptyTree)
 
 def insert(tree, path):
 	assert path[0] == ''
 	for name in path[1 : ]:
 		tree = tree[name]
 
 def parse(inp):
 	numExisting, numWanted = (int(x) for x in inp.readline().split())
 	existingTree = emptyTree()
 	for _ in xrange(numExisting):
 		path = inp.readline().rstrip().split('/')
 		insert(existingTree, path)
 	wantedTree = emptyTree()
 	for _ in xrange(numWanted):
 		path = inp.readline().rstrip().split('/')
 		insert(wantedTree, path)
 	return existingTree, wantedTree
 
 def countMissing(existingTree, wantedTree):
 	total = 0
 	for path in wantedTree.iterkeys():
 		if path not in existingTree:
 			total += 1
 		total += countMissing(existingTree[path], wantedTree[path])
 	return total
 
 def solve(existingTree, wantedTree):
 	return countMissing(existingTree, wantedTree)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635101/mth/563117/0/extracted/A.py,1568,61,174,Python,635101,0,563117,mth,2010
17,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 
 from itertools import izip
 
 def parse(inp):
 	numChicks, numArrive, barnDist, endTime = \
 		(int(x) for x in inp.readline().split())
 	startPos = tuple(int(x) for x in inp.readline().split())
 	assert len(startPos) == numChicks
 	speed = tuple(int(x) for x in inp.readline().split())
 	assert len(speed) == numChicks
 	return numArrive, barnDist, endTime, startPos, speed
 
 def solve(numArrive, barnDist, endTime, startPos, speed):
 	# Fast chicks are the ones that will make it to the barn if they are not
 	# held up by slow chicks.
 	fast = tuple(
 		x + v * endTime >= barnDist
 		for x, v in izip(startPos, speed)
 		)
 	#print numArrive, fast
 	target = numArrive
 	numSlow = 0
 	swaps = 0
 	for isFast in reversed(fast):
 		if isFast:
 			swaps += numSlow
 			target -= 1
 			if target == 0:
 				#print swaps
 				return swaps
 		else:
 			numSlow += 1
 	else:
 		return 0 if numArrive == 0 else 'IMPOSSIBLE'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635101/mth/542118/1/extracted/B.py,1599,62,219,Python,635101,1,542118,mth,2010
18,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt1'
 NUM_PROCESSES = 0
 
 from itertools import izip
 
 def parse(inp):
 	numChicks, numArrive, barnDist, endTime = \
 		(int(x) for x in inp.readline().split())
 	startPos = tuple(int(x) for x in inp.readline().split())
 	assert len(startPos) == numChicks
 	speed = tuple(int(x) for x in inp.readline().split())
 	assert len(speed) == numChicks
 	return numArrive, barnDist, endTime, startPos, speed
 
 def solve(numArrive, barnDist, endTime, startPos, speed):
 	# Fast chicks are the ones that will make it to the barn if they are not
 	# held up by slow chicks.
 	fast = tuple(
 		x + v * endTime >= barnDist
 		for x, v in izip(startPos, speed)
 		)
 	#print numArrive, fast
 	target = numArrive
 	numSlow = 0
 	swaps = 0
 	for isFast in reversed(fast):
 		if isFast:
 			swaps += numSlow
 			target -= 1
 			if target == 0:
 				#print swaps
 				return swaps
 		else:
 			numSlow += 1
 	else:
 		return 0 if numArrive == 0 else 'IMPOSSIBLE'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635101/mth/542118/0/extracted/B.py,1608,62,219,Python,635101,0,542118,mth,2010
19,C2.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	runs, size, numGroups = (int(x) for x in inp.readline().split())
 	groups = [int(x) for x in inp.readline().split()]
 	assert numGroups == len(groups)
 	return runs, size, groups
 
 def solve(runs, size, groups):
 	# Never put non-existant people in the coaster.
 	size = min(size, sum(groups))
 
 	numGroups = len(groups)
 	past = [ None ] * numGroups
 
 	pos = 0
 	money = 0
 	run = 0
 	while run < runs:
 		if past[pos] is None:
 			past[pos] = (run, money)
 		else:
 			pastRun, pastMoney = past[pos]
 			past = [ None ] * numGroups
 			period = run - pastRun
 			cycles = (runs - run) / period
 			if cycles != 0:
 				run += cycles * period
 				money += cycles * (money - pastMoney)
 				continue
 		boarded = 0
 		while True:
 			newBoarded = boarded + groups[pos]
 			if newBoarded > size:
 				break
 			boarded = newBoarded
 			pos = (pos + 1) % numGroups
 		money += boarded
 		run += 1
 
 	return money
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/433101/mth/509101/1/extracted/C2.py,1612,68,230,Python,433101,1,509101,mth,2010
20,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	runs, size, numGroups = (int(x) for x in inp.readline().split())
 	groups = [int(x) for x in inp.readline().split()]
 	assert numGroups == len(groups)
 	return runs, size, groups
 
 def solve(runs, size, groups):
 	# Never put non-existant people in the coaster.
 	size = min(size, sum(groups))
 
 	numGroups = len(groups)
 	pos = 0
 	money = 0
 	for run in xrange(runs):
 		boarded = 0
 		while True:
 			newBoarded = boarded + groups[pos]
 			if newBoarded > size:
 				break
 			boarded = newBoarded
 			pos = (pos + 1) % numGroups
 		money += boarded
 
 	return money
 
 if __name__ == '__main__':
 	from multiprocessing import Pool
 	pool = Pool(NUM_PROCESSES)
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	results = [
 		pool.apply_async(solve, parse(inp))
 		for _ in range(numCases)
 		]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		out.write('Case #%d: %s\n' % (case + 1, result.get()))
 		out.flush()
 	out.close()
",gcj/2010/433101/mth/509101/0/extracted/C.py,1114,46,145,Python,433101,0,509101,mth,2010
21,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	numbers = [int(x) for x in inp.readline().split()]
 	length = numbers[0]
 	assert length == len(numbers) - 1
 	return numbers[1 : ],
 
 def gcd(a, b):
 	'''Returns the greatest common divisor of a and b.
 	'''
 	while a != 0:
 		a, b = b % a, a
 	return b
 
 def solve(events):
 	events = sorted(events)
 	intervals = [
 		events[i + 1] - events[i]
 		for i in xrange(len(events) - 1)
 		]
 	divider = reduce(gcd, intervals, 0)
 	phase = events[0] % divider
 	#print divider, phase, events
 	return 0 if phase == 0 else divider - phase
 
 if __name__ == '__main__':
 	from multiprocessing import Pool
 	pool = Pool(NUM_PROCESSES)
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	results = [
 		pool.apply_async(solve, parse(inp))
 		for _ in range(numCases)
 		]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		out.write('Case #%d: %s\n' % (case + 1, result.get()))
 		out.flush()
 	out.close()
",gcj/2010/433101/mth/506101/1/extracted/B.py,1069,45,152,Python,433101,1,506101,mth,2010
22,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	numbers = [int(x) for x in inp.readline().split()]
 	length = numbers[0]
 	assert length == len(numbers) - 1
 	return numbers[1 : ],
 
 def gcd(a, b):
 	'''Returns the greatest common divisor of a and b.
 	'''
 	while a != 0:
 		a, b = b % a, a
 	return b
 
 def solve(events):
 	events = sorted(events)
 	intervals = [
 		events[i + 1] - events[i]
 		for i in xrange(len(events) - 1)
 		]
 	divider = reduce(gcd, intervals, 0)
 	phase = events[0] % divider
 	#print divider, phase, events
 	return 0 if phase == 0 else divider - phase
 
 if __name__ == '__main__':
 	from multiprocessing import Pool
 	pool = Pool(NUM_PROCESSES)
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	results = [
 		pool.apply_async(solve, parse(inp))
 		for _ in range(numCases)
 		]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		out.write('Case #%d: %s\n' % (case + 1, result.get()))
 		out.flush()
 	out.close()
",gcj/2010/433101/mth/506101/0/extracted/B.py,1078,45,152,Python,433101,0,506101,mth,2010
23,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	length, snaps = (int(x) for x in inp.readline().split())
 	return length, snaps
 
 def solve(length, snaps):
 	allOn = (1 << length) - 1
 	return 'ON' if (snaps & allOn) == allOn else 'OFF'
 
 if __name__ == '__main__':
 	from multiprocessing import Pool
 	pool = Pool(NUM_PROCESSES)
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	results = [
 		pool.apply_async(solve, parse(inp))
 		for _ in range(numCases)
 		]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		out.write('Case #%d: %s\n' % (case + 1, result.get()))
 		out.flush()
 	out.close()
",gcj/2010/433101/mth/502103/1/extracted/A.py,723,29,93,Python,433101,1,502103,mth,2010
24,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	length, snaps = (int(x) for x in inp.readline().split())
 	return length, snaps
 
 def solve(length, snaps):
 	print length, snaps
 	allOn = (1 << length) - 1
 	return 'ON' if (snaps & allOn) == allOn else 'OFF'
 
 if __name__ == '__main__':
 	from multiprocessing import Pool
 	pool = Pool(NUM_PROCESSES)
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	results = [
 		pool.apply_async(solve, parse(inp))
 		for _ in range(numCases)
 		]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		out.write('Case #%d: %s\n' % (case + 1, result.get()))
 		out.flush()
 	out.close()
",gcj/2010/433101/mth/502103/0/extracted/A.py,754,30,96,Python,433101,0,502103,mth,2010
25,B.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'B-test1'
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	numRounds, = (int(x) for x in inp.readline().split())
 	maxMiss = tuple(int(x) for x in inp.readline().split())
 	assert len(maxMiss) == 2 ** numRounds
 	matchPrices = []
 	for i in xrange(numRounds):
 		prices = tuple(int(x) for x in inp.readline().split())
 		assert len(prices) == 2 ** (numRounds - i - 1)
 		matchPrices.append(prices)
 	return numRounds, maxMiss, matchPrices
 
 infinity = 1024 * 100000
 
 def buildTree(numRounds, maxMiss, matchPrices):
 	children = [
 		(None, None, infinity, miss)
 		for miss in maxMiss
 		]
 	for prices in matchPrices:
 		siblings = []
 		for i, price in enumerate(prices):
 			l = children[i * 2]
 			r = children[i * 2 + 1]
 			node = (l, r, price, min(l[3], r[3]) - 1)
 			siblings.append(node)
 		children = siblings
 	assert len(children) == 1
 	return children[0]
 
 def minCost(trees):
 	ltrees = []
 	rtrees = []
 	for l, r, price, miss in trees:
 		ltrees.append(l)
 		rtrees.append(r)
 	if ltrees[0] is None:
 		return [infinity if tree[3] < 0 else 0 for tree in trees]
 	lmin = minCost(ltrees)
 	rmin = minCost(rtrees)
 	ret = []
 	for i, tree in enumerate(trees):
 		l, r, price, miss = tree
 		cost = lmin[i] + rmin[i]
 		if miss < 0:
 			cost += price
 			try:
 				nl = lmin[i + 1]
 				nr = rmin[i + 1]
 			except IndexError:
 				pass
 			else:
 				cost = min(cost, nl + nr)
 		ret.append(cost)
 	return ret
 
 def solve(numRounds, maxMiss, matchPrices):
 	costTrees = []
 	for i in xrange(numRounds):
 		adjustedMiss = [miss - i for miss in maxMiss]
 		tree = buildTree(numRounds, adjustedMiss, matchPrices)
 		costTrees.append(tree)
 	return minCost(costTrees)[0]
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635102/mth/698485/1/extracted/B.py,2353,92,318,Python,635102,1,698485,mth,2010
26,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numRounds, = (int(x) for x in inp.readline().split())
 	maxMiss = tuple(int(x) for x in inp.readline().split())
 	assert len(maxMiss) == 2 ** numRounds
 	matchPrices = []
 	for i in xrange(numRounds):
 		prices = tuple(int(x) for x in inp.readline().split())
 		assert len(prices) == 2 ** (numRounds - i - 1)
 		matchPrices.append(prices)
 	return numRounds, maxMiss, matchPrices
 
 def cost(l, r, price, miss):
 	ret = 0
 	if l is not None:
 		ret += cost(*l)
 		ret += cost(*r)
 	if miss < 0:
 		ret += price
 	return ret
 
 def solve(numRounds, maxMiss, matchPrices):
 	children = [ None ] * (2 ** numRounds)
 	for prices in matchPrices:
 		siblings = []
 		for i, price in enumerate(prices):
 			l = children[i * 2]
 			r = children[i * 2 + 1]
 			lm = maxMiss[i * 2] if l is None else l[3]
 			rm = maxMiss[i * 2 + 1] if r is None else r[3]
 			node = (l, r, price, min(lm, rm) - 1)
 			siblings.append(node)
 		children = siblings
 	assert len(children) == 1
 	tree = children[0]
 
 	return cost(*tree)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2010/635102/mth/698485/0/extracted/B.py,1714,65,245,Python,635102,0,698485,mth,2010
27,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numCandies, = (int(x) for x in inp.readline().split())
 	candyValues = [ int(x) for x in inp.readline().split() ]
 	assert len(candyValues) == numCandies
 	return candyValues,
 
 def solve(candyValues):
 	xorValue = reduce(int.__xor__, candyValues, 0)
 	if xorValue == 0:
 		return sum(candyValues) - min(candyValues)
 	else:
 		return 'NO'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/975485/mth/1059486/1/extracted/C.py,1045,41,125,Python,975485,1,1059486,mth,2011
28,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numCandies, = (int(x) for x in inp.readline().split())
 	candyValues = [ int(x) for x in inp.readline().split() ]
 	assert len(candyValues) == numCandies
 	return candyValues,
 
 def solve(candyValues):
 	xorValue = reduce(int.__xor__, candyValues, 0)
 	if xorValue == 0:
 		return sum(candyValues) - min(candyValues)
 	else:
 		return 'NO'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/975485/mth/1059486/0/extracted/C.py,1054,41,125,Python,975485,0,1059486,mth,2011
29,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	parts = inp.readline().split()
 	numPushes = int(parts[0])
 	assert numPushes * 2 + 1 == len(parts)
 	which = parts[1 : : 2]
 	where = [ int(x) for x in parts[2 : : 2] ]
 	assert len(which) == len(where)
 	return which, where
 
 def solve(which, where):
 	now = 0
 	pos = { 'B': (1, now), 'O': (1, now) }
 	for who, to in zip(which, where):
 		(fr, t) = pos[who]
 		t += abs(fr - to)
 		t = max(now, t) + 1
 		pos[who] = (to, t)
 		now = t
 	return now
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/975485/mth/1080487/1/extracted/A.py,1157,48,170,Python,975485,1,1080487,mth,2011
30,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	parts = inp.readline().split()
 	numPushes = int(parts[0])
 	assert numPushes * 2 + 1 == len(parts)
 	which = parts[1 : : 2]
 	where = [ int(x) for x in parts[2 : : 2] ]
 	assert len(which) == len(where)
 	return which, where
 
 def solve(which, where):
 	now = 0
 	pos = { 'B': (1, now), 'O': (1, now) }
 	for who, to in zip(which, where):
 		(fr, t) = pos[who]
 		t += abs(fr - to)
 		t = max(now, t) + 1
 		pos[who] = (to, t)
 		now = t
 	return now
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/975485/mth/1080487/0/extracted/A.py,1166,48,170,Python,975485,0,1080487,mth,2011
31,B.py,"#!/usr/bin/env python
 
 from collections import defaultdict
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	i = iter(inp.readline().split())
 	numProductions = int(i.next())
 	productions = [ i.next() for _ in xrange(numProductions) ]
 	numOpposed = int(i.next())
 	opposed = [ i.next() for _ in xrange(numOpposed) ]
 	numInvoked = int(i.next())
 	invoked = i.next()
 	assert len(invoked) == numInvoked
 	assert len(list(i)) == 0
 	return productions, opposed, invoked
 
 def solve(productions, opposed, invoked):
 	productionMap = {}
 	for base1, base2, nonbase in productions:
 		productionMap[base1 + base2] = nonbase
 		productionMap[base2 + base1] = nonbase
 	#print 'prod', productionMap
 	
 	opposedMap = defaultdict(set)
 	for base1, base2 in opposed:
 		opposedMap[base1].add(base2)
 		opposedMap[base2].add(base1)
 	#print 'opp', opposedMap
 	
 	elem = []
 	for base in invoked:
 		elem.append(base)
 		if len(elem) < 2:
 			produced = None
 		else:
 			produced = productionMap.get(elem[-2] + elem[-1])
 		if produced is not None:
 			elem = elem[ : -2] + [ produced ]
 		else:
 			opposites = opposedMap.get(base)
 			if opposites is not None and opposites & set(elem[ : -1]):
 				elem = []
 				
 	return '[%s]' % (', '.join(elem))
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/975485/mth/1026487/1/extracted/B.py,1881,71,231,Python,975485,1,1026487,mth,2011
32,B.py,"#!/usr/bin/env python
 
 from collections import defaultdict
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	i = iter(inp.readline().split())
 	numProductions = int(i.next())
 	productions = [ i.next() for _ in xrange(numProductions) ]
 	numOpposed = int(i.next())
 	opposed = [ i.next() for _ in xrange(numOpposed) ]
 	numInvoked = int(i.next())
 	invoked = i.next()
 	assert len(invoked) == numInvoked
 	assert len(list(i)) == 0
 	return productions, opposed, invoked
 
 def solve(productions, opposed, invoked):
 	productionMap = {}
 	for base1, base2, nonbase in productions:
 		productionMap[base1 + base2] = nonbase
 		productionMap[base2 + base1] = nonbase
 	#print 'prod', productionMap
 	
 	opposedMap = defaultdict(set)
 	for base1, base2 in opposed:
 		opposedMap[base1].add(base2)
 		opposedMap[base2].add(base1)
 	#print 'opp', opposedMap
 	
 	elem = []
 	for base in invoked:
 		elem.append(base)
 		if len(elem) < 2:
 			produced = None
 		else:
 			produced = productionMap.get(elem[-2] + elem[-1])
 		if produced is not None:
 			elem = elem[ : -2] + [ produced ]
 		else:
 			opposites = opposedMap.get(base)
 			if opposites is not None and opposites & set(elem[ : -1]):
 				elem = []
 				
 	return '[%s]' % (', '.join(elem))
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/975485/mth/1026487/0/extracted/B.py,1890,71,231,Python,975485,0,1026487,mth,2011
33,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-2'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	length, walkSpd, runSpd, runTime, numWalkways = (int(x) for x in inp.readline().split())
 	walkways = [
 		tuple(float(x) for x in inp.readline().split())
 		for _ in xrange(numWalkways)
 		]
 	return length, walkSpd, runSpd, runTime, walkways
 
 def solve(length, walkSpd, runSpd, runTime, walkways):
 	length = float(length)
 	walkSpd = float(walkSpd)
 	runSpd = float(runSpd)
 	runTime = float(runTime)
 	walkways.append((length, length, 0.0))
 	#walkways.sort()
 	
 	t = 0.0
 	x = 0.0
 	walkIndex = 0
 	while x < length:
 		begin, end, waySpd = walkways[walkIndex]
 		mySpd = runSpd if t < runTime else walkSpd
 		if x < begin:
 			speed = mySpd
 			endX = begin
 		else:
 			speed = waySpd + mySpd
 			endX = end
 		endT = t + (endX - x) / speed
 		if t < runTime and endT > runTime:
 			endT = runTime
 			x += (endT - t) * speed
 		else:
 			x = endX
 		t = endT
 		if x >= end:
 			walkIndex += 1
 	
 	return '%1.10f' % t
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1150486/mth/1163489/0/extracted/A.py,1636,68,228,Python,1150486,0,1163489,mth,2011
34,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-1'
 NUM_PROCESSES = 8
 
 def parse(inp):
 	rows, cols, baseMass = (int(x) for x in inp.readline().split())
 	sheet = []
 	for _ in xrange(rows):
 		line = tuple(int(x) for x in inp.readline().strip())
 		assert len(line) == cols
 		sheet.append(line)
 	return rows, cols, sheet
 
 def solve(rows, cols, sheet):
 
 	def possible(size):
 		for y0 in xrange(rows - size + 1):
 			for x0 in xrange(cols - size + 1):
 				xs = 0
 				ys = 0
 				for yi in xrange(size):
 					yo = -size + 1 + 2 * yi
 					for xi in xrange(size):
 						if not ((xi == 0 or xi == size -1) and (yi == 0 or yi == size - 1)):
 							xo = -size + 1 + 2 * xi
 							m = sheet[y0 + yi][x0 + xi]
 							xs += xo * m
 							ys += yo * m
 				#print size, x0, y0, xs, ys
 				if xs == 0 and ys == 0:
 					return True
 		return False
 
 	size = 3
 	maxSize = min(rows, cols)
 	largestPossible = None
 	for size in xrange(3, maxSize + 1):
 		if possible(size):
 			largestPossible = size
 	
 	return 'IMPOSSIBLE' if largestPossible is None else '%s' % largestPossible
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1150486/mth/1160486/0/extracted/B.py,1703,66,258,Python,1150486,0,1160486,mth,2011
35,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large-0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	maxToday, winToday, winEver = (int(x) for x in inp.readline().split())
 	return maxToday, winToday, winEver
 
 def gcd(a, b):
 	'''Returns the greatest common divisor of a and b.
 	'''
 	while a != 0:
 		a, b = b % a, a
 	return b
 
 def lcm(a, b):
 	'''Returns the least common multiple of a and b.
 	'''
 	d = gcd(a, b)
 	return (a / d) * b
 
 def solve(maxToday, percWinToday, percWinEver):
 	# percWinEver = 100 * numWinEver / numPlayedEver
 	# percWinToday = 100 * numWinToday / numPlayedToday
 	# percWinEver is integer
 	# percWinToday is integer
 	# 0 <= numWinToday <= numWinEver
 	# 0 <= numWinToday <= maxToday
 	# 1 <= numPlayedToday <= numPlayedEver
 	# numPlayedEver - numWinEver >= numPlayedToday - numWinToday
 	#   numPlayedEver - numPlayedToday >= numWinEver - numWinToday
 	#
 	# percWin * numPlayed = 100 * numWin = k * lcm = k * gcd * percWin * 100
 	# k > 0 because we played at least one game today (and therefore ever)
 	#
 	# numPlayed = k * 100 / gcd
 	
 	stepToday = 100 / gcd(percWinToday, 100)
 	possible = (
 		stepToday <= maxToday
 		and (percWinEver > 0 or percWinToday == 0)
 		and (percWinEver < 100 or percWinToday == 100)
 		)
 	return 'Possible' if possible else 'Broken'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1145485/mth/1040487/1/extracted/A.py,1916,69,289,Python,1145485,1,1040487,mth,2011
36,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	maxToday, winToday, winEver = (int(x) for x in inp.readline().split())
 	return maxToday, winToday, winEver
 
 def gcd(a, b):
 	'''Returns the greatest common divisor of a and b.
 	'''
 	while a != 0:
 		a, b = b % a, a
 	return b
 
 def lcm(a, b):
 	'''Returns the least common multiple of a and b.
 	'''
 	d = gcd(a, b)
 	return (a / d) * b
 
 def solve(maxToday, percWinToday, percWinEver):
 	# percWinEver = 100 * numWinEver / numPlayedEver
 	# percWinToday = 100 * numWinToday / numPlayedToday
 	# percWinEver is integer
 	# percWinToday is integer
 	# 0 <= numWinToday <= numWinEver
 	# 0 <= numWinToday <= maxToday
 	# 1 <= numPlayedToday <= numPlayedEver
 	# numPlayedEver - numWinEver >= numPlayedToday - numWinToday
 	#   numPlayedEver - numPlayedToday >= numWinEver - numWinToday
 	#
 	# percWin * numPlayed = 100 * numWin = k * lcm = k * gcd * percWin * 100
 	# k > 0 because we played at least one game today (and therefore ever)
 	#
 	# numPlayed = k * 100 / gcd
 	
 	possible = False
 	stepToday = 100 / gcd(percWinToday, 100)
 	numPlayedToday = 0
 	while True:
 		numPlayedToday += stepToday
 		if numPlayedToday > maxToday:
 			break
 		numWonToday = (numPlayedToday * percWinToday) / 100
 		numLostToday = numPlayedToday - numWonToday
 		#print numWonToday, numLostToday
 		if (percWinEver > 0 or numWonToday == 0) and (percWinEver < 100 or numLostToday == 0):
 			possible = True
 			break
 	
 	return 'Possible' if possible else 'Broken'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1145485/mth/1040487/0/extracted/A.py,2164,77,317,Python,1145485,0,1040487,mth,2011
37,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large-0'
 NUM_PROCESSES = 0
 
 from itertools import izip
 
 def parse(inp):
 	numPoints, minDist = (int(x) for x in inp.readline().split())
 	points = tuple(
 		(int(x) for x in inp.readline().split())
 		for _ in xrange(numPoints)
 		)
 	return points, minDist
 
 def solve(points, minDist):
 	flatPoints = []
 	for x, v in points:
 		flatPoints.extend([x] * v)
 	flatPoints = sorted(flatPoints)
 	#print flatPoints
 	
 	prePoints = [ (x - i * minDist) * 2 for i, x in enumerate(flatPoints) ]
 	
 	preMax = []
 	m = None
 	for x in prePoints:
 		preMax.append(m)
 		m = max(m, x)
 	
 	dists = []
 	for x, m in izip(prePoints, preMax):
 		dists.append(None if m is None else m - x)
 	maxDist = max(dists)
 	
 	t2 = max(0, maxDist)
 	return '%1.1f' % (0.25 * t2)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1150485/mth/1058489/1/extracted/B.py,1420,61,194,Python,1150485,1,1058489,mth,2011
38,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numPoints, minDist = (int(x) for x in inp.readline().split())
 	points = tuple(
 		(int(x) for x in inp.readline().split())
 		for _ in xrange(numPoints)
 		)
 	return points, minDist
 
 def solve(points, minDist):
 	flatPoints = []
 	for x, v in points:
 		flatPoints.extend([x] * v)
 	flatPoints = sorted(flatPoints)
 	print flatPoints
 	
 	def possible(t):
 		xn = None
 		for hx in flatPoints:
 			r = 2 * hx + t
 			if r < xn:
 				return False
 			l = 2 * hx - t
 			xn = max(xn, l) + 2 * minDist
 		return True
 	
 	t = 0
 	while not possible(t):
 		t += 1
 	
 	return '%1.1f' % (0.5 * t)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1150485/mth/1058489/0/extracted/B.py,1302,59,182,Python,1150485,0,1058489,mth,2011
39,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large-0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numTeams, = (int(x) for x in inp.readline().split())
 	numWon = [ 0 ] * numTeams
 	numPlayed = [ 0 ] * numTeams
 	opponents = [ [] for _ in xrange(numTeams) ]
 	results = []
 	for team in xrange(numTeams):
 		line = inp.readline().strip()
 		lineRes = []
 		assert len(line) == numTeams
 		for opp, resCh in enumerate(line):
 			if resCh == '.':
 				res = None
 			else:
 				numPlayed[team] += 1
 				opponents[team].append(opp)
 				res = int(resCh)
 				numWon[team] += res
 			lineRes.append(res)
 		results.append(lineRes)
 	return results, numWon, numPlayed, opponents
 
 def solve(results, numWon, numPlayed, opponents):
 	numTeams = len(numWon)
 	
 	wp = [ None ] * numTeams
 	for team in xrange(numTeams):
 		wp[team] = numWon[team] / float(numPlayed[team])
 	
 	owp = [ None ] * numTeams
 	for team in xrange(numTeams):
 		owp[team] = sum(
 			(numWon[opp] - results[opp][team]) / float(numPlayed[opp] - 1)
 			for opp in opponents[team]
 			) / numPlayed[team]
 
 	oowp = [ None ] * numTeams
 	for team in xrange(numTeams):
 		oowp[team] = sum(
 			owp[opp]
 			for opp in opponents[team]
 			) / numPlayed[team]
 	
 	return '\n' + '\n'.join(
 		'%0.12f' % (0.25 * (wp[team] + 2 * owp[team] + oowp[team]))
 		for team in xrange(numTeams)
 		)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1150485/mth/1048486/1/extracted/A.py,1961,76,256,Python,1150485,1,1048486,mth,2011
40,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numTeams, = (int(x) for x in inp.readline().split())
 	numWon = [ 0 ] * numTeams
 	numPlayed = [ 0 ] * numTeams
 	opponents = [ [] for _ in xrange(numTeams) ]
 	results = []
 	for team in xrange(numTeams):
 		line = inp.readline().strip()
 		lineRes = []
 		assert len(line) == numTeams
 		for opp, resCh in enumerate(line):
 			if resCh == '.':
 				res = None
 			else:
 				numPlayed[team] += 1
 				opponents[team].append(opp)
 				res = int(resCh)
 				numWon[team] += res
 			lineRes.append(res)
 		results.append(lineRes)
 	return results, numWon, numPlayed, opponents
 
 def solve(results, numWon, numPlayed, opponents):
 	numTeams = len(numWon)
 	
 	wp = [ None ] * numTeams
 	for team in xrange(numTeams):
 		wp[team] = numWon[team] / float(numPlayed[team])
 	
 	owp = [ None ] * numTeams
 	for team in xrange(numTeams):
 		owp[team] = sum(
 			(numWon[opp] - results[opp][team]) / float(numPlayed[opp] - 1)
 			for opp in opponents[team]
 			) / numPlayed[team]
 
 	oowp = [ None ] * numTeams
 	for team in xrange(numTeams):
 		oowp[team] = sum(
 			owp[opp]
 			for opp in opponents[team]
 			) / numPlayed[team]
 	
 	return '\n' + '\n'.join(
 		'%0.12f' % (0.25 * (wp[team] + 2 * owp[team] + oowp[team]))
 		for team in xrange(numTeams)
 		)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2011/1150485/mth/1048486/0/extracted/A.py,1961,76,256,Python,1150485,0,1048486,mth,2011
41,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-small-attempt0'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	numRows, numCols = (int(x) for x in inp.readline().split())
 	grid = tuple(
 		inp.readline().strip()
 		for _ in xrange(numRows)
 		)
 	boolGrid = []
 	caves = [ None ] * 10
 	assert len(grid) == numRows
 	for y, row in enumerate(grid):
 		assert len(row) == numCols
 		boolRow = []
 		for x, c in enumerate(row):
 			if c.isdigit():
 				i = int(c)
 				assert caves[i] is None
 				caves[i] = (x, y)
 				boolRow.append(True)
 			else:
 				boolRow.append(c == '.')
 		boolGrid.append(tuple(boolRow))
 	numCaves = sum(cave is not None for cave in caves)
 	assert all(caves[i] is not None for i in xrange(numCaves))
 	assert all(caves[i] is None for i in xrange(numCaves, len(caves)))
 	return tuple(boolGrid), caves[ : numCaves]
 
 def solve(grid, caves):
 	def computeReach(start):
 		reach = set()
 		newReach = set([ start ])
 		while newReach:
 			pos = newReach.pop()
 			if pos not in reach:
 				reach.add(pos)
 				x, y = pos
 				if grid[y - 1][x]:
 					if (x, y - 1) not in reach:
 						newReach.add((x, y - 1))
 				if grid[y][x - 1]:
 					if (x - 1, y) not in reach:
 						newReach.add((x - 1, y))
 				if grid[y][x + 1]:
 					if (x + 1, y) not in reach:
 						newReach.add((x + 1, y))
 		return reach
 
 	def computeLucky(start):
 		def applyMove(positions, dx, dy):
 			moved = set()
 			for x, y in positions:
 				if grid[y + dy][x + dx]:
 					x += dx
 					y += dy
 					if (x, y) not in start:
 						return None
 				moved.add((x, y))
 			return frozenset(moved)
 
 		reach = set()
 		newReach = set([ frozenset(start) ])
 		while newReach:
 			pos = newReach.pop()
 			if pos not in reach:
 				reach.add(pos)
 				moved = applyMove(pos, 0, 1)
 				if moved is not None:
 					if moved not in reach:
 						newReach.add(moved)
 				moved = applyMove(pos, -1, 0)
 				if moved is not None:
 					if moved not in reach:
 						newReach.add(moved)
 				moved = applyMove(pos, 1, 0)
 				if moved is not None:
 					if moved not in reach:
 						newReach.add(moved)
 		return reach
 
 	ret = []
 	for cave in caves:
 		reachable = computeReach(cave)
 		final = computeLucky(reachable)
 		lucky = any(
 			len(reach) == 1 and reach.__iter__().next() == cave
 			for reach in final
 			)
 		ret.append((len(reachable), lucky))
 	return ret
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d:\n' % (case + 1))
 		for i, (reachable, lucky) in enumerate(value):
 			out.write('%d: %d %s\n' % (
 				i, reachable, 'Lucky' if lucky else 'Unlucky'
 				))
 		out.flush()
 	out.close()
",gcj/2012/1842485/mth/1480495/0/extracted/D.py,3100,121,419,Python,1842485,0,1480495,mth,2012
42,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 
 import sys
 sys.setrecursionlimit(20000)
 
 def parse(inp):
 	numVines = int(inp.readline())
 	vines = [
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numVines)
 		]
 	dest = int(inp.readline())
 	vines.append((dest, 0))
 	return tuple(vines),
 
 def solve(vines):
 	numVines = len(vines)
 
 	tried = [0] * numVines
 	def rec(i, l):
 		if i == numVines - 1:
 			return True
 		else:
 			longest = tried[i]
 			if l < longest:
 				return False
 			tried[i] = l
 			di, li = vines[i]
 			for j in xrange(i + 1, numVines):
 				dj, lj = vines[j]
 				if di + l >= dj:
 					if rec(j, min(lj, dj - di)):
 						return True
 				else:
 					break
 			return False
 
 	return 'YES' if rec(0, vines[0][0]) else 'NO'
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1842485/mth/1481486/1/extracted/A.py,1410,65,185,Python,1842485,1,1481486,mth,2012
43,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numbers = tuple(int(x) for x in inp.readline().split())
 	numCont = numbers[0]
 	scores = numbers[1 : ]
 	assert len(scores) == numCont
 	return scores,
 
 def solve(scores):
 	total = sum(scores)
 
 	sortedScores = sorted(scores)
 	cumulative = 0
 	for i in xrange(1, len(sortedScores)):
 		cumulative += sortedScores[i - 1]
 		nextScore = sortedScores[i]
 		if cumulative + total < nextScore * i:
 			unsafeCount = i
 			break
 	else:
 		unsafeCount = len(sortedScores)
 	safeLevel = float(sum(sortedScores[ : unsafeCount]) + total) / unsafeCount
 
 	fractions = [max(safeLevel - score, 0) / total for score in scores]
 
 	return ' '.join('%f' % (f * 100) for f in fractions)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1842485/mth/1481486/0/extracted/A.py,1374,54,178,Python,1842485,0,1481486,mth,2012
44,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	numbers = tuple(int(x) for x in inp.readline().split())
 	numCont = numbers[0]
 	scores = numbers[1 : ]
 	assert len(scores) == numCont
 	return scores,
 
 def solve(scores):
 	total = sum(scores)
 
 	sortedScores = sorted(scores)
 	cumulative = 0
 	for i in xrange(1, len(sortedScores)):
 		cumulative += sortedScores[i - 1]
 		nextScore = sortedScores[i]
 		if cumulative + total < nextScore * i:
 			unsafeCount = i
 			break
 	else:
 		unsafeCount = len(sortedScores)
 	safeLevel = float(sum(sortedScores[ : unsafeCount]) + total) / unsafeCount
 
 	fractions = [max(safeLevel - score, 0) / total for score in scores]
 
 	return ' '.join('%f' % (f * 100) for f in fractions)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1836486/mth/1480487/0/extracted/A.py,1383,54,178,Python,1836486,0,1480487,mth,2012
45,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def parse(inp):
 	water, rows, cols = (int(x) for x in inp.readline().split())
 	ceilings = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(rows)
 		)
 	assert all(len(ceiling) == cols for ceiling in ceilings)
 	floors = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(rows)
 		)
 	assert all(len(floor) == cols for floor in floors)
 	return floors, ceilings, water
 
 def solve(floors, ceilings, water):
 	rows = len(ceilings)
 	cols = len(ceilings[0])
 
 	# Compute in decaseconds, to avoid floating points.
 	#INFINITY = 100000 + 100 * 100 * 100
 	INFINITY = 1 << 30
 
 	# Determine when a square will become reachable from each of its neighbours.
 	deltas = ((0, -1), (1, 0), (0, 1), (-1, 0))
 	reach = []
 	for y in xrange(rows):
 		reachLine = []
 		for x in xrange(cols):
 			reachSquare = []
 			for dx, dy in deltas:
 				nx = x + dx
 				ny = y + dy
 				if 0 <= nx < cols and 0 <= ny < rows:
 					fh = floors[y][x]
 					ch = ceilings[y][x]
 					fn = floors[ny][nx]
 					cn = ceilings[ny][nx]
 					if max(fh, fn) + 50 > cn:
 						r = INFINITY
 					elif fn + 50 > ch:
 						r = INFINITY
 					else:
 						r = max(water - cn + 50, 0)
 				else:
 					r = INFINITY
 				reachSquare.append(r)
 			reachLine.append(reachSquare)
 		reach.append(reachLine)
 
 	start = (0, 0)
 	exit = (cols - 1, rows - 1)
 
 	newReached = start
 	time = 0
 	reachAt = {}
 	reached = set()
 	reachAtLast = []
 	while newReached != exit:
 		reached.add(newReached)
 		x, y = newReached
 		for (dx, dy), rt in zip(deltas, reach[y][x]):
 			if rt < INFINITY:
 				nx = x + dx
 				ny = y + dy
 				nxy = nx, ny
 				if nxy not in reached:
 					rt = max(time, rt)
 					if rt > 0:
 						wt = water - rt
 						rt += 10 if wt >= floors[y][x] + 20 else 100
 					best = reachAt.get(nxy, INFINITY)
 					if rt < best:
 						if best == INFINITY:
 							oi = None
 						else:
 							oi = search(0, len(reachAtLast),
 									lambda i: reachAt[reachAtLast[i]] <= best)
 							while reachAtLast[oi] != nxy:
 								oi += 1
 								assert reachAt[reachAtLast[oi]] == best
 						ni = search(0, len(reachAtLast),
 								lambda i: reachAt[reachAtLast[i]] <= rt)
 						if ni != oi:
 							assert ni > oi
 							reachAtLast.insert(ni, nxy)
 							if oi is not None:
 								del reachAtLast[oi]
 						reachAt[nxy] = rt
 						assert len(reachAtLast) == len(reachAt)
 		newReached = reachAtLast[-1]
 		del reachAtLast[-1]
 		time = reachAt[newReached]
 		del reachAt[newReached]
 
 	return '%0.1f' % (time * 0.1)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1836486/mth/1485488/1/extracted/B.py,3806,141,562,Python,1836486,1,1485488,mth,2012
46,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	water, rows, cols = (int(x) for x in inp.readline().split())
 	ceilings = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(rows)
 		)
 	assert all(len(ceiling) == cols for ceiling in ceilings)
 	floors = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(rows)
 		)
 	assert all(len(floor) == cols for floor in floors)
 	return floors, ceilings, water
 
 def solve(floors, ceilings, water):
 	rows = len(ceilings)
 	cols = len(ceilings[0])
 
 	# Compute in decaseconds, to avoid floating points.
 	#INFINITY = 100000 + 100 * 100 * 100
 	INFINITY = 1 << 30
 
 	# Determine when a square will become reachable from each of its neighbours.
 	deltas = ((0, -1), (1, 0), (0, 1), (-1, 0))
 	reach = []
 	for y in xrange(rows):
 		reachLine = []
 		for x in xrange(cols):
 			reachSquare = []
 			for dx, dy in deltas:
 				nx = x + dx
 				ny = y + dy
 				if 0 <= nx < cols and 0 <= ny < rows:
 					fh = floors[y][x]
 					ch = ceilings[y][x]
 					fn = floors[ny][nx]
 					cn = ceilings[ny][nx]
 					if max(fh, fn) + 50 > cn:
 						r = INFINITY
 					elif fn + 50 > ch:
 						r = INFINITY
 					else:
 						r = max(water - cn + 50, 0)
 				else:
 					r = INFINITY
 				reachSquare.append(r)
 			reachLine.append(reachSquare)
 		reach.append(reachLine)
 
 	start = (0, 0)
 	exit = (cols - 1, rows - 1)
 
 	newReached = start
 	time = 0
 	reachAt = {}
 	reached = set()
 	while newReached != exit:
 		reached.add(newReached)
 		x, y = newReached
 		for (dx, dy), rt in zip(deltas, reach[y][x]):
 			if rt < INFINITY:
 				nx = x + dx
 				ny = y + dy
 				if (nx, ny) not in reached:
 					rt = max(time, rt)
 					if rt > 0:
 						wt = water - rt
 						rt += 10 if wt >= floors[y][x] + 20 else 100
 					best = reachAt.get((nx, ny), INFINITY)
 					reachAt[(nx, ny)] = min(best, rt)
 		# TODO: Keeping the data structure sorted is more efficient.
 		newReached = min(
 			(xy for xy in reachAt.iterkeys()),
 			key = reachAt.__getitem__
 			)
 		time = reachAt[newReached]
 		del reachAt[newReached]
 
 	return '%0.1f' % (time * 0.1)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1836486/mth/1485488/0/extracted/B.py,2793,108,413,Python,1836486,0,1485488,mth,2012
47,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 4
 
 def parse(inp):
 	numbers = tuple(int(x) for x in inp.readline().split())
 	count = numbers[0]
 	numbers = numbers[1 : ]
 	assert len(numbers) == count
 	return numbers,
 
 def solve(numbers):
 
 	count = len(numbers)
 
 	set1 = []
 	set2 = []
 	def rec(total1, total2, i):
 		if i < count:
 			n = numbers[i]
 			# Skip number.
 			if rec(total1, total2, i + 1):
 				return True
 			# Add to set 1.
 			if rec(total1 + n, total2, i + 1):
 				set1.append(n)
 				return True
 			# Add to set 2.
 			if rec(total1, total2 + n, i + 1):
 				set2.append(n)
 				return True
 			return False
 		else:
 			return total1 == total2 and total1 != 0
 
 	if rec(0, 0, 0):
 		return ' '.join(str(x) for x in set1), ' '.join(str(x) for x in set2)
 
 	return numbers
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d:\n%s\n%s\n' % (case + 1, value[0], value[1]))
 		out.flush()
 	out.close()
",gcj/2012/1836486/mth/1484496/0/extracted/C.py,1461,64,201,Python,1836486,0,1484496,mth,2012
48,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	data = tuple(int(x) for x in inp.readline().split())
 	dancers, surprises, points = data[ : 3]
 	totals = data[3 : ]
 	assert len(totals) == dancers
 	return totals, surprises, points
 
 def totalAtDist():
 	'''
 	If a dancer's best result is b, the total can be:
 	  distance 0: 3b
 	  distance 1: [3b-2..3b-1]
 	  distance 2: [3b-4..3b-2]
 	Note: distance d is only possible if d <= b.
 
 	total 15:
 	b = 0..4:  impossible
 	b = 5:     dist = 0
 	b = 6:     dist = 2
 	b = 7..10: impossible
 
 	For every total we have a number of explanations, which are
 	(b, d) pairs where b is the best result and d is the distance.
 
 	The output of this function shows:
 
 	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:
 	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)
 	In other words, always one surprise option and one normal option.
 	The surprise option can have a result one higher than the normal one or
 	equal to it.
 	'''
 
 	print '  ',
 	for b in xrange(0, 11):
 		print 'b=%d' % b,
 	print
 	for total in xrange(0, 31):
 		print '%2d' % total,
 		for b in xrange(0, 11):
 			s = '0' if total == b * 3 else '.'
 			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'
 			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'
 			print s,
 		print
 
 #totalAtDist()
 
 def solve(totals, surprises, points):
 	countCertain = 0
 	countSurprise = 0
 	for total in totals:
 		if (total + 2) / 3 >= points:
 			# A non-surprising score has a best result >= p.
 			countCertain += 1
 		elif 2 <= total <= 28 and (total + 4) / 3 >= points:
 			# Only a surprising score has a best result >= p.
 			countSurprise += 1
 		else:
 			# The best result cannot be >= p.
 			pass
 
 	# Replacing a non-surprise interpretation of a total by a surprise
 	# interpretation is always possible for totals in [2..28] and will never
 	# lower the best result, so it will not put a score in a different
 	# category. Therefore, it is always possible to assign leftover surprise
 	# slots to dancers without changing the outcome.
 
 	return countCertain + min(countSurprise, surprises)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1460488/mth/1595491/1/extracted/B.py,2813,98,473,Python,1460488,1,1595491,mth,2012
49,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	data = tuple(int(x) for x in inp.readline().split())
 	dancers, surprises, points = data[ : 3]
 	totals = data[3 : ]
 	assert len(totals) == dancers
 	return totals, surprises, points
 
 def totalAtDist():
 	'''
 	If a dancer's best result is b, the total can be:
 	  distance 0: 3b
 	  distance 1: [3b-2..3b-1]
 	  distance 2: [3b-4..3b-2]
 	Note: distance d is only possible if d <= b.
 
 	total 15:
 	b = 0..4:  impossible
 	b = 5:     dist = 0
 	b = 6:     dist = 2
 	b = 7..10: impossible
 
 	For every total we have a number of explanations, which are
 	(b, d) pairs where b is the best result and d is the distance.
 
 	The output of this function shows:
 
 	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:
 	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)
 	In other words, always one surprise option and one normal option.
 	The surprise option can have a result one higher than the normal one or
 	equal to it.
 	'''
 
 	print '  ',
 	for b in xrange(0, 11):
 		print 'b=%d' % b,
 	print
 	for total in xrange(0, 31):
 		print '%2d' % total,
 		for b in xrange(0, 11):
 			s = '0' if total == b * 3 else '.'
 			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'
 			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'
 			print s,
 		print
 
 #totalAtDist()
 
 def solve(totals, surprises, points):
 	countCertain = 0
 	countSurprise = 0
 	for total in totals:
 		if (total + 2) / 3 >= points:
 			# A non-surprising score has a best result >= p.
 			countCertain += 1
 		elif 2 <= total <= 28 and (total + 4) / 3 >= points:
 			# Only a surprising score has a best result >= p.
 			countSurprise += 1
 		else:
 			# The best result cannot be >= p.
 			pass
 
 	# Replacing a non-surprise interpretation of a total by a surprise
 	# interpretation is always possible for totals in [2..28] and will never
 	# lower the best result, so it will not put a score in a different
 	# category. Therefore, it is always possible to assign leftover surprise
 	# slots to dancers without changing the outcome.
 
 	return countCertain + min(countSurprise, surprises)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1460488/mth/1595491/0/extracted/B.py,2822,98,473,Python,1460488,0,1595491,mth,2012
50,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 8
 
 def parse(inp):
 	a, b = (int(x) for x in inp.readline().split())
 	return a, b
 
 def solve(a, b):
 	count = 0
 	for i in xrange(a, b):
 		s = str(i)
 		recycled = set()
 		for d in xrange(1, len(s)):
 			r = s[d : ] + s[ : d]
 			if i < int(r) <= b:
 				#if r in recycled:
 				#	print r
 				recycled.add(r)
 		count += len(recycled)
 	return count
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1460488/mth/1483488/1/extracted/C.py,1031,46,146,Python,1460488,1,1483488,mth,2012
51,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 
 def parse(inp):
 	a, b = (int(x) for x in inp.readline().split())
 	return a, b
 
 def solve(a, b):
 	count = 0
 	for i in xrange(a, b):
 		s = str(i)
 		recycled = set()
 		for d in xrange(1, len(s)):
 			r = s[d : ] + s[ : d]
 			if i < int(r) <= b:
 				recycled.add(r)
 		count += len(recycled)
 	return count
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1460488/mth/1483488/0/extracted/C.py,1009,44,139,Python,1460488,0,1483488,mth,2012
52,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small'
 NUM_PROCESSES = 0
 
 def findMapping(knowledge):
 	# Build Googlerese to English mapping from example text.
 	mapping = {}
 	for english, googlerese in knowledge:
 		assert len(english) == len(googlerese)
 		for engChar, gooChar in zip(english, googlerese):
 			if ord('a') <= ord(engChar) <= ord('z'):
 				assert ord('a') <= ord(gooChar) <= ord('z')
 				if gooChar in mapping:
 					assert mapping[gooChar] == engChar
 				else:
 					mapping[gooChar] = engChar
 			else:
 				assert engChar == gooChar
 
 	# If one letter is not be specified in the example text, we can still
 	# complete the mapping.
 	alphabet = set(chr(i) for i in xrange(ord('a'), ord('z') + 1))
 	gooMissing = alphabet - set(mapping.iterkeys())
 	engMissing = alphabet - set(mapping.itervalues())
 	assert len(gooMissing) == len(engMissing)
 	if len(gooMissing) == 1:
 		gooChar, = gooMissing
 		engChar, = engMissing
 		mapping[gooChar] = engChar
 	else:
 		assert len(gooMissing) == 0
 
 	# Convert completed mapping to Python translate table.
 	assert len(mapping) == 26, mapping
 	return ''.join(mapping.get(chr(i), chr(i)) for i in xrange(256))
 
 def parse(inp):
 	return inp.readline().rstrip('\n'),
 
 def solve(line):
 	return line.translate(mapping)
 
 knowledge = (
 	( 'our language is impossible to understand',
 	  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),
 	( 'there are twenty six factorial possibilities',
 	  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),
 	( 'so it is okay if you want to just give up',
 	  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),
 	( 'a zoo',
 	  'y qee' ),
 	)
 
 mapping = findMapping(knowledge)
 
 if __name__ == '__main__':
 	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out.txt', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
",gcj/2012/1460488/mth/1483485/0/extracted/A.py,2290,79,295,Python,1460488,0,1483485,mth,2012
53,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	n, x, y = (int(x) for x in inp.readline().split())
 	return n, x, y
 
 def solve(num, buyX, buyY):
 
 	freq = defaultdict(float)
 
 	mid = num + 1
 	freq[tuple((x - mid) % 2 for x in xrange(mid * 2 + 1))] = 1.0
 
 	#print '-' * 80
 	for _ in xrange(num):
 		#print freq
 		newFreq = defaultdict(float)
 		for height, chance in freq.iteritems():
 			def fall(x, chance):
 				l = height[x - 1]
 				c = height[x]
 				r = height[x + 1]
 
 				if l == c - 1:
 					fl = True
 				elif l == c + 1:
 					fl = False
 				else:
 					assert False, height
 				if r == c - 1:
 					fr = True
 				elif r == c + 1:
 					fr = False
 				else:
 					assert False, height
 
 				if fl and fr: # fall random
 					fall(x - 1, chance / 2)
 					fall(x + 1, chance / 2)
 				elif fl: # fall left
 					fall(x - 1, chance)
 				elif fr: # fall right
 					fall(x + 1, chance)
 				else: # stay here
 					newHeight = list(height)
 					newHeight[x] += 2
 					newFreq[tuple(newHeight)] += chance
 
 			fall(mid, chance)
 		freq = newFreq
 
 	if -mid <= buyX <= mid:
 		return sum(
 			chance
 			for height, chance in freq.iteritems()
 			if buyY < height[buyX + mid]
 			)
 	else:
 		return 0.0
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2434486/mth/2700486/0/extracted/B.py,2221,100,315,Python,2434486,0,2700486,mth,2013
54,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def insertWord(node, word):
 	if node is None:
 		node = [ None ] * 27
 	if word:
 		ch = ord(word[0]) - ord('a')
 		node[ch] = insertWord(node[ch], word[1 : ])
 		return node
 	else:
 		node[26] = True
 		return node
 
 def initTree():
 	global tree
 	root = None
 	for word in words:
 		root = insertWord(root, word)
 	tree = root
 
 def readDict():
 	global words
 	words = []
 	inp = open('garbled_email_dictionary.txt', 'r')
 	for line in inp.readlines():
 		words.append(line.rstrip())
 	inp.close()
 
 def parse(inp):
 	email = inp.readline().rstrip()
 	return email,
 
 def solve(email):
 	email = tuple(ord(c) - ord('a') for c in email)
 	length = len(email)
 	#print email
 
 	states = [ set() for _ in xrange(length + 1) ]
 	states[0].add((0, 0))
 
 	def tryMatch(i, node, changes, nextChange):
 		if node[26]:
 			# Word can end here.
 			states[i].add((changes, nextChange))
 		if i < length:
 			ch = email[i]
 			subNode = node[ch]
 			# Matching char.
 			if subNode is not None:
 				tryMatch(i + 1, subNode, changes, nextChange)
 			# Change char.
 			if i >= nextChange:
 				for alt in xrange(26):
 					if alt == ch:
 						continue
 					subNode = node[alt]
 					if subNode is not None:
 						tryMatch(i + 1, subNode, changes + 1, i + 5)
 
 	for i in xrange(length):
 		#print i, states[i]
 		# Earlier nextChange is always better.
 		best = {}
 		for changes, nextChange in states[i]:
 			prev = best.get(changes)
 			if prev is None:
 				best[changes] = nextChange
 			else:
 				if nextChange < prev:
 					best[changes] = nextChange
 
 		for changes, nextChange in best.iteritems():
 			tryMatch(i, tree, changes, nextChange)
 	#print '.', states[length]
 
 	return min(changes for changes, nextChange in states[length])
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	readDict()
 	initTree()
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2434486/mth/2705486/1/extracted/C.py,2750,118,350,Python,2434486,1,2705486,mth,2013
55,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def insertWord(node, word):
 	if node is None:
 		node = [ None ] * 27
 	if word:
 		ch = ord(word[0]) - ord('a')
 		node[ch] = insertWord(node[ch], word[1 : ])
 		return node
 	else:
 		node[26] = True
 		return node
 
 def initTree():
 	global tree
 	root = None
 	for word in words:
 		root = insertWord(root, word)
 	tree = root
 
 def readDict():
 	global words
 	words = []
 	inp = open('garbled_email_dictionary.txt', 'r')
 	for line in inp.readlines():
 		words.append(line.rstrip())
 	inp.close()
 
 def parse(inp):
 	email = inp.readline().rstrip()
 	return email,
 
 def solve(email):
 	email = tuple(ord(c) - ord('a') for c in email)
 	length = len(email)
 	print email
 
 	states = [ set() for _ in xrange(length + 1) ]
 	states[0].add((0, 0))
 
 	def tryMatch(i, node, changes, nextChange):
 		if node[26]:
 			# Word can end here.
 			states[i].add((changes, nextChange))
 		if i < length:
 			ch = email[i]
 			subNode = node[ch]
 			# Matching char.
 			if subNode is not None:
 				tryMatch(i + 1, subNode, changes, nextChange)
 			# Change char.
 			if i >= nextChange:
 				for alt in xrange(26):
 					if alt == ch:
 						continue
 					subNode = node[alt]
 					if subNode is not None:
 						tryMatch(i + 1, subNode, changes + 1, i + 5)
 
 	for i in xrange(length):
 		#print i, states[i]
 		# Earlier nextChange is always better.
 		best = {}
 		for changes, nextChange in states[i]:
 			prev = best.get(changes)
 			if prev is None:
 				best[changes] = nextChange
 			else:
 				if nextChange < prev:
 					best[changes] = nextChange
 
 		for changes, nextChange in best.iteritems():
 			tryMatch(i, tree, changes, nextChange)
 	#print '.', states[length]
 
 	return min(changes for changes, nextChange in states[length])
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	readDict()
 	initTree()
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2434486/mth/2705486/0/extracted/C.py,2758,118,350,Python,2434486,0,2705486,mth,2013
56,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	start, num = (int(x) for x in inp.readline().split())
 	motes = tuple(int(x) for x in inp.readline().split())
 	assert len(motes) == num
 	return start, motes
 
 def solve(start, motes):
 	motes = sorted(motes)
 	num = len(motes)
 
 	best = num
 	size = start
 	added = 0
 	i = 0
 	while i < num:
 		if motes[i] < size:
 			size += motes[i]
 			i += 1
 		else:
 			# Option: delete the rest.
 			best = min(best, added + num - i)
 			# Option: add mote.
 			if size <= 1:
 				break
 			else:
 				while motes[i] - size >= 0:
 					size += size - 1
 					added += 1
 	else:
 		best = min(best, added)
 
 	return best
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2434486/mth/2692487/1/extracted/A.py,1607,73,216,Python,2434486,1,2692487,mth,2013
57,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	start, num = (int(x) for x in inp.readline().split())
 	motes = tuple(int(x) for x in inp.readline().split())
 	assert len(motes) == num
 	return start, motes
 
 def solve(start, motes):
 	motes = sorted(motes)
 	num = len(motes)
 
 	best = num
 	size = start
 	added = 0
 	i = 0
 	while i < num:
 		if motes[i] < size:
 			size += motes[i]
 			i += 1
 		else:
 			# Option: delete the rest.
 			best = min(best, added + num - i)
 			# Option: add mote.
 			if size <= 1:
 				break
 			else:
 				size += size - 1
 				added += 1
 	else:
 		best = min(best, added)
 
 	return best
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2434486/mth/2692487/0/extracted/A.py,1581,72,210,Python,2434486,0,2692487,mth,2013
58,A.py,"#!/usr/bin/env python
 
 from collections import defaultdict
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	nstops, npairs = (int(x) for x in inp.readline().split())
 	travel = []
 	for _ in xrange(npairs):
 		origin, end, passengers = (int(x) for x in inp.readline().split())
 		travel.append((origin - 1, end - 1, passengers))
 	return nstops, travel
 
 def solve(nstops, travel):
 	mod = 1000002013
 
 	enterDict = defaultdict(int)
 	for o, e, p in travel:
 		enterDict[o] += p
 	enter = sorted(enterDict.iteritems())
 
 	leaveDict = defaultdict(int)
 	for o, e, p in travel:
 		leaveDict[e] += p
 	leave = sorted(leaveDict.iteritems())
 
 	#print enter, leave
 
 	el = len(enter)
 	ei = 0
 	ontrain = []
 	paid = 0
 	for stop, pl in leave:
 		while ei < el and enter[ei][0] <= stop:
 			ontrain.append(enter[ei])
 			ei += 1
 
 		while pl > 0:
 			o, p = ontrain.pop()
 			if p > pl:
 				left = pl
 				ontrain.append((o, p - left))
 			else:
 				left = p
 			pl -= left
 			n = stop - o
 			price = n * nstops - (n * (n - 1)) / 2
 			paid = (paid + price * left) % mod
 
 	expected = 0
 	for o, e, p in travel:
 		n = e - o
 		price = n * nstops - (n * (n - 1)) / 2
 		expected = (expected + price * p) % mod
 
 	return (expected - paid) % mod
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2442487/mth/2772486/1/extracted/A.py,2172,94,315,Python,2442487,1,2772486,mth,2013
59,A.py,"#!/usr/bin/env python
 
 from collections import defaultdict
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	nstops, npairs = (int(x) for x in inp.readline().split())
 	travel = []
 	for _ in xrange(npairs):
 		origin, end, passengers = (int(x) for x in inp.readline().split())
 		travel.append((origin - 1, end - 1, passengers))
 	return nstops, travel
 
 def solve(nstops, travel):
 	mod = 1000002013
 
 	enterDict = defaultdict(int)
 	for o, e, p in travel:
 		enterDict[o] += p
 	enter = sorted(enterDict.iteritems())
 
 	leaveDict = defaultdict(int)
 	for o, e, p in travel:
 		leaveDict[e] += p
 	leave = sorted(leaveDict.iteritems())
 
 	#print enter, leave
 
 	el = len(enter)
 	ei = 0
 	ontrain = []
 	paid = 0
 	for stop, pl in leave:
 		while ei < el and enter[ei][0] <= stop:
 			ontrain.append(enter[ei])
 			ei += 1
 
 		while pl > 0:
 			o, p = ontrain.pop()
 			if p > pl:
 				left = pl
 				ontrain.append((o, p - left))
 			else:
 				left = p
 			pl -= left
 			n = stop - o
 			price = n * nstops - (n * (n - 1)) / 2
 			paid = (paid + price * left) % mod
 
 	expected = 0
 	for o, e, p in travel:
 		n = e - o
 		price = n * nstops - (n * (n - 1)) / 2
 		expected = (expected + price * p) % mod
 
 	return (expected - paid) % mod
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2442487/mth/2772486/0/extracted/A.py,2181,94,315,Python,2442487,0,2772486,mth,2013
60,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rounds, prizes = (int(x) for x in inp.readline().split())
 	return rounds, prizes
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def solve(rounds, prizes):
 
 	#def winLucky(team, rnd, record):
 		#numWorse = ?
 		#return numWorse > 0
 
 	#def winUnlucky(team, rnd, record):
 		#numBetter = ?
 		
 		#if rnd == 0:
 			#numBetter = team
 		
 		
 		#return numBetter == 0
 
 	#def play(team, winFunc):
 		#record = 0
 		#for rnd in xrange(rounds):
 			#record = (record << 1) | int(winFunc(team, rnd, record))
 		#return record
 
 	#def worstRank(team):
 		#return play(team, winUnlucky)
 
 	#def bestRank(team):
 		#return play(team, winLucky)
 
 	def worstRank(team):
 		numBetter = team
 		record = 0
 		for rnd in xrange(rounds):
 			win = numBetter == 0
 			record = (record << 1) | int(not win)
 			if not win:
 				numBetter = (numBetter - 1) / 2
 		return record
 
 	def bestRank(team):
 		numWorse = (1 << rounds) - 1 - team
 		record = 0
 		for rnd in xrange(rounds):
 			win = numWorse != 0
 			record = (record << 1) | int(not win)
 			if win:
 				numWorse = (numWorse - 1) / 2
 		return record
 
 	worstCertainPrize = \
 		search(0, 1 << rounds, lambda t: worstRank(t) >= prizes) - 1
 	worstMaybePrize = \
 		search(0, 1 << rounds, lambda t: bestRank(t) >= prizes) - 1
 
 	assert 0 <= worstCertainPrize < (1 << rounds), worstCertainPrize
 	assert 0 <= worstMaybePrize < (1 << rounds), worstMaybePrize
 
 	return '%d %d' % (worstCertainPrize, worstMaybePrize)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2442487/mth/2766487/1/extracted/B.py,2983,118,420,Python,2442487,1,2766487,mth,2013
61,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rounds, prizes = (int(x) for x in inp.readline().split())
 	return rounds, prizes
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def solve(rounds, prizes):
 
 	#def winLucky(team, rnd, record):
 		#numWorse = ?
 		#return numWorse > 0
 
 	#def winUnlucky(team, rnd, record):
 		#numBetter = ?
 		
 		#if rnd == 0:
 			#numBetter = team
 		
 		
 		#return numBetter == 0
 
 	#def play(team, winFunc):
 		#record = 0
 		#for rnd in xrange(rounds):
 			#record = (record << 1) | int(winFunc(team, rnd, record))
 		#return record
 
 	#def worstRank(team):
 		#return play(team, winUnlucky)
 
 	#def bestRank(team):
 		#return play(team, winLucky)
 
 	def worstRank(team):
 		numBetter = team
 		record = 0
 		for rnd in xrange(rounds):
 			win = numBetter == 0
 			record = (record << 1) | int(not win)
 			if not win:
 				numBetter = (numBetter - 1) / 2
 		return record
 
 	def bestRank(team):
 		numWorse = (1 << rounds) - 1 - team
 		record = 0
 		for rnd in xrange(rounds):
 			win = numWorse != 0
 			record = (record << 1) | int(not win)
 			if win:
 				numWorse = (numWorse - 1) / 2
 		return record
 
 	worstCertainPrize = \
 		search(0, 1 << rounds, lambda t: worstRank(t) >= prizes) - 1
 	worstMaybePrize = \
 		search(0, 1 << rounds, lambda t: bestRank(t) >= prizes) - 1
 
 	assert 0 <= worstCertainPrize < (1 << rounds), worstCertainPrize
 	assert 0 <= worstMaybePrize < (1 << rounds), worstMaybePrize
 
 	return '%d %d' % (worstCertainPrize, worstMaybePrize)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2442487/mth/2766487/0/extracted/B.py,2992,118,420,Python,2442487,0,2766487,mth,2013
62,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	maxE, regain, numAct = (int(x) for x in inp.readline().split())
 	activities = tuple(int(x) for x in inp.readline().split())
 	assert len(activities) == numAct
 	return maxE, regain, activities
 
 def solve(maxE, regain, activities):
 	state = { maxE: 0 }
 	for act in activities:
 		newState = {}
 		for energy, gain in state.iteritems():
 			for spend in xrange(0, energy + 1):
 				newEnergy = min(energy - spend + regain, maxE)
 				newGain = gain + spend * act
 				oldBest = newState.get(newEnergy, -1)
 				if newGain > oldBest:
 					newState[newEnergy] = newGain
 		state = newState
 	return max(state.itervalues())
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2418487/mth/2645486/0/extracted/B.py,1624,60,198,Python,2418487,0,2645486,mth,2013
63,C.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'C-example'
 FILE_NAME_BASE = 'C-small-1-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	numSets, setSize, maxVal, numSamples = \
 		(int(x) for x in inp.readline().split())
 	samples = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numSets)
 		)
 	return setSize, maxVal, samples
 
 def solve(setSize, maxVal, samples):
 
 	def iterSets(i):
 		if i == 0:
 			yield ()
 		else:
 			for v in xrange(2, maxVal + 1):
 				for s in iterSets(i - 1):
 					yield s + (v, )
 
 	def iterProducts(s):
 		if s:
 			n = s[0]
 			for prod in iterProducts(s[1 :]):
 				yield prod
 				yield n * prod
 		else:
 			yield 1
 
 	products = defaultdict(lambda: defaultdict(int))
 	for s in iterSets(setSize):
 		s = tuple(sorted(s))
 		for p in iterProducts(s):
 			products[p][s] += 1
 
 	#print setSize, maxVal, samples
 	#print products
 	#print
 
 	guesses = []
 	for sample in samples:
 		possible = None
 		for prod in sample:
 			if possible is None:
 				possible = dict(products[prod].iteritems())
 			else:
 				newPossible = {}
 				for s, freq in products[prod].iteritems():
 					oldFreq = possible.get(s, 0)
 					if oldFreq != 0:
 						newPossible[s] = oldFreq * freq
 				possible = newPossible
 
 		#print sample, possible
 		bestFreq = -1
 		bestSet = None
 		for s, freq in possible.iteritems():
 			if freq > bestFreq:
 				bestFreq = freq
 				bestSet = s
 
 		guesses.append(''.join(str(d) for d in bestSet))
 
 	return ''.join('\n' + guess for guess in guesses)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d:%s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2418487/mth/2652486/0/extracted/C.py,2478,107,308,Python,2418487,0,2652486,mth,2013
64,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	r, t = (int(x) for x in inp.readline().split())
 	return r, t
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def solve(r, t):
 	def impossible(i):
 		return 2 * i * (i - 1) + i * (2 * r + 1) > t
 
 	return search(0, 708000000, impossible) - 1
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2418487/mth/2464487/1/extracted/A.py,1755,67,255,Python,2418487,1,2464487,mth,2013
65,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	r, t = (int(x) for x in inp.readline().split())
 	return r, t
 
 def solve(r, t):
 	paintLeft = t
 	i = 0
 	while True:
 		ri = r + i * 2
 		paint = 2 * ri + 1
 		if paint <= paintLeft:
 			paintLeft -= paint
 			i += 1
 		else:
 			break
 	return i
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2418487/mth/2464487/0/extracted/A.py,1249,57,164,Python,2418487,0,2464487,mth,2013
66,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	board = tuple( inp.readline().rstrip() for _ in xrange(4) )
 	empty = inp.readline().rstrip()
 	assert empty == '', empty
 	return board,
 
 def solve(board):
 
 	def scan(start, delta):
 		x, y = start
 		dx, dy = delta
 		for _ in xrange(4):
 			yield board[y][x]
 			x += dx
 			y += dy
 
 	# Look for a winner.
 	for start, delta in (
 		# horizontal
 		((0, 0), (1, 0)),
 		((0, 1), (1, 0)),
 		((0, 2), (1, 0)),
 		((0, 3), (1, 0)),
 		# vertical
 		((0, 0), (0, 1)),
 		((1, 0), (0, 1)),
 		((2, 0), (0, 1)),
 		((3, 0), (0, 1)),
 		# diagonal
 		((0, 0), (1, 1)),
 		((3, 0), (-1, 1)),
 		):
 		chars = set(scan(start, delta))
 		if chars == set(['X']) or chars == set(['X', 'T']):
 			return 'X won'
 		elif chars == set(['O']) or chars == set(['O', 'T']):
 			return 'O won'
 
 	# No winner; draw or unfinished game?
 	if any('.' in row for row in board):
 		return 'Game has not completed'
 	else:
 		return 'Draw'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2453486/1/extracted/A.py,1916,84,266,Python,2270488,1,2453486,mth,2013
67,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	board = tuple( inp.readline().rstrip() for _ in xrange(4) )
 	empty = inp.readline().rstrip()
 	assert empty == '', empty
 	return board,
 
 def solve(board):
 
 	def scan(start, delta):
 		x, y = start
 		dx, dy = delta
 		for _ in xrange(4):
 			yield board[y][x]
 			x += dx
 			y += dy
 
 	# Look for a winner.
 	for start, delta in (
 		# horizontal
 		((0, 0), (1, 0)),
 		((0, 1), (1, 0)),
 		((0, 2), (1, 0)),
 		((0, 3), (1, 0)),
 		# vertical
 		((0, 0), (0, 1)),
 		((1, 0), (0, 1)),
 		((2, 0), (0, 1)),
 		((3, 0), (0, 1)),
 		# diagonal
 		((0, 0), (1, 1)),
 		((3, 0), (-1, 1)),
 		):
 		chars = set(scan(start, delta))
 		if chars == set(['X']) or chars == set(['X', 'T']):
 			return 'X won'
 		elif chars == set(['O']) or chars == set(['O', 'T']):
 			return 'O won'
 
 	# No winner; draw or unfinished game?
 	if any('.' in row for row in board):
 		return 'Game has not completed'
 	else:
 		return 'Draw'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2453486/0/extracted/A.py,1925,84,266,Python,2270488,0,2453486,mth,2013
68,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large-1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 precalc_limit = 100000000000000
 
 def parse(inp):
 	a, b = (int(x) for x in inp.readline().split())
 	assert a <= b
 	assert b <= precalc_limit
 	return a, b
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def isFair(x):
 	l1 = list(str(x))
 	l2 = list(l1)
 	l2.reverse()
 	return l1 == l2
 
 numbers = []
 def precalc():
 	rl = search(0, precalc_limit + 1, lambda x: x * x > precalc_limit)
 	for r in xrange(1, rl + 1):
 		if isFair(r) and isFair(r * r):
 			numbers.append(r)
 			print r
 
 def solve(a, b):
 	ia = search(0, len(numbers), lambda i: numbers[i] * numbers[i] >= a)
 	ib = search(0, len(numbers), lambda i: numbers[i] * numbers[i] > b)
 	return ib - ia
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	precalc()
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2463486/1/extracted/C.py,2178,86,314,Python,2270488,1,2463486,mth,2013
69,C.py,"#!/usr/bin/env python
 
 from math import sqrt
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	a, b = (int(x) for x in inp.readline().split())
 	return a, b
 
 def isFair(x):
 	l1 = list(str(x))
 	l2 = list(l1)
 	l2.reverse()
 	return l1 == l2
 
 def solve(a, b):
 	c = 0
 	for i in xrange(a, b + 1):
 		r = int(sqrt(i))
 		if r * r == i and isFair(i) and isFair(r):
 			c += 1
 
 	return str(c)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2463486/0/extracted/C.py,1325,61,173,Python,2270488,0,2463486,mth,2013
70,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	return tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for row in xrange(rows)
 		),
 
 def solve(lawn):
 	#print lawn
 
 	rowMax = tuple(max(row) for row in lawn)
 	colMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))
 	#print rowMax, colMax
 
 	def possible():
 		for y, row in enumerate(lawn):
 			for x, cell in enumerate(row):
 				h = min(rowMax[y], colMax[x])
 				if cell != h:
 					return False
 		return True
 
 	return 'YES' if possible() else 'NO'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2449486/1/extracted/B.py,1539,64,189,Python,2270488,1,2449486,mth,2013
71,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	return tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for row in xrange(rows)
 		),
 
 def solve(lawn):
 	#print lawn
 
 	rowMax = tuple(max(row) for row in lawn)
 	colMax = tuple(max(row[i] for row in lawn) for i in xrange(len(lawn[0])))
 	#print rowMax, colMax
 
 	def possible():
 		for y, row in enumerate(lawn):
 			for x, cell in enumerate(row):
 				h = min(rowMax[y], colMax[x])
 				if cell != h:
 					return False
 		return True
 
 	return 'YES' if possible() else 'NO'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2449486/0/extracted/B.py,1548,64,189,Python,2270488,0,2449486,mth,2013
72,D.py,"#!/usr/bin/env python
 
 from collections import defaultdict
 
 FILE_NAME_BASE = 'D-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numInitKeys, numChests = (int(x) for x in inp.readline().split())
 	initKeys = tuple(int(x) - 1 for x in inp.readline().split())
 	assert len(initKeys) == numInitKeys
 	chests = []
 	for _ in xrange(numChests):
 		chest = tuple(int(x) for x in inp.readline().split())
 		toOpen = chest[0] - 1
 		assert 0 <= toOpen < 200, toOpen
 		numKeysInChest = chest[1]
 		keysInChest = tuple(x - 1 for x in chest[2 : ])
 		assert len(keysInChest) == numKeysInChest
 		chests.append((toOpen, keysInChest))
 	return initKeys, tuple(chests)
 
 def solve(initKeys, chests):
 	print '=' * 10
 	print initKeys
 	for i, (toOpen, keys) in enumerate(chests):
 		print '%d: %d -> %s' % (i, toOpen, keys)
 
 	#openedBy = defaultdict(list)
 	#for i, (toOpen, keys) in enumerate(chests):
 		#openedBy[toOpen].append(i)
 	#print openedBy
 
 	#def canOpen(keys):
 		#return tuple(
 			#i
 			#for i, (toOpen, newKeys) in enumerate(chests)
 			#if toOpen in keys
 			#)
 	#initCanOpen = canOpen(initKeys)
 	#print initCanOpen
 
 	beenThere = set()
 	allOpen = (1 << len(chests)) - 1
 	def search(opened, keys):
 		if opened == allOpen:
 			return ()
 		if opened in beenThere:
 			return None
 		else:
 			beenThere.add(opened)
 		for i, (toOpen, newKeys) in enumerate(chests):
 			if (opened & (1 << i)) == 0 and toOpen in keys:
 				recKeys = list(keys)
 				recKeys.remove(toOpen)
 				recKeys += newKeys
 				rec = search(opened | (1 << i), recKeys)
 				if rec is not None:
 					return (i, ) + rec
 		return None
 
 	solution = search(0, initKeys)
 
 	if solution is None:
 		return 'IMPOSSIBLE'
 	else:
 		return ' '.join('%d' % (c + 1) for c in solution)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2013/2270488/mth/2458486/0/extracted/D.py,2674,103,339,Python,2270488,0,2458486,mth,2013
73,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import chain
 
 def parse(inp):
 	numBlocks, = (int(x) for x in inp.readline().split())
 	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))
 	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))
 	assert len(naomiBlocks) == numBlocks
 	assert len(kenBlocks) == numBlocks
 	return naomiBlocks, kenBlocks
 
 def solve(naomiBlocks, kenBlocks):
 	numBlocks = len(naomiBlocks)
 
 	# greedy strategy for honest play:
 	# play the block that is heavier by the smallest margin (if you have one)
 	# ('honest' meaning sticking to the rules; 'fair' is something else)
 	kenPointsHonest = 0
 	naomiLowerBlocks = 0
 	for _, owner in sorted(chain(
 			((b, 'n') for b in naomiBlocks),
 			((b, 'k') for b in kenBlocks)
 			)):
 		if owner == 'n':
 			naomiLowerBlocks += 1
 		elif naomiLowerBlocks != 0:
 			naomiLowerBlocks -= 1
 			kenPointsHonest += 1
 	naomiPointsHonest = numBlocks - kenPointsHonest
 
 	# strategy for deceitful play:
 	# moves:
 	# + lie and win:
 	#   when Ken can't match the told number, he'll play his lightest block
 	#   so you can lie and win if you play a block heavier than his lightest
 	# + lie and lose:
 	#   name a weight just below Ken's heaviest block, forcing him to play that
 	# - truth and win:
 	#   when you play a block that is actually heavier than anything Ken has
 	#   is just a special case of lie and win
 	# - truth and lose:
 	#   never optimal
 	# optimal order of play:
 	#   always play your lightest block: if it can't win now, it can never win
 	#   in the future either, nor can it be more effective in the future than
 	#   pulling his current heaviest block
 	naomiLoIdx = 0
 	naomiHiIdx = numBlocks - 1
 	kenLoIdx = 0
 	kenHiIdx = numBlocks - 1
 	naomiPointsDeceit = 0
 	while naomiLoIdx <= naomiHiIdx:
 		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx
 		naomiLo = naomiBlocks[naomiLoIdx]
 		#naomiHi = naomiBlocks[naomiHiIdx]
 		kenLo = kenBlocks[kenLoIdx]
 		#kenHi = kenBlocks[kenHiIdx]
 		if naomiLo > kenLo:
 			naomiPointsDeceit += 1
 			kenLoIdx += 1
 		else:
 			kenHiIdx -= 1
 		naomiLoIdx += 1
 
 	#print naomiBlocks
 	#print kenBlocks
 	#print
 
 	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5644738749267968/1/extracted/D.py,3195,109,443,Python,2974486,1,5644738749267968,mth,2014
74,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import chain
 
 def parse(inp):
 	numBlocks, = (int(x) for x in inp.readline().split())
 	naomiBlocks = tuple(sorted(float(x) for x in inp.readline().split()))
 	kenBlocks = tuple(sorted(float(x) for x in inp.readline().split()))
 	assert len(naomiBlocks) == numBlocks
 	assert len(kenBlocks) == numBlocks
 	return naomiBlocks, kenBlocks
 
 def solve(naomiBlocks, kenBlocks):
 	numBlocks = len(naomiBlocks)
 
 	# greedy strategy for honest play:
 	# play the block that is heavier by the smallest margin (if you have one)
 	# ('honest' meaning sticking to the rules; 'fair' is something else)
 	kenPointsHonest = 0
 	naomiLowerBlocks = 0
 	for _, owner in sorted(chain(
 			((b, 'n') for b in naomiBlocks),
 			((b, 'k') for b in kenBlocks)
 			)):
 		if owner == 'n':
 			naomiLowerBlocks += 1
 		elif naomiLowerBlocks != 0:
 			naomiLowerBlocks -= 1
 			kenPointsHonest += 1
 	naomiPointsHonest = numBlocks - kenPointsHonest
 
 	# strategy for deceitful play:
 	# moves:
 	# + lie and win:
 	#   when Ken can't match the told number, he'll play his lightest block
 	#   so you can lie and win if you play a block heavier than his lightest
 	# + lie and lose:
 	#   name a weight just below Ken's heaviest block, forcing him to play that
 	# - truth and win:
 	#   when you play a block that is actually heavier than anything Ken has
 	#   is just a special case of lie and win
 	# - truth and lose:
 	#   never optimal
 	# optimal order of play:
 	#   always play your lightest block: if it can't win now, it can never win
 	#   in the future either, nor can it be more effective in the future than
 	#   pulling his current heaviest block
 	naomiLoIdx = 0
 	naomiHiIdx = numBlocks - 1
 	kenLoIdx = 0
 	kenHiIdx = numBlocks - 1
 	naomiPointsDeceit = 0
 	while naomiLoIdx <= naomiHiIdx:
 		assert naomiHiIdx - naomiLoIdx == kenHiIdx - kenLoIdx
 		naomiLo = naomiBlocks[naomiLoIdx]
 		#naomiHi = naomiBlocks[naomiHiIdx]
 		kenLo = kenBlocks[kenLoIdx]
 		#kenHi = kenBlocks[kenHiIdx]
 		if naomiLo > kenLo:
 			naomiPointsDeceit += 1
 			kenLoIdx += 1
 		else:
 			kenHiIdx -= 1
 		naomiLoIdx += 1
 
 	#print naomiBlocks
 	#print kenBlocks
 	#print
 
 	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5644738749267968/0/extracted/D.py,3204,109,443,Python,2974486,0,5644738749267968,mth,2014
75,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	cost, prod, goal = (float(x) for x in inp.readline().split())
 	return cost, prod, goal
 
 def solve(cost, prod, goal):
 	rate = 2
 	now = 0
 	while True:
 		nobuyEnd = goal / rate
 		buyEnd = cost / rate + goal / (rate + prod)
 		if buyEnd < nobuyEnd:
 			now += cost / rate
 			rate += prod
 		else:
 			return '%0.7f' % (now + nobuyEnd)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5709773144064000/1/extracted/B.py,1330,56,174,Python,2974486,1,5709773144064000,mth,2014
76,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	cost, prod, goal = (float(x) for x in inp.readline().split())
 	return cost, prod, goal
 
 def solve(cost, prod, goal):
 	rate = 2
 	now = 0
 	while True:
 		nobuyEnd = goal / rate
 		buyEnd = cost / rate + goal / (rate + prod)
 		if buyEnd < nobuyEnd:
 			now += cost / rate
 			rate += prod
 		else:
 			return '%0.7f' % (now + nobuyEnd)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5709773144064000/0/extracted/B.py,1339,56,174,Python,2974486,0,5709773144064000,mth,2014
77,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 10000
 
 # The brute force check is used to verify if there is really no solution if
 # the fast search algorithm doesn't find one. However, it is impractically slow
 # for large boards.
 bruteForceCheck = False
 
 def parse(inp):
 	rows, cols, mines = (int(x) for x in inp.readline().split())
 	return rows, cols, mines
 
 def search(rows, cols, mines):
 	# One-dimensional board.
 	# These corner cases are not handled properly by the recursive search.
 	if rows == 1:
 		return ['c' + '.' * (cols - 1 - mines) + '*' * mines]
 	if cols == 1:
 		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines
 
 	def recurse(rowsLeft, maxWidth, minesLeft):
 		if rowsLeft == 1:
 			# Putting fewer mines on the top row than the row below it will
 			# result in unrevealed empty cells.
 			return [maxWidth] if minesLeft == maxWidth else None
 		if minesLeft == 0:
 			# All mines placed, keep top rows empty.
 			return [0] * rowsLeft
 		# We have a non-zero amount of mines to place in a field that has
 		# a sufficient number of cells.
 
 		if minesLeft >= maxWidth:
 			# Try a row with the maximum number of mines.
 			found = recurse(rowsLeft - 1, maxWidth, minesLeft - maxWidth)
 			if found is not None:
 				found.append(maxWidth)
 				return found
 
 		# Try a row with a smaller amount of mines.
 		# Don't leave just one cell open, that prevents flooding.
 		for width in xrange(min(minesLeft, maxWidth - 1, cols - 2) + 1):
 			if rowsLeft * width >= minesLeft:
 				found = recurse(rowsLeft - 1, width, minesLeft - width)
 				if found is not None:
 					found.append(width)
 					return found
 
 	widths = recurse(rows, cols, mines)
 	if widths is None:
 		return None
 
 	board = [
 			'.' * (cols - width) + '*' * width
 			for width in widths
 			]
 	assert board[0][0] == '.'
 	board[0] = 'c' + board[0][1 : ]
 	return board
 
 class SearchBoard(object):
 
 	def __init__(self, rows, cols):
 		self.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]
 		self.mineCount = 0
 
 	def addMine(self, row, col):
 		counts = self.counts
 		assert counts[row + 1][col + 1] < 10
 		top = counts[row + 0]
 		top[col + 0] += 1
 		top[col + 1] += 1
 		top[col + 2] += 1
 		mid = counts[row + 1]
 		mid[col + 0] += 1
 		mid[col + 1] += 10
 		mid[col + 2] += 1
 		bot = counts[row + 2]
 		bot[col + 0] += 1
 		bot[col + 1] += 1
 		bot[col + 2] += 1
 		self.mineCount += 1
 
 	def removeMine(self, row, col):
 		counts = self.counts
 		assert counts[row + 1][col + 1] >= 10
 		top = counts[row + 0]
 		top[col + 0] -= 1
 		top[col + 1] -= 1
 		top[col + 2] -= 1
 		mid = counts[row + 1]
 		mid[col + 0] -= 1
 		mid[col + 1] -= 10
 		mid[col + 2] -= 1
 		bot = counts[row + 2]
 		bot[col + 0] -= 1
 		bot[col + 1] -= 1
 		bot[col + 2] -= 1
 		self.mineCount -= 1
 
 	def checkConnected(self):
 		counts = self.counts
 		cols = len(counts[0]) - 2
 		rows = len(counts) - 2
 
 		# Pick a cell to click on. Any zero cell will do: if all zeroes are
 		# connected, clicking on any zero will reveal them all.
 		for rowIdx, row in enumerate(counts):
 			if rowIdx == 0 or rowIdx > rows:
 				continue
 			try:
 				colIdx = row.index(0, 1, -1)
 			except ValueError:
 				pass
 			else:
 				click = (rowIdx, colIdx)
 				break
 		else:
 			return None
 
 		revealed = set()
 		def reveal(row, col):
 			if 1 <= row <= rows and 1 <= col <= cols:
 				pos = (row, col)
 				if pos not in revealed:
 					revealed.add(pos)
 					count = counts[row][col]
 					if count == 0:
 						for dr in (-1, 0, 1):
 							for dc in (-1, 0, 1):
 								if dr != 0 or dc != 0:
 									reveal(row + dr, col + dc)
 					else:
 						assert count < 10
 		reveal(*click)
 		numNonMines = rows * cols - self.mineCount
 		if len(revealed) != numNonMines:
 			assert len(revealed) < numNonMines
 			return None
 
 		# Construct a board in the solution syntax.
 		board = [
 				['.' if cell < 10 else '*' for cell in row[1 : -1]]
 				for row in counts[1 : -1]
 				]
 		board[click[0] - 1][click[1] - 1] = 'c'
 		return [''.join(row) for row in board]
 
 def searchBruteForce(rows, cols, mines):
 	searchBoard = SearchBoard(rows, cols)
 
 	def searchRec(idx, remaining):
 		if remaining == 0:
 			return searchBoard.checkConnected()
 		elif idx < remaining:
 			return None
 		else:
 			pos = divmod(idx, cols)
 			searchBoard.addMine(*pos)
 			found = searchRec(idx - 1, remaining - 1)
 			searchBoard.removeMine(*pos)
 			if found is not None:
 				return found
 			return searchRec(idx - 1, remaining)
 
 	return searchRec(rows * cols - 1, mines)
 
 def solve(rows, cols, mines):
 	# This is the only case where there are no zero-cells but there is a
 	# solution. Handling it separately means the search functions don't have
 	# to deal with clicking on nonzero-cells.
 	if mines == rows * cols - 1:
 		return '\nc' + '*' * (cols - 1) + ('\n' + '*' * cols) * (rows - 1)
 
 	board = search(rows, cols, mines)
 	if board is None and bruteForceCheck:
 		board = searchBruteForce(rows, cols, mines)
 		if board is None:
 			print 'confirmed: no solution for %dx%d board, %d mines' \
 					% (rows, cols, mines)
 		else:
 			print 'ERROR: missed solution for %dx%d board, %d mines:' \
 					% (rows, cols, mines)
 			for row in board:
 				print row
 			print
 	if board is None:
 		return '\n' + 'Impossible'
 
 	# Perform sanity checks.
 	assert len(board) == rows
 	assert all(len(row) == cols for row in board)
 	counts = { 'c': 0, '.': 0, '*': 0 }
 	for row in board:
 		for cell in row:
 			counts[cell] += 1
 	assert counts['c'] == 1
 	assert counts['*'] == mines
 
 	flowBoard = [
 			['.' if cell == 'c' else cell for cell in row]
 			for row in board
 			]
 	def countMinesOn(row, col):
 		if 0 <= row < rows and 0 <= col < cols:
 			return 1 if flowBoard[row][col] == '*' else 0
 		else:
 			return 0
 	def countMinesNear(row, col):
 		return sum(
 			countMinesOn(row + dr, col + dc)
 			for dr in (-1, 0, 1)
 			for dc in (-1, 0, 1)
 			)
 	def reveal(row, col):
 		if 0 <= row < rows and 0 <= col < cols:
 			assert flowBoard[row][col] != '*'
 			if flowBoard[row][col] == '.':
 				count = countMinesNear(row, col)
 				flowBoard[row][col] = str(count)
 				if count == 0:
 					for dr in (-1, 0, 1):
 						for dc in (-1, 0, 1):
 							reveal(row + dr, col + dc)
 	clickRow, = [i for i, row in enumerate(board) if 'c' in row]
 	clickCol = board[clickRow].index('c')
 	reveal(clickRow, clickCol)
 	assert all('.' not in row for row in flowBoard), flowBoard
 
 	assert all(type(row) == str for row in board)
 	return ''.join('\n' + ''.join(row) for row in board)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5690574640250880/1/extracted/C.py,7520,268,1190,Python,2974486,1,5690574640250880,mth,2014
78,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols, mines = (int(x) for x in inp.readline().split())
 	return rows, cols, mines
 
 def search(rows, cols, mines):
 	# Boundary cases:
 	# TODO: Might be redundant once we have a generic solution.
 
 	# Mine count extremes.
 	assert 0 <= mines < rows * cols
 	if mines == 0:
 		return ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)
 	if mines == rows * cols - 1:
 		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)
 
 	# One-dimensional board.
 	if rows == 1:
 		return ['c' + '.' * (cols - 1 - mines) + '*' * mines]
 	if cols == 1:
 		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines
 
 	# Nearly-full two-dimensional board: the clicked cell must not have any
 	# mines as neighbours or the flooding won't start.
 	if mines > rows * cols - 4:
 		return None
 
 	# TODO: For now, we just give up.
 
 	return None
 
 class SearchBoard(object):
 
 	def __init__(self, rows, cols):
 		self.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]
 		self.mineCount = 0
 
 	def addMine(self, row, col):
 		counts = self.counts
 		assert counts[row + 1][col + 1] < 10
 		top = counts[row + 0]
 		top[col + 0] += 1
 		top[col + 1] += 1
 		top[col + 2] += 1
 		mid = counts[row + 1]
 		mid[col + 0] += 1
 		mid[col + 1] += 10
 		mid[col + 2] += 1
 		bot = counts[row + 2]
 		bot[col + 0] += 1
 		bot[col + 1] += 1
 		bot[col + 2] += 1
 		self.mineCount += 1
 
 	def removeMine(self, row, col):
 		counts = self.counts
 		assert counts[row + 1][col + 1] >= 10
 		top = counts[row + 0]
 		top[col + 0] -= 1
 		top[col + 1] -= 1
 		top[col + 2] -= 1
 		mid = counts[row + 1]
 		mid[col + 0] -= 1
 		mid[col + 1] -= 10
 		mid[col + 2] -= 1
 		bot = counts[row + 2]
 		bot[col + 0] -= 1
 		bot[col + 1] -= 1
 		bot[col + 2] -= 1
 		self.mineCount -= 1
 
 	def checkConnected(self):
 		counts = self.counts
 		cols = len(counts[0]) - 2
 		rows = len(counts) - 2
 
 		# Pick a cell to click on. Any zero cell will do: if all zeroes are
 		# connected, clicking on any zero will reveal them all.
 		for rowIdx, row in enumerate(counts):
 			if rowIdx == 0 or rowIdx > rows:
 				continue
 			try:
 				colIdx = row.index(0, 1, -1)
 			except ValueError:
 				pass
 			else:
 				click = (rowIdx, colIdx)
 				break
 		else:
 			return None
 
 		revealed = set()
 		def reveal(row, col):
 			if 1 <= row <= rows and 1 <= col <= cols:
 				pos = (row, col)
 				if pos not in revealed:
 					revealed.add(pos)
 					count = counts[row][col]
 					if count == 0:
 						for dr in (-1, 0, 1):
 							for dc in (-1, 0, 1):
 								if dr != 0 or dc != 0:
 									reveal(row + dr, col + dc)
 					else:
 						assert count < 10
 		reveal(*click)
 		numNonMines = rows * cols - self.mineCount
 		if len(revealed) != numNonMines:
 			assert len(revealed) < numNonMines
 			return None
 
 		# Construct a board in the solution syntax.
 		board = [
 				['.' if cell < 10 else '*' for cell in row[1 : -1]]
 				for row in counts[1 : -1]
 				]
 		board[click[0] - 1][click[1] - 1] = 'c'
 		return [''.join(row) for row in board]
 
 def searchBruteForce(rows, cols, mines):
 	# This is the only case where there are no zero cells but there is a
 	# solution.
 	if mines == rows * cols - 1:
 		return ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)
 
 	searchBoard = SearchBoard(rows, cols)
 
 	def searchRec(idx, remaining):
 		if remaining == 0:
 			return searchBoard.checkConnected()
 		elif idx < remaining:
 			return None
 		else:
 			pos = divmod(idx, cols)
 			searchBoard.addMine(*pos)
 			found = searchRec(idx - 1, remaining - 1)
 			searchBoard.removeMine(*pos)
 			if found is not None:
 				return found
 			return searchRec(idx - 1, remaining)
 
 	return searchRec(rows * cols - 1, mines)
 
 def solve(rows, cols, mines):
 	board = search(rows, cols, mines)
 
 	if board is None:
 		board = searchBruteForce(rows, cols, mines)
 		if board is None:
 			return '\n' + 'Impossible'
 		print 'ERROR: fast search missed solution for %dx%d board, %d mines:' \
 				% (rows, cols, mines)
 		for row in board:
 			print row
 		print
 
 	# Perform sanity checks.
 	assert len(board) == rows
 	assert all(len(row) == cols for row in board)
 	counts = { 'c': 0, '.': 0, '*': 0 }
 	for row in board:
 		for cell in row:
 			counts[cell] += 1
 	assert counts['c'] == 1
 	assert counts['*'] == mines
 
 	flowBoard = [
 			['.' if cell == 'c' else cell for cell in row]
 			for row in board
 			]
 	def countMinesOn(row, col):
 		if 0 <= row < rows and 0 <= col < cols:
 			return 1 if flowBoard[row][col] == '*' else 0
 		else:
 			return 0
 	def countMinesNear(row, col):
 		return sum(
 			countMinesOn(row + dr, col + dc)
 			for dr in (-1, 0, 1)
 			for dc in (-1, 0, 1)
 			)
 	def reveal(row, col):
 		if 0 <= row < rows and 0 <= col < cols:
 			assert flowBoard[row][col] != '*'
 			if flowBoard[row][col] == '.':
 				count = countMinesNear(row, col)
 				flowBoard[row][col] = str(count)
 				if count == 0:
 					for dr in (-1, 0, 1):
 						for dc in (-1, 0, 1):
 							reveal(row + dr, col + dc)
 	clickRow, = [i for i, row in enumerate(board) if 'c' in row]
 	clickCol = board[clickRow].index('c')
 	reveal(clickRow, clickCol)
 	assert all('.' not in row for row in flowBoard), flowBoard
 
 	assert all(type(row) == str for row in board)
 	return '\n' + ''.join('\n' + ''.join(row) for row in board)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5690574640250880/0/extracted/C.py,6326,238,1018,Python,2974486,0,5690574640250880,mth,2014
79,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parseBoard(inp):
 	rowSel, = (int(x) for x in inp.readline().split())
 	board = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(4)
 		)
 	return board, rowSel - 1
 
 def parse(inp):
 	before, beforeSel = parseBoard(inp)
 	after, afterSel = parseBoard(inp)
 	return before, beforeSel, after, afterSel
 
 def solve(before, beforeSel, after, afterSel):
 	candidates = set(before[beforeSel]) & set(after[afterSel])
 
 	if len(candidates) == 0:
 		return ""Volunteer cheated!""
 	elif len(candidates) == 1:
 		return candidates.pop()
 	else:
 		return ""Bad magician!""
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2974486/mth/5756407898963968/0/extracted/A.py,1573,63,181,Python,2974486,0,5756407898963968,mth,2014
80,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	num, = (int(x) for x in inp.readline().split())
 	strings = tuple(
 		inp.readline().strip()
 		for _ in xrange(num)
 		)
 	return strings,
 
 def solve(strings):
 	ind = [0] * len(strings)
 	moves = 0
 	ends = 0
 	while ends == 0:
 		ch = None
 		rep = []
 		for n, s in enumerate(strings):
 			i = ind[n]
 			if ch is None:
 				ch = s[i]
 			elif ch != s[i]:
 				return 'Fegla Won'
 			while i < len(s) and ch == s[i]:
 				i += 1
 			rep.append(i - ind[n])
 			ind[n] = i
 			if i == len(s):
 				ends += 1
 		moves += min(
 			sum(abs(r - target) for r in rep)
 			for target in xrange(min(rep), max(rep) + 1)
 			)
 	return moves if ends == len(strings) else 'Fegla Won'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2994486/mth/5751500831719424/1/extracted/A.py,1668,73,228,Python,2994486,1,5751500831719424,mth,2014
81,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	num, = (int(x) for x in inp.readline().split())
 	strings = tuple(
 		inp.readline().strip()
 		for _ in xrange(num)
 		)
 	return strings,
 
 def solve(strings):
 	ind = [0] * len(strings)
 	moves = 0
 	ends = 0
 	while ends == 0:
 		ch = None
 		rep = []
 		for n, s in enumerate(strings):
 			i = ind[n]
 			if ch is None:
 				ch = s[i]
 			elif ch != s[i]:
 				return 'Fegla Won'
 			while i < len(s) and ch == s[i]:
 				i += 1
 			rep.append(i - ind[n])
 			ind[n] = i
 			if i == len(s):
 				ends += 1
 		moves += abs(rep[0] - rep[1])
 	return moves if ends == len(strings) else 'Fegla Won'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2994486/mth/5751500831719424/0/extracted/A.py,1600,70,215,Python,2994486,0,5751500831719424,mth,2014
82,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numCities, numFlights = (int(x) for x in inp.readline().split())
 	zipcodes = tuple(inp.readline().strip() for _ in xrange(numCities))
 	flights = tuple(
 		tuple(int(x) - 1 for x in inp.readline().split())
 		for _ in xrange(numFlights)
 		)
 	return zipcodes, flights
 
 def solve(zipcodes, flights):
 	numCities = len(zipcodes)
 	
 	dest = [[] for _ in xrange(numCities)]
 	for i, j in flights:
 		dest[i].append(j)
 		dest[j].append(i)
 	dest.append(range(numCities))
 
 	bestzips = [None]
 	def rec(stack, zips, toVisit):
 		if toVisit == 0:
 			if bestzips[0] is None or zips < bestzips:
 				bestzips[:] = zips
 		elif stack:
 			city = stack[-1]
 			for d in dest[city]:
 				if ((1 << d) & toVisit) != 0:
 					rec(stack + [d],
 						zips + [zipcodes[d]],
 						toVisit & ~(1 << d))
 			if len(stack) > 2:
 				rec(stack[ : -1], zips, toVisit)
 
 	rec([numCities], [], (1 << numCities) - 1)
 
 	return ''.join(bestzips)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2994486/mth/5731331665297408/0/extracted/C.py,1930,77,236,Python,2994486,0,5731331665297408,mth,2014
83,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	a, b, k = (int(x) for x in inp.readline().split())
 	return a, b, k
 
 def solve(a, b, k):
 	win = 0
 	for ga in xrange(a):
 		for gb in xrange(b):
 			if (ga & gb) < k:
 				win += 1
 	return win
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/2994486/mth/5658282861527040/0/extracted/B.py,1196,52,153,Python,2994486,0,5658282861527040,mth,2014
84,B.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'B-example'
 #FILE_NAME_BASE = 'B-small-attempt1'
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	numbers = tuple(int(x) for x in inp.readline().split())
 	assert len(numbers) == n
 	return numbers,
 
 def solve(a):
 	a = list(a)
 	fwd = sorted(enumerate(a), key = lambda p: p[1])
 	ns = [
 		sum(a[j] < v for j in xrange(i))
 		for i, v in enumerate(a)
 		]
 
 	swaps = 0
 	l = 0
 	r = len(a)
 	for f, (i, _) in enumerate(fwd):
 		ri = i - ns[i]
 		sl = ri
 		sr = r - l - ri - 1
 		if sl < sr:
 			swaps += sl
 			l += 1
 		else:
 			swaps += sr
 			r -= 1
 
 	assert l == r
 	return swaps
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/3014486/mth/5721094409420800/1/extracted/B.py,1601,73,224,Python,3014486,1,5721094409420800,mth,2014
85,B.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'B-example'
 FILE_NAME_BASE = 'B-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	numbers = tuple(int(x) for x in inp.readline().split())
 	assert len(numbers) == n
 	return numbers,
 
 def solve(a):
 	a = list(a)
 	fwd = sorted(enumerate(a), key = lambda p: p[1])
 	ns = [
 		sum(a[j] < v for j in xrange(i))
 		for i, v in enumerate(a)
 		]
 
 	swaps = 0
 	l = 0
 	r = len(a)
 	for f, (i, _) in enumerate(fwd):
 		ri = i - ns[i]
 		sl = ri
 		sr = r - l - ri - 1
 		if sl < sr:
 			swaps += sl
 			l += 1
 		else:
 			swaps += sr
 			r -= 1
 
 	assert l == r
 	return swaps
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/3014486/mth/5721094409420800/0/extracted/B.py,1572,72,221,Python,3014486,0,5721094409420800,mth,2014
86,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numFiles, capacity = (int(x) for x in inp.readline().split())
 	sizes = tuple(int(x) for x in inp.readline().split())
 	assert len(sizes) == numFiles
 	return capacity, sizes
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def solve(capacity, sizes):
 	discs = 0
 	sizes = sorted(sizes, reverse = True)
 	while sizes:
 		s1 = sizes[-1]
 		del sizes[-1]
 		limit = capacity - s1
 		j = search(0, len(sizes), lambda j: sizes[j] <= limit)
 		if j != len(sizes):
 			del sizes[j]
 		discs += 1
 	return discs
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/3014486/mth/5737429512224768/1/extracted/A.py,2016,76,281,Python,3014486,1,5737429512224768,mth,2014
87,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numFiles, capacity = (int(x) for x in inp.readline().split())
 	sizes = tuple(int(x) for x in inp.readline().split())
 	assert len(sizes) == numFiles
 	return capacity, sizes
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def solve(capacity, sizes):
 	discs = 0
 	sizes = sorted(sizes, reverse = True)
 	while sizes:
 		s1 = sizes[-1]
 		del sizes[-1]
 		limit = capacity - s1
 		j = search(0, len(sizes), lambda j: sizes[j] <= limit)
 		if j != len(sizes):
 			del sizes[j]
 		discs += 1
 	return discs
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2014/3014486/mth/5737429512224768/0/extracted/A.py,2025,76,281,Python,3014486,0,5737429512224768,mth,2014
88,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	parts = inp.readline().split()
 	numTaps = int(parts[0])
 	targetVolume, targetTemp = (float(x) for x in parts[1:])
 	taps = tuple(
 		tuple(float(x) for x in inp.readline().split())
 		for _ in xrange(numTaps)
 		)
 	return taps, targetVolume, targetTemp
 
 def solve(taps, targetVolume, targetTemp):
 	if max(temp for rate, temp in taps) < targetTemp:
 		return 'IMPOSSIBLE'
 	if min(temp for rate, temp in taps) > targetTemp:
 		return 'IMPOSSIBLE'
 
 	if len(taps) == 1:
 		rate, temp = taps[0]
 		return targetVolume /rate
 
 	if len(taps) == 2:
 		(rate0, temp0), (rate1, temp1) = taps
 		if temp0 == temp1:
 			return targetVolume / (rate0 + rate1)
 
 		# part0 * temp0 + (1 - part0) * temp1 == targetTemp
 		# part0 * (temp0 - temp1) == targetTemp - temp1
 		part0 = (targetTemp - temp1) / (temp0 - temp1)
 		part1 = 1 - part0
 
 		time0 = (part0 * targetVolume) / rate0
 		time1 = (part1 * targetVolume) / rate1
 
 		return max(time0, time1)
 
 	return '--- not implemented ---'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8234486/mth/5750872826970112/0/extracted/B.py,2217,77,288,Python,8234486,0,5750872826970112,mth,2015
89,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import combinations
 
 def parse(inp):
 	numSentences = int(inp.readline())
 	sentences = tuple(
 		inp.readline().split()
 		for _ in xrange(numSentences)
 		)
 	return sentences,
 
 def subsets(sequence):
 	'''Iterates through all subsets of the given sequence.
 	Each yielded element is a tuple containing a subset of the elements of
 	the original sequence, in the same order as in the original sequence.
 	'''
 	sequence = tuple(sequence)
 	size = len(sequence)
 	def rec(s, i):
 		if i == size:
 			yield tuple(s)
 		else:
 			s.append(sequence[i])
 			for sub in rec(s, i + 1):
 				yield sub
 			del s[-1]
 			for sub in rec(s, i + 1):
 				yield sub
 	return rec([], 0)
 
 def solve(sentences):
 	# Convert strings to integers.
 	words = {}
 	for sentence in sentences:
 		for word in sentence:
 			if word not in words:
 				words[word] = len(words)
 	sentences = tuple(
 		set(words[word] for word in sentence)
 		for sentence in sentences
 		)
 
 	enWords = sentences[0]
 	frWords = sentences[1]
 
 	minBiling = len(words)
 	for enSentenceIndices in subsets(xrange(2, len(sentences))):
 		enWords = set()
 		frWords = set()
 		for idx in xrange(len(sentences)):
 			if idx == 0 or idx in enSentenceIndices:
 				enWords |= sentences[idx]
 			else:
 				frWords |= sentences[idx]
 		minBiling = min(minBiling, len(enWords & frWords))
 	return minBiling
 
 	# Every pair in sameLang are words that occur in the same language.
 	sameLang = set()
 	for sentence in sentences:
 		for pair in combinations(sorted(sentence), 2):
 			sameLang.add(pair)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8234486/mth/5759940174020608/0/extracted/C.py,2783,102,348,Python,8234486,0,5759940174020608,mth,2015
90,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import product
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	return rows, cols
 
 def rotateGrid(grid, rot):
 	return tuple((ring[rot:] + ring[:rot]) for ring in grid)
 
 def solve(rows, cols):
 	modulo = 1000000007
 
 	# 0 is disallowed
 	# 4 is impossible
 	# so only 1, 2 and 3 can be used
 	edgeRings = []
 	innerRings = []
 	for ring in product((1, 2, 3), repeat=cols):
 		possible = True
 		expect = []
 		for i in xrange(cols):
 			c = ring[i]
 			p = ring[(i - 1) % cols]
 			n = ring[(i + 1) % cols]
 			same = (p == c) + (n == c)
 			expect.append((c, c - same))
 		expect = tuple(expect)
 		if all(0 <= count <= 2 for val, count in expect):
 			innerRings.append(expect)
 			if all(count <= 1 for val, count in expect):
 				edgeRings.append(expect)
 	print cols, len(edgeRings), len(innerRings)
 
 	solutions = []
 	def rec(prevRings, left):
 		rings = edgeRings if left == 1 else innerRings
 		maxCount = 0 if left == 1 else 1
 		for ring in rings:
 			nextRing = []
 			for (hv, hc), (uv, uc) in zip(ring, prevRings[-1]):
 				if uc == 0:
 					if hv == uv:
 						break
 				elif uc == 1:
 					if hv != uv:
 						break
 					if hc == 0:
 						break
 					hc -= 1
 				else:
 					assert False, uc
 				if hc > maxCount:
 					break
 				nextRing.append((hv, hc))
 			else:
 				recRings = prevRings + [nextRing]
 				if left == 1:
 					grid = tuple(
 						tuple(val for val, count in ring)
 						for ring in recRings
 						)
 					solutions.append(grid)
 				else:
 					rec(recRings, left - 1)
 	for ring in edgeRings:
 		rec([ring], rows - 1)
 
 	uniqueSolutions = set()
 	for grid in solutions:
 		if all(
 				rotateGrid(grid, rot) not in uniqueSolutions
 				for rot in xrange(cols)
 				):
 			uniqueSolutions.add(grid)
 
 	total = len(uniqueSolutions)
 	return total % modulo
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8234486/mth/5677015495606272/0/extracted/D.py,3062,118,415,Python,8234486,0,5677015495606272,mth,2015
91,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	grid = tuple(inp.readline().strip() for _ in xrange(rows))
 	assert all(len(row) == cols for row in grid)
 	return grid,
 
 def solve(grid):
 	rows = len(grid)
 	cols = len(grid[0])
 
 	arrows = tuple(
 		(x, y)
 		for x in xrange(cols)
 		for y in xrange(rows)
 		if grid[y][x] != '.'
 		)
 
 	dirs = '^>v<'
 	dirDelta = ((0, -1), (1, 0), (0, 1), (-1, 0))
 
 	changed = 0
 	for x, y in arrows:
 		redirected = []
 		for dx, dy in dirDelta:
 			wx, wy = x + dx, y + dy
 			while 0 <= wx < cols and 0 <= wy < rows and grid[wy][wx] == '.':
 				wx += dx
 				wy += dy
 			redirected.append(0 <= wx < cols and 0 <= wy < rows)
 		startDir = dirs.index(grid[y][x])
 		if not redirected[startDir]:
 			if any(redirected):
 				changed += 1
 			else:
 				return 'IMPOSSIBLE'
 
 	return changed
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8234486/mth/5708208098246656/1/extracted/A.py,2064,78,280,Python,8234486,1,5708208098246656,mth,2015
92,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	grid = tuple(inp.readline().strip() for _ in xrange(rows))
 	assert all(len(row) == cols for row in grid)
 	return grid,
 
 def solve(grid):
 	rows = len(grid)
 	cols = len(grid[0])
 
 	arrows = tuple(
 		(x, y)
 		for x in xrange(cols)
 		for y in xrange(rows)
 		if grid[y][x] != '.'
 		)
 
 	dirs = '^>v<'
 	dirDelta = ((0, -1), (1, 0), (0, 1), (-1, 0))
 
 	changed = 0
 	for x, y in arrows:
 		redirected = []
 		for dx, dy in dirDelta:
 			wx, wy = x + dx, y + dy
 			while 0 <= wx < cols and 0 <= wy < rows and grid[wy][wx] == '.':
 				wx += dx
 				wy += dy
 			redirected.append(0 <= wx < cols and 0 <= wy < rows)
 		startDir = dirs.index(grid[y][x])
 		if not redirected[startDir]:
 			if any(redirected):
 				changed += 1
 			else:
 				return 'IMPOSSIBLE'
 
 	return changed
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8234486/mth/5708208098246656/0/extracted/A.py,2073,78,280,Python,8234486,0,5708208098246656,mth,2015
93,B.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'B-example'
 FILE_NAME_BASE = 'B-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols, n = (int(x) for x in inp.readline().split())
 	return rows, cols, n
 
 def maxHappy(rows, cols):
 	# How many rooms can be occupied while unhappiness remains 0?
 	if rows % 2 == 0:
 		return (rows / 2) * cols
 	else:
 		return (rows / 2) * cols + (cols + 1) / 2
 
 def solve(rows, cols, n):
 	if n <= maxHappy(rows, cols):
 		return 0
 
 	# Corners share 2 walls.
 	if rows == 1 or cols == 1:
 		l = max(rows, cols)
 		unhappy = l - 1 - 2 * (l - n)
 		assert unhappy > 0
 		return unhappy
 	if n == 3:
 		assert rows == 2
 		assert cols == 2
 		return 2
 	# All corners occupied.
 	assert n >= 4, n
 	n -= 4
 
 	# Edges share 3 walls.
 	if rows == 2 or cols == 2:
 		l = max(rows, cols) - 2
 		if n < l:
 			# Move one out of a corner.
 			assert n == l - 1
 			return 2
 		elif n == l:
 			return 2 + 2
 		unhappy = 2 # touching corners
 		unhappy += l # walls on middle line
 		unhappy += 2 * (l + 1) # walls across
 		unhappy -= 3 * (2 * l - n) # empty rooms
 		assert unhappy > 0
 		return unhappy
 	edges = (rows - 2) * 2 + (cols - 2) * 2
 	unhappy = 2 * edges
 	n -= edges
 
 	# Inner appartments share 4 walls.
 	rows -= 2
 	cols -= 2
 	if rows % 2 == 0:
 		i = (rows / 2) * cols
 		unhappy += cols + rows
 	else:
 		i = (rows / 2) * cols + (cols - 1) / 2
 		unhappy += (cols / 2) * 2 + (rows / 2) * 2
 	if n < i:
 		# Edges are over-saturated.
 		over = i - n
 		unhappy -= 3 * over
 		if over > max(rows, cols) * 2:
 			unhappy += over - max(rows, cols) * 2
 	else:
 		unhappy += 4 * (n - i)
 	return unhappy
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8224486/mth/5769900270288896/0/extracted/B.py,2560,108,449,Python,8224486,0,5769900270288896,mth,2015
94,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n = int(inp.readline())
 	return n,
 
 def solve(n):
 	#print '->', n
 	ndigits = len(str(n))
 	digits = 1
 	c = 1
 	i = 1
 
 	while True:
 		assert c == 10 ** (digits - 1), (c, digits)
 		if c == n:
 			#print
 			return i
 
 		if digits < ndigits:
 			target = 10 ** digits - 1
 		elif n % 10 == 0:
 			target = n - 1
 		else:
 			target = n
 
 		if digits == 1:
 			i += target - c
 			c = target
 		else:
 			frontStr = str(target)[:digits / 2]
 			front = int(frontStr)
 			back = int(''.join(reversed(list(frontStr))))
 
 			i += back
 			c += back
 			if back != 1:
 				i += 1
 				c = int(''.join(reversed(list(str(c)))))
 			i += target - c
 			c = target
 
 			#print front, back, target
 
 			i += target - c
 			c = target
 
 		if digits < ndigits:
 			c += 1
 			i += 1
 			digits += 1
 		else:
 			if n % 10 == 0:
 				i += 1
 				c += 1
 			assert c == n, (c, n)
 			#print
 			return i
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8224486/mth/5688567749672960/1/extracted/A.py,1893,97,276,Python,8224486,1,5688567749672960,mth,2015
95,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n = int(inp.readline())
 	return n,
 
 def solve(n):
 	#print '->', n
 	ndigits = len(str(n))
 	digits = 1
 	c = 1
 	i = 1
 
 	while True:
 		assert c == 10 ** (digits - 1), (c, digits)
 		if c == n:
 			#print
 			return i
 
 		if digits < ndigits:
 			target = 10 ** digits - 1
 		elif n % 10 == 0:
 			target = n - 1
 		else:
 			target = n
 
 		if digits == 1:
 			i += target - c
 			c = target
 		else:
 			frontStr = str(target)[:digits / 2]
 			front = int(frontStr)
 			back = int(''.join(reversed(list(frontStr))))
 
 			i += back
 			c += back
 			if back != 1:
 				i += 1
 				c = int(''.join(reversed(list(str(c)))))
 			i += target - c
 			c = target
 
 			#print front, back, target
 
 			i += target - c
 			c = target
 
 		if digits < ndigits:
 			c += 1
 			i += 1
 			digits += 1
 		else:
 			if n % 10 == 0:
 				i += 1
 				c += 1
 			assert c == n, (c, n)
 			#print
 			return i
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/8224486/mth/5688567749672960/0/extracted/A.py,1902,97,276,Python,8224486,0,5688567749672960,mth,2015
96,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	cells, rows, cols = (int(x) for x in inp.readline().split())
 	return cells, rows, cols
 
 possible = 'GABRIEL'
 impossible = 'RICHARD'
 
 def solve(cells, rows, cols):
 	# Simplify code by ensuring rows >= cols.
 	if rows < cols:
 		rows, cols = cols, rows
 
 	# If we have 7 or more cells, we can create pieces with holes in them.
 	if cells >= 7:
 		return impossible
 
 	if (rows * cols) % cells != 0:
 		# Grid doesn't fit an integer number of X-onimos.
 		return impossible
 
 	# Check whether there is a single piece that won't fit.
 	for corner in xrange(1, (cells + 1) / 2 + 1):
 		after = cells - corner + 1
 		assert corner <= after, cells
 		if corner > cols or after > rows:
 			# L-shape won't fit.
 			return impossible
 
 	if cells <= 3:
 		# No shapes are possible that would prevent filling the grid.
 		return possible
 	elif cells == 4:
 		# 3x4 is always possible (checked manually).
 		# Since the number of cells is a multiple of 4, we have two factors 2
 		# in rows and cols. Any grid where either row or col is divisible by
 		# 4 and the other is 3 or larger can be filled by adding 1x4 bars to
 		# a 3x4 solution.
 		# Grids where rows and cols each have one factor of two can be reduced
 		# to grids where rows or cols is a multiple of 4 by adding 2x2 blocks
 		# on one edge.
 		# So all non-rejected grids larger than 3x4 are possible.
 		# Grids with cols == 1 will have been rejected in the L-shape test.
 		# So that leaves grids with cols == 2.
 		if cols == 2:
 			# The T- and Z-shaped pieces leave an odd amount of free cells
 			# on either side, which cannot be filled with 4-cell pieces.
 			return impossible
 		else:
 			return possible
 	elif cells == 5:
 		# Rows or cols must be a multiple of 5, so every large grid can be
 		# reduced to 5x5 by padding with 1x5 bars.
 		# 5x1 and 5x2 have already been rejected by L-shape test.
 		assert cols >= 3, cols
 		if cols == 3:
 			# The W-shaped piece leaves 1 free cell on one side and 3 free cells
 			# on the other side.
 			return possible if rows >= 10 else impossible
 		# The W-shaped piece doesn't block filling a 5x4 grid and I don't see
 		# any way any of the other pieces would block it either.
 		return possible
 	elif cells == 6:
 		# One side is a multiple of 6, or one is a multiple of 2 and the other
 		# is a mulitple of 3.
 		# Nx1 and Nx2 have already been rejected by L-shape test.
 		assert cols >= 3, cols
 		# Grids that cannot contain the 1x6 bar have been rejected already.
 		assert rows >= 6, rows
 		if cols == 3:
 			# Cross-shaped piece leaves 2 free cells on one side and 4 on the
 			# other side, which cannot be filled by 6-cell pieces in 3-wide
 			# columns.
 			return impossible
 		# It would take too long to exhaustively investigate this, but I don't
 		# see any way filling a grid this large could be blocked.
 		return possible
 	else:
 		assert False
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5658571765186560/1/extracted/D.py,3883,119,654,Python,6224486,1,5658571765186560,mth,2015
97,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	cells, rows, cols = (int(x) for x in inp.readline().split())
 	return cells, rows, cols
 
 possible = 'GABRIEL'
 impossible = 'RICHARD'
 
 def solve(cells, rows, cols):
 	# Simplify code by ensuring rows >= cols.
 	if rows < cols:
 		rows, cols = cols, rows
 
 	# If we have 7 or more cells, we can create pieces with holes in them.
 	if cells >= 7:
 		return impossible
 
 	if (rows * cols) % cells != 0:
 		# Grid doesn't fit an integer number of X-onimos.
 		return impossible
 
 	# Check whether there is a single piece that won't fit.
 	for corner in xrange(1, (cells + 1) / 2 + 1):
 		after = cells - corner + 1
 		assert corner <= after, cells
 		if corner > cols or after > rows:
 			# L-shape won't fit.
 			return impossible
 
 	if cells <= 3:
 		# No shapes are possible that would prevent filling the grid.
 		return possible
 	elif cells == 4:
 		# 3x4 is always possible (checked manually).
 		# Since the number of cells is a multiple of 4, we have two factors 2
 		# in rows and cols. Any grid where either row or col is divisible by
 		# 4 and the other is 3 or larger can be filled by adding 1x4 bars to
 		# a 3x4 solution. So that leaves grids where row and col each have
 		# one factor of two.
 		if cols == 2:
 			# The T- and Z-shaped pieces leave an odd amount of free cells
 			# on either side, which cannot be filled with 4-cell pieces.
 			return impossible
 		# Small input has limit R <= 4.
 		assert rows < 6
 		return possible
 	else:
 		# Small input has limit X <= 4.
 		assert False
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5658571765186560/0/extracted/D.py,2518,89,393,Python,6224486,0,5658571765186560,mth,2015
98,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numPlates = int(inp.readline())
 	plates = tuple(int(x) for x in inp.readline().split())
 	assert len(plates) == numPlates
 	return plates,
 
 def solve(plates):
 	# Observations:
 	# - since there are an infinite number of plates, it is optimal to always
 	#   split a pancake stack onto an empty plate
 	# - it is optimal to put all the special (split) minutes at the start,
 	#   since the eating rate is equal to the number of non-empty plates
 	# - time spent is number of splits + maximum stack size over all plates
 	# - if you decide to not split the highest stack, there is no point in
 	#   splitting any other stack
 
 	# How high is the highest pancake stack?
 	maxStack = max(plates)
 
 	best = maxStack # takes this long if we don't split
 	for target in xrange(2, maxStack):
 		# How many times do we have to split to not be over target?
 		splits = 0
 		for plate in plates:
 			splits += (plate - 1) / target
 		best = min(best, target + splits)
 
 	return best
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5686275109552128/1/extracted/B.py,1969,69,285,Python,6224486,1,5686275109552128,mth,2015
99,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numPlates = int(inp.readline())
 	plates = tuple(int(x) for x in inp.readline().split())
 	assert len(plates) == numPlates
 	return plates,
 
 def solve(plates):
 	# Observations:
 	# - since there are an infinite number of plates, it is optimal to always
 	#   split a pancake stack onto an empty plate
 	# - it is optimal to put all the special (split) minutes at the start,
 	#   since the eating rate is equal to the number of non-empty plates
 	# - time spent is number of splits + maximum stack size over all plates
 	# - if you decide to not split the highest stack, there is no point in
 	#   splitting any other stack
 
 	# How high is the highest pancake stack?
 	maxStack = max(plates)
 
 	best = maxStack # takes this long if we don't split
 	for target in xrange(2, maxStack):
 		# How many times do we have to split to not be over target?
 		splits = 0
 		for plate in plates:
 			splits += (plate - 1) / target
 		best = min(best, target + splits)
 
 	return best
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5686275109552128/0/extracted/B.py,1978,69,285,Python,6224486,0,5686275109552128,mth,2015
100,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	length, repeat = (int(x) for x in inp.readline().split())
 	letters = inp.readline().strip()
 	assert len(letters) == length
 	return letters, repeat
 
 def createTable():
 	# Set up an 8x8 multiply table.
 	# Indices 0-7 are: 1, i, j, k, -1, -i, -j, -k.
 	mult = []
 	for row in (
 			('1',  'i',  'j',  'k'),
 			('i', '-1',  'k', '-j'),
 			('j', '-k', '-1',  'i'),
 			('k',  'j', '-i', '-1'),
 			):
 		multRow = []
 		for cell in row:
 			ch = cell[-1]
 			d = 0 if ch == '1' else (ord(ch) - ord('h'))
 			if cell[0] == '-':
 				d += 4
 			multRow.append(d)
 		mult.append(multRow)
 	for multRow in mult:
 		multRow.extend([d ^ 4 for d in multRow])
 	for multRow in list(mult):
 		mult.append([d ^ 4 for d in multRow])
 	return mult
 mult = createTable()
 
 def power(n, p):
 	if p == 0:
 		return 0
 	v = power(mult[n][n], p >> 1)
 	if p & 1:
 		v = mult[v][n]
 	return v
 
 def solve(letters, repeat):
 	numbers = tuple(ord(letter) - ord('h') for letter in letters)
 
 	# Compute product of one pass through the string.
 	v = 0
 	for n in numbers:
 		v = mult[v][n]
 	onePass = v
 
 	# Check whether the end result matches.
 	if power(onePass, repeat) != 4:
 		return 'NO'
 
 	# Since there are only 8 different multiplication results, the cumulative
 	# result will repeat in 8 passes or less. Since we're looking for two
 	# intermediate results, 15 passes if sufficient.
 	numbers = numbers * min(repeat, 16)
 
 	# Instead of splitting, we check for cumulative results:
 	# i, k (i*j) and -1 (i*j*k).
 	seenI = False
 	v = 0
 	for n in numbers:
 		v = mult[v][n]
 		if seenI:
 			if v == 3:
 				return 'YES'
 		else:
 			seenI = v == 1
 	return 'NO'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5670465267826688/1/extracted/C.py,2653,110,389,Python,6224486,1,5670465267826688,mth,2015
101,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	length, repeat = (int(x) for x in inp.readline().split())
 	letters = inp.readline().strip()
 	assert len(letters) == length
 	return letters, repeat
 
 def solve(letters, repeat):
 	numbers = tuple(ord(letter) - ord('h') for letter in letters)
 
 	# Set up an 8x8 multiply table.
 	# Indices 0-7 are: 1, i, j, k, -1, -i, -j, -k.
 	mult = []
 	for row in (
 			('1',  'i',  'j',  'k'),
 			('i', '-1',  'k', '-j'),
 			('j', '-k', '-1',  'i'),
 			('k',  'j', '-i', '-1'),
 			):
 		multRow = []
 		for cell in row:
 			ch = cell[-1]
 			d = 0 if ch == '1' else (ord(ch) - ord('h'))
 			if cell[0] == '-':
 				d += 4
 			multRow.append(d)
 		mult.append(multRow)
 	for multRow in mult:
 		multRow.extend([d ^ 4 for d in multRow])
 	for multRow in list(mult):
 		mult.append([d ^ 4 for d in multRow])
 
 	# For the small input set, this is feasible.
 	numbers = numbers * repeat
 
 	# Instead of splitting, we check for cumulative results:
 	# i, k (i*j) and -1 (i*j*k).
 	seenI = False
 	seenK = False
 	v = 0
 	for n in numbers:
 		seenI |= v == 1
 		seenK |= seenI and v == 3
 		v = mult[v][n]
 	return 'YES' if seenI and seenK and v == 4 else 'NO'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5670465267826688/0/extracted/C.py,2151,85,309,Python,6224486,0,5670465267826688,mth,2015
102,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	maxShyStr, audienceStr = inp.readline().split()
 	assert int(maxShyStr) + 1 == len(audienceStr)
 	return tuple(int(digit) for digit in audienceStr),
 
 def solve(audience):
 	standing = 0
 	extras = 0
 	for shyness, count in enumerate(audience):
 		extras = max(extras, shyness - standing)
 		standing += count
 	return extras
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5639104758808576/1/extracted/A.py,1317,53,154,Python,6224486,1,5639104758808576,mth,2015
103,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	maxShyStr, audienceStr = inp.readline().split()
 	assert int(maxShyStr) + 1 == len(audienceStr)
 	return tuple(int(digit) for digit in audienceStr),
 
 def solve(audience):
 	standing = 0
 	extras = 0
 	for shyness, count in enumerate(audience):
 		extras = max(extras, shyness - standing)
 		standing += count
 	return extras
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/6224486/mth/5639104758808576/0/extracted/A.py,1326,53,154,Python,6224486,0,5639104758808576,mth,2015
104,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numSamples = int(inp.readline())
 	samples = tuple(int(x) for x in inp.readline().split())
 	assert len(samples) == numSamples
 	return samples,
 
 def solve(samples):
 	min1 = sum(
 		max(samples[i] - samples[i + 1], 0)
 		for i in xrange(len(samples) - 1)
 		)
 
 	maxDelta = max(
 		samples[i] - samples[i + 1]
 		for i in xrange(len(samples) - 1)
 		)
 	min2 = sum(
 		min(samples[i], maxDelta)
 		for i in xrange(len(samples) - 1)
 		)
 
 	return '%d %d' % (min1, min2)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4224486/mth/6404600001200128/1/extracted/A.py,1465,63,181,Python,4224486,1,6404600001200128,mth,2015
105,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numSamples = int(inp.readline())
 	samples = tuple(int(x) for x in inp.readline().split())
 	assert len(samples) == numSamples
 	return samples,
 
 def solve(samples):
 	min1 = sum(
 		max(samples[i] - samples[i + 1], 0)
 		for i in xrange(len(samples) - 1)
 		)
 
 	maxDelta = max(
 		samples[i] - samples[i + 1]
 		for i in xrange(len(samples) - 1)
 		)
 	min2 = sum(
 		min(samples[i], maxDelta)
 		for i in xrange(len(samples) - 1)
 		)
 
 	return '%d %d' % (min1, min2)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4224486/mth/6404600001200128/0/extracted/A.py,1474,63,181,Python,4224486,0,6404600001200128,mth,2015
106,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numBarbers, clientIndex = (int(x) for x in inp.readline().split())
 	barberSpeed = tuple(int(x) for x in inp.readline().split())
 	assert len(barberSpeed) == numBarbers
 	return barberSpeed, clientIndex
 
 def mult(seq):
 	result = 1
 	for n in seq:
 		result *= n
 	return result
 
 def search(low, high, test):
 	'''Binary search: [low..high) is the range to search; function ""test""
 	takes a single value from that interval and returns a truth value.
 	The function must be ascending: (test(x) and y >= x) => test(y).
 	Returns smallest argument in the interval for which the function is true,
 	or ""high"" if the function is false for the entire interval.
 	'''
 	while low < high:
 		mid = (low + high - 1) / 2
 		if test(mid):
 			if mid == low:
 				return low # found
 			high = mid + 1
 		else:
 			low = mid + 1
 	return high # not found
 
 def solve(speed, clientIndex):
 	clientIndex -= 1 # make zero-based
 	numBarbers = len(speed)
 
 	def doneAt(t, speed=speed):
 		'''number of clients complete at time t'''
 		return sum(t / s for s in speed)
 
 	# skip full repeat cycles
 	# (actually faster repeats are possible, but this is the worst case)
 	repeat = mult(speed)
 	clientIndex %= doneAt(repeat)
 
 	# if the fastest barber worked alone
 	timeLimit = clientIndex * max(speed)
 	clientIndex -= numBarbers
 	t = search(0, timeLimit, lambda t: clientIndex < doneAt(t))
 
 	waiting = clientIndex - doneAt(t)
 	for i, s in reversed(tuple(enumerate(speed))):
 		if t % s == 0:
 			waiting += 1
 			if waiting == 0:
 				return i + 1
 	assert False, t
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4224486/mth/5765824346324992/1/extracted/B.py,2553,95,358,Python,4224486,1,5765824346324992,mth,2015
107,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt1'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numBarbers, clientIndex = (int(x) for x in inp.readline().split())
 	barberSpeed = tuple(int(x) for x in inp.readline().split())
 	assert len(barberSpeed) == numBarbers
 	return barberSpeed, clientIndex
 
 def mult(seq):
 	result = 1
 	for n in seq:
 		result *= n
 	return result
 
 
 def solve(speed, clientIndex):
 	clientIndex -= 1 # make zero-based
 	numBarbers = len(speed)
 
 	def doneAt(t):
 		'''number of clients complete at time t'''
 		return sum(t / s for s in speed)
 
 	# skip full repeat cycles
 	repeat = mult(speed)
 	clientIndex %= doneAt(repeat)
 
 	t = 0
 	while True:
 		waiting = clientIndex - numBarbers - doneAt(t)
 		if waiting < 0:
 			break
 		t += 1
 
 	for i, s in reversed(tuple(enumerate(speed))):
 		if t % s == 0:
 			waiting += 1
 			if waiting == 0:
 				return i + 1
 	assert False, t
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	inp = open(FILE_NAME_BASE + '.in', 'r')
 	numCases = int(inp.readline())
 	if NUM_PROCESSES == 0:
 		results = [
 			solve(*parse(inp))
 			for _ in range(numCases)
 			]
 	else:
 		from multiprocessing import Pool
 		pool = Pool(NUM_PROCESSES)
 		results = [
 			pool.apply_async(solve, parse(inp))
 			for _ in range(numCases)
 			]
 	inp.close()
 	out = open(FILE_NAME_BASE + '.out', 'w')
 	for case, result in enumerate(results):
 		value = result if NUM_PROCESSES == 0 else result.get()
 		out.write('Case #%d: %s\n' % (case + 1, value))
 		out.flush()
 	out.close()
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4224486/mth/5765824346324992/0/extracted/B.py,1821,79,235,Python,4224486,0,5765824346324992,mth,2015
108,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	maxSame, numOld, maxValue = (int(x) for x in inp.readline().split())
 	oldCoins = tuple(int(x) for x in inp.readline().split())
 	assert len(oldCoins) == numOld
 	return oldCoins, maxSame, maxValue
 
 def solve(coins, maxSame, maxValue):
 	added = 0
 	coinIdx = 0
 	reach = 0
 	# coins [0..coinIdx) have been used
 	# all numbers [1..reach] can be made
 	while reach < maxValue:
 		if coinIdx < len(coins):
 			coin = coins[coinIdx]
 		else:
 			coin = None
 		target = reach + 1
 		if coin is None or coin > target:
 			# New coin.
 			coin = target
 			added += 1
 		else:
 			coinIdx += 1
 		# Extend range.
 		reach += coin * maxSame
 
 	return added
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4244486/mth/5646553574277120/1/extracted/C.py,1875,69,243,Python,4244486,1,5646553574277120,mth,2015
109,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	maxSame, numOld, maxValue = (int(x) for x in inp.readline().split())
 	oldCoins = tuple(int(x) for x in inp.readline().split())
 	assert len(oldCoins) == numOld
 	return oldCoins, maxSame, maxValue
 
 def reach(coins):
 	values = set()
 	def rec(s, i, coins=coins, n=len(coins)):
 		if i == n:
 			values.add(s)
 		else:
 			rec(s, i + 1)
 			rec(s + coins[i], i + 1)
 	rec(0, 0)
 	values.remove(0)
 	return values
 
 def solve(oldCoins, maxSame, maxValue):
 	values = set(xrange(1, maxValue + 1))
 	def rec(coins):
 		missing = values - reach(tuple(coins))
 		if not missing:
 			return 0
 		v = min(missing)
 		m = maxValue
 		for c in xrange(1, v + 1):
 			if c not in coins:
 				coins.add(c)
 				m = min(m, 1 + rec(coins))
 				coins.remove(c)
 		return m
 	return rec(set(oldCoins))
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4244486/mth/5646553574277120/0/extracted/C.py,2019,74,249,Python,4244486,0,5646553574277120,mth,2015
110,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 from itertools import product
 
 def parse(inp):
 	numKeys, targetLen, typeLen = (int(x) for x in inp.readline().split())
 	keys = inp.readline().strip()
 	assert len(keys) == numKeys
 	target = inp.readline().strip()
 	assert len(target) == targetLen
 	return keys, target, typeLen
 
 def maxPrefix(s):
 	return reduce(max, (i for i in xrange(1, len(s)) if s[:i] == s[-i:]), 0)
 
 def solve(keys, target, typeLen):
 	if set(target) - set(keys):
 		return 0.0
 
 	assert len(target) <= typeLen
 	mp = maxPrefix(target)
 	maxBananas = 1 + (typeLen - len(target)) / (len(target) - mp)
 
 	if False:
 		matches = 0
 		for typed in product(keys, repeat=typeLen):
 			word = ''.join(typed)
 			i = 0
 			while True:
 				i = word.find(target, i)
 				if i == -1:
 					break
 				matches += 1
 				i += 1
 		slowMatches = matches
 
 	keyHist = defaultdict(int)
 	for key in keys:
 		keyHist[key] += 1
 	trans = []
 	for i in xrange(len(target)):
 		nxt = []
 		pref = maxPrefix(target[:i])
 		for key, chance in keyHist.iteritems():
 			full = False
 			if key == target[i]:
 				succ = i + 1
 				if succ == len(target):
 					full = True
 					succ = mp
 			elif key == target[pref]:
 				succ = pref + 1
 			else:
 				succ = 0
 			nxt.append([succ, full, chance])
 		trans.append(nxt)
 	progress = [[1] + [0] * (len(target) - 1)]
 	for rep in xrange(typeLen):
 		newProgress = [[0] * len(target)]
 		for j, pj in enumerate(progress):
 			for i, p in enumerate(pj):
 				for succ, full, chance in trans[i]:
 					if j + full >= len(newProgress):
 						newProgress.append([0] * len(target))
 					newProgress[j + full][succ] += p * chance
 		progress = newProgress
 	matches = 0
 	for j, pj in enumerate(progress):
 		matches += j * sum(pj)
 	#assert matches == slowMatches, (matches, slowMatches)
 
 	words = len(keys) ** typeLen
 	return maxBananas - float(matches) / float(words)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4244486/mth/5708284669460480/1/extracted/B.py,3120,113,406,Python,4244486,1,5708284669460480,mth,2015
111,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import product
 
 def parse(inp):
 	numKeys, targetLen, typeLen = (int(x) for x in inp.readline().split())
 	keys = inp.readline().strip()
 	assert len(keys) == numKeys
 	target = inp.readline().strip()
 	assert len(target) == targetLen
 	return keys, target, typeLen
 
 def maxPrefix(s):
 	return reduce(max, (i for i in xrange(1, len(s)) if s[:i] == s[-i:]), 0)
 
 def solve(keys, target, typeLen):
 	if set(target) - set(keys):
 		return 0.0
 
 	assert len(target) <= typeLen
 	maxBananas = 1 + (typeLen - len(target)) / (len(target) - maxPrefix(target))
 
 	matches = 0
 	words = 0
 	for typed in product(keys, repeat=typeLen):
 		word = ''.join(typed)
 		words += 1
 		i = 0
 		while True:
 			i = word.find(target, i)
 			if i == -1:
 				break
 			matches += 1
 			i += 1
 
 	return maxBananas - float(matches) / float(words)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4244486/mth/5708284669460480/0/extracted/B.py,2059,75,256,Python,4244486,0,5708284669460480,mth,2015
112,A.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'A-small-attempt1'
 #FILE_NAME_BASE = 'A-example'
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols, size = (int(x) for x in inp.readline().split())
 	return rows, cols, size
 
 def solve(rows, cols, size):
 	toHit = cols / size
 	hitFlex = cols % size
 	toSink = size - 1 if hitFlex == 0 else size
 	return rows * toHit + toSink
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4244486/mth/5640146288377856/1/extracted/A.py,1530,52,192,Python,4244486,1,5640146288377856,mth,2015
113,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt1'
 #FILE_NAME_BASE = 'A-example'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols, size = (int(x) for x in inp.readline().split())
 	return rows, cols, size
 
 def solve(rows, cols, size):
 	toHit = cols / size
 	hitFlex = cols % size
 	toSink = size - 1 if hitFlex == 0 else size
 	return rows * toHit + toSink
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2015/4244486/mth/5640146288377856/0/extracted/A.py,1501,51,189,Python,4244486,0,5640146288377856,mth,2015
114,b.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	lists = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(2 * n - 1)
 		)
 	return n, lists
 
 def solve(n, lists):
 	freq = defaultdict(int)
 	for l in lists:
 		for h in l:
 			freq[h] += 1
 	odd = [h for h, f in freq.iteritems() if f % 2 == 1]
 	missing = sorted(odd)
 	return ' '.join(str(h) for h in missing)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/4304486/mth/5630113748090880/1/extracted/b.py,1646,59,214,Python,4304486,1,5630113748090880,mth,2016
115,b.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	lists = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(2 * n - 1)
 		)
 	return n, lists
 
 def subsets(sequence):
 	'''Iterates through all subsets of the given sequence.
 	Each yielded element is a tuple containing a subset of the elements of
 	the original sequence, in the same order as in the original sequence.
 	'''
 	sequence = tuple(sequence)
 	size = len(sequence)
 	def rec(s, i):
 		if i == size:
 			yield tuple(s)
 		else:
 			s.append(sequence[i])
 			for sub in rec(s, i + 1):
 				yield sub
 			del s[-1]
 			for sub in rec(s, i + 1):
 				yield sub
 	return rec([], 0)
 
 def solve(n, lists):
 	for rows in subsets(lists):
 		if len(rows) != n:
 			continue
 		rows = set(rows)
 		if len(rows) != n:
 			# Duplicate lists can exist, but duplicate rows make grid invalid.
 			continue
 		to_drop = set(rows)
 		cols = set()
 		for l in lists:
 			if l in to_drop:
 				to_drop.discard(l)
 			else:
 				cols.add(l)
 		if len(cols) != n - 1:
 			# Duplicate lists can exist, but duplicate cols make grid invalid.
 			continue
 		grid = tuple(sorted(rows))
 		gridcols = set(
 			tuple(grid[row][col] for row in xrange(n))
 			for col in xrange(n)
 			)
 		overlap = gridcols & cols
 		if len(overlap) != n - 1:
 			continue
 		diff = gridcols - cols
 		assert len(diff) == 1, diff
 		missing = diff.pop()
 		break
 	else:
 		assert False
 	return ' '.join(str(h) for h in missing)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/4304486/mth/5630113748090880/0/extracted/b.py,2702,101,363,Python,4304486,0,5630113748090880,mth,2016
116,a.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	s = inp.readline().strip()
 	return s,
 
 def solve(s):
 	r = ''
 	for c in s:
 		#print r
 		if not r:
 			r = c
 		elif c >= r[0]:
 			r = c + r
 		else:
 			r = r + c
 	return r
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/4304486/mth/5631989306621952/1/extracted/a.py,1401,56,181,Python,4304486,1,5631989306621952,mth,2016
117,a.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	s = inp.readline().strip()
 	return s,
 
 def solve(s):
 	r = ''
 	for c in s:
 		#print r
 		if not r:
 			r = c
 		elif c >= r[0]:
 			r = c + r
 		else:
 			r = r + c
 	return r
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/4304486/mth/5631989306621952/0/extracted/a.py,1410,56,181,Python,4304486,0,5631989306621952,mth,2016
118,c.bitslow.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import permutations
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	bff = tuple(int(x) - 1 for x in inp.readline().split())
 	assert len(bff) == n
 	return n, bff
 
 def solve(n, bff):
 	maxlen = 0
 	for included in xrange(1 << n):
 		children = tuple(i for i in xrange(n) if (included >> i) & 1)
 		length = len(children)
 		if length <= maxlen:
 			continue
 
 		for circle in permutations(children):
 			if all(
 					circle[(i - 1) % length] == bff[c] or
 					circle[(i + 1) % length] == bff[c]
 					for i, c in enumerate(circle)
 				):
 				maxlen = length
 				break
 	return maxlen
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/4304486/mth/5631572862566400/0/extracted/c.bitslow.py,1839,66,235,Python,4304486,0,5631572862566400,mth,2016
119,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	return n,
 
 def solve(n):
 	if n == 0:
 		return 'INSOMNIA'
 	seen = set()
 	i = 1
 	while True:
 		seen |= set(str(i * n))
 		if len(seen) == 10:
 			break
 		i += 1
 	return i * n
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5652388522229760/1/extracted/A.py,1451,56,184,Python,6254486,1,5652388522229760,mth,2016
120,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	return n,
 
 def solve(n):
 	if n == 0:
 		return 'INSOMNIA'
 	seen = set()
 	i = 1
 	while True:
 		seen |= set(str(i * n))
 		if len(seen) == 10:
 			break
 		i += 1
 	return i * n
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5652388522229760/0/extracted/A.py,1460,56,184,Python,6254486,0,5652388522229760,mth,2016
121,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	k, c, s = (int(x) for x in inp.readline().split())
 	return k, c, s
 
 def solve(numTiles, complexity, numStudents):
 	if numStudents * complexity < numTiles:
 		return 'IMPOSSIBLE'
 
 	result = []
 	pos = 0
 	while pos < numTiles:
 		# Coordinates to inspect.
 		coord = range(pos, min(pos + complexity, numTiles))
 		coord += [0] * (complexity - len(coord))
 		assert len(coord) == complexity
 		pos += complexity
 
 		# Convert to linear.
 		result.append(sum(x * numTiles ** i for i, x in enumerate(coord)))
 
 	return ' '.join(str(tile + 1) for tile in result)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5636311922769920/1/extracted/D.py,1786,62,225,Python,6254486,1,5636311922769920,mth,2016
122,D.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'D-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	k, c, s = (int(x) for x in inp.readline().split())
 	return k, c, s
 
 def solve(numTiles, complexity, numStudents):
 	if numStudents * complexity < numTiles:
 		return 'IMPOSSIBLE'
 
 	result = []
 	pos = 0
 	while pos < numTiles:
 		# Coordinates to inspect.
 		coord = range(pos, min(pos + complexity, numTiles))
 		coord += [0] * (complexity - len(coord))
 		assert len(coord) == complexity
 		pos += complexity
 
 		# Convert to linear.
 		result.append(sum(x * numTiles ** i for i, x in enumerate(coord)))
 
 	return ' '.join(str(tile + 1) for tile in result)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5636311922769920/0/extracted/D.py,1795,62,225,Python,6254486,0,5636311922769920,mth,2016
123,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def calcPrimes(limit):
 	'''Returns list of all primes under the given limit.
 	'''
 	sieve = [ True ] * limit
 	sieve[0] = False
 	sieve[1] = False
 	i = 2
 	while i * i < limit:
 		if sieve[i]:
 			for j in xrange(2 * i, limit, i):
 				sieve[j] = False
 		i += 1
 	return [ i for i, prime in enumerate(sieve) if prime ]
 
 # NOTE: This limit is not sufficient to find all possible jamcoins for the
 #       large problem set, but it might find enough.
 primes = calcPrimes(10 ** 8)
 print 'Found %d primes' % len(primes)
 
 def parse(inp):
 	n, j = (int(x) for x in inp.readline().split())
 	return n, j
 
 def find_divider(n):
 	for p in primes:
 		if p * p > n:
 			break
 		if n % p == 0:
 			return p
 	return None
 
 def solve(n, j):
 	result = []
 	for d in xrange(1 << (n - 2)):
 		s = ('1{0:0%db}1' % (n - 2)).format(d)
 		divs = []
 		for b in xrange(2, 11):
 			div = find_divider(int(s, b))
 			if div is None:
 				break
 			divs.append(div)
 		if len(divs) == 9:
 			result.append((s, divs))
 			print 'Found %d jamcoins' % len(result)
 			if len(result) == j:
 				break
 	else:
 		assert False, (n, j)
 
 	return '\n' + '\n'.join(
 		' '.join(str(e) for e in [s] + divs)
 		for s, divs in result
 		)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5738606668808192/1/extracted/C.py,2421,94,350,Python,6254486,1,5738606668808192,mth,2016
124,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def calcPrimes(limit):
 	'''Returns list of all primes under the given limit.
 	'''
 	sieve = [ True ] * limit
 	sieve[0] = False
 	sieve[1] = False
 	i = 2
 	while i * i < limit:
 		if sieve[i]:
 			for j in xrange(2 * i, limit, i):
 				sieve[j] = False
 		i += 1
 	return [ i for i, prime in enumerate(sieve) if prime ]
 
 # NOTE: This limit is not sufficient for the large problem set.
 primes = calcPrimes(10 ** 8)
 print 'Found %d primes' % len(primes)
 
 def parse(inp):
 	n, j = (int(x) for x in inp.readline().split())
 	return n, j
 
 def find_divider(n):
 	for p in primes:
 		if p * p > n:
 			break
 		if n % p == 0:
 			return p
 	return None
 
 def solve(n, j):
 	result = []
 	for d in xrange(1 << (n - 2)):
 		s = ('1{0:0%db}1' % (n - 2)).format(d)
 		divs = [find_divider(int(s, b)) for b in xrange(2, 11)]
 		if None not in divs:
 			result.append((s, divs))
 			if len(result) == j:
 				break
 	else:
 		assert False, (n, j)
 
 	return '\n' + '\n'.join(
 		' '.join(str(e) for e in [s] + divs)
 		for s, divs in result
 		)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5738606668808192/0/extracted/C.py,2247,87,325,Python,6254486,0,5738606668808192,mth,2016
125,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	s = inp.readline().strip()
 	return s,
 
 def flip(s):
 	return ''.join(
 		{'+': '-', '-': '+'}[c]
 		for c in reversed(s)
 		)
 
 '''
 Splitting up a sequence isn't going to 
 
 
 '''
 
 def solve_count(s):
 	prev = '?'
 	count = 0
 	for c in s.rstrip('+'):
 		if c != prev:
 			count += 1
 			prev = c
 	return count
 
 def solve_strategy(s):
 	flips = 0
 	while True:
 		#print s, flips
 		if s[0] == '+':
 			i = s.find('-')
 			if i == -1:
 				break
 		else:
 			i = s.rfind('-') + 1
 			if i == 0:
 				break
 		s = flip(s[:i]) + s[i:]
 		flips += 1
 	return flips
 
 def solve_slow(init):
 	n = len(init)
 	old = set()
 	curr = set([init])
 	flips = 0
 	while True:
 		if '+' * n in curr:
 			return flips
 		old |= curr
 		new = set()
 		for s in curr:
 			for i in xrange(1, n + 1):
 				sf = flip(s[:i]) + s[i:]
 				if sf not in old:
 					new.add(sf)
 		curr = new
 		flips += 1
 
 def solve(s):
 	count = solve_count(s)
 	strat = solve_strategy(s)
 	assert count == strat, s
 	if len(s) <= 10:
 		slow = solve_slow(s)
 		assert strat == slow, s
 	return count
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5634697451274240/1/extracted/B.py,2295,108,321,Python,6254486,1,5634697451274240,mth,2016
126,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	s = inp.readline().strip()
 	return s,
 
 def flip(s):
 	return ''.join(
 		{'+': '-', '-': '+'}[c]
 		for c in reversed(s)
 		)
 
 def solve(init):
 	n = len(init)
 	old = set()
 	curr = set([init])
 	flips = 0
 	while True:
 		if '+' * n in curr:
 			return flips
 		old |= curr
 		new = set()
 		for s in curr:
 			for i in xrange(1, n + 1):
 				sf = flip(s[:i]) + s[i:]
 				if sf not in old:
 					new.add(sf)
 		curr = new
 		flips += 1
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/6254486/mth/5634697451274240/0/extracted/B.py,1673,68,218,Python,6254486,0,5634697451274240,mth,2016
127,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	lovers = tuple(int(x) for x in inp.readline().split())
 	assert len(lovers) == 2 * (rows + cols)
 	pairs = tuple(zip(lovers[::2], lovers[1::2]))
 	return rows, cols, pairs
 
 def solve(rows, cols, lovers):
 	n = len(lovers) * 2
 	lovers = set(tuple(sorted((a - 1, b - 1))) for a, b in lovers)
 	done = set()
 	maze = [['?'] * cols for _ in xrange(rows)]
 
 	def lover_coord(i):
 		if i < cols:
 			return -1, i
 		if i < cols + rows:
 			return i - cols, cols
 		if i < cols + rows + cols:
 			return rows, cols + rows + cols - 1 - i
 		if i < cols + rows + cols + rows:
 			return cols + rows + cols + rows - 1 - i, -1
 		assert False, i
 
 	while lovers:
 		for src, dst in lovers:
 			if all(i in done for i in xrange(src + 1, dst)):
 				fwd = True
 				break
 			if all((i % n) in done for i in xrange(dst + 1, n + src)):
 				fwd = False
 				break
 		else:
 			return '\nIMPOSSIBLE'
 
 		sr, sc = lover_coord(src)
 		dr, dc = lover_coord(dst)
 		#print src + 1, '@', (sr, sc), '->', dst + 1, '@', (dr, dc)
 		if not fwd:
 			sr, sc, dr, dc = dr, dc, sr, sc
 
 		#print '\n'.join(''.join(row) for row in maze)
 		#print src + 1, '@', (sr, sc), '->', dst + 1, '@', (dr, dc)
 		if sr < 0:
 			angle = 2
 		elif sc >= cols:
 			angle = 3
 		elif sr >= rows:
 			angle = 0
 		elif sc < 0:
 			angle = 1
 		else:
 			assert False
 
 		while True:
 			sc += (0, 1, 0, -1)[angle]
 			sr += (-1, 0, 1, 0)[angle]
 			if not (0 <= sr < rows and 0 <= sc < cols):
 				if sr == dr and sc == dc:
 					break
 				else:
 					return '\nIMPOSSIBLE'
 
 			hedge = maze[sr][sc]
 			if hedge == '?':
 				hedge = ('\\', '/', '\\', '/')[angle]
 				maze[sr][sc] = hedge
 			if hedge == '/':
 				angle = (1, 0, 3, 2)[angle]
 			elif hedge == '\\':
 				angle = (3, 2, 1, 0)[angle]
 			else:
 				assert False
 
 		done.add(src)
 		done.add(dst)
 		lovers.remove((src, dst))
 
 	for row in xrange(rows):
 		for col in xrange(cols):
 			if maze[row][col] == '?':
 				maze[row][col] = '/'
 
 	return '\n' + '\n'.join(''.join(row) for row in maze)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/10224486/mth/5723605790883840/1/extracted/C.py,3308,125,506,Python,10224486,1,5723605790883840,mth,2016
128,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	rows, cols = (int(x) for x in inp.readline().split())
 	lovers = tuple(int(x) for x in inp.readline().split())
 	assert len(lovers) == 2 * (rows + cols)
 	pairs = tuple(zip(lovers[::2], lovers[1::2]))
 	return rows, cols, pairs
 
 def solve(rows, cols, lovers):
 	n = len(lovers) * 2
 	lovers = set(tuple(sorted((a - 1, b - 1))) for a, b in lovers)
 	done = set()
 	maze = [['?'] * cols for _ in xrange(rows)]
 
 	def lover_coord(i):
 		if i < cols:
 			return -1, i
 		if i < cols + rows:
 			return i - cols, cols
 		if i < cols + rows + cols:
 			return rows, cols + rows + cols - 1 - i
 		if i < cols + rows + cols + rows:
 			return cols + rows + cols + rows - 1 - i, -1
 		assert False, i
 
 	while lovers:
 		for src, dst in lovers:
 			if all(i in done for i in xrange(src + 1, dst)):
 				fwd = True
 				break
 			if all((i % n) in done for i in xrange(dst + 1, n + src)):
 				fwd = False
 				break
 		else:
 			return '\nIMPOSSIBLE'
 
 		sr, sc = lover_coord(src)
 		dr, dc = lover_coord(dst)
 		#print src + 1, '@', (sr, sc), '->', dst + 1, '@', (dr, dc)
 		if not fwd:
 			sr, sc, dr, dc = dr, dc, sr, sc
 
 		#print '\n'.join(''.join(row) for row in maze)
 		#print src + 1, '@', (sr, sc), '->', dst + 1, '@', (dr, dc)
 		if sr < 0:
 			angle = 2
 		elif sc >= cols:
 			angle = 3
 		elif sr >= rows:
 			angle = 0
 		elif sc < 0:
 			angle = 1
 		else:
 			assert False
 
 		while True:
 			sc += (0, 1, 0, -1)[angle]
 			sr += (-1, 0, 1, 0)[angle]
 			if not (0 <= sr < rows and 0 <= sc < cols):
 				if sr == dr and sc == dc:
 					break
 				else:
 					return '\nIMPOSSIBLE'
 
 			hedge = maze[sr][sc]
 			if hedge == '?':
 				hedge = ('\\', '/', '\\', '/')[angle]
 				maze[sr][sc] = hedge
 			if hedge == '/':
 				angle = (1, 0, 3, 2)[angle]
 			elif hedge == '\\':
 				angle = (3, 2, 1, 0)[angle]
 			else:
 				assert False
 
 		done.add(src)
 		done.add(dst)
 		lovers.remove((src, dst))
 
 	for row in xrange(rows):
 		for col in xrange(cols):
 			if maze[row][col] == '?':
 				maze[row][col] = '/'
 
 	return '\n' + '\n'.join(''.join(row) for row in maze)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/10224486/mth/5723605790883840/0/extracted/C.py,3317,125,506,Python,10224486,0,5723605790883840,mth,2016
129,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, r, p, s = (int(x) for x in inp.readline().split())
 	return n, r, p, s
 
 def deadlock(lineup):
 	while len(lineup) > 1:
 		winners = []
 		for a, b in zip(lineup[::2], lineup[1::2]):
 			if a == b:
 				return True
 			if max(a, b) == 'S' and min(a, b) == 'R':
 				winners.append('R')
 			elif max(a, b) == 'R' and min(a, b) == 'P':
 				winners.append('P')
 			elif max(a, b) == 'S' and min(a, b) == 'P':
 				winners.append('S')
 			else:
 				assert False, (a, b)
 		lineup = winners
 	return False
 
 def solve(n, r, p, s):
 	participants = 1 << n
 
 	def rec(lineup, r, p, s):
 		if len(lineup) == participants:
 			if not deadlock(lineup):
 				yield ''.join(lineup)
 		if r > 0:
 			lineup.append('R')
 			for found in rec(lineup, r - 1, p, s):
 				yield found
 			del lineup[-1]
 		if p > 0:
 			lineup.append('P')
 			for found in rec(lineup, r, p - 1, s):
 				yield found
 			del lineup[-1]
 		if s > 0:
 			lineup.append('S')
 			for found in rec(lineup, r, p, s - 1):
 				yield found 
 			del lineup[-1]
 
 	lineups = sorted(rec([], r, p, s))
 	return lineups[0] if len(lineups) > 0 else 'IMPOSSIBLE'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/10224486/mth/5718606851604480/0/extracted/A.py,2350,87,313,Python,10224486,0,5718606851604480,mth,2016
130,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	s = inp.readline().strip()
 	return s,
 
 # ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 
 def solve(s):
 	freqs = defaultdict(int)
 	for c in s:
 		freqs[c] += 1
 	#print freqs
 
 	digits = []
 
 	def eatWord(word, digit, uniqueLetter):
 		while freqs[uniqueLetter] > 0:
 			for c in word:
 				freqs[c] -= 1
 				assert freqs[c] >= 0, word
 			digits.append(digit)
 
 	eatWord('ZERO', 0, 'Z')
 	eatWord('SIX', 6, 'X')
 	eatWord('TWO', 2, 'W')
 	eatWord('EIGHT', 8, 'G')
 	eatWord('SEVEN', 7, 'S')
 	eatWord('THREE', 3, 'H')
 	eatWord('FOUR', 4, 'R')
 	eatWord('FIVE', 5, 'F')
 	eatWord('ONE', 1, 'O')
 	eatWord('NINE', 9, 'I')
 
 	assert all(f == 0 for f in freqs.itervalues()), freqs
 
 	return ''.join(str(d) for d in sorted(digits))
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/11254486/mth/5648941810974720/1/extracted/A.py,2032,78,245,Python,11254486,1,5648941810974720,mth,2016
131,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	s = inp.readline().strip()
 	return s,
 
 # ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 
 def solve(s):
 	freqs = defaultdict(int)
 	for c in s:
 		freqs[c] += 1
 	#print freqs
 
 	digits = []
 
 	def eatWord(word, digit, uniqueLetter):
 		while freqs[uniqueLetter] > 0:
 			for c in word:
 				freqs[c] -= 1
 				assert freqs[c] >= 0, word
 			digits.append(digit)
 
 	eatWord('ZERO', 0, 'Z')
 	eatWord('SIX', 6, 'X')
 	eatWord('TWO', 2, 'W')
 	eatWord('EIGHT', 8, 'G')
 	eatWord('SEVEN', 7, 'S')
 	eatWord('THREE', 3, 'H')
 	eatWord('FOUR', 4, 'R')
 	eatWord('FIVE', 5, 'F')
 	eatWord('ONE', 1, 'O')
 	eatWord('NINE', 9, 'I')
 
 	assert all(f == 0 for f in freqs.itervalues()), freqs
 
 	return ''.join(str(d) for d in sorted(digits))
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/11254486/mth/5648941810974720/0/extracted/A.py,2041,78,245,Python,11254486,0,5648941810974720,mth,2016
132,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	topics = []
 	for i in xrange(n):
 		topic = inp.readline().split()
 		assert len(topic) == 2
 		topics.append(topic)
 	return topics,
 
 def subsets(sequence):
 	'''Iterates through all subsets of the given sequence.
 	Each yielded element is a tuple containing a subset of the elements of
 	the original sequence, in the same order as in the original sequence.
 	'''
 	sequence = tuple(sequence)
 	size = len(sequence)
 	def rec(s, i):
 		if i == size:
 			yield tuple(s)
 		else:
 			s.append(sequence[i])
 			for sub in rec(s, i + 1):
 				yield sub
 			del s[-1]
 			for sub in rec(s, i + 1):
 				yield sub
 	return rec([], 0)
 
 def wordsToIndices(words):
 	known = {}
 	for word in words:
 		idx = known.get(word)
 		if idx is None:
 			idx = len(known)
 			known[word] = idx
 		yield idx
 
 def pairedWith(pairs):
 	paired = defaultdict(list)
 	for word1, word2 in pairs:
 		paired[word1].append(word2)
 	return dict(paired)
 
 '''
 On a sheet, all topics could be fake, except the ones where either the first or the second word is the earliest occurrence of that word.
 
 #fakes = #topic - #unique
 #unique = #new_first + #new_second - #new_both
 
 Every word has to be used for the first time once, so that is constant across all possible sheets. Therefore the sheet with the most possible fakes is the sheet with the highest number of topics that introduces two new words at once.
 
 In other words, we must find the size of the largest subset of topics for which both the first and the second word are unique among that subset.
 '''
 
 def solve(topicWords):
 	#topics = (
 		#list(wordsToIndices(topic[0] for topic in topicWords)),
 		#list(wordsToIndices(topic[1] for topic in topicWords))
 		#)
 	topics = topicWords
 
 	matches = (
 		pairedWith(topics),
 		pairedWith((w2, w1) for w1, w2 in topics)
 		)
 
 	maxDoubleIntro = 0
 	for intro in subsets(topics):
 		if len(set(topic[0] for topic in intro)) != len(intro):
 			continue
 		if len(set(topic[1] for topic in intro)) != len(intro):
 			continue
 		maxDoubleIntro = max(maxDoubleIntro, len(intro))
 
 	return len(topics) - len(matches[0]) - len(matches[1]) + maxDoubleIntro
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/11254486/mth/5686313294495744/0/extracted/C.py,3465,118,462,Python,11254486,0,5686313294495744,mth,2016
133,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 import re
 
 def parse(inp):
 	c, j = (x for x in inp.readline().split())
 	assert len(c) == len(j)
 	return c, j
 
 def validScores(pattern):
 	regexp = re.compile(pattern.replace('?', '.'))
 	formatstr = '%0' + str(len(pattern)) + 'd'
 	for score in xrange(10 ** len(pattern)):
 		if regexp.match(formatstr % score):
 			yield score
 
 def solve(c, j):
 	numDigits = len(c)
 	best = [(10 ** numDigits, None, None)]
 	def rec(i, sc, sj):
 		if i == numDigits:
 			best[0] = min(best[0], (abs(sc - sj), sc, sj))
 		else:
 			pc = c[i]
 			pj = j[i]
 			if pc == '?' and pj == '?':
 				if sc < sj:
 					rec(i + 1, sc * 10 + 9, sj * 10)
 				elif sc > sj:
 					rec(i + 1, sc * 10, sj * 10 + 9)
 				else:
 					rec(i + 1, sc * 10, sj * 10)
 					rec(i + 1, sc * 10, sj * 10 + 1)
 					rec(i + 1, sc * 10 + 1, sj * 10)
 			elif pc == '?':
 				dj = int(pj)
 				if sc < sj:
 					rec(i + 1, sc * 10 + 9, sj * 10 + dj)
 				elif sc > sj:
 					rec(i + 1, sc * 10 + 0, sj * 10 + dj)
 				else:
 					if dj > 0:
 						rec(i + 1, sc * 10 + dj - 1, sj * 10 + dj)
 					rec(i + 1, sc * 10 + dj, sj * 10 + dj)
 					if dj < 9:
 						rec(i + 1, sc * 10 + dj + 1, sj * 10 + dj)
 			elif pj == '?':
 				dc = int(pc)
 				if sc < sj:
 					rec(i + 1, sc * 10 + dc, sj * 10 + 0)
 				elif sc > sj:
 					rec(i + 1, sc * 10 + dc, sj * 10 + 9)
 				else:
 					if dc > 0:
 						rec(i + 1, sc * 10 + dc, sj * 10 + dc - 1)
 					rec(i + 1, sc * 10 + dc, sj * 10 + dc)
 					if dc < 9:
 						rec(i + 1, sc * 10 + dc, sj * 10 + dc + 1)
 			else:
 				dc = int(pc)
 				dj = int(pj)
 				rec(i + 1, sc * 10 + dc, sj * 10 + dj)
 	rec(0, 0, 0)
 
 	#for sc in cScores:
 		#for sj in jScores:
 			#diffs.append((abs(sc - sj), sc, sj))
 
 	formatstr = '%0' + str(numDigits) + 'd'
 	return (formatstr + ' ' + formatstr) % best[0][1:]
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/11254486/mth/5695413893988352/1/extracted/B.py,3016,109,528,Python,11254486,1,5695413893988352,mth,2016
134,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 import re
 
 def parse(inp):
 	c, j = (x for x in inp.readline().split())
 	assert len(c) == len(j)
 	return c, j
 
 def validScores(pattern):
 	regexp = re.compile(pattern.replace('?', '.'))
 	formatstr = '%0' + str(len(pattern)) + 'd'
 	for score in xrange(10 ** len(pattern)):
 		if regexp.match(formatstr % score):
 			yield score
 
 def solve(c, j):
 	cScores = list(validScores(c))
 	jScores = list(validScores(j))
 	#print c, cScores
 	#print j, jScores
 
 	diffs = [
 		(abs(sc - sj), sc, sj)
 		for sc in cScores
 		for sj in jScores
 		]
 
 	formatstr = '%0' + str(len(c)) + 'd'
 	return (formatstr + ' ' + formatstr) % min(diffs)[1:]
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2016/11254486/mth/5695413893988352/0/extracted/B.py,1856,69,232,Python,11254486,0,5695413893988352,mth,2016
135,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt1'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	drHP, drAtk, knHP, knAtk, buff, debuff = (int(x) for x in inp.readline().split())
 	return drHP, drAtk, knHP, knAtk, buff, debuff
 
 def solve(drHP, drAtk, knHP, knAtk, buff, debuff):
 	drFullHP = drHP
 	states = set()
 	states.add((drHP, drAtk, knHP, knAtk))
 	turn = 1
 	while states:
 		# Dragon's move.
 		newStates = set()
 		for drHP, drAtk, knHP, knAtk in states:
 			# Attack.
 			if knHP <= drAtk:
 				# Knight loses.
 				return turn
 			else:
 				newStates.add((drHP, drAtk, knHP - drAtk, knAtk))
 			# Buff.
 			newStates.add((drHP, drAtk + buff, knHP, knAtk))
 			# Cure.
 			if knAtk >= drHP:
 				newStates.add((drFullHP, drAtk, knHP, knAtk))
 			# Debuff.
 			if knAtk > 0 and debuff > 0:
 				newStates.add((drHP, drAtk, knHP, max(knAtk - debuff, 0)))
 		# Knight's move.
 		newStates2 = set()
 		for drHP, drAtk, knHP, knAtk in newStates:
 			drHP -= knAtk
 			if drHP > 0:
 				newStates2.add((drHP, drAtk, knHP, knAtk))
 		if newStates2 == states:
 			# Stalemate.
 			break
 		states = newStates2
 		turn += 1
 	return 'IMPOSSIBLE'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/5304486/mth/5719039502450688/0/extracted/C.py,2284,80,288,Python,5304486,0,5719039502450688,mth,2017
136,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	numIngr, numPacks = (int(x) for x in inp.readline().split())
 	recipe = tuple(int(x) for x in inp.readline().split())
 	assert len(recipe) == numIngr
 	packs = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numIngr)
 		)
 	assert all(len(packIngr) == numPacks for packIngr in packs)
 	return recipe, packs
 
 def solve(recipe, packs):
 	ingrServings = []
 	for perServing, contents in zip(recipe, packs):
 		packServings = []
 		for grams in contents:
 			low = (grams * 10) / (11 * perServing)
 			if low * 11 * perServing < grams * 10:
 				low += 1
 			assert low * 11 * perServing >= grams * 10
 
 			high = (grams * 10) / (9 * perServing)
 			assert high * 9 * perServing <= grams * 10
 
 			if low <= high:
 				packServings.append((low, high))
 		ingrServings.append(packServings)
 
 	events = defaultdict(list)
 	for ingr, packServings in enumerate(ingrServings):
 		for low, high in packServings:
 			events[low].append((ingr, 1))
 			events[high + 1].append((ingr, -1))
 
 	numIngr = len(recipe)
 	kits = 0
 	numPackagesInRange = [0] * numIngr
 	numPackagesUsed = [0] * numIngr
 	for servings in sorted(events.iterkeys()):
 		for ingr, delta in events[servings]:
 			numPackagesInRange[ingr] += delta
 			if delta < 0:
 				numPackagesUsed[ingr] = max(0, numPackagesUsed[ingr] + delta)
 		addKits = min(
 			numPackagesInRange[ingr] - numPackagesUsed[ingr]
 			for ingr in xrange(numIngr)
 			)
 		for ingr in xrange(numIngr):
 			numPackagesUsed[ingr] += addKits
 		kits += addKits
 	for ingr in xrange(numIngr):
 		assert numPackagesInRange[ingr] == 0, ingr
 
 	return kits
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/5304486/mth/5697460110360576/1/extracted/B.py,2873,97,355,Python,5304486,1,5697460110360576,mth,2017
137,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	numIngr, numPacks = (int(x) for x in inp.readline().split())
 	recipe = tuple(int(x) for x in inp.readline().split())
 	assert len(recipe) == numIngr
 	packs = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numIngr)
 		)
 	assert all(len(packIngr) == numPacks for packIngr in packs)
 	return recipe, packs
 
 def solve(recipe, packs):
 	ingrServings = []
 	for perServing, contents in zip(recipe, packs):
 		packServings = []
 		for grams in contents:
 			low = (grams * 10) / (11 * perServing)
 			if low * 11 * perServing < grams * 10:
 				low += 1
 			assert low * 11 * perServing >= grams * 10
 
 			high = (grams * 10) / (9 * perServing)
 			assert high * 9 * perServing <= grams * 10
 
 			if low <= high:
 				packServings.append((low, high))
 		ingrServings.append(packServings)
 
 	events = defaultdict(list)
 	for ingr, packServings in enumerate(ingrServings):
 		for low, high in packServings:
 			events[low].append((ingr, 1))
 			events[high + 1].append((ingr, -1))
 
 	numIngr = len(recipe)
 	kits = 0
 	numPackagesInRange = [0] * numIngr
 	numPackagesUsed = [0] * numIngr
 	for servings in sorted(events.iterkeys()):
 		for ingr, delta in events[servings]:
 			numPackagesInRange[ingr] += delta
 			if delta < 0:
 				numPackagesUsed[ingr] = max(0, numPackagesUsed[ingr] + delta)
 		addKits = min(
 			numPackagesInRange[ingr] - numPackagesUsed[ingr]
 			for ingr in xrange(numIngr)
 			)
 		for ingr in xrange(numIngr):
 			numPackagesUsed[ingr] += addKits
 		kits += addKits
 	for ingr in xrange(numIngr):
 		assert numPackagesInRange[ingr] == 0, ingr
 
 	return kits
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/5304486/mth/5697460110360576/0/extracted/B.py,2882,97,355,Python,5304486,0,5697460110360576,mth,2017
138,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	return n,
 
 def solve(n):
 	digits = [int(d) for d in str(n)]
 	
 	def rec(num):
 		i = 0
 		while i + 1 < num:
 			if digits[i] > digits[i + 1]:
 				digits[i] -= 1
 				rec(i + 1)
 				for j in xrange(i + 1, num):
 					digits[j] = 9
 			i += 1
 
 	rec(len(digits))
 	return sum(d * 10 ** i for i, d in enumerate(reversed(digits)))
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5633382285312000/1/extracted/B.py,1603,60,208,Python,3264486,1,5633382285312000,mth,2017
139,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, = (int(x) for x in inp.readline().split())
 	return n,
 
 def solve(n):
 	while True:
 		s = str(n)
 		if sorted(s) == list(s):
 			return n
 		n -= 1
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5633382285312000/0/extracted/B.py,1383,51,167,Python,3264486,0,5633382285312000,mth,2017
140,D.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'D-example'
 #FILE_NAME_BASE = 'D-small-attempt1'
 FILE_NAME_BASE = 'D-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import ifilter, izip
 
 def parse(inp):
 	size, numModels = (int(x) for x in inp.readline().split())
 	stage = [['.'] * size for _ in range(size)]
 	for _ in range(numModels):
 		typ, rowStr, colStr = inp.readline().split()
 		assert typ in '+xo', typ
 		row = int(rowStr) - 1
 		col = int(colStr) - 1
 		stage[row][col] = typ
 	return stage,
 
 def checkValid(stage):
 	size = len(stage)
 
 	# Horizontal.
 	for row in xrange(size):
 		limitedModels = 0
 		for col in xrange(size):
 			if stage[row][col] in 'xo':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 	# Vertical.
 	for col in xrange(size):
 		limitedModels = 0
 		for row in xrange(size):
 			if stage[row][col] in 'xo':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 	# Slash.
 	for dia in xrange(size * 2 - 1):
 		limitedModels = 0
 		for col in xrange(size):
 			row = dia - col
 			if 0 <= row < size and stage[row][col] in '+o':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 	# Backslash.
 	for dia in xrange(size * 2 - 1):
 		limitedModels = 0
 		for col in xrange(size):
 			row = dia - size + 1 + col
 			if 0 <= row < size and stage[row][col] in '+o':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 def solve(orgStage):
 	size = len(orgStage)
 
 	# Deep copy of stage data.
 	stage = [list(rowData) for rowData in orgStage]
 	checkValid(stage)
 
 	# Determine which rows and columns have restricted models in them.
 	rowTaken = [False] * size
 	colTaken = [False] * size
 	for row, rowData in enumerate(stage):
 		for col, typ in enumerate(rowData):
 			if typ == 'x' or typ == 'o':
 				assert not rowTaken[row]
 				rowTaken[row] = True
 				assert not colTaken[col]
 				colTaken[col] = True
 
 	# Place x/o models where possible.
 	freeRows = ifilter(lambda row: not rowTaken[row], xrange(size))
 	freeCols = ifilter(lambda col: not colTaken[col], xrange(size))
 	for row, col in izip(freeRows, freeCols):
 		stage[row][col] = {'.' : 'x', '+': 'o'}[stage[row][col]]
 	checkValid(stage)
 
 	# Determine which diagonals have restricted models in them.
 	diaPTaken = [False] * (size * 2 - 1)
 	diaMTaken = [False] * (size * 2 - 1)
 	for row, rowData in enumerate(stage):
 		for col, typ in enumerate(rowData):
 			if typ == '+' or typ == 'o':
 				assert not diaPTaken[row + col]
 				diaPTaken[row + col] = True
 				assert not diaMTaken[row - col + size - 1]
 				diaMTaken[row - col + size - 1] = True
 
 	# Iterate through diagonals from short to long.
 	def diaWalk():
 		for i in xrange(size):
 			yield i
 			if i != size - 1:
 				yield size * 2 - 2 - i
 	assert sorted(diaWalk()) == range(size * 2 - 1)
 
 	# Place +/o models where possible.
 	freeDiaPs = ifilter(lambda dia: not diaPTaken[dia], diaWalk())
 	freeDiaMs = ifilter(lambda dia: not diaMTaken[dia], diaWalk())
 	freeDiaMs = list(freeDiaMs)
 	for diaP in freeDiaPs:
 		for i, diaM in enumerate(freeDiaMs):
 			col2 = diaP - diaM + size - 1
 			if col2 & 1 == 0:
 				col = col2 / 2
 				row = diaP - col
 				if 0 <= row < size and 0 <= col < size:
 					stage[row][col] = {'.' : '+', 'x': 'o'}[stage[row][col]]
 					del freeDiaMs[i]
 					break
 	checkValid(stage)
 
 	# Calculate style points.
 	points = 0
 	for rowData in stage:
 		for typ in rowData:
 			i = '.+xo'.index(typ)
 			points += (i & 1) + (i >> 1)
 
 	# Collect changes.
 	changes = []
 	for row, rowData in enumerate(stage):
 		for col, typ in enumerate(rowData):
 			if typ != orgStage[row][col]:
 				changes.append((typ, row + 1, col + 1))
 
 	# Format output.
 	output = ['%d %d' % (points, len(changes))]
 	for change in changes:
 		output.append('%s %d %d' % change)
 	return '\n'.join(output)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5719854539603968/1/extracted/D.py,4934,172,704,Python,3264486,1,5719854539603968,mth,2017
141,D.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'D-example'
 FILE_NAME_BASE = 'D-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from itertools import ifilter, izip
 
 def parse(inp):
 	size, numModels = (int(x) for x in inp.readline().split())
 	stage = [['.'] * size for _ in range(size)]
 	for _ in range(numModels):
 		typ, rowStr, colStr = inp.readline().split()
 		assert typ in '+xo', typ
 		row = int(rowStr) - 1
 		col = int(colStr) - 1
 		stage[row][col] = typ
 	return stage,
 
 def checkValid(stage):
 	size = len(stage)
 
 	# Horizontal.
 	for row in xrange(size):
 		limitedModels = 0
 		for col in xrange(size):
 			if stage[row][col] in 'xo':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 	# Vertical.
 	for col in xrange(size):
 		limitedModels = 0
 		for row in xrange(size):
 			if stage[row][col] in 'xo':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 	# Slash.
 	for dia in xrange(size * 2 - 1):
 		limitedModels = 0
 		for col in xrange(size):
 			row = dia - col
 			if 0 <= row < size and stage[row][col] in '+o':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 	# Backslash.
 	for dia in xrange(size * 2 - 1):
 		limitedModels = 0
 		for col in xrange(size):
 			row = dia - size + 1 + col
 			if 0 <= row < size and stage[row][col] in '+o':
 				limitedModels += 1
 		assert limitedModels <= 1
 
 def solve(orgStage):
 	size = len(orgStage)
 
 	# Deep copy of stage data.
 	stage = [list(rowData) for rowData in orgStage]
 	checkValid(stage)
 
 	# Determine which rows and columns have restricted models in them.
 	rowTaken = [False] * size
 	colTaken = [False] * size
 	for row, rowData in enumerate(stage):
 		for col, typ in enumerate(rowData):
 			if typ == 'x' or typ == 'o':
 				assert not rowTaken[row]
 				rowTaken[row] = True
 				assert not colTaken[col]
 				colTaken[col] = True
 
 	# Place x/o models where possible.
 	freeRows = ifilter(lambda row: not rowTaken[row], xrange(size))
 	freeCols = ifilter(lambda col: not colTaken[col], xrange(size))
 	for row, col in izip(freeRows, freeCols):
 		stage[row][col] = {'.' : 'x', '+': 'o'}[stage[row][col]]
 	checkValid(stage)
 
 	# Determine which diagonals have restricted models in them.
 	diaPTaken = [False] * (size * 2 - 1)
 	diaMTaken = [False] * (size * 2 - 1)
 	for row, rowData in enumerate(stage):
 		for col, typ in enumerate(rowData):
 			if typ == '+' or typ == 'o':
 				assert not diaPTaken[row + col]
 				diaPTaken[row + col] = True
 				assert not diaMTaken[row - col + size - 1]
 				diaMTaken[row - col + size - 1] = True
 
 	# Iterate through diagonals from short to long.
 	def diaWalk():
 		for i in xrange(size):
 			yield i
 			if i != size - 1:
 				yield size * 2 - 2 - i
 	assert sorted(diaWalk()) == range(size * 2 - 1)
 
 	# Place +/o models where possible.
 	freeDiaPs = ifilter(lambda dia: not diaPTaken[dia], diaWalk())
 	freeDiaMs = ifilter(lambda dia: not diaMTaken[dia], diaWalk())
 	freeDiaMs = list(freeDiaMs)
 	for diaP in freeDiaPs:
 		for i, diaM in enumerate(freeDiaMs):
 			col2 = diaP - diaM + size - 1
 			if col2 & 1 == 0:
 				col = col2 / 2
 				row = diaP - col
 				if 0 <= row < size and 0 <= col < size:
 					stage[row][col] = {'.' : '+', 'x': 'o'}[stage[row][col]]
 					del freeDiaMs[i]
 					break
 	checkValid(stage)
 
 	# Calculate style points.
 	points = 0
 	for rowData in stage:
 		for typ in rowData:
 			i = '.+xo'.index(typ)
 			points += (i & 1) + (i >> 1)
 
 	# Collect changes.
 	changes = []
 	for row, rowData in enumerate(stage):
 		for col, typ in enumerate(rowData):
 			if typ != orgStage[row][col]:
 				changes.append((typ, row + 1, col + 1))
 
 	# Format output.
 	output = ['%d %d' % (points, len(changes))]
 	for change in changes:
 		output.append('%s %d %d' % change)
 	return '\n'.join(output)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5719854539603968/0/extracted/D.py,4905,171,701,Python,3264486,0,5719854539603968,mth,2017
142,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	sidesStr, spanStr = inp.readline().split()
 	sides = tuple('+-'.index(p) for p in sidesStr)
 	span = int(spanStr)
 	return sides, span
 
 def solve(sides, span):
 	num = len(sides)
 	mask = (1 << span) - 1
 	bits = sum(1 << i for i, p in enumerate(sides) if p)
 
 	flips = 0
 	for i in xrange(num - span + 1):
 		if (bits >> i) & 1:
 			flips += 1
 			bits ^= mask << i
 	return flips if bits == 0 else 'IMPOSSIBLE'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5736519012712448/1/extracted/A.py,1636,58,217,Python,3264486,1,5736519012712448,mth,2017
143,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	sidesStr, spanStr = inp.readline().split()
 	sides = tuple('+-'.index(p) for p in sidesStr)
 	span = int(spanStr)
 	return sides, span
 
 def solve(sides, span):
 	num = len(sides)
 	mask = (1 << span) - 1
 	bits = sum(1 << i for i, p in enumerate(sides) if p)
 
 	flips = 0
 	for i in xrange(num - span + 1):
 		if (bits >> i) & 1:
 			flips += 1
 			bits ^= mask << i
 	return flips if bits == 0 else 'IMPOSSIBLE'
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5736519012712448/0/extracted/A.py,1645,58,217,Python,3264486,0,5736519012712448,mth,2017
144,C.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'C-example'
 #FILE_NAME_BASE = 'C-small-1-attempt0'
 #FILE_NAME_BASE = 'C-small-2-attempt0'
 FILE_NAME_BASE = 'C-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from collections import defaultdict
 
 def parse(inp):
 	numStalls, numPeople = (int(x) for x in inp.readline().split())
 	return numStalls, numPeople
 
 def solve(numStalls, numPeople):
 	freq = defaultdict(int)
 	freq[numStalls] = 1
 	numOccupied = 0
 	while True:
 		empty = max(freq.iterkeys())
 		fe = freq[empty]
 		assert fe != 0, empty
 		ls = (empty - 1) / 2
 		rs = empty - ls - 1
 		numOccupied += fe
 		if numOccupied >= numPeople:
 			return '%d %d' % (rs, ls)
 		del freq[empty]
 		freq[ls] += fe
 		freq[rs] += fe
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5654742835396608/2/extracted/C.py,1842,66,226,Python,3264486,2,5654742835396608,mth,2017
145,C.py,"#!/usr/bin/env python
 
 #FILE_NAME_BASE = 'C-example'
 FILE_NAME_BASE = 'C-small-2-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 from bisect import bisect
 
 def parse(inp):
 	numStalls, numPeople = (int(x) for x in inp.readline().split())
 	return numStalls, numPeople
 
 def solve(numStalls, numPeople):
 	freq = [0] * numStalls + [1]
 	numOccupied = 0
 	empty = numStalls
 	while True:
 		if freq[empty] == 0:
 			empty -= 1
 		else:
 			ls = (empty - 1) / 2
 			rs = empty - ls - 1
 			freq[empty] -= 1
 			freq[ls] += 1
 			freq[rs] += 1
 			numOccupied += 1
 			if numOccupied == numPeople:
 				return '%d %d' % (rs, ls)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5654742835396608/1/extracted/C.py,1743,64,222,Python,3264486,1,5654742835396608,mth,2017
146,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-1-attempt0'
 NUM_PROCESSES = 4
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numStalls, numPeople = (int(x) for x in inp.readline().split())
 	return numStalls, numPeople
 
 def solve(numStalls, numPeople):
 	occupied = [True] + [False] * numStalls + [True]
 
 	numOccupied = 0
 	while True:
 		best = (None, None, None)
 		for stall in range(1, numStalls + 1):
 			ri = occupied.index(True, stall)
 			if ri == stall:
 				continue
 			li = stall
 			while not occupied[li]:
 				li -= 1
 			ls = stall - li - 1
 			rs = ri - stall - 1
 			# Note: This prefers the rightmost on ties, but since the problem
 			#       is entirely symmetrical, it doesn't matter whether we
 			#       pick left or right on ties as long as we're consistent.
 			best = max(best, ((min(ls, rs), max(ls, rs), stall)))
 
 		assert not occupied[best[-1]], best
 		occupied[best[-1]] = True
 		numOccupied += 1
 		if numOccupied == numPeople:
 			return '%d %d' % (best[1], best[0])
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3264486/mth/5654742835396608/0/extracted/C.py,2115,70,275,Python,3264486,0,5654742835396608,mth,2017
147,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	dest, numHorses = (int(x) for x in inp.readline().split())
 	horses = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numHorses)
 		)
 	return dest, horses
 
 def solve(dest, horses):
 	arrival = max(
 		(dest - pos) / float(spd)
 		for pos, spd in horses
 		)
 	return dest / arrival
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/8294486/mth/5630967708385280/1/extracted/A.py,1532,55,187,Python,8294486,1,5630967708385280,mth,2017
148,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	dest, numHorses = (int(x) for x in inp.readline().split())
 	horses = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numHorses)
 		)
 	return dest, horses
 
 def solve(dest, horses):
 	arrival = max(
 		(dest - pos) / float(spd)
 		for pos, spd in horses
 		)
 	return dest / arrival
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/8294486/mth/5630967708385280/0/extracted/A.py,1541,55,187,Python,8294486,0,5630967708385280,mth,2017
149,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, r, o, y, g, b, v = (int(x) for x in inp.readline().split())
 	assert n == r + o + y + g + b + v
 	return n, r, o, y, g, b, v
 
 def solve(n, r, o, y, g, b, v):
 	# Mandatory neighbours: BOB, RGR, YVY.
 	if o > 0:
 		b -= o
 		if b < 0:
 			return 'IMPOSSIBLE'
 	if g > 0:
 		r -= g
 		if r < 0:
 			return 'IMPOSSIBLE'
 	if v > 0:
 		y -= v
 		if y < 0:
 			return 'IMPOSSIBLE'
 
 	manes = [r, y, b]
 	letters = 'RYB'
 
 	searchOrder = sorted(xrange(3), key=manes.__getitem__, reverse=True)
 	stables = []
 	while True:
 		col1 = max(
 			(col for col in searchOrder),
 			key=manes.__getitem__
 			)
 		col2 = max(
 			(col for col in searchOrder if col != col1),
 			key=manes.__getitem__
 			)
 		if manes[col1] == 0:
 			break
 		stables.append(col1)
 		manes[col1] -= 1
 		if manes[col2] == 0:
 			break
 		stables.append(col2)
 		manes[col2] -= 1
 
 	if manes != [0] * 3:
 		return 'IMPOSSIBLE'
 	elif len(stables) == 0:
 		if o + g + v == max(o, g, v):
 			if o > 0:
 				return 'OB' * o
 			if g > 0:
 				return 'GR' * g
 			if v > 0:
 				return 'VY' * v
 		return 'IMPOSSIBLE'
 	elif stables[-1] == stables[0]:
 		return 'IMPOSSIBLE'
 	else:
 		solution = ''.join(letters[color] for color in stables)
 		assert solution.count('R') == r
 		assert solution.count('Y') == y
 		assert solution.count('B') == b
 		assert len(solution) == n - 2 * o - 2 * g - 2 * v
 		assert 'RR' not in solution + solution[0]
 		assert 'YY' not in solution + solution[0]
 		assert 'BB' not in solution + solution[0]
 
 		if o > 0:
 			solution = solution.replace('B', 'B' + 'OB' * o, 1)
 		if g > 0:
 			solution = solution.replace('R', 'R' + 'GR' * g, 1)
 		if v > 0:
 			solution = solution.replace('Y', 'Y' + 'VY' * v, 1)
 		return solution
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/8294486/mth/5654117850546176/1/extracted/B.py,2956,114,442,Python,8294486,1,5654117850546176,mth,2017
150,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	n, r, o, y, g, b, v = (int(x) for x in inp.readline().split())
 	assert n == r + o + y + g + b + v
 	return n, r, o, y, g, b, v
 
 def solve(n, r, o, y, g, b, v):
 	manes = [
 			#BYR
 		0,	#000
 		r,	#001
 		y,	#010
 		o,	#011
 		b,	#100
 		v,	#101
 		g,	#110
 		0	#111
 		]
 	letters = '-RYOBVG-'
 
 	searchOrder = sorted(xrange(1, 7), key=manes.__getitem__, reverse=True)
 	stables = []
 	while True:
 		col1 = max(
 			(col for col in searchOrder),
 			key=manes.__getitem__
 			)
 		col2 = max(
 			(col for col in searchOrder if col != col1),
 			key=manes.__getitem__
 			)
 		if manes[col1] == 0:
 			break
 		stables.append(col1)
 		manes[col1] -= 1
 		if manes[col2] == 0:
 			break
 		stables.append(col2)
 		manes[col2] -= 1
 
 	if manes != [0] * 8 or stables[-1] == stables[0]:
 		return 'IMPOSSIBLE'
 	else:
 		solution = ''.join(letters[color] for color in stables)
 		assert len(solution) == n
 		assert solution.count('R') == r
 		assert solution.count('Y') == y
 		assert solution.count('B') == b
 		assert 'RR' not in solution + solution[0]
 		assert 'YY' not in solution + solution[0]
 		assert 'BB' not in solution + solution[0]
 		return solution
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/8294486/mth/5654117850546176/0/extracted/B.py,2398,92,321,Python,8294486,0,5654117850546176,mth,2017
151,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numCities, numDeliveries = (int(x) for x in inp.readline().split())
 	horses = tuple(
 		# (endurance, speed)
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numCities)
 		)
 	routes = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numCities)
 		)
 	deliveries = tuple(
 		# (start, end)
 		tuple(int(x) - 1 for x in inp.readline().split())
 		for _ in xrange(numDeliveries)
 		)
 	return horses, routes, deliveries
 
 def solve(horses, routes, deliveries):
 	numCities = len(routes)
 
 	if len(deliveries) != 1 or deliveries[0] != (0, numCities - 1):
 		return '-non-linear-'
 
 	state = [(0, 0, 0)]
 	curCity = 0
 	while True:
 		fastest = min(time for left, speed, time in state)
 		nextCity = curCity + 1
 		if nextCity == numCities:
 			return fastest
 		dist = routes[curCity][nextCity]
 		assert dist > 0, dist
 
 		# Add this city's horse to options.
 		state.append(horses[curCity] + (fastest,))
 
 		# Try all possible horses.
 		newState = []
 		for left, speed, time in state:
 			if left >= dist:
 				newState.append((left - dist, speed, time + dist / float(speed)))
 		state = newState
 		curCity = nextCity
 
 	return (horses, routes, deliveries)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/8294486/mth/5681755159789568/0/extracted/C.py,2440,87,306,Python,8294486,0,5681755159789568,mth,2017
152,B.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'B-small-attempt1'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numC, numJ = (int(x) for x in inp.readline().split())
 	activities = tuple(
 		tuple(int(x) for x in inp.readline().split()) + (idx < numC,)
 		for idx in xrange(numC + numJ)
 		)
 	return activities,
 
 def solve(activities):
 	activities = sorted(activities)
 	if len(activities) == 1:
 		return 2
 	elif len(activities) == 2:
 		if activities[0][2] == activities[1][2]:
 			if activities[1][1] - activities[0][0] <= 720:
 				return 2
 			elif activities[1][0] - activities[0][1] >= 720:
 				return 2
 			else:
 				return 4
 		else:
 			return 2
 	else:
 		return 'not-small'
 
 	#active = activities[0][2]
 	#time = 0
 	#schedule = []
 	#for start, end, who in activities:
 		#if who != active:
 			#schedule.append((time, start))
 			#active = who
 			#time = end
 	#if active != activities[0][2]:
 		#schedule.append((time, 1440))
 	#return schedule
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3274486/mth/5706636844859392/0/extracted/B.py,2087,77,250,Python,3274486,0,5706636844859392,mth,2017
153,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-large'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numAvailable, numOrdered = (int(x) for x in inp.readline().split())
 	pancakes = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numAvailable)
 		)
 	return pancakes, numOrdered
 
 from math import pi
 
 def solve(pancakes, numOrdered):
 	pancakes = sorted(
 		(r, h * 2 * pi * r)
 		for r, h in pancakes
 		)
 	best = 0
 	for bottomIdx, bottom in enumerate(pancakes):
 		bottomRad = bottom[0]
 		base = pi * bottomRad ** 2
 		candidates = []
 		for candIdx, candidate in enumerate(pancakes):
 			if candIdx != bottomIdx and candidate[0] <= bottomRad:
 				candidates.append(candidate[1])
 		sides = [bottom[1]] + sorted(candidates, reverse=True)[:numOrdered - 1]
 		area = base + sum(sides)
 		best = max(best, area)
 	return best
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3274486/mth/5768968631484416/1/extracted/A.py,1979,68,244,Python,3274486,1,5768968631484416,mth,2017
154,A.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'A-small-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numAvailable, numOrdered = (int(x) for x in inp.readline().split())
 	pancakes = tuple(
 		tuple(int(x) for x in inp.readline().split())
 		for _ in xrange(numAvailable)
 		)
 	return pancakes, numOrdered
 
 def subsets(sequence):
 	'''Iterates through all subsets of the given sequence.
 	Each yielded element is a tuple containing a subset of the elements of
 	the original sequence, in the same order as in the original sequence.
 	'''
 	sequence = tuple(sequence)
 	size = len(sequence)
 	def rec(s, i):
 		if i == size:
 			yield tuple(s)
 		else:
 			s.append(sequence[i])
 			for sub in rec(s, i + 1):
 				yield sub
 			del s[-1]
 			for sub in rec(s, i + 1):
 				yield sub
 	return rec([], 0)
 
 from math import pi
 
 def calcSurface(pancakes):
 	surface = 0
 	for r, h in pancakes:
 		surface += h * 2 * pi * r
 	surface += pi * pancakes[-1][0] ** 2
 	return surface
 
 def solve(pancakes, numOrdered):
 	pancakes = sorted(pancakes)
 	best = 0.0
 	for selected in subsets(pancakes):
 		if len(selected) == numOrdered:
 			best = max(best, calcSurface(selected))
 	return best
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3274486/mth/5768968631484416/0/extracted/A.py,2317,84,297,Python,3274486,0,5768968631484416,mth,2017
155,C.py,"#!/usr/bin/env python
 
 FILE_NAME_BASE = 'C-small-1-attempt0'
 NUM_PROCESSES = 0
 MEM_LIMIT_GB = 1.5 # per worker process
 RECURSION_LIMIT = 1000
 
 def parse(inp):
 	numCores, numSuccess = (int(x) for x in inp.readline().split())
 	units, = (float(x) for x in inp.readline().split())
 	rates = tuple(float(x) for x in inp.readline().split())
 	assert len(rates) == numCores
 	return numSuccess, units, rates
 
 def solve(success, units, rates):
 	if success != len(rates):
 		return 'not-implemented'
 
 	rates = sorted(rates)
 	idx = 0
 	minRate = rates[0]
 	while idx < len(rates) and rates[idx] == minRate:
 		idx += 1
 	while minRate < 1.0:
 		nextRate = rates[idx] if idx < len(rates) else 1.0
 		trainRate = minRate + units / idx
 		if trainRate < nextRate:
 			# Out of training units.
 			minRate = trainRate
 			break
 		units -= (nextRate - minRate) * idx
 		minRate = nextRate
 		while idx < len(rates) and rates[idx] == minRate:
 			idx += 1
 
 	return reduce(lambda x, y: x * y, rates[idx:], minRate ** idx)
 
 def main():
 	import sys
 	sys.setrecursionlimit(RECURSION_LIMIT)
 
 	import resource
 	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
 	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
 
 	with open(FILE_NAME_BASE + '.in', 'r') as inp:
 		numCases = int(inp.readline())
 		inputs = [parse(inp) for _ in xrange(numCases)]
 
 	if NUM_PROCESSES == 0:
 		runners = [lambda inp=inp: apply(solve, inp) for inp in inputs]
 	else:
 		from multiprocessing import Pool
 		from signal import SIGINT, SIG_IGN, signal
 		pool = Pool(NUM_PROCESSES, signal, (SIGINT, SIG_IGN))
 		runners = [pool.apply_async(solve, inp).get for inp in inputs]
 		pool.close()
 
 	caseFmt = '%' + str(len(str(numCases))) + 'd'
 	progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
 	with open(FILE_NAME_BASE + '.out', 'w') as out:
 		for case, runner in enumerate(runners, 1):
 			result = runner()
 			out.write('Case #%d: %s\n' % (case, result))
 			out.flush()
 			sys.stderr.write(progressFmt % (case, numCases, result))
 
 if __name__ == '__main__':
 	main()
",gcj/2017/3274486/mth/5633143511973888/0/extracted/C.py,2086,70,267,Python,3274486,0,5633143511973888,mth,2017
156,00000000000497b5.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys
from collections import defaultdict

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def subsets(sequence):
    '''Iterates through all subsets of the given sequence.
    Each yielded element is a tuple containing a subset of the elements of
    the original sequence, in the same order as in the original sequence.
    '''
    sequence = tuple(sequence)
    size = len(sequence)
    def rec(s, i):
        if i == size:
            yield tuple(s)
        else:
            s.append(sequence[i])
            for sub in rec(s, i + 1):
                yield sub
            del s[-1]
            for sub in rec(s, i + 1):
                yield sub
    return rec([], 0)

def solve():
    size = int(input())
    grid = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(size)
        )

    row_conflicts = set()
    for ri, row in enumerate(grid):
        value_at = defaultdict(list)
        for ci, value in enumerate(row):
            value_at[value].append(ci)
        for cis in value_at.values():
            if len(cis) >= 2:
                for ci in cis:
                    row_conflicts.add((ri, ci))

    col_conflicts = set()
    for ci in range(size):
        value_at = defaultdict(list)
        for ri in range(size):
            value = grid[ri][ci]
            value_at[value].append(ri)
        for ris in value_at.values():
            if len(ris) >= 2:
                for ri in ris:
                    col_conflicts.add((ri, ci))

    conflicts = row_conflicts | col_conflicts

    def is_fixed(fix):
        rows = set()
        cols = set()
        for ri, ci in conflicts - set(fix):
            if ri in rows:
                return False
            rows.add(ri)

            if ci in cols:
                return False
            cols.add(ci)

        return True

    best = len(conflicts)
    for fix in subsets(conflicts):
        if len(fix) < best and is_fixed(fix):
            best = len(fix)

    return best

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2622,99,292,Python,7706,00000000000497b5,0000000000045875,mth,2018
157,0000000000049210.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys
from collections import defaultdict

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def solve():
    size = int(input())
    grid = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(size)
        )

    row_conflicts = set()
    row_fixes = 0
    for ri, row in enumerate(grid):
        value_at = defaultdict(list)
        for ci, value in enumerate(row):
            value_at[value].append(ci)
        for cis in value_at.values():
            if len(cis) >= 2:
                row_fixes += len(cis) - 1
                for ci in cis:
                    row_conflicts.add((ri, ci))

    col_conflicts = set()
    col_fixes = 0
    for ci in range(size):
        value_at = defaultdict(list)
        for ri in range(size):
            value = grid[ri][ci]
            value_at[value].append(ri)
        for ris in value_at.values():
            if len(ris) >= 2:
                col_fixes += len(ris) - 1
                for ri in ris:
                    col_conflicts.add((ri, ci))

    return row_fixes + col_fixes - len(row_conflicts & col_conflicts)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1735,63,186,Python,7706,0000000000049210,0000000000045875,mth,2018
158,000000000004887f.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def solve():
    num_red, num_blue = (int(x) for x in input().split())
    if num_blue > num_red:
        num_red, num_blue = num_blue, num_red

    cache = {}
    def max_jugglers(*key):
        try:
            return cache[key]
        except KeyError:
            value = compute(*key)
            cache[key] = value
            return value

    def compute(rl, bl, r):
        nbl = bl
        best = 0
        b = 0
        while True:
            if nbl < b:
                break
            nbl -= b

            jugglers = b + 1
            nrl = rl - r * jugglers
            if nrl < 0:
                break
            best = max(best, jugglers + max_jugglers(nrl, nbl, r + 1))

            b += 1
        return best

    # Subtract one because (0, 0) is not valid.
    return max_jugglers(num_red, num_blue, 0) - 1

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1531,63,184,Python,7706,000000000004887f,00000000000459f3,mth,2018
159,00000000000483d4.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def solve():
    num_red, num_blue = (int(x) for x in input().split())
    if num_blue > num_red:
        num_red, num_blue = num_blue, num_red

    def max_jugglers(rl, bl, r):
        nbl = bl
        best = 0
        b = 0
        while True:
            if nbl < b:
                break
            nbl -= b

            jugglers = b + 1
            nrl = rl - r * jugglers
            if nrl < 0:
                break
            best = max(best, jugglers + max_jugglers(nrl, nbl, r + 1))

            b += 1
        return best

    # Subtract one because (0, 0) is not valid.
    return max_jugglers(num_red, num_blue, 0) - 1

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1334,54,166,Python,7706,00000000000483d4,00000000000459f3,mth,2018
160,0000000000046be6.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def solve():
    num_cols = int(input())
    target_balls_in_col = tuple(int(x) for x in input().split())
    assert len(target_balls_in_col) == num_cols

    if target_balls_in_col[0] == 0 or target_balls_in_col[-1] == 0:
        return 'IMPOSSIBLE'
    if sum(target_balls_in_col) != num_cols:
        return 'IMPOSSIBLE'

    cumulative_targets = []
    count = 0
    for balls in target_balls_in_col:
        count += balls
        cumulative_targets.append(count)

    solution = []
    curr = list(range(1, num_cols + 1))
    empty = ['.'] * num_cols
    while True:
        line = []
        nxt = list(curr)
        for col, balls in enumerate(curr):
            if col == 0 or col == num_cols - 1:
                line.append('.')
                continue

            if cumulative_targets[col - 1] > curr[col - 1]:
                line.append('/')
                nxt[col - 1] = curr[col]
            elif cumulative_targets[col] < curr[col]:
                line.append('\\')
                nxt[col] = curr[col - 1]
            else:
                line.append('.')
        curr = nxt
        log('%s : %s of %s', ''.join(line), curr, cumulative_targets)
        solution.append(''.join(line))
        if line == empty:
            break

        # TODO: I don't have a proof that there will always be a solution,
        #       but if there is a solution we'll find it before the timeout.
        if len(solution) > num_cols * 2:
            return 'IMPOSSIBLE'

    return '%d\n%s' % (len(solution), '\n'.join(solution))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2237,76,245,Python,7706,0000000000046be6,00000000000459f2,mth,2018
161,0000000000035122.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys
from math import sqrt

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def cut_range(width, height):
    if width < height:
        width, height = height, width

    lo = 2 * height

    hi = 2 * sqrt(width ** 2 + height ** 2)

    return lo, hi

def solve():
    num_cookies, total_perimeter = (int(x) for x in input().split())
    cookies = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_cookies)
        )

    uncut = tuple(
        width * 2 + height * 2
        for width, height in cookies
        )
    uncut_perimeter = sum(uncut)
    target_perimeter = total_perimeter - uncut_perimeter

    cut = tuple(cut_range(*cookie) for cookie in cookies)

    # Knapsack.
    weights = tuple(lo for lo, hi in cut)
    values = tuple(hi for lo, hi in cut)
    max_weight = min(sum(weights), target_perimeter)
    max_values = [0] * (max_weight + 1)
    for i in range(num_cookies):
        weight = weights[i]
        value = values[i]
        for j in range(max_weight, weight - 1, -1):
            max_values[j] = max(
                max_values[j],
                max_values[j - weight] + value
                )
    max_value = max_values[max_weight]

    return float(uncut_perimeter + min(max_value, target_perimeter))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1911,72,231,Python,0000000000007883,0000000000035122,000000000002fff7,mth,2018
162,00000000000349e1.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys
from math import sqrt

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def cut_range(width, height):
    if width < height:
        width, height = height, width

    lo = 2 * height

    hi = 2 * sqrt(width ** 2 + height ** 2)

    return lo, hi

def solve():
    num_cookies, total_perimeter = (int(x) for x in input().split())
    cookies = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_cookies)
        )

    uncut = tuple(
        width * 2 + height * 2
        for width, height in cookies
        )
    uncut_perimeter = sum(uncut)
    target_perimeter = total_perimeter - uncut_perimeter

    cut = tuple(cut_range(*cookie) for cookie in cookies)

    # Knapsack.
    weights = tuple(lo for lo, hi in cut)
    values = tuple(hi for lo, hi in cut)
    max_weight = min(sum(weights), target_perimeter)
    prev_max_value = [0] * (max_weight + 1)
    for i in range(num_cookies):
        weight = weights[i]
        value = values[i]
        new_max_value = []
        for j in range(max_weight + 1):
            if weight > j:
                max_value = prev_max_value[j]
            else:
                max_value = max(
                    prev_max_value[j],
                    prev_max_value[j - weight] + value
                    )
            new_max_value.append(max_value)
        prev_max_value = new_max_value
    max_value = prev_max_value[max_weight]

    return float(uncut_perimeter + min(max_value, target_perimeter))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2128,78,244,Python,0000000000007883,00000000000349e1,000000000002fff7,mth,2018
163,0000000000034511.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys
from math import sqrt

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def cut_range(width, height):
    if width < height:
        width, height = height, width

    lo = 2 * height

    hi = 2 * sqrt(width ** 2 + height ** 2)

    return lo, hi

def solve():
    num_cookies, total_perimeter = (int(x) for x in input().split())
    cookies = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_cookies)
        )

    uncut = tuple(
        width * 2 + height * 2
        for width, height in cookies
        )
    uncut_perimeter = sum(uncut)
    target_perimeter = total_perimeter - uncut_perimeter

    cut = tuple(cut_range(*cookie) for cookie in cookies)

    # Knapsack.
    weights = tuple(lo for lo, hi in cut)
    values = tuple(hi for lo, hi in cut)
    max_weight = sum(weights)
    prev_max_value = [0] * (max_weight + 1)
    for i in range(num_cookies):
        weight = weights[i]
        value = values[i]
        new_max_value = []
        for j in range(max_weight + 1):
            if weight > j:
                max_value = prev_max_value[j]
            else:
                max_value = max(
                    prev_max_value[j],
                    prev_max_value[j - weight] + value
                    )
            new_max_value.append(max_value)
        prev_max_value = new_max_value
    max_value = prev_max_value[max_weight]

    return float(uncut_perimeter + min(max_value, target_perimeter))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2105,78,243,Python,0000000000007883,0000000000034511,000000000002fff7,mth,2018
164,0000000000032777.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys
from math import sqrt

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def cut_range(width, height):
    if width < height:
        width, height = height, width

    lo = 2 * width + 4 * height

    hi = 2 * width + 2 * height + 2 * sqrt(width ** 2 + height ** 2)

    return lo, hi

def solve():
    num_cookies, target_perimeter = (int(x) for x in input().split())
    cookies = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_cookies)
        )

    uncut = tuple(
        width * 2 + height * 2
        for width, height in cookies
        )

    cut = tuple(cut_range(*cookie) for cookie in cookies)

    best = 0
    for num_cuts in range(num_cookies + 1):
        lo = num_cuts * cut[0][0] + (num_cookies - num_cuts) * uncut[0]
        hi = num_cuts * cut[0][1] + (num_cookies - num_cuts) * uncut[0]
        if lo <= target_perimeter:
            best = max(best, min(target_perimeter, hi))

    return float(best)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1606,62,212,Python,0000000000007883,0000000000032777,000000000002fff7,mth,2018
165,0000000000031c13.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def search(low, high, test):
    '''Binary search: [low..high) is the range to search; function ""test""
    takes a single value from that interval and returns a truth value.
    The function must be ascending: (test(x) and y >= x) => test(y).
    Returns smallest argument in the interval for which the function is true,
    or ""high"" if the function is false for the entire interval.
    '''
    while low < high:
        mid = (low + high - 1) // 2
        if test(mid):
            if mid == low:
                return low # found
            high = mid + 1
        else:
            low = mid + 1
    return high # not found

def solve():
    num_robots, total_bits, num_cashiers = (int(x) for x in input().split())
    cashiers = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_cashiers)
        )

    def check(time_limit):
        bits_per_cashier = []
        for max_bits, secs_per_bit, secs_const in cashiers:
            if secs_const >= time_limit:
                bits = 0
            else:
                bits = min(max_bits, (time_limit - secs_const) // secs_per_bit)
            bits_per_cashier.append(bits)

        log('limit %d: %s', time_limit, bits_per_cashier)

        bits_per_cashier.sort(reverse=True)
        return sum(bits_per_cashier[:num_robots]) >= total_bits

    # pick up to num_robots cashiers
    # minimize max(bits * secs_per_bit + secs_const)
    # sum of bits per cachiers must equal total_bits

    # Find an upper time limit.
    time_limit = max(
        max_bits * secs_per_bit + secs_const
        for max_bits, secs_per_bit, secs_const in cashiers
        )

    return search(0, time_limit, check)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2382,78,287,Python,0000000000007883,0000000000031c13,000000000002fff6,mth,2018
166,000000000003196e.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def search(low, high, test):
    '''Binary search: [low..high) is the range to search; function ""test""
    takes a single value from that interval and returns a truth value.
    The function must be ascending: (test(x) and y >= x) => test(y).
    Returns smallest argument in the interval for which the function is true,
    or ""high"" if the function is false for the entire interval.
    '''
    while low < high:
        mid = (low + high - 1) // 2
        if test(mid):
            if mid == low:
                return low # found
            high = mid + 1
        else:
            low = mid + 1
    return high # not found

def solve():
    num_robots, total_bits, num_cashiers = (int(x) for x in input().split())
    cashiers = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_cashiers)
        )

    def check(time_limit):
        bits_per_cashier = []
        for max_bits, secs_per_bit, secs_const in cashiers:
            if secs_const >= time_limit:
                bits = 0
            else:
                bits = min(max_bits, (time_limit - secs_const) // secs_per_bit)
            bits_per_cashier.append(bits)

        log('limit %d: %s', time_limit, bits_per_cashier)

        bits_per_cashier.sort(reverse=True)
        return sum(bits_per_cashier[:num_robots]) >= total_bits

    # pick up to num_robots cashiers
    # minimize max(bits * secs_per_bit + secs_const)
    # sum of bits per cachiers must equal total_bits

    # Find an upper time limit by being greedy.
    time_limit = 0
    bits_left = total_bits
    for max_bits, secs_per_bit, secs_const in cashiers:
        bits = min(bits_left, max_bits)
        time_limit = max(time_limit, bits * secs_per_bit + secs_const)
        bits_left -= bits
    assert bits_left == 0

    return search(0, time_limit, check)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2527,81,306,Python,0000000000007883,000000000003196e,000000000002fff6,mth,2018
167,0000000000030a1f.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def solve():
    rows, cols, hcuts, vcuts = (int(x) for x in input().split())
    chips = []
    for _ in range(rows):
        line = input()
        assert len(line) == cols
        chips.append([])
        for char in line:
            if char == '@':
                chips[-1].append(True)
            elif char == '.':
                chips[-1].append(False)
            else:
                assert False, char

    total_chips = sum(chip for row_chips in chips for chip in row_chips)
    total_waffles = (hcuts + 1) * (vcuts + 1)
    if total_chips % total_waffles != 0:
        return 'IMPOSSIBLE'
    chips_per_waffle = total_chips // total_waffles
    if chips_per_waffle == 0:
        return 'POSSIBLE'

    chips_per_row = chips_per_waffle * (vcuts + 1)
    hcut_pos = []
    count = 0
    for row in range(rows):
        count += sum(chips[row])
        if count > chips_per_row:
            return 'IMPOSSIBLE'
        if count == chips_per_row:
            hcut_pos.append(row)
            count = 0
    assert count == 0, count
    assert len(hcut_pos) == hcuts + 1
    log('hcut_pos: %s', hcut_pos)

    chips_per_col = chips_per_waffle * (hcuts + 1)
    vcut_pos = []
    count = 0
    for col in range(cols):
        count += sum(row_chips[col] for row_chips in chips)
        if count > chips_per_col:
            return 'IMPOSSIBLE'
        if count == chips_per_col:
            vcut_pos.append(col)
            count = 0
    assert count == 0, count
    assert len(vcut_pos) == vcuts + 1
    log('vcut_pos: %s', vcut_pos)

    for hcut_idx in range(hcuts):
        row_lo = hcut_pos[hcut_idx] + 1
        row_hi = hcut_pos[hcut_idx + 1] + 1
        for vcut_idx in range(vcuts):
            col_lo = vcut_pos[vcut_idx] + 1
            col_hi = vcut_pos[vcut_idx + 1] + 1
            count = 0
            for row in range(row_lo, row_hi):
                for col in range(col_lo, col_hi):
                    count += chips[row][col]
            if count != chips_per_waffle:
                return 'IMPOSSIBLE'

    return 'POSSIBLE'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2756,94,317,Python,0000000000007883,0000000000030a1f,000000000003005a,mth,2018
168,00000000000148c3.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def troubleSort(values):
    values = list(values)
    done = False
    while not done:
        done = True
        for i in range(len(values) - 2):
            if values[i] > values[i + 2]:
                done = False
                values[i], values[i + 2] = values[i + 2], values[i]
    return values

def fastTroubleSort(values):
    even = iter(sorted(values[0::2]))
    odd = iter(sorted(values[1::2]))
    while True:
        yield next(even)
        yield next(odd)

def solve():
    numValues, = (int(x) for x in input().split())
    values = tuple(int(x) for x in input().split())
    assert len(values) == numValues

    #assert troubleSort(values) == list(fastTroubleSort(values))

    for i, (tv, rv) in enumerate(zip(fastTroubleSort(values), sorted(values))):
        if tv != rv:
            return i
    else:
        return 'OK'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1541,59,170,Python,00000000000000cb,00000000000148c3,00000000000079cb,mth,2018
169,00000000000136d7.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

from math import sqrt

def log(message, *args):
    print(message % args, file=sys.stderr)

def search(low, high, threshold, func):
    '''Finds the point in the interval [low..high] at which the ascending
    floating point function 'func' crosses zero.
    '''
    while True:
        mid = (low + high) / 2
        #print('[%.16f .. %.16f]: %.16f' % (low, high, mid))
        value = func(mid)
        #print('  %.16f' % value)
        if abs(value) <= threshold:
            return mid
        if value < 0:
            assert low != mid
            low = mid
        else:
            assert high != mid
            high = mid

def solveSingle(area):
    y_for_x = lambda x: sqrt(0.5 ** 2 - x ** 2)
    x = search(0.5 * sqrt(0.5), 0.5, 1.0e-10,
               lambda x: area - 2 * (x + y_for_x(x)))
    y = y_for_x(x)
    #print('area:', 2 * (x + y))
    print('%.16f %.16f %.16f' % (x, y, 0.0))
    print('%.16f %.16f %.16f' % (-y, x, 0.0))
    print('%.16f %.16f %.16f' % (0.0, 0.0, 0.5))

def solve():
    area, = (float(x) for x in input().split())

    solveSingle(area)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    for case in range(1, numCases + 1):
        print('Case #%d:' % case)
        solve()
        log('[%s/%s]' % (case, numCases))

def test():
    steps = 100000
    for i in range(steps + 1):
        log('[%s/%s]' % (i, steps))
        solveSingle(1.0 + 0.414213 * (i / steps))

if __name__ == '__main__':
    main()
    #test()
",,1729,68,225,Python,00000000000000cb,00000000000136d7,00000000000079cc,mth,2018
170,0000000000012b57.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

from math import acos, cos, pi, sqrt

def log(message, *args):
    print(message % args, file=sys.stderr)

def search(low, high, threshold, func):
    '''Finds the point in the interval [low..high] at which the ascending
    floating point function 'func' crosses zero.
    '''
    while True:
        mid = (low + high) / 2
        #print('[%.16f .. %.16f]: %.16f' % (low, high, mid))
        value = func(mid)
        #print('  %.16f' % value)
        if abs(value) <= threshold:
            return mid
        if value < 0:
            assert low != mid
            low = mid
        else:
            assert high != mid
            high = mid

def solveSingle(area):
    y_for_x = lambda x: sqrt(0.5 ** 2 - x ** 2)
    x = search(0.5 * sqrt(0.5), 0.5, 1.0e-14,
               lambda x: area - 2 * (x + y_for_x(x)))
    y = y_for_x(x)
    #print('area:', 2 * (x + y))
    print('%.16f %.16f %.16f' % (x, y, 0.0))
    print('%.16f %.16f %.16f' % (-y, x, 0.0))
    print('%.16f %.16f %.16f' % (0.0, 0.0, 0.5))

def solve():
    area, = (float(x) for x in input().split())

    solveSingle(area)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    for case in range(1, numCases + 1):
        print('Case #%d:' % case)
        solve()
        log('[%s/%s]' % (case, numCases))

if __name__ == '__main__':
    main()
",,1583,61,205,Python,00000000000000cb,0000000000012b57,00000000000079cc,mth,2018
171,000000000000f1d6.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    pass #print(message % args, file=sys.stderr)

def prepare(land):
    height = len(land)
    width = len(land[0])

    def repeat(check, ask):
        """"""Request 'ask' to be prepared until 'check' is prepared.""""""
        x, y = check
        while not land[y][x]:
            yield ask

    # For each corner, there is only one safe coordinate we can request.
    yield from repeat((0, 0), (1, 1))
    yield from repeat((width - 1, 0), (width - 2, 1))
    yield from repeat((0, height - 1), (1, height - 2))
    yield from repeat((width - 1, height - 1), (width - 2, height - 2))

    # For sides, one coordinate is fixed while the other can be varied.
    # We will try to fill the sides in increasing order.
    for checkX in range(1, width - 1):
        askX = min(checkX + 1, width - 2)
        yield from repeat((checkX, 0), (askX, 1))
        yield from repeat((checkX, height - 1), (askX, height - 2))
    for checkY in range(1, height - 1):
        askY = min(checkY + 1, height - 2)
        yield from repeat((0, checkY), (1, askY))
        yield from repeat((width - 1, checkY), (width - 2, askY))

    # For inner cells, find the 3x3 location that has the least filled cells.
    # Note: Repeating this computation is slow, but still fast enough.
    while True:
        target = None
        targetFilled = 10
        for cy in range(1, height - 1):
            for cx in range(1, width - 1):
                filled = sum(
                    land[y][x]
                    for y in range(cy - 1, cy + 2)
                    for x in range(cx - 1, cx + 2)
                    )
                if filled < targetFilled:
                    target = (cx, cy)
                    targetFilled = filled
        if targetFilled == 9:
            break
        yield target

    #log('%s', land)

def pickRect(minArea):
    # Start with a square that is large enough.
    width = 3
    while width * width < minArea:
        width += 1
    height = width

    # Try different rectangles.
    # Note: Really narrow rectangles might be worse than slightly larger
    #       rectangles that are closer to square, because of the number of
    #       side cells.
    #       For the fixed inputs A=20 and A=200 this should not be an issue.
    bestRect = (width, height)
    while height > 3:
        while width * (height - 1) >= minArea and height > 3:
            height -= 1
        if width * height < bestRect[0] * bestRect[1]:
            bestRect = (width, height)
        width += 1

    return bestRect

def solve():
    minArea, = (int(x) for x in input().split())

    width, height = pickRect(minArea)
    log('desired rectangle: %d x %d', width, height)
    assert width * height >= minArea, minArea
    assert width >= 3, minArea
    assert height >= 3, minArea

    land = [[False for _ in range(width)] for _ in range(height)]
    gen = prepare(land)
    while True:
        ask = next(gen)
        print('%d %d' % (ask[0] + 1, ask[1] + 1))
        prep = tuple(int(x) for x in input().split())
        if prep == (0, 0):
            return
        elif prep == (-1, -1):
            assert False
        land[prep[1] - 1][prep[0] - 1] = True

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    for case in range(1, numCases + 1):
        solve()
        log('[%s/%s]' % (case, numCases))

if __name__ == '__main__':
    #print(pickRect(20))
    #print(pickRect(200))
    main()
",,3696,118,516,Python,00000000000000cb,000000000000f1d6,0000000000007a30,mth,2018
172,000000000000cbf5.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def troubleSort(values):
    values = list(values)
    done = False
    while not done:
        done = True
        for i in range(len(values) - 2):
            if values[i] > values[i + 2]:
                done = False
                values[i], values[i + 2] = values[i + 2], values[i]
    return values

def solve():
    numValues, = (int(x) for x in input().split())
    values = tuple(int(x) for x in input().split())
    assert len(values) == numValues

    for i, (tv, rv) in enumerate(zip(troubleSort(values), sorted(values))):
        if tv != rv:
            return i
    else:
        return 'OK'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1301,50,152,Python,00000000000000cb,000000000000cbf5,00000000000079cb,mth,2018
173,000000000000c95c.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def calcDamage(shots):
    return sum(freq << level for level, freq in enumerate(shots))

def solve():
    shieldStr, program = input().split()
    shield = int(shieldStr)

    # For each charge level, the number of shots fired at that level.
    shots = [0]
    for instr in program:
        if instr == 'S':
            shots[-1] += 1
        elif instr == 'C':
            shots.append(0)
        else:
            assert False, instr

    # It is possible to do this in linear order by doing all swaps at a level
    # at once, but with a maximum program size of 30, quadratic is good enough.
    swaps = 0
    damage = calcDamage(shots)
    level = len(shots) - 1
    while level > 0 and damage > shield:
        if shots[level] == 0:
            level -= 1
        else:
            swaps += 1
            shots[level] -= 1
            damage -= 1 << level
            shots[level - 1] += 1
            damage += 1 << (level - 1)
        assert calcDamage(shots) == damage, (shots, damage)

    return swaps if damage <= shield else 'IMPOSSIBLE'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1745,63,228,Python,00000000000000cb,000000000000c95c,0000000000007966,mth,2018
174,00000000000053a0.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_stalls, num_people = (int(x) for x in input().split())

    spaces = defaultdict(int)
    spaces[num_stalls] = 1

    people_left = num_people
    while people_left > 0:
        space = max(spaces.keys())
        count = spaces[space]
        del spaces[space]

        people_left -= count

        side_lo = (space - 1) // 2
        side_hi = space // 2
        assert side_lo + side_hi + 1 == space
        spaces[side_lo] += count
        spaces[side_hi] += count

    return '%d %d' % (side_hi, side_lo)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1259,51,146,Python,0000000000000130,00000000000053a0,0000000000000652,mth,2018
175,000000000000539b.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_stalls, num_people = (int(x) for x in input().split())

    spaces = [num_stalls]

    for _ in range(num_people):
        spaces.sort()
        space = spaces.pop()
        side_lo = (space - 1) // 2
        side_hi = space // 2
        assert side_lo + side_hi + 1 == space
        spaces += [side_lo, side_hi]

    return '%d %d' % (side_hi, side_lo)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1068,43,127,Python,0000000000000130,000000000000539b,0000000000000652,mth,2018
176,00000000000052b4.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 5
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    dest, num_horses = (int(x) for x in input().split())
    horses = [
        tuple(int(x) for x in input().split())
        for _ in range(num_horses)
        ]

    time = max(
        (dest - pos) / speed
        for pos, speed in horses
        )

    return dest / time

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,983,42,117,Python,0000000000000130,00000000000052b4,0000000000000652,mth,2018
177,000000000000538f.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    dest, num_horses = (int(x) for x in input().split())
    horses = [
        tuple(int(x) for x in input().split())
        for _ in range(num_horses)
        ]

    time = max(
        (dest - pos) / speed
        for pos, speed in horses
        )

    return dest / time

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,983,42,117,Python,0000000000000130,000000000000538f,0000000000000524,mth,2018
178,000000000000526f.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_parties, = (int(x) for x in input().split())
    senators = tuple(int(x) for x in input().split())
    assert len(senators) == num_parties

    remaining = [
        (count, chr(ord('A') + party))
        for party, count in enumerate(senators)
        ]
    order = []
    while True:
        remaining.sort(reverse=True)
        #log(remaining)
        largest = remaining[0][0]
        if largest == 0:
            break

        num_largest = 1
        while num_largest < num_parties and remaining[num_largest][0] == largest:
            num_largest += 1

        if num_largest == 2:
            leave = [0, 1]
        else:
            leave = [0]

        order.append(''.join(remaining[i][1] for i in leave))
        for i in leave:
            remaining[i] = (remaining[i][0] - 1, remaining[i][1])

    return ' '.join(order)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1550,60,168,Python,0000000000000130,000000000000526f,00000000000004c0,mth,2018
179,00000000000052f4.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 5
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    lo, hi = (int(x) for x in input().split())
    max_guesses, = (int(x) for x in input().split())

    for i in range(1, max_guesses + 1):
        guess = (lo + hi + 1) // 2
        print(guess)
        judgement = input()
        log('guess %d/%d: %d -> %s', i, max_guesses, guess, judgement)
        if judgement == 'CORRECT':
            return 'ok'
        elif judgement == 'TOO_SMALL':
            lo = guess
        elif judgement == 'TOO_BIG':
            hi = guess - 1
        else:
            assert False, judgement
    return 'ERROR'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1209,46,144,Python,0000000000000130,00000000000052f4,0000000000000523,mth,2018
180,000000000014ce31.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_metals = int(input())
    formulas = tuple(
        tuple(int(x) - 1 for x in input().split())
        for _ in range(num_metals)
        )
    stocks = tuple(int(x) for x in input().split())
    assert len(stocks) == num_metals

    # Is there a path to lead?
    done = set()
    new = set([0])
    while new:
        dest = new.pop()
        done.add(dest)
        for metal, prod in enumerate(formulas):
            if metal not in done:
                if dest in prod:
                    new.add(metal)
    produces_lead = done

    def compute_factor(metal, visited):
        prod1, prod2 = formulas[metal]
        factor1 = lead_factor(prod1, visited)
        if factor1 is None:
            return None
        factor2 = lead_factor(prod2, visited)
        if factor2 is None:
            return None
        factor = factor1 + factor2
        if metal == 0:
            return max(1, factor)
        else:
            return factor

    cache = [0] * num_metals
    for metal in produces_lead:
        cache[metal] = -1
    def lead_factor(metal, visited):
        cached = cache[metal]
        if cached == -1:
            if metal in visited:
                # Cycle producing ourselves and lead exists.
                cached = None
            else:
                visited.add(metal)
                cached = compute_factor(metal, visited)
                visited.remove(metal)
            cache[metal] = cached
        return cached

    total = 0
    for metal, amount in enumerate(stocks):
        if amount == 0:
            continue
        factor = lead_factor(metal, set())
        if factor is None:
            return 'UNBOUNDED'
        total = (total + amount * factor) % 1000000007

    return total

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2443,90,268,Python,0000000000051679,000000000014ce31,0000000000146185,mth,2019
181,0000000000149d2d.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    vases = [[] for _ in range(20)]
    recent = [0] * 20

    def stuff(vase, token):
        vases[vase].append(token)
        print(vase + 1, token, flush=True)

    def inspect(vase):
        print(vase + 1, 0, flush=True)
        vases[vase] = [int(x) for x in input().split()]
        recent[vase] = day

    def size(vase):
        return len(vases[vase]) + (day - recent[vase]) / 20

    day = 0
    while day < 100:
        day = int(input())
        if day == -1:
            return 'FAIL'

        if day < 50:
            stuff(day % 10, 100)
        elif day < 60:
            inspect(10 + day - 50)
        elif day < 81:
            if day == 60:
                num_winners = 3
                winners = sorted(range(10, 20), key=size)
            stuff(winners[num_winners + (day - 60) % (10 - num_winners)], 100)
        elif day < 91:
            inspect(10 + day - 81)
        else:
            winners = sorted(range(10, 20), key=size)
            if day == 100:
                stuff(winners[0], 100)
            else:
                stuff(winners[1], 100)

    return ''

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        #log(progressFmt % (case, numCases, 'start'))
        result = solve()
        #log(progressFmt % (case, numCases, result or 'pass'))
        if result:
            break

if __name__ == '__main__':
    main()
",,1856,72,215,Python,0000000000051679,0000000000149d2d,00000000001461c8,mth,2019
182,000000000012e2ec.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_swords, fairness = (int(x) for x in input().split())
    skills_c = tuple(int(x) for x in input().split())
    skills_d = tuple(int(x) for x in input().split())

    count = 0
    for start in range(num_swords):
        max_c = 0
        max_d = 0
        for end in range(start, num_swords):
            max_c = max(max_c, skills_c[end])
            max_d = max(max_d, skills_d[end])
            count += abs(max_c - max_d) <= fairness

    return count

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1170,44,135,Python,51706,000000000012e2ec,0000000000122838,mth,2019
183,000000000012c1ac.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_people, size = (int(x) for x in input().split())
    size += 1
    col = [0] * size
    row = [0] * size
    for _ in range(num_people):
        x_str, y_str, d_str = input().split()
        x = int(x_str)
        y = int(y_str)
        if d_str == 'N':
            for i in range(y + 1, size):
                row[i] += 1
        elif d_str == 'E':
            for i in range(x + 1, size):
                col[i] += 1
        elif d_str == 'S':
            for i in range(y):
                row[i] += 1
        elif d_str == 'W':
            for i in range(x):
                col[i] += 1
        else:
            assert False, d_str

    max_x = min(range(size), key=lambda x: (-col[x], x))
    max_y = min(range(size), key=lambda y: (-row[y], y))

    return '%d %d' % (max_x, max_y)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1504,57,188,Python,51706,000000000012c1ac,000000000012295c,mth,2019
184,000000000012b43e.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve(num_guesses):

    day_counts = []
    for day in (40, 200):
        print(day, flush=True)
        read = input()
        if read == '-1':
            return 'FAIL'
        day_counts.append(int(read))

    # day 200: 2^200 * r1 + 2^100 * r2 + 2^66 * r3 + 2^50 * r4 + 2^40 * r5 + 2^33 * r6
    day_200 = day_counts[1]
    r6 = (day_200 >> 33) & 127
    r5 = (day_200 >> 40) & 127
    r4 = (day_200 >> 50) & 127

    # day 40: 2^40 * r1 + 2^20 * r2 + 2^13 * r3 + 2^10 * r4 + 2^8 * r5 + 2^6 * r6
    day_40 = day_counts[0]
    day_40 -= (r4 << 10) + (r5 << 8) + (r6 << 6)
    r3 = (day_40 >> 13) & 127
    r2 = (day_40 >> 20) & 127
    r1 = (day_40 >> 40) & 127

    print(r1, r2, r3, r4, r5, r6, flush=True)

    judgement = input()
    if judgement == '1':
        return None
    elif judgement == '-1':
        return 'WRONG ANSWER'
    else:
        return 'UNEXPECTED JUDGEMENT'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases, num_guesses = (int(x) for x in input().split())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve(num_guesses)
        #log(progressFmt % (case, numCases, result or 'pass'))
        if result:
            break

if __name__ == '__main__':
    main()
",,1633,62,242,Python,51706,000000000012b43e,0000000000122837,mth,2019
185,0000000000128275.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_swords, fairness = (int(x) for x in input().split())
    skills = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(2)
        )

    count = 0
    for start in range(num_swords):
        for end in range(start + 1, num_swords + 1):
            skill_c = max(skills[0][start:end])
            skill_d = max(skills[1][start:end])
            if abs(skill_c - skill_d) <= fairness:
                count += 1

    return count

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1167,45,132,Python,51706,0000000000128275,0000000000122838,mth,2019
186,0000000000126d30.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def search(counts, r0):
    counts = list(counts)
    rings = []
    for day in range(6):
        if day == 0:
            rd = r0
        else:
            rd = counts[day] - counts[day - 1]
        rings.append(rd)
        for i in range(6):
            if (i + 1) % (day + 1) == 0:
                rd <<= 1
            counts[i] -= rd
        if min(counts) < 0:
            return None
    return rings

def solve(num_guesses):

    day_counts = []
    for day in range(num_guesses):
        print(day + 1, flush=True)
        read = input()
        if read == '-1':
            return 'FAIL'
        day_counts.append(int(read))

    #print(day_counts, file=sys.stderr)

    for r0 in range(101):
        solution = search(day_counts, r0)
        if solution is not None:
            break

    #print('!', solution, file=sys.stderr)
    if solution is None:
        print('NO SOLUTION COULD BE FOUND !', flush=True)
    else:
        print(' '.join(str(r) for r in solution), flush=True)
    judgement = input()
    if judgement == '1':
        return None
    elif judgement == '-1':
        return 'WRONG ANSWER'
    else:
        return 'UNEXPECTED JUDGEMENT'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases, num_guesses = (int(x) for x in input().split())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve(num_guesses)
        #log(progressFmt % (case, numCases, result or 'pass'))
        if result:
            break

if __name__ == '__main__':
    main()
",,1908,76,218,Python,51706,0000000000126d30,0000000000122837,mth,2019
187,00000000001239ff.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_people, size = (int(x) for x in input().split())
    size += 1
    people = []
    for _ in range(num_people):
        x_str, y_str, d_str = input().split()
        x = int(x_str)
        y = int(y_str)
        d = {
            'N': (0, 1),
            'E': (1, 0),
            'S': (0, -1),
            'W': (-1, 0),
            }[d_str]
        people.append(((x, y), d))

    count = [[0 for x in range(size)] for y in range(size)]
    for (x, y), (dx, dy) in people:
        if dx == 0:
            if dy < 0:
                rows = count[:y]
            else:
                rows = count[y + 1:]
            for row in rows:
                for i in range(size):
                    row[i] += 1
        elif dy == 0:
            for row in count:
                if dx < 0:
                    cols = range(x)
                else:
                    cols = range(x + 1, size)
                for i in cols:
                    row[i] += 1
        else:
            assert False

    best = (0, -1, -1)
    for y, row in enumerate(count):
        for x, n in enumerate(row):
            best = min(best, (-n, x, y))

    return '%d %d' % best[1:]

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1870,72,230,Python,51706,00000000001239ff,000000000012295c,mth,2019
188,000000000011067d.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve(num_nights, max_num_gophers):
    num_gophers = 0
    for _ in range(num_nights):
        mills = [18] * 18
        assert len(mills) == 18, mills
        print(' '.join('%d' % blades for blades in mills), flush=True)
        read = input()
        if read == '-1':
            return 'FAIL'
        positions = tuple(int(x) for x in read.split())
        assert len(positions) == 18, read
        #print(positions, file=sys.stderr)
        num_gophers = max(num_gophers, sum(positions))

    print(num_gophers, flush=True)
    judgement = input()
    if judgement == '1':
        return None
    elif judgement == '-1':
        return 'WRONG ANSWER'
    else:
        return 'UNEXPECTED JUDGEMENT'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases, num_nights, num_gophers = (int(x) for x in input().split())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve(num_nights, num_gophers)
        #log(progressFmt % (case, numCases, result or 'pass'))
        if result:
            break

if __name__ == '__main__':
    main()
",,1472,52,160,Python,51635,000000000011067d,0000000000104f1a,mth,2019
189,000000000010cd5e.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from itertools import combinations, permutations
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def subsets(sequence):
    """"""Iterates through all subsets of the given sequence.
    Each yielded element is a tuple containing a subset of the elements of
    the original sequence, in the same order as in the original sequence.
    """"""
    sequence = tuple(sequence)
    size = len(sequence)
    def rec(s, i):
        if i == size:
            yield tuple(s)
        else:
            s.append(sequence[i])
            for sub in rec(s, i + 1):
                yield sub
            del s[-1]
            for sub in rec(s, i + 1):
                yield sub
    return rec([], 0)

def solve():
    num_words, = (int(x) for x in input().split())
    words = tuple(sorted(
        ''.join(reversed(input()))
        for _ in range(num_words)
        ))

    def is_poem(candidate):
        num_pairs = len(candidate) // 2
        for pairing in permutations(candidate):
            prefixes = defaultdict(int)
            for i in range(num_pairs):
                pair = pairing[i * 2:(i + 1) * 2]
                min_len = min(len(word) for word in pair)
                prefix_len = min(
                    (j for j in range(min_len) if pair[0][j] != pair[1][j]),
                    default=min_len
                    )
                prefix = pair[0][:prefix_len]
                assert pair[1][:prefix_len] == prefix, (pair, prefix_len)
                prefixes[prefix] += 1

            prefix_len = max(len(prefix) for prefix in prefixes)
            #print(prefixes, prefix_len)
            while prefix_len > 0:
                for prefix in list(prefixes):
                    if len(prefix) == prefix_len:
                        count = prefixes.pop(prefix)
                        assert count > 0
                        count -= 1
                        if count > 0:
                            prefixes[prefix[:prefix_len - 1]] += count
                if not prefixes:
                    return True
                prefix_len -= 1

        #print('not a poem:', candidate)
        return False

    longest_poem = 0
    for candidate in subsets(words):
        poem_len = len(candidate)
        if poem_len > longest_poem and poem_len % 2 == 0:
            if is_poem(candidate):
                longest_poem = poem_len

    return longest_poem

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,3050,97,320,Python,51635,000000000010cd5e,0000000000104e05,mth,2019
190,0000000000106a60.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from itertools import combinations, permutations
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_words, = (int(x) for x in input().split())
    words = tuple(sorted(
        input()
        for _ in range(num_words)
        ))

    suffix_lengths = {}
    for word1, word2 in combinations(words, 2):
        min_len = min(len(word1), len(word2))
        i = 0
        while i < min_len:
            if word1[-(i+1)] == word2[-(i+1)]:
                i += 1
            else:
                break
        suffix_lengths[(word1, word2)] = i

    max_pairings = 0
    max_num_pairs = len(words) // 2
    for candidates in combinations(words, max_num_pairs * 2):
        for pairing in permutations(candidates):
            pairings_at_suflen = defaultdict(int)
            for i in range(max_num_pairs):
                pair = tuple(sorted(pairing[i * 2:(i + 1) * 2]))
                pairings_at_suflen[suffix_lengths[pair]] += 1

            num_pairings = 0
            active_pairings = 0
            for suflen in range(max(pairings_at_suflen), 0, -1):
                active_pairings += pairings_at_suflen[suflen]
                if active_pairings > 0:
                    active_pairings -= 1
                    num_pairings += 1

            max_pairings = max(max_pairings, num_pairings)

    return max_pairings * 2

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2029,69,207,Python,51635,0000000000106a60,0000000000104e05,mth,2019
191,00000000001062ed.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from itertools import combinations
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_words, = (int(x) for x in input().split())
    words = tuple(
        input()
        for _ in range(num_words)
        )

    suffix_lengths = {}
    for word1, word2 in combinations(words, 2):
        min_len = min(len(word1), len(word2))
        i = 0
        while i < min_len:
            if word1[-(i+1)] == word2[-(i+1)]:
                i += 1
            else:
                break
        suffix_lengths[(word1, word2)] = i

    max_pairings = 0
    max_num_pairs = len(words) // 2
    for pairing in combinations(words, max_num_pairs * 2):
        pairings_at_suflen = defaultdict(int)
        for i in range(max_num_pairs):
            pair = pairing[i * 2:(i + 1) * 2]
            pairings_at_suflen[suffix_lengths[pair]] += 1

        num_pairings = 0
        active_pairings = 0
        for suflen in range(max(pairings_at_suflen), 0, -1):
            active_pairings += pairings_at_suflen[suflen]
            if active_pairings > 0:
               active_pairings -= 1
               num_pairings += 1

        max_pairings = max(max_pairings, num_pairings)

    return max_pairings * 2

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1890,68,202,Python,51635,00000000001062ed,0000000000104e05,mth,2019
192,0000000000105be6.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from itertools import combinations, permutations
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_words, = (int(x) for x in input().split())
    words = tuple(sorted(
        input()
        for _ in range(num_words)
        ))

    suffix_lengths = {}
    for word1, word2 in combinations(words, 2):
        min_len = min(len(word1), len(word2))
        i = 0
        while i < min_len:
            if word1[-(i+1)] == word2[-(i+1)]:
                i += 1
            else:
                break
        suffix_lengths[(word1, word2)] = i

    max_pairings = 0
    for pairing in permutations(words):
        pairings_at_suflen = defaultdict(int)
        for i in range(0, len(words), 2):
            # We do duplicate work, but should still be fast enough for small.
            pair = tuple(sorted(pairing[i:i+2]))
            if len(pair) == 2:
                pairings_at_suflen[suffix_lengths[pair]] += 1

        num_pairings = 0
        active_pairings = 0
        for suflen in range(max(pairings_at_suflen), 0, -1):
            active_pairings += pairings_at_suflen[suflen]
            if active_pairings > 0:
               active_pairings -= 1
               num_pairings += 1

        max_pairings = max(max_pairings, num_pairings)

    return max_pairings * 2

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1977,69,208,Python,51635,0000000000105be6,0000000000104e05,mth,2019
193,00000000000c5485.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def calcPrimes(limit):
    '''Returns list of all primes under the given limit.
    '''
    sieve = [True] * limit
    sieve[0] = False
    sieve[1] = False
    i = 2
    while i * i < limit:
        if sieve[i]:
            for j in range(2 * i, limit, i):
                sieve[j] = False
        i += 1
    return [i for i, prime in enumerate(sieve) if prime]

def solve():
    max_prime, cypher_len = (int(x) for x in input().split())
    cypher = tuple(int(x) for x in input().split())
    assert len(cypher) == cypher_len

    primes = calcPrimes(max_prime + 1)
    factored = []
    for product in cypher:
        for prime in primes:
            if product % prime == 0:
                other = product // prime
                assert other in primes
                factored.append((prime, other))
                break
        else:
            assert False, product

    encodings = set()
    for prime1, prime2 in factored:
        encodings.add(prime1)
        encodings.add(prime2)
    assert len(encodings) == 26, encodings
    decoder = {
        prime: chr(ord('A') + idx)
        for idx, prime in enumerate(sorted(encodings))
        }
    #log('decoder: %s', decoder)

    def sequence(prev):
        ret = []
        for prime1, prime2 in factored:
            if prime1 == prev or prime2 == prev:
                ret.append(prev)
                prev = prime1 + prime2 - prev
            else:
                return None
        ret.append(prev)
        return ret
    return ''.join(
        decoder[prime]
        for prime in sequence(factored[0][0]) or sequence(factored[0][1])
        )

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,2309,85,265,Python,51705,00000000000c5485,000000000008830b,mth,2019
194,00000000000c111e.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    total_bits, total_broken, max_probes = (int(x) for x in input().split())

    # Pretend that the bit string is a power of two long.
    # The bits that we invented will never be read back,
    # so we will detect them as broken.
    pretend_bits = 1 << (total_bits - 1).bit_length()
    pretend_broken = total_broken + pretend_bits - total_bits
    #log('pretend: %d %d', pretend_bits, pretend_broken)

    seq_len = 1 << total_broken.bit_length()
    broken_seq = None
    while seq_len:
        num_seq = pretend_bits // seq_len
        pattern = '0' * seq_len + '1' * seq_len
        store = (pattern * max(1, num_seq // 2))[:total_bits]
        assert len(store) == total_bits
        #log('%d %d, %d %d: %s', total_bits, total_broken, seq_len, num_seq, store)
        print(store, flush=True)
        read = input()
        if read == '-1':
            return 'PROBES EXCEEDED'
        num_read = len(read)
        assert num_read == total_bits - total_broken, read

        def count_read():
            """"""Yields the read-back size of each segment.""""""
            start = 0
            for broken in broken_seq:
                # Because broken_seq describes the previous iteration,
                # it represents two sequences in this iteration.
                end = start + seq_len * 2 - broken
                assert end <= pretend_bits, end
                flip = read.find('1', start, end)
                if flip == -1:
                    flip = end
                yield flip - start
                yield end - flip
                start = end

        if broken_seq is None:
            broken_seq = []
            value = 0
            start = 0
            while len(broken_seq) < num_seq:
                end = read.find('10'[value], start)
                if end == -1:
                    end = num_read
                for ch in read[start:end]:
                    assert int(ch) == value

                actual = end - start
                broken_seq.append(seq_len - actual)

                value ^= 1
                start = end
        else:
            broken_seq = [seq_len - actual for actual in count_read()]

        #log('broken: %s', broken_seq)
        assert sum(broken_seq) == pretend_broken, broken_seq

        seq_len //= 2

    assert len(broken_seq) == pretend_bits
    broken_bits = [
        i
        for i, broken in enumerate(broken_seq[:total_bits])
        if broken
        ]
    assert len(broken_bits) == total_broken
    print(' '.join(str(i) for i in broken_bits), flush=True)

    judgement = input()
    if judgement == '1':
        return None
    elif judgement == '-1':
        return 'WRONG ANSWER'
    else:
        return 'UNEXPECTED JUDGEMENT'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        #log(progressFmt % (case, numCases, result or 'pass'))
        if result:
            break

if __name__ == '__main__':
    main()
",,3424,110,390,Python,51705,00000000000c111e,00000000000881de,mth,2019
195,00000000000b6107.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    size = int(input())
    path = input()
    assert len(path) == size * 2 - 2

    return path.replace('S', 'X').replace('E', 'S').replace('X', 'E')

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,858,35,97,Python,51705,00000000000b6107,00000000000881da,mth,2019
196,00000000000b59ae.PYTHON3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    value = input()
    assert value.isdigit()

    check1 = []
    check2 = []
    for digit in value:
        if digit == '4':
            check1.append('3')
            check2.append('1')
        else:
            check1.append(digit)
            if check2:
                check2.append('0')

    if not check2:
        check2.append('0')

    return '%s %s' % (''.join(check1), ''.join(check2))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",,1107,48,114,Python,51705,00000000000b59ae,0000000000088231,mth,2019
197,0000000000249f33,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def gen_sums(min_val, max_val, num_val, total):
    if num_val == 0:
        if total == 0:
            yield []
    else:
        new_num = num_val - 1
        for val in range(min_val, max_val):
            new_total = total - val
            if val * new_num <= new_total <= (max_val - 1) * new_num:
                for lst in gen_sums(val, max_val, new_num, new_total):
                    lst.append(val)
                    yield lst

def find_square(trace):
    size = len(trace)

    row_remain = [{n for n in range(size) if n != t} for t in trace]
    col_remain = [{n for n in range(size) if n != t} for t in trace]
    matrix = [
        [trace[ri] if ri == ci else None for ci in range(size)]
        for ri in range(size)
        ]

    def rec(ri, ci):
        if ci == size:
            ci = 0
            ri += 1
            if ri == size:
                return True
        if ri == ci:
            return rec(ri, ci + 1)
        for n in row_remain[ri] & col_remain[ci]:
            matrix[ri][ci] = n
            row_remain[ri].remove(n)
            col_remain[ci].remove(n)
            if rec(ri, ci + 1):
                return True
            row_remain[ri].add(n)
            col_remain[ci].add(n)
        return False

    return matrix if rec(0, 0) else None

def solve():
    size, target_trace = (int(x) for x in input().split())

    for trace in gen_sums(0, size, size, target_trace - size):
        trace.reverse()
        matrix = find_square(trace)
        if matrix is not None:
            return 'POSSIBLE\n' + '\n'.join(
                ' '.join(str(n + 1) for n in row)
                for row in matrix
                )
    else:
        return 'IMPOSSIBLE'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000249f33.PYTHON3,2393,85,288,Python,000000000019fd27,0000000000249f33,0000000000209aa0,mth,2020
198,0000000000221bf0,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve(bits):
    query_count = 0

    def query(bit):
        assert 0 <= bit < bits
        nonlocal query_count
        query_count += 1
        print(bit + 1, flush=True)
        answer = input()
        assert answer != 'N'
        return int(answer)

    def submit(bitstring):
        assert isinstance(bitstring, str)
        assert len(bitstring) == bits
        print(bitstring, flush=True)
        answer = input()
        assert answer != 'N'

    data = [None for _ in range(bits)]
    same_idx = None
    diff_idx = None

    for query_idx in range((bits + 1) // 2):
        if query_count % 10 == 0:
            # Data will fluctuate on next query.

            if same_idx is None:
                # All mirror bits so far differ, so complement is identical
                # to reverse.
                pass
            else:
                if query(same_idx) != data[same_idx]:
                    # Data was complemented.
                    for idx in range(bits):
                        value = data[idx]
                        if value is not None:
                            data[idx] = value ^ 1

            if diff_idx is None:
                # All mirror bits so far match, so reverse is a no-op.
                pass
            else:
                if query(diff_idx) != data[diff_idx]:
                    # Data was reversed.
                    data.reverse()

        if query_count % 2 != 0:
            # Do a dummy query to make sure we stay at an even query count.
            query(0)

        # Query two mirror bits.
        # Since the number of queries so far is even, there won't be
        # a fluctuation between these two queries.
        data[query_idx] = value1 = query(query_idx)
        data[bits - 1 - query_idx] = value2 = query(bits - 1 - query_idx)
        if value1 == value2:
            if same_idx is None:
                same_idx = query_idx
        else:
            if diff_idx is None:
                diff_idx = query_idx

    submit(''.join(str(d) for d in data))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases, bits = (int(x) for x in input().split())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve(bits)
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000221bf0.PYTHON3,2716,92,319,Python,000000000019fd27,0000000000221bf0,0000000000209a9e,mth,2020
199,000000000021d6cd,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_activities = int(input())
    activities = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_activities)
        )
    assert all(len(act) == 2 for act in activities)

    c_end = 0
    j_end = 0
    solution = [None for _ in range(num_activities)]
    for (start, end), idx in sorted((act, idx)
                                    for idx, act in enumerate(activities)
                                    ):
        # Have previous activities ended?
        if start >= c_end:
            c_end = 0
        if start >= j_end:
            j_end = 0

        # Assign new activity.
        assert end > 0 # since it's larger than start
        if not c_end:
            c_end = end
            solution[idx] = 'C'
        elif not j_end:
            j_end = end
            solution[idx] = 'J'
        else:
            return 'IMPOSSIBLE'

    assert None not in solution
    return ''.join(solution)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000021d6cd.PYTHON3,1647,62,189,Python,000000000019fd27,000000000021d6cd,000000000020bdf9,mth,2020
200,000000000021cc18,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_activities = int(input())
    activities = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_activities)
        )
    assert all(len(act) == 2 for act in activities)

    c_end = 0
    j_end = 0
    solution = []
    for start, end in sorted(activities):
        # Have previous activities ended?
        if start >= c_end:
            c_end = 0
        if start >= j_end:
            j_end = 0

        # Assign new activity.
        if not c_end:
            c_end = end
            solution.append('C')
        elif not j_end:
            j_end = end
            solution.append('J')
        else:
            return 'IMPOSSIBLE'

    return ''.join(solution)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000021cc18.PYTHON3,1410,58,158,Python,000000000019fd27,000000000021cc18,000000000020bdf9,mth,2020
201,000000000021c152,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    seq = tuple(int(x) for x in input())

    out = []
    depth = 0
    for digit in seq:
        while digit > depth:
            out.append('(')
            depth += 1
        while digit < depth:
            out.append(')')
            depth -= 1
        out.append(str(digit))
    while depth > 0:
        out.append(')')
        depth -= 1

    return ''.join(out)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000021c152.PYTHON3,1078,47,122,Python,000000000019fd27,000000000021c152,0000000000209a9f,mth,2020
202,000000000021b5d6,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def transpose(matrix):
    size = len(matrix)
    return tuple(
        tuple(matrix[ri][ci] for ri in range(size))
        for ci in range(size)
        )

def solve():
    size = int(input())
    matrix = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(size)
        )

    trace = sum(matrix[i][i] for i in range(size))
    row_rep = sum(len(set(row)) != size for row in matrix)
    col_rep = sum(len(set(row)) != size for row in transpose(matrix))

    return '%d %d %d' % (trace, row_rep, col_rep)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000021b5d6.PYTHON3,1226,48,144,Python,000000000019fd27,000000000021b5d6,000000000020993c,mth,2020
203,000000000021b370,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def transpose(matrix):
    size = len(matrix)
    return tuple(
        tuple(matrix[ri][ci] for ri in range(size))
        for ci in range(size)
        )

def solve():
    size = int(input())
    matrix = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(size)
        )

    trace = sum(matrix[i][i] for i in range(size))
    row_rep = sum(len(set(row)) != size for row in matrix)
    col_rep = sum(len(set(row)) != size for row in transpose(matrix))

    return f'{trace} {row_rep} {col_rep}'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000021b370.PYTHON3,1218,48,140,Python,000000000019fd27,000000000021b370,000000000020993c,mth,2020
204,00000000002c5655,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

class Dancer:

    def __init__(self, skill):
        self.skill = skill

    def init_neighbours(self, neighbours):
        self.neighbours = list(neighbours)

    def check_survive(self):
        nskill = 0
        ncount = 0
        for neighbour in self.neighbours:
            if neighbour:
                nskill += neighbour.skill
                ncount += 1
        return self.skill * ncount >= nskill

    def eliminated(self):
        neighbours = self.neighbours
        for cdir in range(4):
            cn = neighbours[cdir]
            if cn:
                odir = cdir ^ 1
                #assert cn.neighbours[odir] is self
                cn.neighbours[odir] = neighbours[odir]
                yield cn

def solve():
    num_rows, num_cols = (int(x) for x in input().split())
    skills = list(
        list(int(x) for x in input().split())
        for _ in range(num_rows)
        )

    floor = [
        Dancer(skills[ri][ci])
        for ri in range(num_rows)
        for ci in range(num_cols)
        ]
    def initial_neighbours(ri, ci):
        yield (ri - 1, ci) if ri > 0 else None
        yield (ri + 1, ci) if ri + 1 < num_rows else None
        yield (ri, ci - 1) if ci > 0 else None
        yield (ri, ci + 1) if ci + 1 < num_cols else None
    eliminations = []
    for ri in range(num_rows):
        for ci in  range(num_cols):
            dancer = floor[ri * num_cols + ci]
            dancer.init_neighbours(
                None if pos is None else floor[pos[0] * num_cols + pos[1]]
                for pos in initial_neighbours(ri, ci)
                )
            if not dancer.check_survive():
                eliminations.append(dancer)

    floor_skill = sum(dancer.skill for dancer in floor)
    level = floor_skill
    while eliminations:
        prev_elim = eliminations
        eliminations = []
        for dancer in prev_elim:
            floor_skill -= dancer.skill
            dancer.skill = 0
        for dancer in prev_elim:
            for neighbour in dancer.eliminated():
                if neighbour.skill and not neighbour.check_survive():
                    eliminations.append(neighbour)
        level += floor_skill

    return level

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002c5655.PYTHON3,2890,99,318,Python,000000000019fd74,00000000002c5655,00000000002b1355,mth,2020
205,00000000002c4734,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

class Dancer:

    def __init__(self, skill):
        self.skill = skill

    def init_neighbours(self, neighbours):
        self.neighbours = list(neighbours)

    def check_survive(self):
        nskill = 0
        ncount = 0
        for neighbour in self.neighbours:
            if neighbour:
                nskill += neighbour.skill
                ncount += 1
        return self.skill * ncount >= nskill

    def eliminated(self):
        neighbours = self.neighbours
        for cdir in range(4):
            cn = neighbours[cdir]
            if cn:
                odir = cdir ^ 1
                #assert cn.neighbours[odir] is self
                cn.neighbours[odir] = neighbours[odir]
                yield cn

def solve():
    num_rows, num_cols = (int(x) for x in input().split())
    skills = list(
        list(int(x) for x in input().split())
        for _ in range(num_rows)
        )

    floor = [
        Dancer(skills[ri][ci])
        for ri in range(num_rows)
        for ci in range(num_cols)
        ]
    def initial_neighbours(ri, ci):
        yield (ri - 1, ci) if ri > 0 else None
        yield (ri + 1, ci) if ri + 1 < num_rows else None
        yield (ri, ci - 1) if ci > 0 else None
        yield (ri, ci + 1) if ci + 1 < num_cols else None
    eliminations = []
    for ri in range(num_rows):
        for ci in  range(num_cols):
            dancer = floor[ri * num_cols + ci]
            dancer.init_neighbours(
                None if pos is None else floor[pos[0] * num_cols + pos[1]]
                for pos in initial_neighbours(ri, ci)
                )
            if not dancer.check_survive():
                eliminations.append(dancer)

    floor_skill = sum(dancer.skill for dancer in floor)
    level = floor_skill
    while eliminations:
        prev_elim = eliminations
        eliminations = []
        for dancer in prev_elim:
            floor_skill -= dancer.skill
            for neighbour in dancer.eliminated():
                if not neighbour.check_survive():
                    eliminations.append(neighbour)
        level += floor_skill

    return level

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002c4734.PYTHON3,2808,97,309,Python,000000000019fd74,00000000002c4734,00000000002b1355,mth,2020
206,00000000002c2180,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

class Dancer:

    def __init__(self, skill):
        self.skill = skill

    def init_neighbours(self, neighbours):
        self.neighbours = list(neighbours)

    def survive(self):
        nskill = 0
        ncount = 0
        for neighbour in self.neighbours:
            if neighbour:
                nskill += neighbour.skill
                ncount += 1
        return self.skill * ncount >= nskill

    def eliminated(self):
        neighbours = self.neighbours
        for cdir in range(4):
            cn = neighbours[cdir]
            if cn:
                odir = cdir ^ 1
                assert cn.neighbours[odir] is self
                cn.neighbours[odir] = neighbours[odir]

def solve():
    num_rows, num_cols = (int(x) for x in input().split())
    skills = list(
        list(int(x) for x in input().split())
        for _ in range(num_rows)
        )

    floor = [
        Dancer(skills[ri][ci])
        for ri in range(num_rows)
        for ci in range(num_cols)
        ]
    def initial_neighbours(ri, ci):
        yield (ri - 1, ci) if ri > 0 else None
        yield (ri + 1, ci) if ri + 1 < num_rows else None
        yield (ri, ci - 1) if ci > 0 else None
        yield (ri, ci + 1) if ci + 1 < num_cols else None
    for ri in range(num_rows):
        for ci in  range(num_cols):
            dancer = floor[ri * num_cols + ci]
            dancer.init_neighbours(
                None if pos is None else floor[pos[0] * num_cols + pos[1]]
                for pos in initial_neighbours(ri, ci)
                )

    level = 0
    while True:
        nxt_floor = []
        eliminations = []
        for dancer in floor:
            level += dancer.skill
            if dancer.survive():
                nxt_floor.append(dancer)
            else:
                eliminations.append(dancer)
        if not eliminations:
            break
        floor = nxt_floor
        for dancer in eliminations:
            dancer.eliminated()

    return level

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002c2180.PYTHON3,2670,97,299,Python,000000000019fd74,00000000002c2180,00000000002b1355,mth,2020
207,00000000002bdfd0,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_rows, num_cols = (int(x) for x in input().split())
    skills = list(
        list(int(x) for x in input().split())
        for _ in range(num_rows)
        )

    def find_neighbours(ri, ci):
        for cn in range(ci - 1, -1, -1):
            skill = skills[ri][cn]
            if skill:
                yield skill
                break
        for cn in range(ci + 1, num_cols):
            skill = skills[ri][cn]
            if skill:
                yield skill
                break
        for rn in range(ri - 1, -1, -1):
            skill = skills[rn][ci]
            if skill:
                yield skill
                break
        for rn in range(ri + 1, num_rows):
            skill = skills[rn][ci]
            if skill:
                yield skill
                break

    level = 0
    while True:
        nxt_skill = []
        eliminations = 0
        for ri in range(num_rows):
            nxt_skill.append([])
            for ci in range(num_cols):
                skill = skills[ri][ci]
                if skill:
                    level += skill
                    neighbours = list(find_neighbours(ri, ci))
                    if neighbours:
                        nskill = sum(neighbours)
                        if skill * len(neighbours) < nskill:
                            skill = 0
                            eliminations += 1
                nxt_skill[-1].append(skill)
        skills = nxt_skill
        if eliminations == 0:
            break

    return level

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002bdfd0.PYTHON3,2219,80,224,Python,000000000019fd74,00000000002bdfd0,00000000002b1355,mth,2020
208,00000000002ba820,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def create_walk(n):
    yield 0, 0
    total = 1
    r = 0
    while total + r + 1 <= n:
        r += 1
        yield r, 1
        total += r
    while total < n:
        yield r, 0
        total += 1
        r -= 1

def test(limit):
    fac = []
    n = 1
    for x in range(1, 501):
        fac.append(n)
        n *= x

    for n in range(1, limit + 1):
        walk = tuple(create_walk(n))
        #print(n, walk)
        assert len(walk) <= 500, n
        assert len(set(walk)) == len(walk), walk
        assert all(0 <= k <= r for r, k in walk), walk
        assert sum(
            (fac[r] // fac[k]) // fac[r - k]
            for r, k in walk
            ) == n, n

def solve():
    n = int(input())
    return '\n' + '\n'.join(
        '%d %d' % (r + 1, k + 1) for r, k in create_walk(n)
        )

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
    #test(1000)
",00000000002ba820.PYTHON3,1517,66,211,Python,000000000019fd74,00000000002ba820,00000000002b1353,mth,2020
209,00000000002b4bd3,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def reverse(s):
    return ''.join(reversed(s))

def find_start(patterns):
    longest = ''
    for pattern in patterns:
        start = pattern[:pattern.index('*')]
        if len(start) > len(longest):
            if start.startswith(longest):
                longest = start
            else:
                return None
        elif not longest.startswith(start):
            return None
    return longest

def solve():
    num_patterns = int(input())
    patterns = tuple(input() for _ in range(num_patterns))

    start = find_start(patterns)
    if start is None:
        return '*'

    end = find_start(reverse(pattern) for pattern in patterns)
    if end is None:
        return '*'
    end = reverse(end)

    middle = []
    for pattern in patterns:
        for fragment in pattern.split('*')[1:-1]:
            if fragment:
                middle.append(fragment)

    return start + ''.join(middle) + end

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002b4bd3.PYTHON3,1614,65,168,Python,000000000019fd74,00000000002b4bd3,00000000002b3034,mth,2020
210,00000000003057e5,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_ranks, num_suits = (int(x) for x in input().split())
    num_cards = num_ranks * num_suits

    stack = list(range(num_ranks)) * num_suits
    assert len(stack) == num_cards

    swaps = []
    good = num_cards
    while good > 0:
        #print(good, stack)
        value = (good - 1) // num_suits
        if stack[good - 1] != value:
            index = stack.index(value) + 1
            swaps.append((index, good - index))
            stack[:good] = stack[index:good] + stack[:index]
        good -= 1

    return ('%d\n' % len(swaps)) + '\n'.join(
        '%d %d' % swap for swap in swaps
        )

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000003057e5.PYTHON3,1319,50,157,Python,000000000019fef2,00000000003057e5,00000000002d5b64,mth,2020
211,00000000002ff9f2,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_ranks, num_suits = (int(x) for x in input().split())
    num_cards = num_ranks * num_suits

    stack = list(range(num_ranks)) * num_suits
    assert len(stack) == num_cards

    swaps = []
    good = 0
    while good < num_cards:
        #print(good, stack)
        value = good // num_suits
        if stack[good] != value:
            index = stack.index(value, good + 1)
            swaps.append((num_cards - index, index - good))
            stack[good:] = stack[index:] + stack[good:index]
        good += 1

    return ('%d\n' % len(swaps)) + '\n'.join(
        '%d %d' % swap for swap in swaps
        )

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002ff9f2.PYTHON3,1327,50,156,Python,000000000019fef2,00000000002ff9f2,00000000002d5b64,mth,2020
212,00000000002faa8b,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

#def solve(gx, gy):
def solve():
    gx, gy = (int(n) for n in input().split())

    positions = {(0, 0): ''}
    jump = 1
    while positions:
        #print(jump, positions)
        next_positions = {}
        for (x, y), dirs in positions.items():
            dx = gx - x
            dy = gy - y
            if dx == 0 and dy == 0:
                return dirs
            if (abs(dx) & (jump - 1)) or (abs(dy) & (jump - 1)):
                continue
            if dx != 0:
                next_positions[(x + jump, y)] = dirs + 'E'
                next_positions[(x - jump, y)] = dirs + 'W'
            if dy != 0:
                next_positions[(x, y + jump)] = dirs + 'N'
                next_positions[(x, y - jump)] = dirs + 'S'
        positions = next_positions
        jump *= 2

    return 'IMPOSSIBLE'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
    #for gx in range(-4, 5):
        #for gy in range(-4, 5):
            #solve(gx, gy)
",00000000002faa8b.PYTHON3,1598,58,203,Python,000000000019fef2,00000000002faa8b,00000000002d5b62,mth,2020
213,00000000002f95b0,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    gx, gy = (int(n) for n in input().split())

    positions = {(0, 0): ''}
    jump = 1
    while positions:
        next_positions = {}
        for (x, y), dirs in positions.items():
            dx = gx - x
            dy = gy - y
            if dx == 0 and dy == 0:
                return dirs
            if 0 < abs(dx) < jump or 0 < abs(dy) < jump:
                continue
            if dx != 0:
                next_positions[(x + jump, y)] = dirs + 'E'
                next_positions[(x - jump, y)] = dirs + 'W'
            if dy != 0:
                next_positions[(x, y + jump)] = dirs + 'N'
                next_positions[(x, y - jump)] = dirs + 'S'
        positions = next_positions
        jump *= 2

    return 'IMPOSSIBLE'

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",00000000002f95b0.PYTHON3,1449,53,186,Python,000000000019fef2,00000000002f95b0,00000000002d5b62,mth,2020
214,0000000000329cad,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from fractions import Fraction
import sys

def solve():
    num_slices, num_diners = (int(x) for x in input().split())
    slices = sorted(int(x) for x in input().split())
    assert len(slices) == num_slices

    '''
    Worst case, you can pick any slice and perform (num_diners - 1) cuts.
    But if you have slices that are multiples of the same (possibly
    non-integer) angle, you can save on cuts: 2 and 3 can be cut into
    for example 5 or 10 equal slices with N - 2 cuts.

    T: target size
    A[i] = T * U[i] for some integer U[i]
    produces sum(U[i]) equal slices in sum(U[i] - 1) cuts

    remainder R = D - sum(U[i]) must be cut from other slices
    possible if at least R slices of size T can be cut from non-used slices
    if possible this takes R cuts

    note that T need not be integer
    supporting only rational numbers is sufficient though
    '''

    targets = defaultdict(int)
    for size in slices:
        for pieces in range(1, num_diners):
            targets[Fraction(size, pieces)] += 1
    #print(' '.join(str(target) for target in targets))

    best_cuts = num_diners - 1
    for target, freq in targets.items():
        if freq == 1:
            continue
        todo = num_diners
        imperfect = 0
        cuts = 0

        for size in slices:
            pieces = size / target
            whole = int(pieces)
            if pieces == whole and todo >= whole:
                cuts += whole - 1
                todo -= whole
            else:
                imperfect += whole

        if todo <= imperfect:
            cuts += todo
            best_cuts = min(cuts, best_cuts)

    return best_cuts

def main():
    #sys.setrecursionlimit(RECURSION_LIMIT)

    #import resource
    #soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    #resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000329cad.PYPY2,2305,79,310,Python,000000000019fef4,0000000000329cad,00000000003172d1,mth,2020
215,0000000000329339,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from fractions import Fraction
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_slices, num_diners = (int(x) for x in input().split())
    slices = sorted(int(x) for x in input().split())
    assert len(slices) == num_slices

    '''
    Worst case, you can pick any slice and perform (num_diners - 1) cuts.
    But if you have slices that are multiples of the same (possibly
    non-integer) angle, you can save on cuts: 2 and 3 can be cut into
    for example 5 or 10 equal slices with N - 2 cuts.

    T: target size
    A[i] = T * U[i] for some integer U[i]
    produces sum(U[i]) equal slices in sum(U[i] - 1) cuts

    remainder R = D - sum(U[i]) must be cut from other slices
    possible if at least R slices of size T can be cut from non-used slices
    if possible this takes R cuts

    note that T need not be integer
    supporting only rational numbers is sufficient though
    '''

    targets = defaultdict(int)
    for size in slices:
        for pieces in range(1, num_diners):
            targets[Fraction(size, pieces)] += 1
    #print(' '.join(str(target) for target in targets))

    best_cuts = num_diners - 1
    for target, freq in targets.items():
        if freq == 1:
            continue
        todo = num_diners
        imperfect = 0
        cuts = 0

        for size in slices:
            pieces = size / target
            whole = int(pieces)
            if pieces == whole and todo >= whole:
                cuts += whole - 1
                todo -= whole
            else:
                imperfect += whole

        if todo <= imperfect:
            cuts += todo
            best_cuts = min(cuts, best_cuts)

    return best_cuts

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000329339.PYTHON3,2370,82,317,Python,000000000019fef4,0000000000329339,00000000003172d1,mth,2020
216,0000000000327aeb,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from fractions import Fraction
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_slices, num_diners = (int(x) for x in input().split())
    slices = sorted(int(x) for x in input().split())
    assert len(slices) == num_slices

    '''
    Worst case, you can pick any slice and perform (num_diners - 1) cuts.
    But if you have slices that are multiples of the same (possibly
    non-integer) angle, you can save on cuts: 2 and 3 can be cut into
    for example 5 or 10 equal slices with N - 2 cuts.

    T: target size
    A[i] = T * U[i] for some integer U[i]
    produces sum(U[i]) equal slices in sum(U[i] - 1) cuts

    remainder R = D - sum(U[i]) must be cut from other slices
    possible if at least R slices of size T can be cut from non-used slices
    if possible this takes R cuts

    note that T need not be integer
    supporting only rational numbers is sufficient though
    '''

    targets = set()
    for size in slices:
        for pieces in range(1, num_diners):
            targets.add(Fraction(size, pieces))
    #print(' '.join(str(target) for target in targets))

    best_cuts = num_diners - 1
    for target in targets:
        todo = num_diners
        imperfect = 0
        cuts = 0

        for size in slices:
            pieces = size / target
            whole = int(pieces)
            if pieces == whole and todo >= whole:
                cuts += whole - 1
                todo -= whole
            else:
                imperfect += whole

        if todo <= imperfect:
            cuts += todo
            best_cuts = min(cuts, best_cuts)

    return best_cuts

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000327aeb.PYTHON3,2265,79,305,Python,000000000019fef4,0000000000327aeb,00000000003172d1,mth,2020
217,0000000000323da5,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_slices, num_diners = (int(x) for x in input().split())
    slices = sorted(int(x) for x in input().split())
    assert len(slices) == num_slices

    '''
    Worst case, you can pick any slice and perform (num_diners - 1) cuts.
    But if you have slices that are multiples of the same (possibly
    non-integer) angle, you can save on cuts: 2 and 3 can be cut into
    for example 5 or 10 equal slices with N - 2 cuts.

    T: target size
    A[i] = T * U[i] for some integer U[i]
    produces sum(U[i]) equal slices in sum(U[i] - 1) cuts

    remainder R = D - sum(U[i]) must be cut from other slices
    possible if at least R slices of size T can be cut from non-used slices
    if possible this takes R cuts

    note that T need not be integer
    supporting only rational numbers is sufficient though
    '''

    if num_diners == 2:
        for i in range(num_slices - 1):
            if slices[i] == slices[i + 1]:
                return 0
        return 1
    else:
        for i in range(num_slices - 2):
            if slices[i] == slices[i + 1] and slices[i + 1] == slices[i + 2]:
                return 0
        for i in range(num_slices - 1):
            if slices[i] == slices[i + 1] and i + 2 < num_slices:
                return 1
        for i in range(num_slices):
            for j in range(i + 1, num_slices):
                if slices[j] == 2 * slices[i]:
                    return 1
        return 2

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000323da5.PYTHON3,2141,69,302,Python,000000000019fef4,0000000000323da5,00000000003172d1,mth,2020
218,0000000000322bc4,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_slices, num_diners = (int(x) for x in input().split())
    slices = sorted(int(x) for x in input().split())
    assert len(slices) == num_slices

    '''
    Worst case, you can pick any slice and perform (num_diners - 1) cuts.
    But if you have slices that are multiples of the same (possibly
    non-integer) angle, you can save on cuts: 2 and 3 can be cut into
    for example 5 or 10 equal slices with N - 2 cuts.

    T: target size
    A[i] = T * U[i] for some integer U[i]
    produces sum(U[i]) equal slices in sum(U[i] - 1) cuts

    remainder R = D - sum(U[i]) must be cut from other slices
    possible if there are at least R slices of size >= T
    if possible this takes R cuts

    note that T need not be integer
    supporting only rational numbers is sufficient though
    '''

    if num_diners == 2:
        for i in range(num_slices - 1):
            if slices[i] == slices[i + 1]:
                return 0
        return 1
    else:
        assert num_diners == 3
        for i in range(num_slices - 2):
            if slices[i] == slices[i + 1] and slices[i + 1] == slices[i + 2]:
                return 0
        for i in range(num_slices):
            for j in range(i + 1, num_slices):
                if slices[j] == 2 * slices[i]:
                    return 1
        return 2

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000322bc4.PYTHON3,2022,67,283,Python,000000000019fef4,0000000000322bc4,00000000003172d1,mth,2020
219,000000000032151a,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_slices, num_diners = (int(x) for x in input().split())
    slices = sorted(int(x) for x in input().split())
    assert len(slices) == num_slices

    '''
    Worst case, you can pick any slice and perform (num_diners - 1) cuts.
    But if you have slices that are multiples of the same (possibly
    non-integer) angle, you can save on cuts: 2 and 3 can be cut into
    for example 5 or 10 equal slices with N - 2 cuts.

    T: target size
    A[i] = T * U[i] for some integer U[i]
    produces sum(U[i]) equal slices in sum(U[i] - 1) cuts

    remainder R = D - sum(U[i]) must be cut from other slices
    possible if there are at least R slices of size >= T
    if possible this takes R cuts

    note that T need not be integer
    supporting only rational numbers is sufficient though
    '''

    if num_diners == 2:
        for i in range(num_slices - 1):
            if slices[i] == slices[i + 1]:
                return 0
        return 1
    else:
        for i in range(num_slices - 2):
            if slices[i] == slices[i + 1] and slices[i + 1] == slices[i + 2]:
                return 0
        for i in range(num_slices):
            for j in range(i + 1, num_slices):
                if slices[j] == 2 * slices[i]:
                    return 1
        return 2

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000032151a.PYTHON3,1991,66,279,Python,000000000019fef4,000000000032151a,00000000003172d1,mth,2020
220,000000000031cc10,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    max_len = int(input())
    known_queries = 0
    unknown_queries = 0
    responses = []
    for _ in range(10**4):
        query_str, response = input().split()
        query = int(query_str)
        if query == -1:
            known_queries += 1
        else:
            unknown_queries += 1
        responses.append(response)
    assert known_queries == 0 or unknown_queries == 0

    first = defaultdict(int)
    middle = defaultdict(int)
    last = defaultdict(int)
    for response in responses:
        first[response[0]] += 1
        if len(response) > 1:
            last[response[-1]] += 1
            if len(response) > 2:
                for char in response[1:-1]:
                    middle[char] += 1

    first_sorted = sorted((d, n) for n, d in first.items())
    #print('first: ', first_sorted)
    #print('middle:', sorted((d, n) for n, d in middle.items()))
    #print('last:  ', sorted((d, n) for n, d in last.items()))

    # TPFOXLUSHB
    # first: 301 B, 404 H, 569 S, 721 U, 911 L, 1156 X, 1526 O, 1872 F, 2540 P
    # last:  612 H, 624 B, 636 L, 648 S, 652 U,  736 O,  737 F,  746 X,  802 P, 817 T

    # No leading zeroes are printed, so first char never encodes zero.
    zero_chars = (set(middle) | set(last)) - set(first)
    assert len(zero_chars) == 1
    zero_char = next(iter(zero_chars))

    if known_queries:
        pass
    else:
        pass

    return zero_char + ''.join(char for count, char in reversed(first_sorted))

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000031cc10.PYTHON3,2209,76,272,Python,000000000019fef4,000000000031cc10,00000000003179a1,mth,2020
221,0000000000318c4c,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    sx_str, sy_str, cat_route_str = input().split()
    sx = int(sx_str)
    sy = int(sy_str)

    dirs = {'N': (0, 1), 'E': (1, 0), 'S': (0, -1), 'W': (-1, 0)}
    x, y = sx, sy
    for steps, cat_move in enumerate(cat_route_str + '.'):
        if abs(x) + abs(y) <= steps:
            return steps
        try:
            dx, dy = dirs[cat_move]
        except KeyError:
            assert cat_move == '.'
            return 'IMPOSSIBLE'
        x += dx
        y += dy

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000318c4c.PYTHON3,1180,46,142,Python,000000000019fef4,0000000000318c4c,0000000000317409,mth,2020
222,000000000033ee1d,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from fractions import Fraction
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_holes = int(input())
    holes = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_holes)
        )

    angles = defaultdict(set)
    for i in range(num_holes):
        for j in range(i + 1, num_holes):
            h1 = holes[i]
            h2 = holes[j]
            if h1 < h2:
                h1, h2 = h2, h1
            dx = h1[0] - h2[0]
            dy = h1[1] - h2[1]
            angle = None if dx == 0 else Fraction(dy, dx)
            ah = angles[angle]
            ah.add(i)
            ah.add(j)

    best = 1
    for angle, hole_indexes in sorted(angles.items(),
                                      key=lambda p: len(p[1]), reverse=True):
        lines = defaultdict(int)
        for hi in hole_indexes:
            x, y = holes[hi]
            b = x if angle is None else y - angle * x
            lines[b] += 1

        others = num_holes - len(hole_indexes)
        pairs = 0
        triples = 0
        for length in lines.values():
            if length % 2 == 1:
                triples += 1
                length -= 3
            pairs += length // 2

        if triples == 1:
            triples = 0
            pairs += 1
            others += 1

        score = pairs * 2 + triples * 3 + min(others, 2)
        if score > best:
            best = score

    return best

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000033ee1d.PYTHON3,2108,80,261,Python,000000000019ffb9,000000000033ee1d,00000000003386d0,mth,2020
223,000000000033deae,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
from fractions import Fraction
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_holes = int(input())
    holes = tuple(
        tuple(int(x) for x in input().split())
        for _ in range(num_holes)
        )

    angles = defaultdict(set)
    for i in range(num_holes):
        for j in range(i + 1, num_holes):
            h1 = holes[i]
            h2 = holes[j]
            if h1 < h2:
                h1, h2 = h2, h1
            dx = h1[0] - h2[0]
            dy = h1[1] - h2[1]
            angle = None if dx == 0 else Fraction(dy, dx)
            ah = angles[angle]
            ah.add(i)
            ah.add(j)

    best = 1
    for angle, hole_indexes in sorted(angles.items(),
                                      key=lambda p: len(p[1]), reverse=True):
        best = min(len(hole_indexes) + 2, num_holes)
        break

    return best

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000033deae.PYTHON3,1550,59,177,Python,000000000019ffb9,000000000033deae,00000000003386d0,mth,2020
224,000000000033bb62,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_computers, num_connections = (int(x) for x in input().split())
    received = (0, ) + tuple(int(x) for x in input().split())
    assert len(received) == num_computers
    connections = tuple(
        tuple(int(x) - 1 for x in input().split())
        for _ in range(num_connections)
        )

    spread = defaultdict(list)
    abstimes = []
    for i, r in enumerate(received):
        if r < 0:
            spread[-r].append(i)
        else:
            abstimes.append((r, i))
    abstimes.sort()

    time = 0
    arrived = [None] * num_computers
    arrived[0] = time
    num_arrived = 1
    abs_idx = 0
    for pred in sorted(spread):
        assert pred >= num_arrived
        while pred < num_arrived:
            time, node = abstimes[abs_idx]
            abs_idx += 1
            arrived[node] = time
        time += 1
        nodes = spread[pred]
        for node in nodes:
            arrived[node] = time
    for time, node in abstimes[abs_idx:]:
        arrived[node] = time

    graph = [{} for _ in range(num_computers)]
    for i, (node1, node2) in enumerate(connections):
        graph[node1][node2] = i
        graph[node2][node1] = i

    latency = [None] * num_connections
    for node1 in range(1, num_computers):
        time = arrived[node1]
        for node2, conn in graph[node1].items():
            delta = time - arrived[node2]
            if delta > 0:
                latency[conn] = delta

    # These connections were not used.
    MAX_LATENCY = 1000000
    for i in range(num_connections):
        if latency[i] is None:
            latency[i] = MAX_LATENCY

    return ' '.join(str(l) for l in latency)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000033bb62.PYTHON3,2390,86,275,Python,000000000019ffb9,000000000033bb62,000000000033871f,mth,2020
225,000000000033ba2c,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

from collections import defaultdict
import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    num_computers, num_connections = (int(x) for x in input().split())
    received = (0, ) + tuple(int(x) for x in input().split())
    assert len(received) == num_computers
    connections = tuple(
        tuple(int(x) - 1 for x in input().split())
        for _ in range(num_connections)
        )

    spread = defaultdict(list)
    for i, r in enumerate(received):
        if r < 0:
            spread[-r].append(i)

    time = 0
    arrived = [None] * num_computers
    arrived[0] = time
    for pred in sorted(spread):
        time += 1
        nodes = spread[pred]
        for node in nodes:
            arrived[node] = time

    graph = [{} for _ in range(num_computers)]
    for i, (node1, node2) in enumerate(connections):
        graph[node1][node2] = i
        graph[node2][node1] = i

    latency = [None] * num_connections
    for node1 in range(1, num_computers):
        time = arrived[node1]
        for node2, conn in graph[node1].items():
            delta = time - arrived[node2]
            if delta > 0:
                latency[conn] = delta

    # These connections were not used.
    MAX_LATENCY = 1000000
    for i in range(num_connections):
        if latency[i] is None:
            latency[i] = MAX_LATENCY

    return ' '.join(str(l) for l in latency)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",000000000033ba2c.PYTHON3,2025,73,236,Python,000000000019ffb9,000000000033ba2c,000000000033871f,mth,2020
226,0000000000339f40,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    l, r = (int(x) for x in input().split())

    i = 1
    while True:
        if l >= r:
            if l < i:
                break
            l -= i
        else:
            if r < i:
                break
            r -= i
        i += 1

    return '%d %d %d' % (i - 1, l, r)

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000339f40.PYTHON3,992,45,125,Python,000000000019ffb9,0000000000339f40,00000000003384ea,mth,2020
227,0000000000339fd9,"#!/usr/bin/env python3

MEM_LIMIT_GB = 1
RECURSION_LIMIT = 1000

import sys

def log(message, *args):
    print(message % args, file=sys.stderr)

def solve():
    l, r = (int(x) for x in input().split())

    i = 1
    while True:
        if l < r:
            if l < i:
                break
            l -= i
        else:
            if r < i:
                break
            r -= i
        i += 1

    return i

def main():
    sys.setrecursionlimit(RECURSION_LIMIT)

    import resource
    soft, hard = resource.getrlimit(resource.RLIMIT_AS)
    resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))

    numCases = int(input())
    caseFmt = '%' + str(len(str(numCases))) + 'd'
    progressFmt = '[%s/%s] %%s\n' % (caseFmt, caseFmt)
    for case in range(1, numCases + 1):
        result = solve()
        print('Case #%d: %s' % (case, result))
        #log(progressFmt % (case, numCases, result))

if __name__ == '__main__':
    main()
",0000000000339fd9.PYTHON3,966,45,117,Python,000000000019ffb9,0000000000339fd9,00000000003384ea,mth,2020
228,go.py,"#!/usr/bin/env python
 
 import sys
 
 CACHE={}
 def do_count(x, y, rooks, h, w):
     k = (x, y, rooks, h, w)
     p = (x,y)
     if CACHE.has_key(k): return CACHE[k]
     if p in rooks: return 0
     if x>h or y>w: return 0
     if x==h and y==w: return 1
     count = 0
     count = count + do_count(x+2, y+1,rooks, h,w)
     count = count + do_count(x+1, y+2,rooks, h,w)
     count %= 10007
     CACHE[k]=count
     #print k, count
     return count
 
 def do_trial(f):
     H,W,R = [int(x) for x in f.readline().split()]
     rooks = set()
     for i in range(R):
         rooks.add(tuple([int(x) for x in f.readline().split()]))
     rooks = frozenset(rooks)
 
     global CACHE
     CACHE={}
 
     return do_count(1,1,rooks,H,W)
 
 f = sys.stdin
 #f = file(""tiny.in"")
 count = int(f.readline())
 for i in range(count):
     r = do_trial(f)
     print ""Case #%d: %s"" % (i+1, r)
",gcj/2008/32002/gizzywump/24445/0/extracted/go.py,885,39,121,Python,32002,0,24445,gizzywump,2008
229,go.py,"#!/usr/bin/env python
 
 import sys
 
 DIR_TO_V={
     ""N"":0,
     ""E"":1,
     ""S"":2,
     ""W"":3
 }
 
 V_TO_DIR=""NESW""
 
 def turn(which, dir):
     v = DIR_TO_V[dir]
     v += which
     v %=4
     return V_TO_DIR[v]
 
 def delta_for_dir(dir):
     return { ""N"" : (0,1), ""S"" : (0,-1), ""E"" : (1,0), ""W"" : (-1,0)}[dir]
 
 def do_trial(f):
     L = int(f.readline())
     st_pairs = []
     while len(st_pairs) < L*2:
         st_pairs = st_pairs + [x for x in f.readline().split()]
 
     ud_segs = dict()
     lr_segs = dict()
     dir = 'N'
     x,y=0,0
     min_x,min_y,max_x,max_y=0,0,0,0
 
     #print st_pairs
 
     while len(st_pairs)>0:
         s,t = st_pairs[0:2]
         st_pairs = st_pairs[2:]
         t = int(t)
         while t>0:
             t = t-1
             for d in s:
                 if d == 'L':
                     dir = turn(-1, dir)
                 if d == 'R':
                     dir = turn(1,dir)
                 if d == 'F':
                     delta = delta_for_dir(dir)
                     if delta[1] == 0:
                         st = ud_segs.setdefault(x+delta[0]/2.0,set())
                         #print st
                         st.add(y)
                     else:
                         st = lr_segs.setdefault(y+delta[1]/2.0,set())
                         #print st
                         st.add(x)
                     x,y = x+delta[0],y+delta[1]
                     #print x,y
                     min_x = min(x,min_x)
                     max_x = max(x,max_x)
                     min_y = min(y,min_y)
                     max_y = max(y,max_y)
 
     if (x,y) != (0,0):
         print x,y
         assert (x,y) == (0,0)
 
     #print ud_segs
     #print lr_segs
 
     #print min_x, max_x, min_y, max_y
     area = 0
 
     stdout = file(""/dev/null"", ""w"")
 
     outside=[]
 
     for y in range(min_y-1, max_y+2):
         stdout.write("" "")
         for x in range(min_x-1, max_x+2):
             if y in ud_segs.get(x+0.5, []):
                 stdout.write("" _"")
             else:
                 stdout.write(""  "")
         #print
         for x in range(min_x-1, max_x+2):
             if x in lr_segs.get(y+0.5,[]):
                 n = ""|""
             else:
                 n = "" ""
             is_pocket = False
             # count above, below
             l_count = 0
             s_count = 0
             for y0 in ud_segs.get(x-0.5,[]):
                 if y0<=y: l_count = l_count+1
                 else: s_count = s_count+1
             #print ""count"", x,y,l_count,s_count
             if l_count%2 == 0 and s_count%2 == 0 and s_count>0 and l_count>0:
                 outside.append((x,y))
                 #print ""***"", x, y
                 area = area + 1
                 stdout.write(""*"" + n)
                 continue
             # count left, right
             l_count = 0
             s_count = 0
             for x0 in lr_segs.get(y+0.5, []):
                 if x0<x: l_count = l_count+1
                 else: s_count = s_count+1
             #print ""count"", x,y,l_count,s_count
             if l_count%2 == 0 and s_count%2 == 0 and s_count>0 and l_count>0:
                 #print ""***"", x, y
                 outside.append((x,y))
                 area = area + 1
                 stdout.write(""*"" + n)
                 continue
             stdout.write("" "" + n)
         #print
 
     #print ud_segs, lr_segs
     #print ""OUTSIDE"", outside
     return area
 
 f = sys.stdin
 #f = file(""tiny.in"")
 count = int(f.readline())
 for i in range(count):
     r = do_trial(f)
     print ""Case #%d: %s"" % (i+1, r)
",gcj/2008/32002/gizzywump/24444/0/extracted/go.py,3607,132,361,Python,32002,0,24444,gizzywump,2008
230,go.py,"#!/usr/bin/env python
 
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def find_shortest(list_of_lists):
     best_size = len(min(list_of_lists, key=len))
     return [l for l in list_of_lists if len(l) == best_size]
 
 #@Memoize
 CACHE={}
 def all_paths(se, qs):
     t = (se,qs)
     if CACHE.has_key(t): return CACHE[t]
     if len(qs) == 0:
         v = [[c] for c in se]
         CACHE[t] = v
         return v
     q0 = qs[0]
     l = []
     for c in se:
         if c == q0: continue
         paths = all_paths(se, qs[1:])
         for p in paths:
             if len(p) > 0 and c == p[0]:
                 l.append(p)
             else:
                 l.append([c] + p)
     l = find_shortest(l)
     CACHE[t] = l
     return l
 
 def choose(n, m):
     pass
 
 def do_trial(f):
     search_engine_count = int(f.readline())
     search_engines = tuple([f.readline()[:-1] for i in xrange(search_engine_count)])
     #print search_engines
     query_count = int(f.readline())
     queries = tuple([f.readline()[:-1] for i in xrange(query_count)])
     #print queries
     v = find_shortest(all_paths(search_engines, queries))[0]
     return len(v)-1
 
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     v = do_trial(f)
     print ""Case #%d: %d"" % (i+1, v)
",gcj/2008/32016/gizzywump/24483/0/extracted/go.py,1759,66,189,Python,32016,0,24483,gizzywump,2008
231,go.py,"#!/usr/bin/env python
 
 import sys
 
 def do_trial(f):
     N = int(f.readline())
     M = int(f.readline())
     faves = []
     for i in range(M):
         v = [int(x) for x in f.readline().split()][1:]
         malted = None
         unmalted_set = set()
         for j in range(0,len(v),2):
             if v[j+1]:
                 malted = v[j]
             else:
                 unmalted_set.add(v[j])
         faves.append((malted, unmalted_set))
     must_be_malted = set()
     while 1:
         all_fine = True
         no_updates = True
         #print ""MBM->"", must_be_malted
 
         for m, u in faves:
             u = u.difference(must_be_malted)
             #print ""mu->"", m,u
             if m is not None:
                 if m in must_be_malted:
                     continue
 
             if len(u) == 0:
                 all_fine = False
                 if m is None: break
                 must_be_malted.add(m)
                 no_updates = False
                 continue
         if all_fine or no_updates: break
     if not all_fine: return ""IMPOSSIBLE""
     return "" "".join(['1' if ((x+1) in must_be_malted) else '0' for x in range(N)])
 
 f = sys.stdin
 #f = file(""mine"")
 #f = file(""B-small-attempt0.in.txt"")
 #f = file(""z"")
 count = int(f.readline())
 for i in xrange(count):
     v = do_trial(f)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2008/32016/gizzywump/24482/1/extracted/go.py,1371,50,149,Python,32016,1,24482,gizzywump,2008
232,go.py,"#!/usr/bin/env python
 
 import sys
 
 def do_trial(f):
     N = int(f.readline())
     xN = [int(x) for x in f.readline().split()]
     yN = [int(x) for x in f.readline().split()]
     xN.sort()
     yN.sort()
     yN.reverse()
     t = sum(xN[n] * yN[n] for n in range(N))
     return t
 
 f = sys.stdin
 T = int(f.readline())
 for i in xrange(T):
     v = do_trial(f)
     print ""Case #%d: %d"" % (i+1, v)
",gcj/2008/32016/gizzywump/24484/1/extracted/go.py,408,20,57,Python,32016,1,24484,gizzywump,2008
233,go.py,"#!/usr/bin/env python
 
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def find_shortest(list_of_lists):
     best_size = len(min(list_of_lists, key=len))
     return [l for l in list_of_lists if len(l) == best_size]
 
 @Memoize
 def all_paths(se, qs):
     if len(qs) == 0:
         return [[c] for c in se]
     q0 = qs[0]
     l = []
     for c in se:
         if c == q0: continue
         paths = all_paths(se, qs[1:])
         for p in paths:
             if len(p) > 0 and c == p[0]:
                 l.append(p)
             else:
                 l.append([c] + p)
     l = find_shortest(l)
     return l
 
 def do_trial(f):
     search_engine_count = int(f.readline())
     search_engines = tuple([f.readline()[:-1] for i in xrange(search_engine_count)])
     #print search_engines
     query_count = int(f.readline())
     queries = tuple([f.readline()[:-1] for i in xrange(query_count)])
     #print queries
     v = find_shortest(all_paths(search_engines, queries))[0]
     return len(v)-1
 
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     v = do_trial(f)
     print ""Case #%d: %d"" % (i+1, v)
",gcj/2008/32013/gizzywump/24480/0/extracted/go.py,1603,57,168,Python,32013,0,24480,gizzywump,2008
234,go.py,"#!/usr/bin/env python
 
 import math
 import sys
 
 def indef_integral(x1, x0, r0):
     def f(x):
         return (x/2.0) * math.sqrt(r0*r0-x*x) + r0*r0*math.asin(x/r0)/2.0
     return f(x1) - f(x0)
 
 def square_arc_intersect_area(c_x, c_y, d, r):
 
     # does the bottom-left of the square lie outside the arc?
     if c_x * c_x + c_y * c_y >= r*r:
         return 0
 
     # (c_x, c_y) is the bottom-left corner of the square of size d
     # r is the radius of the circle centered at the origin
     if (c_x+d) * (c_x+d) + (c_y+d) * (c_y+d) <= r*r:
         return d*d
 
     # where does the arc cross the right edge?
 
     left_rectangle_end = c_x
 
     left_edge_y_squared = r*r-c_x*c_x
     # case: arc intersects left edge of square
     if left_edge_y_squared > (c_y+d) * (c_y+d):
         # nope
         # where does the arc cross the top edge?
         left_rectangle_end = math.sqrt(r*r-(c_y+d)*(c_y+d))
 
     integral_x1 = c_x+d
     # case: arc intersects bottom
     # where does the arc cross the bottom edge?
     bottom_edge_x_squared = r*r-c_y*c_y
     if bottom_edge_x_squared < (c_x+d) * (c_x+d):
         integral_x1 = math.sqrt(bottom_edge_x_squared)
 
     return d * (left_rectangle_end-c_x) + indef_integral(integral_x1, left_rectangle_end, r) + c_y * (left_rectangle_end - integral_x1)
 
 def do_trial(f, R, t, r, g):
 
     inner_radius = R-t
 
     total_fly_area = math.pi * R * R / 4.0
 
     fly_safe_area = 0.0
 
     s_x = r
     while s_x<inner_radius:
         s_y = r
         while s_y < inner_radius:
             fly_safe_area += square_arc_intersect_area(s_x+f, s_y+f, g-f-f, R-t-f)
             s_y += g+2*r
         s_x += g+2*r
     return 1.0-fly_safe_area/total_fly_area
 
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     args = [float(x) for x in f.readline().split()]
     #print args
     p = do_trial(*args)
     print ""Case #%d: %1.6f"" % (i+1, p)
",gcj/2008/32013/gizzywump/24479/0/extracted/go.py,1928,66,249,Python,32013,0,24479,gizzywump,2008
235,go.py,"#!/usr/bin/env python
 
 import sys
 
 def parse_time(t):
     hour, minute = [int(x) for x in t.split("":"")]
     return hour * 60 + minute
 
 def do_trial(f):
     turnaround_time = int(f.readline())
     a2b_count, b2a_count = [int(x) for x in f.readline().split()]
     #print turnaround_time, a2b_count, b2a_count
 
     events = []
 
     for i in xrange(a2b_count):
         leave_time, arrive_time = f.readline().split()
         leave_event = (parse_time(leave_time), 1, 0)
         events.append(leave_event)
         arrive_event = (parse_time(arrive_time)+turnaround_time, 0, 1)
         events.append(arrive_event)
 
     for i in xrange(b2a_count):
         leave_time, arrive_time = f.readline().split()
         leave_event = (parse_time(leave_time), 1, 1)
         events.append(leave_event)
         arrive_event = (parse_time(arrive_time)+turnaround_time, 0, 0)
         events.append(arrive_event)
 
     events.sort()
 
     max_a, max_b = 0, 0
 
     count_tuple = [0,0]
 
     for e in events:
         when, is_leaving, is_B = e
         if is_leaving:
             count_tuple[is_B] = count_tuple[is_B] + 1
         else:            
             count_tuple[is_B] = count_tuple[is_B] - 1
         #print ""%02d:%02d : %s station %s (%d %d)"" % (when/60, when%60, ""leaving"" if is_leaving else ""arriving"", ""B"" if is_B else ""A"", count_tuple[0], count_tuple[1])
         max_a = max(count_tuple[0], max_a)
         max_b = max(count_tuple[1], max_b)
 
     return max_a, max_b
 
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     a, b = do_trial(f)
     print ""Case #%d: %d %d"" % (i+1, a, b)
",gcj/2008/32013/gizzywump/24481/1/extracted/go.py,1632,53,168,Python,32013,1,24481,gizzywump,2008
236,go.py,"#!/usr/bin/env python
 
 import sys
 
 class Nope(Exception):
     pass
 
 # node: 
 # (gate_type, can_change)
 # bool_val
 
 AND=1
 OR=0
 
 INFINITE=1e12
 
 def eval(T, i):
     if is_val(T,i):
         #print ""i="", i, ""T[i]="", T[i]
         return T[i]
     c1, c2 = children(T, i)
     if gate_type(T,i) == AND:
         c = (eval(T, c1) and eval(T, c2))
     else:
         c = (eval(T, c1) or eval(T, c2))
     #print ""i="", i, ""T[i]="", c
     return 1 if c else 0
 
 def is_val(T, i):
     return type(T[i]) is not tuple
 
 def gate_type(T, i):
     return T[i][0]
 
 def children(T, i):
     return i*2+1, i*2+2
 
 def can_change(T, i):
     if T[i][1]:
         pass
         #print ""can change"", i
     return T[i][1]
 
 def count_changes_needed(T, index, V):
     if is_val(T, index):
         V1 = eval(T, index)
         if V==V1: return 0
         return INFINITE
 
     c1, c2 = children(T, index)
 
     cc1 = count_changes_needed(T, c1, V)
     #print c1, cc1
     cc2 = count_changes_needed(T, c2, V)
     #print c2, cc2
 
     if gate_type(T, index) == V:
         #print ""MATCH""
         # both of them need to match
         r = cc1+cc2
         if can_change(T,index):
             #print ""maybe changing index"", index
             r = min(1+cc1, 1+cc2, r)
     else:
         r = min(cc1, cc2)
 
     return r
 
 def do_trial(f):
     M, V = [int(x) for x in f.readline().split()]
 
     nodes = []
     for i in range((M-1)/2):
         x,y = [int(x) for x in f.readline().split()]
         nodes.append((x,y))
 
     for i in range((M+1)/2):
         nodes.append(int(f.readline()))
 
     n = count_changes_needed(nodes, 0, V)
     if n>=INFINITE: return ""IMPOSSIBLE""
     return n
 
 f = sys.stdin
 #f = file(""tiny.in"")
 count = int(f.readline())
 for i in range(count):
     r = do_trial(f)
     print ""Case #%d: %s"" % (i+1, r)
",gcj/2008/32001/gizzywump/24439/1/extracted/go.py,1854,90,233,Python,32001,1,24439,gizzywump,2008
237,go.py,"#!/usr/bin/env python
 
 import sys
 
 def all_perms(str):
     if len(str) <=1:
         yield str
     else:
         for perm in all_perms(str[1:]):
             for i in range(len(perm)+1):
                 yield perm[:i] + str[0:1] + perm[i:]
 
 def compress_size(s):
     changes = 0
     last = None
     for i in s:
         if i!=last:
             changes = changes+1
             last = i
     return changes
 
 #print compress_size(""aabcaaaa"")
 
 def permute_block(b, p):
     s = list(b)
     for i,v in enumerate(p):
         s[v] = b[i]
     return ''.join(s)
 
 def permute_repeated(b, p):
     s = []
     for i in range(0,len(b),len(p)):
         s.append(permute_block(b[i:i+len(p)], p))
     return ''.join(s)
 
 def do_trial(f):
     k = int(f.readline())
     s = f.readline()[:-1]
     m = compress_size(s)
     for p in all_perms(range(k)):
         m = min(m, compress_size(permute_repeated(s, p)))
     return m
 
 f = sys.stdin
 #f = file(""tiny.in"")
 count = int(f.readline())
 for i in range(count):
     r = do_trial(f)
     print ""Case #%d: %s"" % (i+1, r)
",gcj/2008/32001/gizzywump/24442/0/extracted/go.py,1086,50,124,Python,32001,0,24442,gizzywump,2008
238,go.py,"#!/usr/bin/env python
 
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 @Memoize
 def is_happy(n, base, possibly_unhappy=frozenset()):
     if n in possibly_unhappy: return False
     if n == 1: return True
     nv = next_val(n, base)
     possibly_unhappy = possibly_unhappy.union([n])
     return is_happy(nv, base, possibly_unhappy)
 
 @Memoize
 def next_val(v, base):
     if v == 0: return 0
     t = v%base
     return t*t + next_val(v/base, base)
 
 def test():
     assert next_val(10, 10) == 1
     assert next_val(9, 10) == 81
     assert next_val(19, 10) == 82
     assert next_val(4, 2) == 1
     assert is_happy(3, 2)
     assert is_happy(3, 3)
     assert is_happy(143, 2)
     assert is_happy(143, 3)
     assert is_happy(143, 7)
     assert not is_happy(142, 7)
 
 test()
 #sys.exit(1)
 
 
 def do_trial(f):
     bases = [int(x) for x in f.readline().split()]
     N = 2
     while 1:
         ok = True
         for b in bases:
             if not is_happy(N, b):
                 N = N + 1
                 ok = False
                 break
         if ok: break
     return N
 
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     v = do_trial(f)
     print ""Case #%d: %d"" % (i+1, v)
",gcj/2009/188266/gizzywump/168107/0/extracted/go.py,1694,69,193,Python,188266,0,168107,gizzywump,2009
239,go.py,"#!/usr/bin/env python
 
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 @Memoize
 def fact(N):
     if N<2: return 1
     return N * fact(N-1)
 
 def inv_fact(N):
     if N < 0: return 0
     return 1.0/fact(N)
 
 def expected_probs(C, N, probs):
     new_probs = [0.0] * len(probs)
     #print probs
     for i, old_prob in enumerate(probs):
         #print ""**********"", i
         for c in xrange(0, C-i+1):
             #print ""***"", i, n, old_prob, C, N, new_probs
             p = prob(C-i, i, c, N-c)
             #print ""%d card types; %d cards per pack; %d cards collected; %d new found with prob %f"" % (C, N, i, c, p)
             new_probs[i+c] += old_prob * prob(C-i, i, c, N-c)
             #print ""new_probs"", new_probs
     return new_probs
 
 @Memoize
 def choose(a, b):
     return fact(a)/fact(b)/fact(a-b)
 
 @Memoize
 def prob(K0, K1, P0, P1):
     import pdb
     #pdb.set_trace()
     # K0+K1 = C
     # P0+P1 = N
     P = 1.0 * fact(K0+K1-P0-P1) * inv_fact(K0+K1) * fact(K0) * inv_fact(K0-P0) * fact(K1) * inv_fact(K1-P1) * choose(P0+P1, P0)
     return P
 
 #print prob(1, 1, 1, 0)
 #print prob(1, 1, 0, 1)
 
 def test():
     #assert choose(5, 3) == 10
     #assert prob_we_get(2, 1, 0, 0) == 0.0
     total = 0.0
     for i in range(3):
         p1 = prob(3, 4, i, 2-i)
         print ""p1="", p1
         total += p1
     #print ""*******"", total
     assert total == 1.0
 
 #test()
 #sys.exit(1)
 
 
 
 
 def do_trial(f):
     C, N = [int(x) for x in f.readline().split()]
     #print C, N
     probs = [1.0]
     for i in range(C):
         probs.append(0.0)
     COUNT = 0
     EXPECTED = 0.0
     while 1:
         #print ""-""*50, COUNT, probs
         new_probs = expected_probs(C, N, probs)
         COUNT = COUNT + 1
         EXPECTED += COUNT * (new_probs[-1] - probs[-1])
         probs = new_probs
         if probs[-1] > 1.0-1e-10:
             break
     return EXPECTED
 
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     v = do_trial(f)
     print ""Case #%d: %f"" % (i+1, v)
",gcj/2009/188266/gizzywump/190103/1/extracted/go.py,2505,99,315,Python,188266,1,190103,gizzywump,2009
240,go.py,"#!/usr/bin/env python
 
 import pdb
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 #sys.exit(1)
 
 def score(rows):
     s = 0
     for i, r in enumerate(rows):
         #print r[i+1:]
         s += sum(r[i+1:])
     return s
 
 def swap_with_next(rows, i):
     r1, r2 = rows[i], rows[i+1]
     for j in xrange(len(r1)-1, -1, -1):
         if r1[j] != r2[j]:
             if r1[j]:
                 r = list(rows[:i]) + [r2, r1] + list(rows[i+2:])
                 r = tuple(r)
                 return r
             return None
 
 def test():
     assert score([[1, 0], [1, 1]]) == 0
     assert score([(0, 0, 1), (1, 0, 0), (0, 1, 0)]) == 1
     assert score([(1, 1, 1, 0), (1, 1, 0, 0), (1, 1, 0, 0), (1, 0, 0, 0)]) == 2
     #print swap_with_next([(1, 0), (1, 1)], 0)
     assert swap_with_next([(1, 0), (1, 1)], 0) == None #((1,1), (1,0))
     assert swap_with_next([(0, 0, 1), (1, 0, 0), (0, 1, 0)], 0) == ((1, 0, 0), (0, 0, 1), (0, 1, 0))
     #pdb.set_trace()
     assert swap_with_next([(0, 0, 1), (1, 0, 0), (0, 1, 0)], 1) == None #((0, 0, 1), (0, 1, 0), (1, 0, 0))
     assert swap_with_next([(0,0,1), (1,0,0), (0,1,0)], 1) == None
 
 test()
 
 def dump(rows):
     return
     for r in rows:
         print r
 
 @Memoize
 def best(rows, best_score=1e6):
     if score(rows) == 0:
         #print ""***** SCORE 0"", rows
         return 0
     scores = []
     for i in xrange(len(rows)-1):
         new_rows = swap_with_next(rows, i)
         if new_rows:
             dump(rows)
             dump(new_rows)
             scores.append(1+best(new_rows))
     return min(scores)
 
 def do_trial(f):
     row_count = int(f.readline())
     rows = []
     for i in xrange(row_count):
         rows.append(tuple([int(x) for x in list(f.readline()[:-1])]))
     rows = tuple(rows)
     #print rows
     count = best(rows)
     return count
 
 f = file(""small"") #sys.stdin
 f = sys.stdin
 count = int(f.readline())
 for i in xrange(count):
     v = do_trial(f)
     print ""Case #%d: %d"" % (i+1, v)
",gcj/2009/204113/gizzywump/241102/0/extracted/go.py,2477,90,301,Python,204113,0,241102,gizzywump,2009
241,go.py,"#!/usr/bin/env python
 
 import math
 import pdb
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def size(p1, p2):
     x1, y1, r1 = p1
     x2, y2, r2 = p2
     xd = abs(x2-x1)
     yd = abs(y2-y1)
     return math.sqrt(xd*xd+yd*yd)/2.0 + (r1 + r2)/2.0
 
 def best_size(plants):
     bs = 0
     for i in xrange(len(plants)):
         for j in xrange(i, len(plants)):
             bs = max(size(plants[i], plants[j]), bs)
     return bs
 
 def test():
     assert 0 == 0
     import pdb
     #pdb.set_trace()
     assert size((20, 10, 2), (20, 20, 2)) == 7.0
     assert(best_size([(20, 20, 2), (20, 10, 2)]) == 7.0)
     
 #    assert(best_size([(40, 10, 3), (20, 10, 2)]) == 7.0)
 
 test()
 
 
 
 def do_trial(f):
     plant_count = int(f.readline())
     plants = []
     for i in xrange(plant_count):
         plants.append(list(int(x) for x in f.readline().split()))
     best = 1e20
     for i in xrange(2**plant_count):
         ps1, ps2 = [], []
         #print ""---""
         for j, p in enumerate(plants):
             #print i, j, not not(i& (1<<j))
             if i & (1<<j):
                 ps1.append(p)
             else:
                 ps2.append(p)
         #if len(ps1) < 1 or len(ps2) < 1: continue
         #print ps1, best_size(ps1)
         #print ps2, best_size(ps2)
         best = min(best, max(best_size(ps1), best_size(ps2)))
     return best
 
 f = sys.stdin
 #f = file(""D-small-attempt0.in.txt"")
 count = int(f.readline())
 for i in xrange(count):
     #pdb.set_trace()
     v = do_trial(f)
     print ""Case #%d: %f"" % (i+1, v)
",gcj/2009/204113/gizzywump/250101/0/extracted/go.py,2036,79,226,Python,204113,0,250101,gizzywump,2009
242,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def find_directions(the_map):
     H, W = len(the_map), len(the_map[0])
     dirs = [(0,-1), (-1,0), (1,0), (0,1)]
     dir_map = []
     for y in range(H):
         row = []
         for x in range(W):
             #print ""ON SQUARE"", x, y
             best_val, best_dir = the_map[y][x], None
             for d in dirs:
                 x1 = x + d[0]
                 y1 = y + d[1]
                 if 0<=x1<W and 0<=y1<H:
                     #print ""checking"", x1, y1
                     v = the_map[y1][x1]
                     if v < best_val:
                         best_val, best_dir = v, (x1,y1)
             #print ""best is"", best_dir
             row.append(best_dir)
         dir_map.append(row)
     return dir_map
 
 def do_trial(the_map):
     directions = find_directions(the_map)
     basin = [[None for v in t] for t in directions]
     for y in range(H):
         for x in range(W):
             if directions[y][x] is None:
                 basin[y][x] = frozenset([(x,y)])
     #for r in basin: print r
     for y in range(H):
         for x in range(W):
             if basin[y][x] is None:
                 path = set([(x,y)])
                 x1,y1=x,y
                 while 1:
                     p = directions[y1][x1]
                     if p is None:
                         break
                     path.add(p)
                     x1,y1 = p
                 # unwind path into the basin set
                 #print ""path="", path
                 #print x1, y1
                 new_set = frozenset(basin[y1][x1].union(path))
                 for p in new_set:
                     basin[p[1]][p[0]] = new_set
     #for r in basin: print r
     basin_list = [[None for i in range(W)] for j in range(H)]
     lookup = {}
     next = 'a'
     for y in range(H):
         for x in range(W):
             fs = basin[y][x]
             if not lookup.has_key(fs):
                 lookup[fs] = next
                 next = chr(ord(next)+1)
                 #print ""NEXT=>"", next
                 #print ""x,y=>"", x,y
                 #print ""lookup=>"", lookup
             basin_list[y][x] = lookup[fs]
     return basin_list
 
 f = sys.stdin
 T = int(f.readline())
 for i in range(T):
     the_map = []
     H, W = [int(x) for x in f.readline().split()]
     for j in range(H):
         the_map.append([int(x) for x in f.readline().split()])
     basin = do_trial(the_map)
     print ""Case #%d:"" % (i+1)
     for row in basin:
         print "" "".join(row)
",gcj/2009/90101/gizzywump/111101/1/extracted/go.py,3043,96,318,Python,90101,1,111101,gizzywump,2009
243,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 sys.setrecursionlimit(10000)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 @Memoize
 def find_subset(text_to_find, text_to_search):
     if len(text_to_find) == 0: return 1
     if len(text_to_search) == 0: return 0
     if text_to_find[0] == text_to_search[0]:
         return (find_subset(text_to_find[1:], text_to_search[1:]) + find_subset(text_to_find, text_to_search[1:])) % 10000
     return find_subset(text_to_find, text_to_search[1:])
 
 f = sys.stdin
 N = int(f.readline())
 for i in range(N):
     text_to_find = ""welcome to code jam""
     T = f.readline()[:-1]
     r = find_subset(text_to_find, T)
     print ""Case #%d: %04d"" % (i+1, r)
",gcj/2009/90101/gizzywump/122101/1/extracted/go.py,1162,39,109,Python,90101,1,122101,gizzywump,2009
244,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 @Memoize
 def find_subset(text_to_find, text_to_search):
     if len(text_to_find) == 0: return 1
     if len(text_to_search) == 0: return 0
     if text_to_find[0] == text_to_search[0]:
         return (find_subset(text_to_find[1:], text_to_search[1:]) + find_subset(text_to_find, text_to_search[1:])) % 10000
     return find_subset(text_to_find, text_to_search[1:])
 
 f = sys.stdin
 N = int(f.readline())
 for i in range(N):
     text_to_find = ""welcome to code jam""
     T = f.readline()[:-1]
     r = find_subset(text_to_find, T)
     print ""Case #%d: %04d"" % (i+1, r)
",gcj/2009/90101/gizzywump/122101/0/extracted/go.py,1130,37,108,Python,90101,0,122101,gizzywump,2009
245,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(L, pattern, words):
     pattern = re.sub(""\("", ""["", pattern)
     pattern = re.sub(""\)"", ""]"", pattern)
     cre = re.compile(pattern)
     count = 0
     for w in words:
         if cre.match(w):
             count = count + 1
     return count
 
 f = sys.stdin
 L, D, N = [int(x) for x in f.readline().split()]
 words = [f.readline()[:-1] for i in range(D)]
 for i in range(N):
     case = f.readline()[:-1]
     count = do_trial(L, case, words)
     print ""Case #%d: %d"" % (i+1, count)
",gcj/2009/90101/gizzywump/116101/1/extracted/go.py,1057,39,118,Python,90101,1,116101,gizzywump,2009
246,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def rotated_board(B):
     N = len(B)
     rows = [list() for i in xrange(len(B))]
     for i, row in enumerate(B):
         for j, square in enumerate(row):
             rows[N-1-j].append(square)
     return rows
 
 def apply_gravity(B):
     #import pdb; pdb.set_trace()
     N = len(B)
     rows = [list("".""*N) for i in xrange(len(B))]
     for col_n in xrange(N):
         dst_row = N-1
         for src_row in xrange(N-1,-1,-1):
             if B[src_row][col_n] != '.':
                 rows[dst_row][col_n] = B[src_row][col_n]
                 dst_row = dst_row - 1
     return rows
 
 def show_board(B):
     for row in B:
         print """".join(row)
     print
 
 def has_winner(B, K, c):
     N = len(B)
     for x_delta in (-1,0,1):
         for y_delta in (-1,0,1):
             if x_delta == 0 and y_delta == 0:
                 continue
             for x_start in xrange(N):
                 x = x_start + x_delta * K
                 if x > N or x < 0:
                     continue
                 for y_start in xrange(N):
                     y = y_start + y_delta * K
                     if y > N or y < 0:
                         continue
                     for k in xrange(K):
                         if B[x_start+x_delta*k][y_start+y_delta*k] != c:
                             break
                     else:
                         print c, ""wins with"",K,""in a row""
                         return True
     return False
 
 def test():
     B = [list(x) for x in (""...."", ""BBBB"", ""RRRR"", ""BRBR"")]
     has_winner(B, 4, 'B')
     has_winner(B, 4, 'R')
 
 def do_trial(B,K):
     print ""-"" * 80
     show_board(B)
     print K, ""in a row""
     b_wins = False
     r_wins = False
     B = rotated_board(B)
     B = rotated_board(B)
     B = rotated_board(B)
     show_board(B)
     G = apply_gravity(B)
     show_board(G)
     b_wins = b_wins or has_winner(G, K, 'B')
     r_wins = r_wins or has_winner(G, K, 'R')
     if b_wins and r_wins:
         return ""Both""
     if b_wins:
         return ""Blue""
     if r_wins:
         return ""Red""
     return ""Neither""
 
 def read_board(f, N):
     B = []
     for i in xrange(N):
         B.append(list(f.readline()[:-1]))
     return B
 
 
 out = file(""out"", ""w"")
 f = file(""in"")
 
 T = int(f.readline()[:-1])
 for i in range(T):
     N, K = [int(x) for x in f.readline()[:-1].split()]
     B = read_board(f, N)
     v = do_trial(B,K)
     print ""Case #%d: %s"" % (i+1, v)
     print >>out, ""Case #%d: %s"" % (i+1, v)
     out.flush()
",gcj/2010/544101/gizzywump/567116/1/extracted/go.py,3065,114,343,Python,544101,1,567116,gizzywump,2010
247,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a,b):
     if a>b: a,b = b,a
     if a==0: return b
     return gcf(b%a, a)
 
 @Memoize
 def is_winning_position(A, B):
     if A==B:
         print ""lose from"", A, B
         return 0
     if A<B:
         return is_winning_position(B, A)
     print ""checking"", A, B
     if B == 0: # or A%B == 0:
         print ""win! from"", A, B
         return 1
     for k in xrange(A/B, 0, -1):
         print ""from"", A, B, ""trying"", A-k*B, B
     for k in xrange(A/B, 0, -1):
         if not is_winning_position(A-k*B, B):
             print ""move from"", A, B, ""to %d %d"" % (A-k*B, B), ""which is a losing position for the opponent""
             return 1
     print ""all moves lose from"", A, B
     return 0
 
 def do_trial(A1, A2, B1, B2):
     c = 0
     for A in xrange(A1, A2+1):
         for B in xrange(B1, B2+1):
             if is_winning_position(A, B):
                 print ""*** WINNING:"", A, B
                 c = c + 1
             else:
                 print ""*** LOSING:"", A, B
     return c
 
 out = file(""out"", ""w"")
 f = file(""in"")
 
 T = int(f.readline()[:-1])
 for i in range(T):
     A1, A2, B1, B2 = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(A1, A2, B1, B2)
     print >>out, ""Case #%d: %s"" % (i+1, v)
     print ""Case #%d: %s"" % (i+1, v), ""of"", ""%d"" % ((B2-B1+1) * (A2-A1+1))
     out.flush()
",gcj/2010/544101/gizzywump/583114/0/extracted/go.py,1890,68,243,Python,544101,0,583114,gizzywump,2010
248,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(R, k, groups):
     initial_groups = None
     money = 0
     rides_taken = 0
     while R-rides_taken > 0:
         if rides_taken == 1000:
             money_memo_start = money
             initial_groups = groups
         seats_left = k
         riders = []
         while len(groups) > 0 and seats_left >= groups[0]:
             seats_left -= groups[0]
             riders.append(groups[0])
             groups = groups[1:]
         #print rides_taken
         #print riders
         rides_taken = rides_taken + 1
         money = money + sum(riders)
         groups = tuple(list(groups) + riders)
         if groups == initial_groups:
             # now we skip ahead
             loops = R / (rides_taken-1000)
             R %= rides_taken
             money = money + (money-money_memo_start) * loops
     return money
 
 f = file(""C-small-attempt0.in.txt"")
 f = file(""tiny"")
 f = file(""C-large.in.txt"")
 T = int(f.readline()[:-1])
 for i in range(T):
     R, k, N = [int(x) for x in f.readline()[:-1].split()]
     groups = tuple([int(x) for x in f.readline()[:-1].split()])
     v = do_trial(R, k, groups)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2010/433101/gizzywump/509101/1/extracted/go.py,1722,57,184,Python,433101,1,509101,gizzywump,2010
249,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(R, k, groups):
     initial_groups = groups
     money = 0
     while R >= 1:
         R = R - 1
         seats_left = k
         riders = []
         while len(groups) > 0 and seats_left >= groups[0]:
             seats_left -= groups[0]
             riders.append(groups[0])
             groups = groups[1:]
         #print riders
         money = money + sum(riders)
         groups = tuple(list(groups) + riders)
     return money
 
 f = file(""C-small-attempt0.in.txt"")
 T = int(f.readline()[:-1])
 for i in range(T):
     R, k, N = [int(x) for x in f.readline()[:-1].split()]
     groups = tuple([int(x) for x in f.readline()[:-1].split()])
     v = do_trial(R, k, groups)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2010/433101/gizzywump/509101/0/extracted/go.py,1283,45,139,Python,433101,0,509101,gizzywump,2010
250,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a, b):
     #print ""gcf"", a, b
     a,b = min(a,b), max(a,b)
     while a>0:
         a, b = b%a, a
     return b
 
 def do_trial(vals):
     #import pdb; pdb.set_trace()
     vals.sort()
     first_val = vals[0]
     new_vals = [v-first_val for v in vals if v>first_val]
     big_gcf = reduce(gcf, new_vals)
     remainder = first_val % big_gcf
     if remainder == 0: return 0
     return big_gcf - remainder
 
 #f = file(""B-small-attempt1.in.txt"")
 #f = file(""1"")
 #f = file(""tiny"")
 f = file(""B-large.in.txt"")
 C = int(f.readline()[:-1])
 for i in range(C):
     vals = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(vals[1:])
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2010/433101/gizzywump/506101/1/extracted/go.py,1246,48,140,Python,433101,1,506101,gizzywump,2010
251,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a, b):
     #print ""gcf"", a, b
     a,b = min(a,b), max(a,b)
     while a>0:
         a, b = b%a, a
     return b
 
 def do_trial(vals):
     #import pdb; pdb.set_trace()
     vals.sort()
     first_val = vals[0]
     new_vals = [v-first_val for v in vals if v>first_val]
     big_gcf = reduce(gcf, new_vals)
     remainder = first_val % big_gcf
     if remainder == 0: return 0
     return big_gcf - remainder
 
 f = file(""B-small-attempt1.in.txt"")
 #f = file(""1"")
 #f = file(""tiny"")
 C = int(f.readline()[:-1])
 for i in range(C):
     vals = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(vals[1:])
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2010/433101/gizzywump/506101/0/extracted/go.py,1217,47,137,Python,433101,0,506101,gizzywump,2010
252,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(N,K):
     while N>1:
         #print N, K
         if K%2!=1:
             return ""OFF""
         K=K/2
         N=N-1
     if K%2!=1:
         return ""OFF""
     return ""ON""
 
 f = file(""A-large.in.txt"")
 #f = file(""tiny"")
 T = int(f.readline()[:-1])
 for i in range(T):
     N, K = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(N,K)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2010/433101/gizzywump/502103/1/extracted/go.py,955,40,97,Python,433101,1,502103,gizzywump,2010
253,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(N,K):
     while N>1:
         #print N, K
         if K%2!=1:
             return ""OFF""
         K=K/2
         N=N-1
     if K%2!=1:
         return ""OFF""
     return ""ON""
 
 f = file(""A-small-attempt1.in.txt"")
 #f = file(""tiny"")
 T = int(f.readline()[:-1])
 for i in range(T):
     N, K = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(N,K)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2010/433101/gizzywump/502103/0/extracted/go.py,964,40,97,Python,433101,0,502103,gizzywump,2010
254,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""C-large.in.txt""
 
 def debug(*args):
     pass
     #print >>sys.stderr, str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(candies):
     t = 0
     for c in candies:
         t ^= c
     if t != 0 or len(candies) < 2:
         return ""NO""
     return ""%s"" % sum(sorted(candies)[1:])
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     items = [int(x) for x in f.readline()[:-1].split()]
     debug(items)
     v = do_trial(items)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2011/975485/gizzywump/1059486/1/extracted/go.py,1087,46,118,Python,975485,1,1059486,gizzywump,2011
255,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""C-small-attempt0.in.txt""
 
 def debug(*args):
     pass
     #print >>sys.stderr, str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(candies):
     t = 0
     for c in candies:
         t ^= c
     if t != 0 or len(candies) < 2:
         return ""NO""
     return ""%s"" % sum(sorted(candies)[1:])
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     items = [int(x) for x in f.readline()[:-1].split()]
     debug(items)
     v = do_trial(items)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2011/975485/gizzywump/1059486/0/extracted/go.py,1096,46,118,Python,975485,0,1059486,gizzywump,2011
256,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-large.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(pairs):
     pos = dict({ ""B"" : 1, ""O"" : 1 })
     slop = dict({ ""B"" : 0, ""O"" : 0 })
     k = 0
     moves = 0
     for col1, z in pairs:
         debug(pos, slop, moves)
         b_pos = int(z)
         debug(col1, b_pos)
         col2 = chr(ord(""B"") ^ ord(""O"") ^ ord(col1))
         distance = max(0,abs(pos[col1] - b_pos)-slop[col1]) + 1
         pos[col1] = b_pos
         slop[col1] = 0
         slop[col2] = slop[col2] + distance
         moves += distance
     return moves
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     items = f.readline()[:-1].split()[1:]
     pairs = [(items[v],items[v+1]) for v in xrange(0,len(items)-1,2)]
     debug(pairs)
     #N, K = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(pairs)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2011/975485/gizzywump/1080487/1/extracted/go.py,1470,55,170,Python,975485,1,1080487,gizzywump,2011
257,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-small-attempt0.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(pairs):
     pos = dict({ ""B"" : 1, ""O"" : 1 })
     slop = dict({ ""B"" : 0, ""O"" : 0 })
     k = 0
     moves = 0
     for col1, z in pairs:
         debug(pos, slop, moves)
         b_pos = int(z)
         debug(col1, b_pos)
         col2 = chr(ord(""B"") ^ ord(""O"") ^ ord(col1))
         distance = max(0,abs(pos[col1] - b_pos)-slop[col1]) + 1
         pos[col1] = b_pos
         slop[col1] = 0
         slop[col2] = slop[col2] + distance
         moves += distance
     return moves
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     items = f.readline()[:-1].split()[1:]
     pairs = [(items[v],items[v+1]) for v in xrange(0,len(items)-1,2)]
     debug(pairs)
     #N, K = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(pairs)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2011/975485/gizzywump/1080487/0/extracted/go.py,1479,55,170,Python,975485,0,1080487,gizzywump,2011
258,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-large.in.txt""
 
 def debug(*args):
     pass
     print >>sys.stderr, str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(items):
     invokers = {}
     combiners = {}
     idx = 0
     count = int(items[idx])
     idx += 1
     for i in xrange(count):
         ivk = items[idx]
         idx += 1
         invokers[ivk[0:2]] = ivk[-1]
         invokers[''.join(reversed(ivk[0:2]))] = ivk[-1]
     count = int(items[idx])
     idx += 1
     for i in xrange(count):
         a,b = items[idx]
         combiners[a] = b
         combiners[b] = a
         idx +=1 
     idx +=1 
     text = items[idx]
     idx += 1
     debug(invokers)
     result = [] #list(text)
     debug(result)
     for c in text:
         debug(""at %s; adding %s"" % (''.join(result), c))
         result.append(c)
         if len(result) > 1:
             last_two = ''.join(result[-2:])
             if last_two in invokers:
                 result = result[:-2]
                 for c in invokers[last_two]:
                     result.append(c)
             if c in combiners:
                 if combiners[c] in result:
                     result = []
     return ""[%s]"" % "", "".join(result)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     items = f.readline()[:-1].split()
     debug(items)
     v = do_trial(items)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2011/975485/gizzywump/1026487/1/extracted/go.py,1920,75,200,Python,975485,1,1026487,gizzywump,2011
259,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-small-attempt2.in.txt""
 
 def debug(*args):
     pass
     print >>sys.stderr, str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(items):
     invokers = {}
     combiners = {}
     idx = 0
     count = int(items[idx])
     idx += 1
     for i in xrange(count):
         ivk = items[idx]
         idx += 1
         invokers[ivk[0:2]] = ivk[-1]
         invokers[''.join(reversed(ivk[0:2]))] = ivk[-1]
     count = int(items[idx])
     idx += 1
     for i in xrange(count):
         a,b = items[idx]
         combiners[a] = b
         combiners[b] = a
         idx +=1 
     idx +=1 
     text = items[idx]
     idx += 1
     debug(invokers)
     result = [] #list(text)
     debug(result)
     for c in text:
         debug(""at %s; adding %s"" % (''.join(result), c))
         result.append(c)
         if len(result) > 1:
             last_two = ''.join(result[-2:])
             if last_two in invokers:
                 result = result[:-2]
                 for c in invokers[last_two]:
                     result.append(c)
             if c in combiners:
                 if combiners[c] in result:
                     result = []
     return ""[%s]"" % "", "".join(result)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     items = f.readline()[:-1].split()
     debug(items)
     v = do_trial(items)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2011/975485/gizzywump/1026487/0/extracted/go.py,1929,75,200,Python,975485,0,1026487,gizzywump,2011
260,go.py,"#!/Users/kiss/bin/pypy
 
 import pdb
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a, b):
     while 1:
         a, b = min(a,b), max(a,b)
         if a == 0: return b
         b %= a
 
 def lcm(a, b):
     return a * b / gcf(a,b)
 
 def distances(P, adjacencies):
     distances = [P+1] * P
     distances[0] = 0
     for i in range(P):
         for p in xrange(P):
             if distances[p] < P:
                 for b in adjacencies[p]:
                     distances[b] = min(distances[b], distances[p] + 1)
     return distances
 
 def threatened_sets(P, adjacencies, l):
     #import pdb; pdb.set_trace()
     threatened = {}
     threatened[0] = set(x for x in [adjacencies[0]])
 
     for i in xrange(1,l[1]+1):
         for p in xrange(P):
             if l[p] == i:
                 locally_threatened = adjacencies[p]
                 for a in adjacencies[p]:
                     if l[a] == i-1:
                         if p not in threatened:
                             threatened[p] = set()
                         for sa in threatened[a]:
                             threatened_via_a = locally_threatened.union(sa)
                             threatened[p].add(threatened_via_a)
                 if p not in threatened:
                     pdb.set_trace()
                 max_size = max(len(x) for x in threatened[p])
                 threatened[p] = set(x for x in threatened[p] if len(x) == max_size)
     return threatened
 
 def do_trial(P, adjacencies):
     print P, adjacencies
     l = distances(P, adjacencies)
     print l
     t = threatened_sets(P, adjacencies, l)
     print t
     rep = (x for x in t[1]).next()
     print rep
     return l[1]-1, len(rep)-l[1]
 
 def readints(f):
     return [int(x) for x in f.readline()[:-1].split()]
 
 def readstrings(f):
     return [x for x in f.readline()[:-1].split()]
 
 def main():
     out = file(""out"", ""w"")
     f = file(""in"")
 
     T = int(f.readline()[:-1])
     for i in range(T):
         (P,W) = readints(f)
         adjacencies = dict((i,frozenset()) for i in xrange(P))
         for s in readstrings(f):
             a, b = [int(x) for x in s.split("","")]
             adjacencies[a] = adjacencies[a].union(set([b]))
             adjacencies[b] = adjacencies[b].union(set([a]))
         v = do_trial(P, adjacencies)
         print >>out, ""Case #%d: %s"" % (i+1, v)
         out.flush()
 
 main()",gcj/2011/1150486/gizzywump/1201485/0/extracted/go.py,2881,96,298,Python,1150486,0,1201485,gizzywump,2011
261,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a, b):
     while 1:
         a, b = min(a,b), max(a,b)
         if a == 0: return b
         b %= a
 
 def lcm(a, b):
     return a * b / gcf(a,b)
 
 def count_gcd_changes(nums):
     N = 0
     changes = 0
     for n in nums:
         new_lcm = lcm(max(1,N), n)
         if new_lcm != N:
             changes = changes+1
         N = new_lcm
     return changes
 
 def do_trial(N):
     r = list(range(1,N+1))
     r.sort()
     high = count_gcd_changes(r)
     r.reverse()
     low = count_gcd_changes(r)
     print N, low, high
     return high - low
 
 def readints(f):
     return [int(x) for x in f.readline()[:-1].split()]
 
 def readstrings(f):
     return [x for x in f.readline()[:-1].split()]
 
 def main():
     out = file(""out"", ""w"")
     f = file(""in"")
 
     T = int(f.readline()[:-1])
     for i in range(T):
         (N,) = readints(f)
         v = do_trial(N)
         print >>out, ""Case #%d: %s"" % (i+1, v)
         out.flush()
 
 main()",gcj/2011/1150486/gizzywump/1100485/0/extracted/go.py,1520,67,172,Python,1150486,0,1100485,gizzywump,2011
262,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def pad_walkways(X, S, walkways):
     # pad out walkways
     speeds = []
     last_x = 0
     while len(walkways) > 0:
         w, walkways = walkways[0], walkways[1:]
         x_s, x_e, w_s = w
         speeds.append((x_s-last_x, S))
         speeds.append((x_e-x_s, S+w_s))
         last_x = x_e
     if last_x < X:
         speeds.append((X - last_x, S))
     return speeds
 
 def run_track(run_diff, t, speeds):
     total = 0
     while len(speeds) > 0:
         (dist, vel), speeds = speeds[0], speeds[1:]
         # let's run for as long as we can
         run_vel = vel + run_diff
         run_distance = min(run_vel * t, dist)
         time_running = float(run_distance)/run_vel
         t -= time_running
         walk_distance = dist-run_distance
         time_walking = float(walk_distance)/vel
         total += time_running
         total += time_walking
     return total
 
 def do_trial(X, S, R, t, walkways):
     print X, S, R, t, walkways
     run_diff = R - S
     speeds = pad_walkways(X, S, walkways)
     print walkways
     print speeds
     speeds.sort(key=lambda x: x[1])
 
     t = run_track(run_diff, t, speeds)
     return t
 
 def readints(f):
     return [int(x) for x in f.readline()[:-1].split()]
 
 def readstrings(f):
     return [x for x in f.readline()[:-1].split()]
 
 def main():
     out = file(""out"", ""w"")
     f = file(""in"")
 
     T = int(f.readline()[:-1])
     for i in range(T):
         X, S, R, t, N = readints(f)
         walkways = []
         for j in range(N):
             walkways.append(readints(f))
         v = do_trial(X, S, R, t, walkways)
         print >>out, ""Case #%d: %s"" % (i+1, v)
         print ""-"" * 80
         out.flush()
 
 main()",gcj/2011/1150486/gizzywump/1163489/1/extracted/go.py,2270,84,255,Python,1150486,1,1163489,gizzywump,2011
263,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a,b):
     while a!=b and a>0:
         if a>=b: a,b = b,a
         b-=a
     return a
 
 def lt(a, b):
     if a == 0:
         return 0, 1
     g = gcf(a,b)
     return a/g, b/g
 
 def today_possibilities(N, PD):
     pdn, pdd = lt(PD, 100)
     print N/pdd
     for i in range(1, min(1000,N/pdd+1)):
         yield i*pdn, i*pdd
 
 def forever_possible(wins, total, PG):
     if PG == 100:
         return wins == total
     if PG == 0:
         return wins == 0
     return True
 
 def do_trial(N,PD,PG):
     for wins, total in today_possibilities(N, PD):
         if forever_possible(wins, total, PG):
             return ""Possible""
     return ""Broken""
 
 out = file(""out"", ""w"")
 f = file(""in"")
 
 T = int(f.readline()[:-1])
 for i in range(T):
     N, PD, PG = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(N,PD,PG)
     print >>out, ""Case #%d: %s"" % (i+1, v)
     out.flush()
",gcj/2011/1145485/gizzywump/1040487/1/extracted/go.py,1463,62,168,Python,1145485,1,1040487,gizzywump,2011
264,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcf(a,b):
     while a!=b and a>0:
         if a>=b: a,b = b,a
         b-=a
     return a
 
 def lt(a, b):
     if a == 0:
         return 0, 1
     g = gcf(a,b)
     return a/g, b/g
 
 def today_possibilities(N, PD):
     pdn, pdd = lt(PD, 100)
     print N/pdd
     for i in range(1, N/pdd+1):
         yield i*pdn, i*pdd
 
 def forever_possible(wins, total, PG):
     if PG == 100:
         return wins == total
     if PG == 0:
         return wins == 0
     return True
 
 def do_trial(N,PD,PG):
     for wins, total in today_possibilities(N, PD):
         if forever_possible(wins, total, PG):
             return ""Possible""
     return ""Broken""
 
 out = file(""out"", ""w"")
 f = file(""in"")
 
 T = int(f.readline()[:-1])
 for i in range(T):
     N, PD, PG = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(N,PD,PG)
     print >>out, ""Case #%d: %s"" % (i+1, v)
     out.flush()
",gcj/2011/1145485/gizzywump/1040487/0/extracted/go.py,1453,62,168,Python,1145485,0,1040487,gizzywump,2011
265,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def consistent(w, guess, alphabet):
     if len(guess) != len(w):
         return False
     for i in range(len(guess)):
         c1, c2 = guess[i], w[i]
         if c1 == '_':
             if c2 not in alphabet:
                 return False
         elif c1 != c2:
             return False
     return True
 
 def reveal(letter, guess, chosen):
     s = []
     for i in range(len(guess)):
         if letter == chosen[i]:
             s.append(letter)
         else:
             s.append(guess[i])
     return ''.join(s)
 
 #@Memoize
 def error_count(words, alphabet, chosen, guess=None):
     if guess is None:
         print ""-------------------------""
         print words
         guess = ""_"" * len(chosen)
         #import pdb; pdb.set_trace()
     if ""_"" not in guess:
         return 0
     for i, a in enumerate(alphabet):
         for w in words:
             if a in w and consistent(w, guess, alphabet):
                 # we're going to guess a
                 print ""guessing %s %s for %s because it matches %s (alphabet %s)"" % (a, guess, chosen, w, alphabet)
                 new_guess = reveal(a, guess, chosen)
                 if new_guess == guess:
                     print ""XXX""
                     return 1 + error_count(words, alphabet[i+1:], chosen, new_guess)
                 return error_count(words, alphabet[i+1:], chosen, new_guess)
 
 def do_test(words, alphabet):
     counts = [(w, error_count(words, alphabet, w)) for w in words]
     print counts
     best_score = max(t[1] for t in counts)
     for (w,c) in counts:
         if best_score == c:
             return w
 
 def do_trial(words, alphabets):
     o = []
     for alphabet in alphabets:
         o.append(do_test(words, alphabet))
     return "" "".join(o)
 
 out = file(""out"", ""w"")
 f = file(""in"")
 
 T = int(f.readline()[:-1])
 for i in range(T):
     N, M = [int(x) for x in f.readline().split()]
     words = []
     for j in range(N):
         words.append(f.readline()[:-1])
     alphabets = []
     for j in range(M):
         alphabets.append(f.readline()[:-1])
     v = do_trial(tuple(words), tuple(alphabets))
     print >>out, ""Case #%d: %s"" % (i+1, v)
     out.flush()
",gcj/2011/1145485/gizzywump/1062486/0/extracted/go.py,2736,92,296,Python,1145485,0,1062486,gizzywump,2011
266,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 INPUT = ""tiny""
 
 INPUT = ""B-large.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 def zdebug(*args):
     print ''.join(str(s) for s in args)
 
 def can_score_p(N, p):
     low_p = max(p-1, 0)
     if low_p + low_p + p <= N:
         return ""Y""
     low_p = max(p-2, 0)
     if low_p + low_p + p <= N:
         return ""S""
     return ""N""
 
 def do_trial(N, S, p, *scores):
     d = { ""Y"" : 0, ""N"" : 0, ""S"" : 0 }
     for s in scores:
         v = can_score_p(s, p)
         debug(""score %s p=%s : %s"" % (s, p, v))
         d[v] = d[v] + 1
     return d[""Y""] + min(d[""S""], S)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     l = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(*l)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1460488/gizzywump/1595491/1/extracted/go.py,828,40,132,Python,1460488,1,1595491,gizzywump,2012
267,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 INPUT = ""tiny""
 
 INPUT = ""B-small-attempt0.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 def zdebug(*args):
     print ''.join(str(s) for s in args)
 
 def can_score_p(N, p):
     low_p = max(p-1, 0)
     if low_p + low_p + p <= N:
         return ""Y""
     low_p = max(p-2, 0)
     if low_p + low_p + p <= N:
         return ""S""
     return ""N""
 
 def do_trial(N, S, p, *scores):
     d = { ""Y"" : 0, ""N"" : 0, ""S"" : 0 }
     for s in scores:
         v = can_score_p(s, p)
         debug(""score %s p=%s : %s"" % (s, p, v))
         d[v] = d[v] + 1
     return d[""Y""] + min(d[""S""], S)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     l = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(*l)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1460488/gizzywump/1595491/0/extracted/go.py,837,40,132,Python,1460488,0,1595491,gizzywump,2012
268,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 INPUT = ""tiny""
 
 INPUT = ""C-large.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 if 1:
     def debug(*args):
         sys.stderr.write(''.join(str(s) for s in args) + ""\n"")
 
 def recycleables(N, A, B):
     t = set()
     s = str(N)
     for i in range(len(s)):
         s1 = int(s[i:] + s[:i])
         if A <= s1 <= B:
             t.add(s1)
     return t
 
 def do_trial(A, B):
     total = 0
     seen = set()
     for i in xrange(A, B+1):
         if i not in seen:
             t = recycleables(i, A, B)
             z = len(t)
             total += z * (z-1) / 2
             seen.update(t)
     return total
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     debug(""i=%s"" % i)
     A, B = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(A, B)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1460488/gizzywump/1483488/1/extracted/go.py,900,45,127,Python,1460488,1,1483488,gizzywump,2012
269,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 INPUT = ""tiny""
 
 INPUT = ""C-small-attempt0.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 if 0:
     def debug(*args):
         sys.stderr(''.join(str(s) for s in args) + ""\n"")
 
 def recycleables(N, A, B):
     t = set()
     s = str(N)
     for i in range(len(s)):
         s1 = int(s[i:] + s[:i])
         if A <= s1 <= B:
             t.add(s1)
     return t
 
 def do_trial(A, B):
     total = 0
     seen = set()
     for i in xrange(A, B+1):
         if i not in seen:
             t = recycleables(i, A, B)
             z = len(t)
             total += z * (z-1) / 2
             seen.update(t)
     return total
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = [int(x) for x in f.readline()[:-1].split()]
     v = do_trial(A, B)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1460488/gizzywump/1483488/0/extracted/go.py,880,44,124,Python,1460488,0,1483488,gizzywump,2012
270,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 INPUT = ""tiny""
 
 INPUT = ""D-small-attempt0.in.txt""
 
 def debug(*args):
     pass #print str(args)
 
 if 0:
     def debug(*args):
         sys.stderr.write(''.join(str(s) for s in args) + ""\n"")
 
 def gcd(a,b):
     a,b = abs(a), abs(b)
     while 1:
         if a > b: a,b=b,a
         if a < 1: return b
         a, b = b%a, a
 
 def do_simple_trial(H, W, D, X, Y):
     debug(""W, H, X, Y, D ="", W, H, X, Y, D)
     x = 2*X - 1
     y = 2*Y - 1
     w = 2 * (W - 2)
     h = 2 * (H - 2)
     def x_coords():
         max_x = int(D/w)+3
         for i in xrange(-max_x, max_x):
             yield i * w
             yield i * w + x
     def y_coords():
         max_y = int(D/h)+3
         for i in xrange(-max_y, max_y):
             yield i * h
             yield i * h + y
     l = []
     max_d = D * D
     for x0 in x_coords():
         for y0 in y_coords():
             if y0 == x0 == 0: continue
             d = x0 * x0 + y0 * y0
             if d <= max_d:
                 l.append((x0*x0+y0*y0,x0,y0))
     l.sort()
     s = set()
     for d, x0, y0 in l:
         g = gcd(x0,y0)
         x0 /= g
         y0 /= g
         s.add((x0, y0))
     debug(""s = %s"" % s, len(s))
     return len(s)
 
 def do_trial(H, W, D, lines):
     for j in range(H):
         l = lines[j]
         v = l.find('X')
         if v > -1:
             x, y = v, j
     return do_simple_trial(H, W, D, x, y)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     debug(""i=%s"" % i)
     H, W, D = [int(x) for x in f.readline()[:-1].split()]
     lines = []
     for j in range(H):
         lines.append(f.readline()[:-1])
     v = do_trial(H,W,D,lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1460488/gizzywump/1285485/0/extracted/go.py,1759,77,271,Python,1460488,0,1285485,gizzywump,2012
271,go.py,"#!/usr/bin/env python
 
 import pdb
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-small-attempt2.in.txt""
 
 I=re.sub("" "", """", ""ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv"")
 O=re.sub("" "", """", ""our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up"")
 
 #print I, O
 
 MAP={ 'z' : 'q', 'q' : 'z' }
 for i,o in zip(I,O):
     MAP[i] = o
 
 def debug(*args):
     pass #print str(args)
 
 def debug(*args):
     print str(args)
 
 def do_trial(l):
     t = list(l)
     t1 = [MAP.get(x, x) for x in t]
     return ''.join(t1)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     l = f.readline()[:-1]
     v = do_trial(l)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1460488/gizzywump/1483485/0/extracted/go.py,846,37,129,Python,1460488,0,1483485,gizzywump,2012
272,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-large.in""
 
 def log(*args):
     pass
 
 def zlog(*args):
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def exp_return(A, B, probs):
     e = 1 + B + 1
     log(""exp_return"", e)
     return e
 
 def exp_typing(backspace_count, A, B, probs):
     chars_left_pretyped = A - backspace_count
     prob_all_correct = reduce(lambda x,y: x*y, probs[:chars_left_pretyped], 1.0)
     log(""backspace_count"", backspace_count, ""chars_left_pretyped"", chars_left_pretyped, ""prob_all_correct"", prob_all_correct)
     # probability the backspacing fixed everything is prob_all_correct
     typed = (1 + backspace_count + backspace_count + B - A)
     exp1 = prob_all_correct * typed
     log(typed, ""typed"", prob_all_correct, exp1)
     # backspacing did NOT fix everything
     typed = (1 + backspace_count + backspace_count + B - A + B + 1)
     exp2 = (1.0-prob_all_correct) * typed
     log(typed, ""typed"", (1.0-prob_all_correct), exp2)
     e = exp1 + exp2
     log(""exp_typing"", backspace_count, e)
     return e
 
 def do_trial(A, B, probs):
     e = min(exp_return(A, B, probs), *[exp_typing(x, A, B, probs) for x in range(A+1)])
     return e
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = (int(x) for x in f.readline()[:-1].split())
     probs = [float(x) for x in f.readline()[:-1].split()]
     v = do_trial(A, B, probs)
     sys.stderr.write(""%d\n"" % i)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1645485/gizzywump/1673486/1/extracted/go.py,2011,65,228,Python,1645485,1,1673486,gizzywump,2012
273,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-small-attempt1.in""
 
 def log(*args):
     pass
 
 def log(*args):
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def exp_return(A, B, probs):
     e = 1 + B + 1
     log(""exp_return"", e)
     return e
 
 def exp_typing(backspace_count, A, B, probs):
     chars_left_pretyped = A - backspace_count
     prob_all_correct = reduce(lambda x,y: x*y, probs[:chars_left_pretyped], 1.0)
     log(""backspace_count"", backspace_count, ""chars_left_pretyped"", chars_left_pretyped, ""prob_all_correct"", prob_all_correct)
     # probability the backspacing fixed everything is prob_all_correct
     typed = (1 + backspace_count + backspace_count + B - A)
     exp1 = prob_all_correct * typed
     log(typed, ""typed"", prob_all_correct, exp1)
     # backspacing did NOT fix everything
     typed = (1 + backspace_count + backspace_count + B - A + B + 1)
     exp2 = (1.0-prob_all_correct) * typed
     log(typed, ""typed"", (1.0-prob_all_correct), exp2)
     e = exp1 + exp2
     log(""exp_typing"", backspace_count, e)
     return e
 
 def do_trial(A, B, probs):
     e = min(exp_return(A, B, probs), *[exp_typing(x, A, B, probs) for x in range(A+1)])
     return e
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = (int(x) for x in f.readline()[:-1].split())
     probs = [float(x) for x in f.readline()[:-1].split()]
     v = do_trial(A, B, probs)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1645485/gizzywump/1673486/0/extracted/go.py,1985,64,225,Python,1645485,0,1673486,gizzywump,2012
274,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-large.in""
 
 def log(*args):
     sys.stderr.write(str(args) + ""\n"")
 
 def log(*args):
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(levels, pairs):
     pairs.sort(key=lambda x:-x[1])
     log('-'*80)
     for p in pairs:
         log(p)
     level_state = [0] * levels
     stars = 0
     rounds = 0
     while 1:
         stars = sum(level_state)
         log(stars, ""stars"")
         if stars >= 2 * levels: break
         for i,p in enumerate(pairs):
             if level_state[i] == 2: continue
             if p[1] <= stars:
                 log(""getting 2 stars in round"", i)
                 rounds += 1
                 level_state[i] = 2
                 break
         else:
             for i,p in enumerate(pairs):
                 if level_state[i] >= 1: continue
                 if p[0] <= stars:
                     log(""getting 1 star in round"", i)
                     rounds +=1
                     level_state[i] = 1
                     break
             else:
                 return ""Too Bad""
     return rounds
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     sys.stderr.write(""%d\n"" % i)
     levels = int(f.readline()[:-1])
     pairs = []
     for j in range(levels):
         pairs.append([int(x) for x in f.readline()[:-1].split()])
     v = do_trial(levels, pairs)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1645485/gizzywump/1482494/1/extracted/go.py,1935,73,196,Python,1645485,1,1482494,gizzywump,2012
275,go.py,"#!/usr/bin/env python
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-small-attempt2.in""
 
 def log(*args):
     sys.stderr.write(str(args) + ""\n"")
 
 def zlog(*args):
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(levels, pairs):
     pairs.sort(key=lambda x:-x[1])
     log('-'*80)
     for p in pairs:
         log(p)
     level_state = [0] * levels
     stars = 0
     rounds = 0
     while 1:
         stars = sum(level_state)
         log(stars, ""stars"")
         if stars >= 2 * levels: break
         for i,p in enumerate(pairs):
             if level_state[i] == 2: continue
             if p[1] <= stars:
                 log(""getting 2 stars in round"", i)
                 rounds += 1
                 level_state[i] = 2
                 break
         else:
             for i,p in enumerate(pairs):
                 if level_state[i] >= 1: continue
                 if p[0] <= stars:
                     log(""getting 1 star in round"", i)
                     rounds +=1
                     level_state[i] = 1
                     break
             else:
                 return ""Too Bad""
     return rounds
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     levels = int(f.readline()[:-1])
     pairs = []
     for j in range(levels):
         pairs.append([int(x) for x in f.readline()[:-1].split()])
     v = do_trial(levels, pairs)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2012/1645485/gizzywump/1482494/0/extracted/go.py,1911,72,193,Python,1645485,0,1482494,gizzywump,2012
276,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1: #1:
     INPUT = ""A-small-attempt2.in""
 
 def debug(*args):
     #print str(args)
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def cost(M, N):
     return M * N + M * (1-M) / 2
 
 assert cost(1, 5) == 5
 assert cost(2, 5) == 5 + 4
 assert cost(3, 5) == 5 + 4 + 3
 assert cost(4, 5) == 5 + 4 + 3 + 2
 assert cost(5, 6) == 6 + 5 + 4 + 3 + 2
 assert cost(6, 6) == 6 + 5 + 4 + 3 + 2 + 1
 
 
 def improve(N, array):
     swaps = 0
     for s0 in range(N):
         for e0 in range(s0+1, N):
             #debug(""checking %s, %s"" % (s0+1, e0+1))
             p0 = array[s0][e0]
             if p0 == 0:
                 continue
             #import pdb; pdb.set_trace()
             for e1 in range(N-1, e0, -1):
                 for s1 in range(s0+1, e0+1):
                     p1 = array[s1][e1]
                     if p1 == 0: continue
                     swaps = 1
                     smaller = min(p0, p1)
                     debug(""swapping (%s %s) with (%s, %s) [%s]"" % (s0+1, e0+1, s1+1, e1+1, smaller))
                     p0 -= smaller
                     array[s0][e0] -= smaller
                     array[s1][e1] -= smaller
                     array[s0][e1] += smaller
                     array[s1][e0] += smaller
                     if p0 == 0: break
                 if p0 == 0: break
     return swaps
 
 def find_total(N, array):
     total = 0
     for o in range(N):
         for e in range(o+1, N):
             p = array[o][e]
             if p:
                 total += cost(e-o, N) * p
                 total %= 1000002013
     return total
 
 def show_array(N, array):
     for s0 in range(N):
         for e0 in range(s0, N):
             p0 = array[s0][e0]
             if p0>0:
                 debug(""%s %s %s"" % (s0+1, e0+1, p0))
 
 def do_trial(N, M, triples):
     array = [[0] * N for i in range(N)]
     for (s, e, p) in triples:
         array[s-1][e-1] += p
     original_total = find_total(N, array)
     show_array(N, array)
     while 1:
         c = improve(N, array)
         if not c: break
     show_array(N, array)
     new_total = find_total(N, array)
     #import pdb; pdb.set_trace()
     return (original_total-new_total) % 1000002013
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, M = [int(x) for x in f.readline().split()]
     debug(""**** %s, %s"" % (N,M))
     triples = []
     for j in range(M):
         triples.append([int(x) for x in f.readline().split()])
     v = do_trial(N, M, triples)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2442487/gizzywump/2772486/0/extracted/go.py,3092,110,389,Python,2442487,0,2772486,gizzywump,2013
277,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""C-small-attempt1.in""
 
 def debug(*args):
     #print str(args)
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(N, A_list, B_list):
     #import pdb; pdb.set_trace()
     answer = [None] * N
     cur_idx = 1
     next_val = 1
     while None in answer:
         for i in range(N-1, -1, -1):
             if A_list[i] == cur_idx:
                 answer[i] = next_val
                 next_val += 1
         cur_idx += 1
 
     return ' '.join(str(a) for a in answer)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = [int(x) for x in f.readline().split()]
     A_list = [int(x) for x in f.readline().split()]
     B_list = [int(x) for x in f.readline().split()]
     v = do_trial(N, A_list, B_list)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2442487/gizzywump/2779487/0/extracted/go.py,1363,55,155,Python,2442487,0,2779487,gizzywump,2013
278,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-large.in""
 
 def debug(*args):
     #print str(args)
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def prod(l):
     return l[0] * l[1]
 
 def do_trial(E, R, v_list):
     N = len(v_list)
     min_after = [0] * N
     max_before = [E] * N
     spend = [None] * N
     the_order = sorted(range(N), key=lambda i: -v_list[i])
     debug(""v_list"", v_list)
     debug(""ORDER"", the_order)
     for idx in the_order:
         #import pdb; pdb.set_trace()
         spend[idx] = max_before[idx] - min_after[idx]
         idx2 = idx
         mb = min_after[idx]
         while idx2 < N-1:
             idx2 += 1
             mb += R
             if mb > E: break
             max_before[idx2] = min(mb, max_before[idx2])
         ma = spend[idx] + min_after[idx]
         idx2 = idx
         while idx2 > 0:
             idx2 -= 1
             ma -= R
             if ma <= 0: break
             min_after[idx2] = max(ma, min_after[idx2])
         debug(""==>"", v_list, spend, max_before, min_after)
     debug(spend, v_list)
     return sum(prod(t) for t in zip(spend, v_list))
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     E, R, N = [int(x) for x in f.readline().split()]
     v_list = [int(x) for x in f.readline().split()]
     v = do_trial(E, R, v_list)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2418487/gizzywump/2645486/1/extracted/go.py,1902,72,218,Python,2418487,1,2645486,gizzywump,2013
279,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-small-attempt2.in""
 
 def debug(*args):
     #print str(args)
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def prod(l):
     return l[0] * l[1]
 
 def do_trial(E, R, v_list):
     N = len(v_list)
     min_after = [0] * N
     max_before = [E] * N
     spend = [None] * N
     the_order = sorted(range(N), key=lambda i: -v_list[i])
     debug(""v_list"", v_list)
     debug(""ORDER"", the_order)
     for idx in the_order:
         #import pdb; pdb.set_trace()
         spend[idx] = max_before[idx] - min_after[idx]
         idx2 = idx
         mb = min_after[idx]
         while idx2 < N-1:
             idx2 += 1
             mb += R
             if mb > E: break
             max_before[idx2] = min(mb, max_before[idx2])
         ma = spend[idx] + min_after[idx]
         idx2 = idx
         while idx2 > 0:
             idx2 -= 1
             ma -= R
             if ma <= 0: break
             min_after[idx2] = max(ma, min_after[idx2])
         debug(""==>"", v_list, spend, max_before, min_after)
     debug(spend, v_list)
     return sum(prod(t) for t in zip(spend, v_list))
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     E, R, N = [int(x) for x in f.readline().split()]
     v_list = [int(x) for x in f.readline().split()]
     v = do_trial(E, R, v_list)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2418487/gizzywump/2645486/0/extracted/go.py,1911,72,218,Python,2418487,0,2645486,gizzywump,2013
280,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""C-small-1-attempt1.in""
 
 def debug(*args):
     #print str(args)
     pass
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def gcf(a, b):
     while 1:
         a, b = min(a,b), max(a,b)
         if a == 0:
             return b
         b %= a
 
 def lcm(a, b):
     return a * b / gcf(a,b)
 
 def lcm_m(args):
     return reduce(lcm, args, 1)
 
 def trial(N, M, K, the_set):
     #import pdb; pdb.set_trace()
     factors = []
     lcm_v = lcm_m(the_set)
     while lcm_v % 5 == 0:
         factors.append(5)
         lcm_v /= 5
     while lcm_v % 3 == 0:
         factors.append(3)
         lcm_v /= 3
     if lcm_v == 16:
         factors.append(4)
         factors.append(4)
     elif lcm_v == 8:
         return ""\n222""
     elif lcm_v == 4:
         factors.append(4)
     elif lcm_v == 2:
         factors.append(2)
     while len(factors) < 3:
         factors.append(2)
     return ""\n"" + ''.join(str(f) for f in factors[:3])
 
 def do_trial(N, M, K, sets):
     v = [trial(N, M, K, s) for s in sets]
     return ''.join(v)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, N, M, K = [int(x) for x in f.readline().split()]
     sets = []
     for j in range(R):
         sets.append([int(x) for x in f.readline().split()])
     v = do_trial(N, M, K, sets)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2418487/gizzywump/2652486/0/extracted/go.py,1906,82,229,Python,2418487,0,2652486,gizzywump,2013
281,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-large.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def f_x(R, r, t):
     return 2*R*R + (2*r-1) * R - t
 
 def do_trial(r, t):
     guess = int((1-2*r+math.sqrt(4*r*r-4*r+1+8*t))/4.0 + 2)
     while 1:
         if f_x(guess, r, t) <= 0:
             return max(0, guess)
         guess -= 1
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     r, t = [int(x) for x in f.readline().split()]
     v = do_trial(r, t)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2418487/gizzywump/2464487/1/extracted/go.py,1109,48,127,Python,2418487,1,2464487,gizzywump,2013
282,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def f_x(R, r, t):
     return 2*R*R + (2*r-1) * R - t
 
 def do_trial(r, t):
     guess = int((1-2*r+math.sqrt(4*r*r-4*r+1+8*t))/4.0 + 2)
     while 1:
         if f_x(guess, r, t) <= 0:
             return guess
         guess -= 1
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     r, t = [int(x) for x in f.readline().split()]
     v = do_trial(r, t)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2418487/gizzywump/2464487/0/extracted/go.py,1110,48,126,Python,2418487,0,2464487,gizzywump,2013
283,go.py,"#!/usr/bin/env python
 
 import collections
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-large.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def check(board, x, y, dx, dy):
     #import pdb; pdb.set_trace()
     c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))
     if c.get(""X"", 0) + c.get(""T"", 0) == 4: return ""X won""
     if c.get(""O"", 0) + c.get(""T"", 0) == 4: return ""O won""
 
 def do_trial(board):
     #return ""X won"" #(the game is over, and X won)
     #""O won"" (the game is over, and O won)
     #""Draw"" (the game is over, and it ended in a draw)
     #""Game has not completed"" (the game is not over yet)
     for x in range(4):
         v = check(board, x, 0, 0, 1)
         if v: return v
         v = check(board, 0, x, 1, 0)
         if v: return v
     v = check(board, 0, 0, 1, 1)
     if v: return v
     v = check(board, 3, 0, -1, 1)
     if v: return v
     if '.' in ''.join(board):
         return ""Game has not completed""
     return ""Draw""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     lines = [f.readline()[:-1] for j in range(4)]
     f.readline()
     v = do_trial(lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2270488/gizzywump/2453486/1/extracted/go.py,1712,62,229,Python,2270488,1,2453486,gizzywump,2013
284,go.py,"#!/usr/bin/env python
 
 import collections
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def check(board, x, y, dx, dy):
     #import pdb; pdb.set_trace()
     c = collections.Counter((board[x+dx*i][y+dy*i] for i in range(4)))
     if c.get(""X"", 0) + c.get(""T"", 0) == 4: return ""X won""
     if c.get(""O"", 0) + c.get(""T"", 0) == 4: return ""O won""
 
 def do_trial(board):
     #return ""X won"" #(the game is over, and X won)
     #""O won"" (the game is over, and O won)
     #""Draw"" (the game is over, and it ended in a draw)
     #""Game has not completed"" (the game is not over yet)
     for x in range(4):
         v = check(board, x, 0, 0, 1)
         if v: return v
         v = check(board, 0, x, 1, 0)
         if v: return v
     v = check(board, 0, 0, 1, 1)
     if v: return v
     v = check(board, 3, 0, -1, 1)
     if v: return v
     if '.' in ''.join(board):
         return ""Game has not completed""
     return ""Draw""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     lines = [f.readline()[:-1] for j in range(4)]
     f.readline()
     v = do_trial(lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2270488/gizzywump/2453486/0/extracted/go.py,1721,62,229,Python,2270488,0,2453486,gizzywump,2013
285,go.py,"#!/usr/bin/env python
 
 import collections
 
 import pickle
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""C-large-1.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def is_palindrome(N):
     s = str(N)
     return s == ''.join(reversed(s))
 
 def fair_and_square_set(max_N):
     p = ""squareset_%d"" % max_N
     try:
         s = pickle.load(file(p))
         return s
     except:
         pass
     s = set()
     for i in range(1,max_N+1):
         if is_palindrome(i) and is_palindrome(i*i):
             s.add(i*i)
     pickle.dump(s, file(p, ""wb""))
     return s
 
 MAX_N = int(1e7)
 SQUARE_SET = fair_and_square_set(MAX_N)
 #print(SQUARE_SET)
 
 def do_trial(A, B):
     count = 0
     for ss in SQUARE_SET:
         if A <= ss <= B:
             count += 1
     return count
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = [int(x) for x in f.readline().split()]
     v = do_trial(A, B)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2270488/gizzywump/2463486/1/extracted/go.py,1487,67,162,Python,2270488,1,2463486,gizzywump,2013
286,go.py,"#!/usr/bin/env python
 
 import collections
 
 import pickle
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def is_palindrome(N):
     s = str(N)
     return s == ''.join(reversed(s))
 
 def fair_and_square_set(max_N):
     p = ""squareset_%d"" % max_N
     try:
         s = pickle.load(file(p))
         return s
     except:
         pass
     s = set()
     for i in range(1,max_N+1):
         if is_palindrome(i) and is_palindrome(i*i):
             s.add(i*i)
     pickle.dump(s, file(p, ""wb""))
     return s
 
 MAX_N = int(1e7)
 SQUARE_SET = fair_and_square_set(MAX_N)
 #print(SQUARE_SET)
 
 def do_trial(A, B):
     count = 0
     for ss in SQUARE_SET:
         if A <= ss <= B:
             count += 1
     return count
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B = [int(x) for x in f.readline().split()]
     v = do_trial(A, B)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2270488/gizzywump/2463486/0/extracted/go.py,1494,67,162,Python,2270488,0,2463486,gizzywump,2013
287,go.py,"#!/usr/bin/env python
 
 import collections
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-large.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(lawn):
     w = len(lawn[0])
     h = len(lawn)
     x_maxes = [max(lawn_row) for lawn_row in lawn]
     y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]
     def lawn_row(y):
         x_max = x_maxes[y]
         return tuple([min(y_maxes[x], x_max) for x in range(w)])
     new_lawn = tuple([lawn_row(y) for y in range(h)])
     #import pdb; pdb.set_trace()
     if new_lawn == lawn:
         return ""YES""
     return ""NO""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     w, h = [int(x) for x in f.readline().split()]
     lawn = []
     for k in range(w):
         lawn.append(tuple([int(x) for x in f.readline().split()]))
     lawn = tuple(lawn)
     #if i==2:
     #    import pdb; pdb.set_trace()
     v = do_trial(lawn)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2270488/gizzywump/2449486/1/extracted/go.py,1487,57,167,Python,2270488,1,2449486,gizzywump,2013
288,go.py,"#!/usr/bin/env python
 
 import collections
 
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     pass #print str(args)
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(lawn):
     w = len(lawn[0])
     h = len(lawn)
     x_maxes = [max(lawn_row) for lawn_row in lawn]
     y_maxes = [max(lawn[y][x] for y in range(h)) for x in range(w)]
     def lawn_row(y):
         x_max = x_maxes[y]
         return tuple([min(y_maxes[x], x_max) for x in range(w)])
     new_lawn = tuple([lawn_row(y) for y in range(h)])
     #import pdb; pdb.set_trace()
     if new_lawn == lawn:
         return ""YES""
     return ""NO""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     w, h = [int(x) for x in f.readline().split()]
     lawn = []
     for k in range(w):
         lawn.append(tuple([int(x) for x in f.readline().split()]))
     lawn = tuple(lawn)
     #if i==2:
     #    import pdb; pdb.set_trace()
     v = do_trial(lawn)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2013/2270488/gizzywump/2449486/0/extracted/go.py,1496,57,167,Python,2270488,0,2449486,gizzywump,2013
289,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""D-small-attempt0.in""
 INPUT = ""D-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def war_wins(N, K):
     wins = 0
     debug(N, K)
     #import pdb; pdb.set_trace()
     while 1:
         if len(N) == 0:
             return wins
         N,n = N[:-1], N[-1]
         if n > K[-1]:
             wins += 1
             K = K[1:]
             continue
         for idx, v in enumerate(K):
             if v > n:
                 break
         K = K[:idx] + K[idx+1:]
 
 def dwar_wins(N, K):
     wins = 0
     while 1:
         if len(N) == 0:
             return wins
         n, N = N[0], N[1:]
         if n > K[0]:
             wins += 1
             K = K[1:]
         else:
             K = K[:-1]
 
 
 def do_trial(N, K):
     N.sort()
     K.sort()
     dww = dwar_wins(N, K)
     ww = war_wins(N, K)
     return ""%d %d"" % (dww, ww)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     f.readline()
     N = [float(x) for x in f.readline().split()]
     K = [float(x) for x in f.readline().split()]
     v = do_trial(N, K)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2974486/gizzywump/5644738749267968/1/extracted/go.py,1769,80,204,Python,2974486,1,5644738749267968,gizzywump,2014
290,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""D-small-attempt0.in""
 #INPUT = ""D-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def war_wins(N, K):
     wins = 0
     debug(N, K)
     #import pdb; pdb.set_trace()
     while 1:
         if len(N) == 0:
             return wins
         N,n = N[:-1], N[-1]
         if n > K[-1]:
             wins += 1
             K = K[1:]
             continue
         for idx, v in enumerate(K):
             if v > n:
                 break
         K = K[:idx] + K[idx+1:]
 
 def dwar_wins(N, K):
     wins = 0
     while 1:
         if len(N) == 0:
             return wins
         n, N = N[0], N[1:]
         if n > K[0]:
             wins += 1
             K = K[1:]
         else:
             K = K[:-1]
 
 
 def do_trial(N, K):
     N.sort()
     K.sort()
     dww = dwar_wins(N, K)
     ww = war_wins(N, K)
     return ""%d %d"" % (dww, ww)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     f.readline()
     N = [float(x) for x in f.readline().split()]
     K = [float(x) for x in f.readline().split()]
     v = do_trial(N, K)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2974486/gizzywump/5644738749267968/0/extracted/go.py,1770,80,204,Python,2974486,0,5644738749267968,gizzywump,2014
291,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 #INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(C, F, X, rate=2.0):
     so_far = 0
     while 1:
         #import pdb; pdb.set_trace()
         win_time_wait = X / rate
         buy_time = C / rate
         win_time_buy_1 = buy_time + X / (rate+F)
         if win_time_wait < win_time_buy_1:
             return so_far + win_time_wait
         so_far += buy_time
         rate += F
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     C, F, X = [float(x) for x in f.readline().split()]
     v = do_trial(C, F, X)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2974486/gizzywump/5709773144064000/1/extracted/go.py,1299,53,142,Python,2974486,1,5709773144064000,gizzywump,2014
292,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 sys.setrecursionlimit(5000)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(C, F, X, rate=2.0):
     #import pdb; pdb.set_trace()
     win_time_wait = X / rate
     buy_time = C / rate
     win_time_buy_1 = buy_time + X / (rate+F)
     if win_time_wait < win_time_buy_1:
         return win_time_wait
     return buy_time + do_trial(C, F, X, rate+F)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     C, F, X = [float(x) for x in f.readline().split()]
     v = do_trial(C, F, X)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2974486/gizzywump/5709773144064000/0/extracted/go.py,1239,50,136,Python,2974486,0,5709773144064000,gizzywump,2014
293,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""C-small-attempt1.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])
 
 for i in range(2,51):
     IMPOSSIBLE.add((2,i,1))
     IMPOSSIBLE.add((i,2,1))
 
 SOLN = {
     (1,2,1) : [""c*""],
     (2,1,1) : [""c"", ""*""],
     (2,2,3) : [""c*"", ""**""],
 }
 
 def solve(R, C, M):
     if M == 0:
         s = [""c%s"" % ('.' * (C-1))]
         for i in range(R-1):
             s.append('.' * C)
         return s
     t = (R, C, M)
     if t in IMPOSSIBLE:
         debug(""** %s %s %s"" % t)
         raise ValueError
     if t in SOLN:
         return SOLN[t]
 
     # last row?
     if C < M and R > 2:
         try:
             return solve(R-1, C, M-C) + [""*"" * C]
         except ValueError:
             pass
 
     if C <= R:
         if M >= C and R > 2:
             return solve(R-1, C, M-C) + [""*"" * C]
     else:
         if M >= R and C > 2:
             return [""%s*"" % s for s in solve(R, C-1, M-R)]
     if R > 2:
         # fill in last row
         mines = min(C, M)
         if mines == C - 1:
             mines -= 1
         try:
             return solve(R-1, C, M-mines) + [(""."" * (C - mines)) + (""*"" * mines)]
         except ValueError:
             if C > 2:
                 mines = min(R, M)
             if mines == R - 1:
                 mines -= 1
             s = [""%s%s"" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]
             return s
     debug(R, C, M)
     return []
 
 def do_trial(R, C, M):
     try:
         r = solve(R,C,M)
         s = ""\n"" + '\n'.join(r)
         assert len(r) == R
         for r1 in r:
             assert len(r1) == C
         assert len(''.join(k for k in s if k == '*')) == M
         return s
     except ValueError:
         return ""\nImpossible""
 
 
 def all():
     for R in range(1,50):
         for C in range(1,50):
             for M in range(R*C):
                 print(R, C, M)
                 print(do_trial(R, C, M))
     sys.exit(0)
 
 #all()
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, C, M = [int(x) for x in f.readline().split()]
     #import pdb; pdb.set_trace()
     v = do_trial(R, C, M)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2974486/gizzywump/5690574640250880/0/extracted/go.py,2932,120,385,Python,2974486,0,5690574640250880,gizzywump,2014
294,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 if 1:
     INPUT = ""A-large.in""
     INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(a1, r1, a2, r2):
     p1 = set(r1[a1-1])
     p2 = set(r2[a2-1])
     u = p1.intersection(p2)
     if len(u) < 1:
         return ""Volunteer cheated!""
     if len(u) > 1:
         return ""Bad magician!""
     return list(u)[0]
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     rows1 = []
     a1 = int(f.readline()[:-1])
     for r in range(4):
         rows1.append([int(x) for x in f.readline().split()])
     a2 = int(f.readline()[:-1])
     rows2 = []
     for r in range(4):
         rows2.append([int(x) for x in f.readline().split()])
     v = do_trial(a1, rows1, a2, rows2)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2974486/gizzywump/5756407898963968/0/extracted/go.py,1402,57,151,Python,2974486,0,5756407898963968,gizzywump,2014
295,go.py,"#!/usr/bin/env python
 
 import collections
 import itertools
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-large.in""
 INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def counts_for_string(s):
     chars = []
     counts = []
     count = 0
     this_char = None
     for idx, c in enumerate(s):
         if c == this_char:
             count += 1
         else:
             if count:
                 counts.append(count)
                 chars.append(this_char)
             this_char = c
             count = 1
     counts.append(count)
     chars.append(this_char)
     return ''.join(chars), counts
 
 assert counts_for_string(""aabbccc"") == (""abc"", [2,2,3])
 
 def fastest(vals):
     debug(vals)
     best = 1e8
     for v in set(vals):
         total = sum(abs(k - v) for k in vals)
         best = min(total, best)
     debug(""***"", vals, best)
     return best
 
 def do_trial(strings):
     rv = [counts_for_string(s) for s in strings]
     debug(rv)
     if len(set(c[0] for c in rv)) > 1:
         return ""Fegla Won""
     counts = [r[1] for r in rv]
     debug(counts)
     total = 0
     for vals in zip(*counts):
         total += fastest(vals)
     return total
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = [int(x) for x in f.readline().split()]
     strings = []
     for k in range(N):
         strings.append(f.readline()[:-1])
     v = do_trial(strings)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2994486/gizzywump/5751500831719424/1/extracted/go.py,2058,86,220,Python,2994486,1,5751500831719424,gizzywump,2014
296,go.py,"#!/usr/bin/env python
 
 import collections
 import itertools
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def counts_for_string(s):
     chars = []
     counts = []
     count = 0
     this_char = None
     for idx, c in enumerate(s):
         if c == this_char:
             count += 1
         else:
             if count:
                 counts.append(count)
                 chars.append(this_char)
             this_char = c
             count = 1
     counts.append(count)
     chars.append(this_char)
     return ''.join(chars), counts
 
 assert counts_for_string(""aabbccc"") == (""abc"", [2,2,3])
 
 def fastest(vals):
     debug(vals)
     best = 1e8
     for v in set(vals):
         total = sum(abs(k - v) for k in vals)
         best = min(total, best)
     debug(""***"", vals, best)
     return best
 
 def do_trial(strings):
     rv = [counts_for_string(s) for s in strings]
     debug(rv)
     if len(set(c[0] for c in rv)) > 1:
         return ""Fegla Won""
     counts = [r[1] for r in rv]
     debug(counts)
     total = 0
     for vals in zip(*counts):
         total += fastest(vals)
     return total
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = [int(x) for x in f.readline().split()]
     strings = []
     for k in range(N):
         strings.append(f.readline()[:-1])
     v = do_trial(strings)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2994486/gizzywump/5751500831719424/0/extracted/go.py,2059,86,220,Python,2994486,0,5751500831719424,gizzywump,2014
297,go.py,"#!/usr/bin/env python
 
 import collections
 import itertools
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""A-large.in""
 INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(A, B, K):
     count = 0
     for a in range(A):
         for b in range(B):
             debug(a, b, a&b, K)
             if a & b < K:
                 count += 1
     return count
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     A, B, K = [int(x) for x in f.readline().split()]
     v = do_trial(A, B, K)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/2994486/gizzywump/5658282861527040/0/extracted/go.py,1164,51,130,Python,2994486,0,5658282861527040,gizzywump,2014
298,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 INPUT = ""B-small-attempt7.in""
 #INPUT = ""B-large.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def fact(N):
     t = 1
     for i in range(1,N+1):
         t *= i
     return t
 
 
 def collapse(car):
     s = car[0]
     for c in car[1:]:
         if c != s[-1]:
             s += c
     return s[0] + s[-1], frozenset(s[1:-1])
     
 
 MOD = 1000000007
     
 
 def do_trial(cars):
     car_pairs = [collapse(car) for car in cars]
     cars = [cp[0] for cp in car_pairs]
     internal_chars = set()
     for cp in car_pairs:
         internal_chars.update(cp[1])
     #import pdb; pdb.set_trace()
     # we have cars, internal_chars
     count = 1
     ind_cars = []
     # deal with cars that are all the same first
     cars.sort(key=lambda x: -len(set(x)))
     while len(cars) > 0:
         debug(cars, ind_cars, count)
         car = cars[-1]
         c0, c1 = car
         if c0 in internal_chars:
             return 0
         if c1 in internal_chars:
             return 0
         if c0 == c1:
             all_units = [c for c in cars if c == car]
             others = [c for c in cars if c != car]
             count *= fact(len(all_units))
             count %= MOD
             cars = others
             all_others = set()
             for o in others:
                 all_others.update(o)
             if c0 not in all_others:
                 ind_cars.append(car)
             continue
         cars = cars[:-1]
         for idx, car_1 in enumerate(cars):
             if car_1[0] == car_1[-1]:
                 return 0
             if c1 == car_1[0]:
                 # meld 'em
                 cars = [(c0 + car_1[-1])] + cars[:idx] + cars[idx+1:]
                 internal_chars.add(c1)
                 break
             if car_1[-1] == c0:
                 cars = [(car_1[0] + c1)] + cars[:idx] + cars[idx+1:]
                 internal_chars.add(c0)
                 break
         else:
             ind_cars.append(car)
             internal_chars.update(car)
     debug(cars, ind_cars, count)
     count *= fact(len(ind_cars))
     count %= MOD
     return count
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = (int(x) for x in f.readline().split())
     cars = f.readline().split()
     v = do_trial(cars)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/3004486/gizzywump/5669245564223488/0/extracted/go.py,2950,113,322,Python,3004486,0,5669245564223488,gizzywump,2014
299,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt0.in""
 INPUT = ""A-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def gcf(a, b):
     while 1:
         if a > b:
             a, b = b, a
         if a in (0, b):
             return b
         b %= a
 
 
 def do_trial(P, Q):
     g = gcf(P, Q)
     P /= g
     Q /= g
     if (1 << (Q.bit_length()-1)) != Q:
         return ""impossible""
     gen = 0
     while 1:
         if P >= Q:
             return gen
         gen += 1
         P += P
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     P, Q = (int(x) for x in f.readline().split(""/""))
     v = do_trial(P, Q)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/3004486/gizzywump/5706278382862336/1/extracted/go.py,1296,62,157,Python,3004486,1,5706278382862336,gizzywump,2014
300,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt0.in""
 #INPUT = ""A-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def gcf(a, b):
     while 1:
         if a > b:
             a, b = b, a
         if a in (0, b):
             return b
         b %= a
 
 
 def do_trial(P, Q):
     g = gcf(P, Q)
     P /= g
     Q /= g
     if (1 << (Q.bit_length()-1)) != Q:
         return ""impossible""
     gen = 0
     while 1:
         if P >= Q:
             return gen
         gen += 1
         P += P
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     P, Q = (int(x) for x in f.readline().split(""/""))
     v = do_trial(P, Q)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2014/3004486/gizzywump/5706278382862336/0/extracted/go.py,1297,62,157,Python,3004486,0,5706278382862336,gizzywump,2014
301,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-small-attempt1.in""
 #INPUT = ""C-large.in""
 #INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(V, X, src_list):
     debug(src_list, V, X)
     if len(src_list) == 1:
         #import pdb; pdb.set_trace()
         if X != src_list[0][-1]:
             return ""IMPOSSIBLE""
         return V/src_list[0][0]
 
     min_src = min(src_list, key=lambda x:x[-1])
     max_src = max(src_list, key=lambda x:x[-1])
     min_rate, min_temp = min_src
     max_rate, max_temp = max_src
     if min_temp > X or max_temp < X:
         #import pdb; pdb.set_trace()
         return ""IMPOSSIBLE""
 
     if X == max_temp:
         return V / max_rate
 
     K = (X-min_temp)/(max_temp-X)
 
     # for every 1 liter of min_temp we need K liters of max_temp
     v_min = V / (K+1)
     v_max = V * K / (K+1)
     t_min = v_min / min_rate
     t_max = v_max / max_rate
 
     #import pdb; pdb.set_trace()
     vol = t_min * min_rate + t_max * max_rate
     assert abs(vol - V) < 1e-6
     assert abs((t_min * min_rate * min_temp + t_max * max_rate * max_temp) / V - X) < 1e-6
 
     return max(t_min, t_max)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     row = f.readline().split()
     N = int(row[0])
     V, X = float(row[1]), float(row[2])
     src_list = []
     for _ in range(N):
         x, c = [float(x) for x in f.readline().split()]
         src_list.append((x, c))
     v = do_trial(V, X, src_list)
     if type(v) == float:
         v = ""%1.6f"" % v
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8234486/gizzywump/5750872826970112/0/extracted/go.py,2218,84,267,Python,8234486,0,5750872826970112,gizzywump,2015
302,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""C-small-attempt3.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 @Memoize
 def bit_count(v):
     c = 0
     while v > 0:
         if v & 1:
             c += 1
         v >>= 1
     return c
 
 
 def show_words(lang, lookup):
     rev = dict((a,b) for b, a in lookup.items())
     t = 0
     while lang > 0:
         if lang & 1:
             debug(rev[t])
         t += 1
         lang >>= 1
 
 
 def do_trial(sentences):
     words = [set(s.split()) for s in sentences]
     all_words = []
     for s in sentences:
         all_words.extend(s.split())
     all_words = sorted(set(all_words))
     #import pdb; pdb.set_trace()
     word_lookup = dict((w, n) for n, w in enumerate(all_words))
     words_v = []
     for s in sentences:
         v = 0
         for w in s.split():
             v |= (1 << word_lookup[w])
         words_v.append(v)
 
     english = words_v[0]
     show_words(english, word_lookup)
     debug(""-----------"")
     french = words_v[1]
     show_words(french, word_lookup)
     debug(""-----------"")
     both = english & french
     min_both = len(all_words)
     #import pdb; pdb.set_trace()
     c = 2**(len(words)-2)
     i = 0
     while i < c:
         debug(bin(i))
         english = words_v[0]
         french = words_v[1]
         for _, s in enumerate(words_v[2:]):
             which = (i & (1<<_))
             if which:
                 english |= words_v[2+_]
             else:
                 french |= words_v[2+_]
             both = english & french
             if bit_count(both) > min_both:
                 break
                 #i = c
                 #import pdb; pdb.set_trace()
                 #i 
         min_both = min(bit_count(both), min_both)
         i += 1
     return min_both
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     sentences = []
     for _ in range(N):
         sentences.append(f.readline()[:-1])
     #if i == 2:
     #    import pdb; pdb.set_trace()
     v = do_trial(sentences)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8234486/gizzywump/5759940174020608/0/extracted/go.py,2756,113,294,Python,8234486,0,5759940174020608,gizzywump,2015
303,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt1.in""
 INPUT = ""A-large.in""
 #INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 DIRS = {
     ""^"" : (0, -1),
     ""v"" : (0, 1),
     ""<"" : (-1, 0),
     "">"" : (1, 0)
 }
 
 def do_trial(rows):
     count = 0
     height = len(rows)
     width = len(rows[0])
     bad = []
     for _ in range(height):
         row = []
         for _ in range(width):
             row.append(set())
         bad.append(row)
 
     for x in range(width):
         y = 0
         while y < height:
             if rows[y][x] == ""."":
                 y += 1
                 continue
             bad[y][x].add(""^"")
             break
 
     for x in range(width):
         y = height - 1
         while y >= 0:
             if rows[y][x] == ""."":
                 y -= 1
                 continue
             bad[y][x].add(""v"")
             break
 
     for y in range(height):
         x = 0
         while x < width:
             if rows[y][x] == ""."":
                 x += 1
                 continue
             bad[y][x].add(""<"")
             break
 
     for y in range(height):
         x = width - 1
         while x >= 0:
             if rows[y][x] == ""."":
                 x -= 1
                 continue
             bad[y][x].add("">"")
             break
 
     for r in rows:
         debug(r)
 
     for r in bad:
         debug(r)
 
     #import pdb; pdb.set_trace()
     count = 0
     for x in range(width):
         for y in range(height):
             if len(bad[y][x]) >= 4:
                 return ""IMPOSSIBLE""
             if rows[y][x] in bad[y][x]:
                 count += 1
     return count
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, C = [int(x) for x in f.readline().split()]
     rows = []
     for _ in range(R):
         row = f.readline()[:-1]
         rows.append(row)
     v = do_trial(rows)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8234486/gizzywump/5708208098246656/1/extracted/go.py,2595,117,283,Python,8234486,1,5708208098246656,gizzywump,2015
304,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt1.in""
 #INPUT = ""C-large.in""
 #INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 DIRS = {
     ""^"" : (0, -1),
     ""v"" : (0, 1),
     ""<"" : (-1, 0),
     "">"" : (1, 0)
 }
 
 def do_trial(rows):
     count = 0
     height = len(rows)
     width = len(rows[0])
     bad = []
     for _ in range(height):
         row = []
         for _ in range(width):
             row.append(set())
         bad.append(row)
 
     for x in range(width):
         y = 0
         while y < height:
             if rows[y][x] == ""."":
                 y += 1
                 continue
             bad[y][x].add(""^"")
             break
 
     for x in range(width):
         y = height - 1
         while y >= 0:
             if rows[y][x] == ""."":
                 y -= 1
                 continue
             bad[y][x].add(""v"")
             break
 
     for y in range(height):
         x = 0
         while x < width:
             if rows[y][x] == ""."":
                 x += 1
                 continue
             bad[y][x].add(""<"")
             break
 
     for y in range(height):
         x = width - 1
         while x >= 0:
             if rows[y][x] == ""."":
                 x -= 1
                 continue
             bad[y][x].add("">"")
             break
 
     for r in rows:
         debug(r)
 
     for r in bad:
         debug(r)
 
     #import pdb; pdb.set_trace()
     count = 0
     for x in range(width):
         for y in range(height):
             if len(bad[y][x]) >= 4:
                 return ""IMPOSSIBLE""
             if rows[y][x] in bad[y][x]:
                 count += 1
     return count
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, C = [int(x) for x in f.readline().split()]
     rows = []
     for _ in range(R):
         row = f.readline()[:-1]
         rows.append(row)
     v = do_trial(rows)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8234486/gizzywump/5708208098246656/0/extracted/go.py,2596,117,283,Python,8234486,0,5708208098246656,gizzywump,2015
305,go.py,"#!/usr/bin/env python
 
 import collections
 import itertools
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def unhappiness_score(C, R, oa):
     s = 0
     for x in range(C-1):
         for y in range(R):
             if (x,y) in oa and (x+1,y) in oa:
                 s += 1
     for x in range(C):
         for y in range(R-1):
             if (x,y) in oa and (x,y+1) in oa:
                 s += 1
     return s
 
 
 def do_trial(C, R, N):
     pairs = list(itertools.product(range(C), range(R)))
     us = int(1e9)
     for oa in itertools.combinations(pairs, N):
         us = min(us, unhappiness_score(C, R, set(oa)))
     return us
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     C, R, N = [int(x) for x in f.readline().split()]
     v = do_trial(C, R, N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8224486/gizzywump/5769900270288896/0/extracted/go.py,1477,61,168,Python,8224486,0,5769900270288896,gizzywump,2015
306,go.py,"#!/usr/bin/env python
 
 import collections
 import fractions
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""C-small-2-attempt0.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(groups):
     trips = []
     for (D, H, M) in groups:
         for _ in range(H):
             trips.append((D, M+_))
     if len(trips) == 1:
         return 0
     times = []
     for pos, minutes in trips:
         time_once = fractions.Fraction(360 - pos, 360) * minutes
         time_twice = time_once + minutes
         times.append((time_once, time_twice))
     debug(times)
     best_time_twice = min(t[-1] for t in times)
     # deer time = best_time_twice
     count = 0
     for t in times:
         if t[0] >= best_time_twice:
             count += 1
     return count
     worst_time_once = max(t[0] for t in times)
     debug(worst_time_once, best_time_twice)
     if worst_time_once >= best_time_twice:
         return 1
     return 0
     # let's get the fast hiker to catch up with the slow
     
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = [int(x) for x in f.readline().split()]
     groups = []
     for _ in range(N):
         D, H, M = [int(x) for x in f.readline().split()]
         groups.append((D, H, M))
     v = do_trial(groups)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8224486/gizzywump/5662291475300352/1/extracted/go.py,1926,74,219,Python,8224486,1,5662291475300352,gizzywump,2015
307,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""C-large.in""
 #INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial():
     so_far = 0
     while 1:
         #import pdb; pdb.set_trace()
         win_time_wait = X / rate
         buy_time = C / rate
         win_time_buy_1 = buy_time + X / (rate+F)
         if win_time_wait < win_time_buy_1:
             return so_far + win_time_wait
         so_far += buy_time
         rate += F
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     C, F, X = [float(x) for x in f.readline().split()]
     v = do_trial(C, F, X)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8224486/gizzywump/5662291475300352/0/extracted/go.py,1283,53,139,Python,8224486,0,5662291475300352,gizzywump,2015
308,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""A-small-attempt0.in""
 INPUT = ""A-large.in""
 
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def calc_distance():
     MAX = int(1e4) + 2
     m = [MAX] * int(MAX)
     m[0] = 0
     for idx, v in enumerate(m[:-1]):
         m[idx+1] = min(m[idx+1], m[idx] + 1)
         # reverse it
         rm = int(''.join(reversed(str(idx))))
         m[rm] = min(m[rm], m[idx] + 1)
     return m
 
 CD = calc_distance()
 
 def count_down(N, so_far=0):
     if N == 10:
         import pdb; pdb.set_trace()
     while 1:
         s = str(N)
         if len(s) == 1:
             return so_far + N
         rN = int(''.join(reversed(s)))
         ur = 0
         half_s = len(s) // 2
         lh = s[-half_s:]
         s1 = '0' * (half_s-1) + '1'
         if lh == s1 and N != rN:
             ur = 1
         if ur:
             N = int(''.join(reversed(s)))
             so_far += 1
         else:
             diff = int(s[-half_s:]) - int(s1)
             if diff <= 0:
                 diff = 1
             N -= diff
             so_far += diff
 
 def check():
     for i in range(int(1e6)):
         if i == 11111:
             import pdb; pdb.set_trace()
         debug(i, count_down(i), CD[i])
         assert count_down(i) == CD[i]
 
 #check()
 
 def do_trial(N):
     return count_down(N)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     v = do_trial(N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8224486/gizzywump/5688567749672960/1/extracted/go.py,2119,91,240,Python,8224486,1,5688567749672960,gizzywump,2015
309,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def calc_distance():
     MAX = int(1e6) + 2
     m = [MAX] * int(MAX)
     m[0] = 0
     for idx, v in enumerate(m[:-1]):
         m[idx+1] = min(m[idx+1], m[idx] + 1)
         # reverse it
         rm = int(''.join(reversed(str(idx))))
         m[rm] = min(m[rm], m[idx] + 1)
     return m
 
 CD = calc_distance()
 
 def do_trial(N):
     return CD[N]
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     v = do_trial(N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/8224486/gizzywump/5688567749672960/0/extracted/go.py,1253,56,134,Python,8224486,0,5688567749672960,gizzywump,2015
310,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""D-small-attempt1.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 RICH = ""RICHARD""
 GABE = ""GABRIEL""
 
 def do_trial(X, R, C):
     # WLOG, let R <= C
     debug(""X = %d, R, C = %d, %d"" % (X, R, C))
     R, C = min(R, C), max(R, C)
     if R * C % X != 0:
         debug(""size %d x %d is not a multiple of %d"" % (R, C, X))
         return RICH
     if X >= 7:
         # for 7-ominos or higher, Richard always wins by creating a hole
         # .xx
         # x.x
         # xxx
         debug(""X > 7"")
         return RICH
     if X in (1, 2):
         # X = 1: easy
         # X = 2: you can always tile a chessboard
         debug(""X in (1, 2)"")
         return GABE
     if X == 3:
         if R <= 1:
             # choose .x
             #        xx  which is too wide
             return RICH
         return GABE
     if X == 4:
         if R <= 1:
             # rows is 1, R wins as we can pick the T piece
             return RICH
         if R == 2:
             # choose xx.
             #        .xx
             # and then there are an odd number to the right of wherever it's placed
             return RICH
         if R >= 4:
             return GABE
         # so R == 3
         # this means C >= 3
         # C = 3 means % 4 != 0 so this is handled
         # C = 4
         # 4 x 4 is always solvable
         return GABE
 
     # X = 5
     if X == 5:
         if R <= 2:
             # choose x..
             #        xx.
             #        .xx
             return RICH
         if R >= 5:
             return GABE
         # cases:
         # R = 3 or 4
         if R == 3:
             if C == 5:
                 # choose
                 #    x..
                 #    xx.
                 #    .xx
                 return RICH
             # for C == 10, 15 or 20, GABE wins
             return GABE
         # R = 4
         if R == 4:
             return GABE
     # X = 6
     if X == 6:
         pass
 
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     X, R, C= [int(x) for x in f.readline().split()]
     v = do_trial(X, R, C)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/6224486/gizzywump/5658571765186560/0/extracted/go.py,2803,115,403,Python,6224486,0,5658571765186560,gizzywump,2015
311,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-small-attempt2.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(S):
     distribution = [0] * (max(S) + 1)
     for s in S:
         distribution[s] += 1
     minutes = 0
     best_size = int(1e8)
     while len(distribution) > 0:
         best_size = min(best_size, minutes + len(distribution) - 1)
         if minutes >= best_size:
             break
         if distribution[-1] == 0:
             distribution = distribution[:-1]
             continue
         most_cakes = len(distribution) - 1
         debug(""%s: most_cakes is %d, %d minutes, best solution %d"" % (distribution, most_cakes, minutes, best_size))
         if distribution[-1] >= most_cakes:
             # too big... just wait that many minutes
             minutes += most_cakes
             break
         s1, s2 = (most_cakes + 1) // 2, most_cakes // 2
         distribution[s1] += distribution[most_cakes]
         distribution[s2] += distribution[most_cakes]
         minutes += distribution[most_cakes]
         distribution[most_cakes] = 0
         
     return best_size
 
 def do_trial(S):
     distribution = [0] * (max(S) + 1)
     for s in S:
         distribution[s] += 1
     best_time = 10000
     current_time = 0
     while 1:
         if len(distribution) == 0:
             return best_time
         if distribution[-1] == 0:
             distribution = distribution[:-1]
             continue
         if current_time >= best_time:
             return best_time
         most_pancakes = len(distribution) - 1
         best_time = min(best_time, current_time + most_pancakes)
         redistributed = distribution[-1]
         current_time += redistributed
         p1 = most_pancakes//2
         p2 = (most_pancakes+1)//2
         distribution[p1] += redistributed
         distribution[p2] += redistributed
         distribution[-1] = 0
 
 
 def do_trial(S):
     distribution = [0] * (max(S) + 1)
     for s in S:
         distribution[s] += 1
     #import pdb; pdb.set_trace()
     return best_time(tuple(distribution))
 
 
 def best_time(distribution, give_up_time=100000):
     debug(distribution, give_up_time)
     if len(distribution) == 0:
         return 0
     if distribution[-1] == 0:
         return best_time(distribution[:-1], give_up_time)
     most_pancakes = len(distribution) - 1
     if most_pancakes == 1:
         return 1
     just_eat_time = most_pancakes
     if just_eat_time > give_up_time:
         return just_eat_time
     plate_count_to_redistribute = distribution[-1]
     p1 = most_pancakes//2
     p2 = (most_pancakes+1)//2
     distribution[p1] += plate_count_to_redistribute
     distribution[p2] += plate_count_to_redistribute
     return min(plate_count_to_redistribute+best_time(distribution[:-1], just_eat_time), just_eat_time)
 
 
 #@Memoize
 def best_time(distribution):
     debug(""dist = %s"" % str(distribution))
     #import pdb; pdb.set_trace()
     # handle all pancakes gone
     if len(distribution) <= 1:
         return 0
     # no one has len(distribution) - 1 pancakes
     if distribution[-1] == 0:
         return best_time(distribution[:-1])
     # not a special minute
     d = [0] + list(distribution[2:])
     time_for_unspecial = 1 + best_time(tuple(d))
     # is a special minute (and so are the next distribution[-1])
     plate_count_to_redistribute = distribution[-1]
     if plate_count_to_redistribute >= time_for_unspecial:
         return time_for_unspecial
     distribution = list(distribution)
     most_pancakes = len(distribution) - 1
     p1 = most_pancakes//2
     p2 = (most_pancakes+1)//2
     distribution[p1] += plate_count_to_redistribute
     distribution[p2] += plate_count_to_redistribute
     time_for_special = plate_count_to_redistribute + best_time(tuple(distribution[:-1]))
     return min(time_for_special, time_for_unspecial)
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     S = [int(x) for x in f.readline().split()]
     v = do_trial(S)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/6224486/gizzywump/5686275109552128/0/extracted/go.py,4707,148,454,Python,6224486,0,5686275109552128,gizzywump,2015
312,go.py,"#!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""C-small-attempt0.in""
 INPUT = ""C-large.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 #            0     1    2     3    4     5    6     7
 Q_LOOKUP = [""1"", ""-1"", ""i"", ""-i"", ""j"", ""-j"", ""k"", ""-k""]
 Q_LOOKUP_REV = dict((q, idx) for idx, q in enumerate(Q_LOOKUP))
 
 
 def m(a, b):
     M_LOOKUP = [
             [0, 1, 2, 3, 4, 5, 6, 7], # 1
             [1, 0, 3, 2, 5, 4, 7, 6], # -1
             [2, 3, 1, 0, 6, 7, 5, 4], # i
             [3, 2, 0, 1, 7, 6, 4, 5], # -i
             [4, 5, 7, 6, 1, 0, 2, 3], # j
             [5, 4, 6, 7, 0, 1, 3, 2], # -j
             [6, 7, 4, 5, 3, 2, 1, 0], # k
             [7, 6, 5, 4, 2, 3, 0, 1], # -k
     ]
     return M_LOOKUP[a][b]
 
 
 def dump():
     for a in range(8):
         for b in range(8):
             debug(""%s x %s = %s"" % (Q_LOOKUP[a], Q_LOOKUP[b], Q_LOOKUP[m(a, b)]))
 
 dump()
 
 def check_associtivity():
     for a in range(8):
         for b in range(8):
             for c in range(8):
                 debug("" "".join(Q_LOOKUP[x] for x in (a, b, c)))
                 assert m(a, m(b, c)) == m(m(a, b), c)
     debug(""all checked"")
 
 check_associtivity()
 
 
 def do_trial(X, line):
     # check that the total product is -1
     if X > 12:
         X %= 12
         X += 12
     debug(X, line)
     vals = [Q_LOOKUP_REV[x] for x in line]
     prod = 0
     for v in vals:
         prod = m(prod, v)
     t = 0
     for idx in range(X):
         t = m(t, prod)
     debug(""%s ^ %d = %s"" % (line, X, Q_LOOKUP[t]))
     if t != 1:
         debug(""can't make ijk as final product is not -1"")
         return ""NO""
 
     all_vals = vals * X
     p = 0
     # look for i
     for i_idx, v in enumerate(all_vals):
         p = m(p, v)
         if p == 2:
             break
     else:
         debug(""can't make i"")
         return ""NO""
 
     i_idx += 1
 
     p = 0
     for k_idx, v in enumerate(reversed(all_vals)):
         p = m(v, p)
         if p == 6:
             break
     else:
         debug(""can't make k"")
         return ""NO""
     k_idx += 1
     k_idx = len(all_vals) - k_idx
     if i_idx >= k_idx:
         return ""NO""
     debug(""i = %s"" % "" . "".join(Q_LOOKUP[v] for v in all_vals[:i_idx]))
     debug(""j = %s"" % "" . "".join(Q_LOOKUP[v] for v in all_vals[i_idx:k_idx]))
     debug(""k = %s"" % "" . "".join(Q_LOOKUP[v] for v in all_vals[k_idx:]))
     p = 0
     for v in all_vals[i_idx:k_idx]:
         p = m(p, v)
     assert p == 4
     return ""YES""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     L, X = [int(x) for x in f.readline().split()]
     line = f.readline()[:-1]
     v = do_trial(X, line)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/6224486/gizzywump/5670465267826688/1/extracted/go.py,3349,132,473,Python,6224486,1,5670465267826688,gizzywump,2015
313,go.py,"#!/usr/bin/env python
 # -*- coding: utf-8 -*-
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     #return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 #            0     1    2     3    4     5    6     7
 Q_LOOKUP = [""1"", ""-1"", ""i"", ""-i"", ""j"", ""-j"", ""k"", ""-k""]
 Q_LOOKUP_REV = dict((q, idx) for idx, q in enumerate(Q_LOOKUP))
 
 
 def m(a, b):
     M_LOOKUP = [
             [0, 1, 2, 3, 4, 5, 6, 7], # 1
             [1, 0, 3, 2, 5, 4, 7, 6], # -1
             [2, 3, 1, 0, 6, 7, 5, 4], # i
             [3, 2, 0, 1, 7, 6, 4, 5], # -i
             [4, 5, 7, 6, 1, 0, 2, 3], # j
             [5, 4, 6, 7, 0, 1, 3, 2], # -j
             [6, 7, 4, 5, 3, 2, 1, 0], # k
             [7, 6, 5, 4, 2, 3, 0, 1], # -k
     ]
     return M_LOOKUP[a][b]
 
 
 def dump():
     for a in range(8):
         for b in range(8):
             debug(""%s x %s = %s"" % (Q_LOOKUP[a], Q_LOOKUP[b], Q_LOOKUP[m(a, b)]))
 
 dump()
 
 def check_associtivity():
     for a in range(8):
         for b in range(8):
             for c in range(8):
                 debug("" "".join(Q_LOOKUP[x] for x in (a, b, c)))
                 assert m(a, m(b, c)) == m(m(a, b), c)
     debug(""all checked"")
 
 check_associtivity()
 
 
 def do_trial(X, line):
     # check that the total product is -1
     if X > 12:
         X %= 12
         X += 12
     debug(X, line)
     vals = [Q_LOOKUP_REV[x] for x in line]
     prod = 0
     for v in vals:
         prod = m(prod, v)
     t = 0
     for idx in range(X):
         t = m(t, prod)
     debug(""%s ^ %d = %s"" % (line, X, Q_LOOKUP[t]))
     if t != 1:
         debug(""can't make ijk as final product is not -1"")
         return ""NO""
 
     all_vals = vals * X
     p = 0
     # look for i
     for i_idx, v in enumerate(all_vals):
         p = m(p, v)
         if p == 2:
             break
     else:
         debug(""can't make i"")
         return ""NO""
 
     i_idx += 1
 
     p = 0
     for k_idx, v in enumerate(reversed(all_vals)):
         p = m(v, p)
         if p == 6:
             break
     else:
         debug(""can't make k"")
         return ""NO""
     k_idx += 1
     k_idx = len(all_vals) - k_idx
     if i_idx >= k_idx:
         return ""NO""
     debug(""i = %s"" % "" . "".join(Q_LOOKUP[v] for v in all_vals[:i_idx]))
     debug(""j = %s"" % "" . "".join(Q_LOOKUP[v] for v in all_vals[i_idx:k_idx]))
     debug(""k = %s"" % "" . "".join(Q_LOOKUP[v] for v in all_vals[k_idx:]))
     p = 0
     for v in all_vals[i_idx:k_idx]:
         p = m(p, v)
     assert p == 4
     return ""YES""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     L, X = [int(x) for x in f.readline().split()]
     line = f.readline()[:-1]
     v = do_trial(X, line)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/6224486/gizzywump/5670465267826688/0/extracted/go.py,3327,131,470,Python,6224486,0,5670465267826688,gizzywump,2015
314,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny.txt""
 INPUT = ""A-small-attempt0.in""
 INPUT = ""A-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 def do_trial(N, S):
     S = [int(x) for x in S]
     debug(S)
     total_standing = 0
     total_need = 0
     #import pdb; pdb.set_trace()
     for need, standing_round in enumerate(S):
         debug(""round %d: %d standing"" % (need, total_standing))
         if total_standing < need:
             debug(""not enough standing in round %d, adding one here"" % need)
             total_need += 1
             total_standing += 1
         total_standing += standing_round
     return total_need
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, S_list = f.readline().split()
     N = int(N)
     v = do_trial(N, S_list)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/6224486/gizzywump/5639104758808576/1/extracted/go.py,945,42,112,Python,6224486,1,5639104758808576,gizzywump,2015
315,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny.txt""
 INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 def do_trial(N, S):
     S = [int(x) for x in S]
     debug(S)
     total_standing = 0
     total_need = 0
     #import pdb; pdb.set_trace()
     for need, standing_round in enumerate(S):
         debug(""round %d: %d standing"" % (need, total_standing))
         if total_standing < need:
             debug(""not enough standing in round %d, adding one here"" % need)
             total_need += 1
             total_standing += 1
         total_standing += standing_round
     return total_need
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, S_list = f.readline().split()
     N = int(N)
     v = do_trial(N, S_list)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/6224486/gizzywump/5639104758808576/0/extracted/go.py,923,41,109,Python,6224486,0,5639104758808576,gizzywump,2015
316,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-large.in""
 
 def debug(*args):
     sys.stderr.write(str(args) + ""\n"")
 
 #debug = lambda *args: None
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(N, M):
     debug(M)
     assert N == len(M)
     best_rate = 0
     min_eaten = 0
     last_m = M[0]
     for m in M[1:]:
         diff = max(0, last_m - m)
         best_rate = max(best_rate, diff)
         min_eaten += diff
         debug(""%d %d => %d, total now %d, best_rate now %d"" % (last_m, m, diff, min_eaten, best_rate))
         last_m = m
     debug(""******** best_rate is %d"" % best_rate)
 
     eaten_fixed_rate = 0
     last_m = M[0]
     for m in M[1:]:
         eaten = min(last_m, best_rate)
         eaten_fixed_rate += eaten
         debug(""%d %d => %d total now %d"" % (last_m, m, eaten, eaten_fixed_rate))
         last_m = m
     return min_eaten, eaten_fixed_rate
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = [int(x) for x in f.readline().split()]
     M = [int(x) for x in f.readline().split()]
     v = do_trial(N, M)
     print ""Case #%d: %d %d"" % (i+1, v[0], v[1])
",gcj/2015/4224486/gizzywump/6404600001200128/1/extracted/go.py,1691,66,199,Python,4224486,1,6404600001200128,gizzywump,2015
317,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt2.in""
 
 def debug(*args):
     sys.stderr.write(str(args) + ""\n"")
 
 #debug = lambda *args: None
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(N, M):
     debug(M)
     assert N == len(M)
     best_rate = 0
     min_eaten = 0
     last_m = M[0]
     for m in M[1:]:
         diff = max(0, last_m - m)
         best_rate = max(best_rate, diff)
         min_eaten += diff
         debug(""%d %d => %d, total now %d, best_rate now %d"" % (last_m, m, diff, min_eaten, best_rate))
         last_m = m
     debug(""******** best_rate is %d"" % best_rate)
 
     eaten_fixed_rate = 0
     last_m = M[0]
     for m in M[1:]:
         eaten = min(last_m, best_rate)
         eaten_fixed_rate += eaten
         debug(""%d %d => %d total now %d"" % (last_m, m, eaten, eaten_fixed_rate))
         last_m = m
     return min_eaten, eaten_fixed_rate
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, = [int(x) for x in f.readline().split()]
     M = [int(x) for x in f.readline().split()]
     v = do_trial(N, M)
     print ""Case #%d: %d %d"" % (i+1, v[0], v[1])
",gcj/2015/4224486/gizzywump/6404600001200128/0/extracted/go.py,1700,66,199,Python,4224486,0,6404600001200128,gizzywump,2015
318,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-small-attempt1.in""
 INPUT = ""B-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def gcd(a, b):
     while 1:
         if a > b: b,a = a,b
         if a == 0: return b
         b %= a
 
 def gcdm(*args):
     return reduce(gcd, args)
 
 def lcm(a, b):
     return (a*b) / gcd(a,b)
 
 def lcmm(*args):
     return reduce(lcm, args)
 
 def view_at_time(M, T):
     mods = [divmod(T, b) for b in M]
     q = tuple(m[0] for m in mods)
     r = tuple(m[1] for m in mods)
     return q, r
 
 def do_trial(B, N, M):
     haircuts_per_minute = 1/(sum(1.0/m for m in M))
     biggest_m = max(M)
     early_time = int(N * haircuts_per_minute) - biggest_m
     late_time = early_time + biggest_m * 4
 
     while early_time < late_time:
         t = (early_time + late_time) // 2
         debug(""early, t, late_time = %d %d %d"" % (early_time, t, late_time))
         q, r = view_at_time(M, t)
         finished = sum(q)
         if finished >= N:
             late_time = t
         else:
             early_time = t + 1
 
     t -= 1000
     q, r = view_at_time(M, t)
     busy_table = [t - r1 for r1 in r]
     N -= sum(q)
     debug(busy_table, N)
     assert B == len(M)
     while 1:
         smallest_busy = min(busy_table)
         debug(""%s %d %d"" % (busy_table, smallest_busy, N))
         for idx, b in enumerate(busy_table):
             if b == smallest_busy:
                 if N == 1:
                     return idx + 1
                 N -= 1
                 busy_table[idx] += M[idx]
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     B, N = [int(x) for x in f.readline().split()]
     M = [int(x) for x in f.readline().split()]
     v = do_trial(B, N, M)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2015/4224486/gizzywump/5765824346324992/1/extracted/go.py,2407,96,302,Python,4224486,1,5765824346324992,gizzywump,2015
319,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt0.in""
 INPUT = ""A-large.in""
 #INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(N):
     seen = [False] * 10
     for i in range(10000000):
         k = (i+1) * N
         for d in str(k):
             seen[int(d)] = True
         if all(seen):
             return k
     return ""INSOMNIA""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     v = do_trial(N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5652388522229760/1/extracted/go.py,1146,50,121,Python,6254486,1,5652388522229760,gizzywump,2016
320,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 INPUT = ""tiny""
 INPUT = ""A-small-attempt0.in""
 #INPUT = ""C-large.in""
 #INPUT = ""C-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 def do_trial(N):
     seen = [False] * 10
     for i in range(1000):
         k = (i+1) * N
         for d in str(k):
             seen[int(d)] = True
         if all(seen):
             return k
     return ""INSOMNIA""
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     v = do_trial(N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5652388522229760/0/extracted/go.py,1143,50,121,Python,6254486,0,5652388522229760,gizzywump,2016
321,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 
 INPUT = ""tiny""
 INPUT = ""D-small-attempt0.in""
 INPUT = ""D-large.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 def iterate(rng, K):
     v = 0
     for i in rng:
         v *= K
         v += i
     return v
 
 def do_trial(K, C, S):
     if S * C < K:
         return ""IMPOSSIBLE""
 
     r = []
     checked_max = 0
     while checked_max < K:
         rng = list(range(checked_max, min(checked_max + C, K)))
         rng = ([0] * (C - len(rng))) + rng
         v = iterate(rng, K)
         checked_max += C
         r.append(v + 1)
     return ' '.join(str(x) for x in r)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     K, C, S = [int(x) for x in f.readline().split()]
     v = do_trial(K, C, S)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5636311922769920/1/extracted/go.py,879,45,129,Python,6254486,1,5636311922769920,gizzywump,2016
322,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 
 INPUT = ""tiny""
 #INPUT = ""D-large.in""
 INPUT = ""D-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 def iterate(t, K, C):
     v = t
     for i in range(C-1):
         v = v * K + t
     return v
 
 def do_trial(K, C, S):
     r = []
     for t in range(S):
         r.append(iterate(t, K, C) + 1)
     return ' '.join(str(x) for x in r)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     K, C, S = [int(x) for x in f.readline().split()]
     v = do_trial(K, C, S)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5636311922769920/0/extracted/go.py,655,36,99,Python,6254486,0,5636311922769920,gizzywump,2016
323,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""C-large.in""
 #INPUT = ""C-small-attempt1.in""
 
 class Prime(object):
     def __init__(self):
         self.primes = [2]
         self.N = 2
 
     def prime_iter(self, S=2):
         for n in self.primes:
             if n >= S:
                 yield n
         to_check = self.primes[-1]
         while 1:
             to_check += 1
             if self.is_prime(to_check):
                 self.primes.append(to_check)
                 if n >= S:
                     yield to_check
 
     def is_prime(self, n):
         if n in self.primes:
             return True
         if n < self.primes[-1]:
             return False
         for p in self.prime_iter():
             if p * p > n:
                 return True
             if n % p == 0:
                 return False
 
 
 PRIMES = set()
 for i in Prime().prime_iter():
     if i > 10000:
         break
     PRIMES.add(i)
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 def find_next_coin(fv):
     while 1:
         fv_bin = bin(fv)[2:]
         divs = []
         for k in range(2, 11):
             v = int(fv_bin, k)
             for p in PRIMES:
                 if v % p == 0:
                     divs.append(p)
                     if len(divs) == 9:
                         return fv, divs
                     break
             else:
                 break
         fv += 2
 
 def do_trial(N, J):
     fv = (1 << (N-1)) + 1
     out = []
     while len(out) < J:
         fv, divs = find_next_coin(fv)
         out.append((bin(fv)[2:], divs))
         fv += 2
     def rep(o, l):
         return ""%s %s"" % (o, "" "".join(str(d) for d in l))
     return ""\n%s"" % ""\n"".join([rep(o, l) for o, l in out])
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, J = [int(x) for x in f.readline().split()]
     v = do_trial(N, J)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5738606668808192/1/extracted/go.py,2026,89,236,Python,6254486,1,5738606668808192,gizzywump,2016
324,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""C-large.in""
 INPUT = ""C-small-attempt1.in""
 
 class Prime(object):
     def __init__(self):
         self.primes = [2]
         self.N = 2
 
     def prime_iter(self, S=2):
         for n in self.primes:
             if n >= S:
                 yield n
         to_check = self.primes[-1]
         while 1:
             to_check += 1
             if self.is_prime(to_check):
                 self.primes.append(to_check)
                 if n >= S:
                     yield to_check
 
     def is_prime(self, n):
         if n in self.primes:
             return True
         if n < self.primes[-1]:
             return False
         for p in self.prime_iter():
             if p * p > n:
                 return True
             if n % p == 0:
                 return False
 
 
 PRIMES = set()
 for i in Prime().prime_iter():
     if i > 10000:
         break
     PRIMES.add(i)
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 def find_next_coin(fv):
     while 1:
         fv_bin = bin(fv)[2:]
         divs = []
         for k in range(2, 11):
             v = int(fv_bin, k)
             for p in PRIMES:
                 if v % p == 0:
                     divs.append(p)
                     if len(divs) == 9:
                         return fv, divs
                     break
             else:
                 break
         fv += 2
 
 def do_trial(N, J):
     fv = (1 << (N-1)) + 1
     out = []
     while len(out) < J:
         fv, divs = find_next_coin(fv)
         out.append((bin(fv)[2:], divs))
         fv += 2
     def rep(o, l):
         return ""%s %s"" % (o, "" "".join(str(d) for d in l))
     return ""\n%s"" % ""\n"".join([rep(o, l) for o, l in out])
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, J = [int(x) for x in f.readline().split()]
     v = do_trial(N, J)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5738606668808192/0/extracted/go.py,2025,89,236,Python,6254486,0,5738606668808192,gizzywump,2016
325,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 #INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 def do_trial(s):
     count = 0
     last = ""+""
     for c in reversed(s):
         if c != last:
             count += 1
         last = c
     return count
     
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     s = f.readline()[:-1]
     v = do_trial(s)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5634697451274240/1/extracted/go.py,576,35,73,Python,6254486,1,5634697451274240,gizzywump,2016
326,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""B-large.in""
 INPUT = ""B-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 def do_trial(s):
     count = 0
     last = ""+""
     for c in reversed(s):
         if c != last:
             count += 1
         last = c
     return count
     
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     s = f.readline()[:-1]
     v = do_trial(s)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/6254486/gizzywump/5634697451274240/0/extracted/go.py,576,35,73,Python,6254486,0,5634697451274240,gizzywump,2016
327,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-large.in""
 #INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
 
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(S):
     c = collections.Counter(S)
     r = [0] * 10
     r[0] = c[""Z""]
     r[1] = c[""O""] - c[""Z""] - c[""W""] - c[""U""]
     r[2] = c[""W""]
     r[3] = c[""H""] - c[""G""]
     r[4] = c[""U""]
     r[5] = c[""F""] - c[""U""]
     r[6] = c[""X""]
     r[7] = c[""S""] - c[""X""]
     r[8] = c[""G""]
     r[9] = c[""I""] - r[5] - r[6] - r[8]
     l = []
     for i in range(10):
         l.append((""%d"" % i) * r[i])
     return ''.join(l)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     S = f.readline()[:-1]
     v = do_trial(S)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/11254486/gizzywump/5648941810974720/1/extracted/go.py,1326,59,162,Python,11254486,1,5648941810974720,gizzywump,2016
328,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""A-large.in""
 INPUT = ""A-small-attempt0.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
 
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(S):
     c = collections.Counter(S)
     r = [0] * 10
     r[0] = c[""Z""]
     r[1] = c[""O""] - c[""Z""] - c[""W""] - c[""U""]
     r[2] = c[""W""]
     r[3] = c[""H""] - c[""G""]
     r[4] = c[""U""]
     r[5] = c[""F""] - c[""U""]
     r[6] = c[""X""]
     r[7] = c[""S""] - c[""X""]
     r[8] = c[""G""]
     r[9] = c[""I""] - r[5] - r[6] - r[8]
     l = []
     for i in range(10):
         l.append((""%d"" % i) * r[i])
     return ''.join(l)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     S = f.readline()[:-1]
     v = do_trial(S)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/11254486/gizzywump/5648941810974720/0/extracted/go.py,1326,59,162,Python,11254486,0,5648941810974720,gizzywump,2016
329,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""C-small-attempt2.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
 
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def do_trial(pairs):
     remaining = set(pairs)
     fakes = set()
     reals = set()
     #import pdb; pdb.set_trace()
     while len(remaining) > 0:
         count = [collections.Counter(p[i] for p in remaining) for i in range(2)]
         debug(""count"", count)
         uniques = set([p for p in remaining if count[0][p[0]] == 1 or count[1][p[1]] == 1])
         debug(""U "", uniques)
         if len(uniques) == 0:
             ll = [(s, (count[0][s[0]], count[1][s[1]])) for s in remaining]
             #import pdb; pdb.set_trace()
             u1 = min(remaining, key=lambda s: (count[0][s[0]], count[1][s[1]]))
             debug(u1)
             uniques.add(u1)
         s_u = [set(p[i] for p in reals.union(uniques)) for i in range(2)]
         for p in remaining:
             if p in uniques:
                 continue
             if p[0] in s_u[0] and p[1] in s_u[1]:
                 fakes.add(p)
                 continue
         reals.update(uniques)
         remaining.difference_update(uniques)
         remaining.difference_update(fakes)
         debug(""R "", remaining)
     return len(fakes)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     pairs = []
     for _ in range(N):
         pairs.append(tuple(f.readline()[:-1].split()))
     v = do_trial(pairs)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/11254486/gizzywump/5686313294495744/0/extracted/go.py,2116,73,210,Python,11254486,0,5686313294495744,gizzywump,2016
330,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 #INPUT = ""B-small-attempt7.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
 
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def does_match(n, s):
     if len(n) != len(s):
         return False
     for a, b in zip(n, s):
         if a != b and b != '?':
             return False
     return True
 
 
 def do_trial(s1, s2):
     L = len(s1)
     r1 = []
     r2 = []
     r1p = []
     r2p = []
     state = ""min_both""
     switch_idx = None
     for idx, (c1, c2) in enumerate(zip(s1, s2)):
         if c1 == c2 and c2 == '?':
             if state == ""min_both"":
                 r1.append(""0"")
                 r2.append(""0"")
                 r1p.append(""0"")
                 r2p.append(""0"")
                 continue
             elif state == 'min_1':
                 r1.append(""0"")
                 r2.append(""9"")
                 r1p.append(""9"")
                 r2p.append(""0"")
                 continue
             else:
                 r1.append(""9"")
                 r2.append(""0"")
                 r1p.append(""0"")
                 r2p.append(""9"")
                 continue
         if c1 == '?':
             r2.append(c2)
             r2p.append(c2)
             if state == ""min_both"":
                 r1.append(c2)
                 r1p.append(c2)
                 continue
             elif state == 'min_1':
                 r1.append(""0"")
                 r1p.append(""9"")
                 continue
             else:
                 r1.append(""9"")
                 r1p.append(""0"")
                 continue
         if c2 == '?':
             r1.append(c1)
             r1p.append(c1)
             if state == ""min_both"":
                 r2.append(c1)
                 r2p.append(c1)
                 continue
             elif state == 'min_2':
                 r2.append(""0"")
                 r2p.append(""9"")
                 continue
             else:
                 r2.append(""9"")
                 r2p.append(""0"")
                 continue
         # neither is wild
         r1.append(c1)
         r1p.append(c1)
         r2.append(c2)
         r2p.append(c2)
         # change state
         if c1 == c2 or state != ""min_both"":
             continue
         #import pdb; pdb.set_trace()
         if idx > 0:
             switch_idx = idx - 1
         if c1 > c2:
             state = ""min_1""
             continue
         state = ""min_2""
     t1 = int(''.join(r1))
     t2 = int(''.join(r2))
     t1p = int(''.join(r1p))
     t2p = int(''.join(r2p))
     fs = ""%%0%dd"" % L
     #import pdb; pdb.set_trace()
     min_diff = 1e80
     add_factor = 0
     if switch_idx is not None:
         ll = ['0'] * L
         ll[switch_idx] = '1'
         add_factor = int(''.join(ll))
 
     for v1 in sorted([t1-add_factor, t1, t1+add_factor, t1p-add_factor, t1p, t1p+add_factor]):
         if v1 < 0:
             continue
         if not does_match(fs % v1, s1):
             continue
         for v2 in sorted([t2-add_factor, t2, t2+add_factor, t2p-add_factor, t2p, t2p+add_factor]):
             if v2 < 0:
                 continue
             if not does_match(fs % v2, s2):
                 continue
             if abs(v1-v2) < min_diff:
                 bv1, bv2 = v1, v2
                 min_diff = abs(v1-v2)
     return (""%s %s"" % (fs, fs)) % (bv1, bv2)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     s1, s2 = f.readline().split()
     v = do_trial(s1, s2)
     v1 = do_trial(s2, s1)
     if ' '.join(reversed(v1.split())) != v:
         print s1, s2, v, v1
         import pdb; pdb.set_trace()
         print ""OOPS""
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/11254486/gizzywump/5695413893988352/1/extracted/go.py,4237,156,397,Python,11254486,1,5695413893988352,gizzywump,2016
331,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""B-large.in""
 INPUT = ""B-small-attempt7.in""
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
 
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args
 
 def does_match(n, s):
     if len(n) != len(s):
         return False
     for a, b in zip(n, s):
         if a != b and b != '?':
             return False
     return True
 
 
 def do_trial(s1, s2):
     L = len(s1)
     r1 = []
     r2 = []
     r1p = []
     r2p = []
     state = ""min_both""
     switch_idx = None
     for idx, (c1, c2) in enumerate(zip(s1, s2)):
         if c1 == c2 and c2 == '?':
             if state == ""min_both"":
                 r1.append(""0"")
                 r2.append(""0"")
                 r1p.append(""0"")
                 r2p.append(""0"")
                 continue
             elif state == 'min_1':
                 r1.append(""0"")
                 r2.append(""9"")
                 r1p.append(""9"")
                 r2p.append(""0"")
                 continue
             else:
                 r1.append(""9"")
                 r2.append(""0"")
                 r1p.append(""0"")
                 r2p.append(""9"")
                 continue
         if c1 == '?':
             r2.append(c2)
             r2p.append(c2)
             if state == ""min_both"":
                 r1.append(c2)
                 r1p.append(c2)
                 continue
             elif state == 'min_1':
                 r1.append(""0"")
                 r1p.append(""9"")
                 continue
             else:
                 r1.append(""9"")
                 r1p.append(""0"")
                 continue
         if c2 == '?':
             r1.append(c1)
             r1p.append(c1)
             if state == ""min_both"":
                 r2.append(c1)
                 r2p.append(c1)
                 continue
             elif state == 'min_2':
                 r2.append(""0"")
                 r2p.append(""9"")
                 continue
             else:
                 r2.append(""9"")
                 r2p.append(""0"")
                 continue
         # neither is wild
         r1.append(c1)
         r1p.append(c1)
         r2.append(c2)
         r2p.append(c2)
         # change state
         if c1 == c2 or state != ""min_both"":
             continue
         #import pdb; pdb.set_trace()
         if idx > 0:
             switch_idx = idx - 1
         if c1 > c2:
             state = ""min_1""
             continue
         state = ""min_2""
     t1 = int(''.join(r1))
     t2 = int(''.join(r2))
     t1p = int(''.join(r1p))
     t2p = int(''.join(r2p))
     fs = ""%%0%dd"" % L
     #import pdb; pdb.set_trace()
     min_diff = 1e9
     add_factor = 0
     if switch_idx is not None:
         ll = ['0'] * L
         ll[switch_idx] = '1'
         add_factor = int(''.join(ll))
 
     for v1 in sorted([t1-add_factor, t1, t1+add_factor, t1p-add_factor, t1p, t1p+add_factor]):
         if v1 < 0:
             continue
         if not does_match(fs % v1, s1):
             continue
         for v2 in sorted([t2-add_factor, t2, t2+add_factor, t2p-add_factor, t2p, t2p+add_factor]):
             if v2 < 0:
                 continue
             if not does_match(fs % v2, s2):
                 continue
             if abs(v1-v2) < min_diff:
                 bv1, bv2 = v1, v2
                 min_diff = abs(v1-v2)
     return (""%s %s"" % (fs, fs)) % (bv1, bv2)
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     s1, s2 = f.readline().split()
     v = do_trial(s1, s2)
     v1 = do_trial(s2, s1)
     if ' '.join(reversed(v1.split())) != v:
         print s1, s2, v, v1
         import pdb; pdb.set_trace()
         print ""OOPS""
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2016/11254486/gizzywump/5695413893988352/0/extracted/go.py,4236,156,397,Python,11254486,0,5695413893988352,gizzywump,2016
332,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import pdb
 from pdb import set_trace as brk
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 #INPUT = ""B-small-attempt2.in""
 
 
 def debug(*args):
     # return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
 
     def __init__(self, function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args, **kwds)
         try:
             return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args, **kwds)
             return cachedValue
 
     def _getKey(self, *args, **kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def size_to_servings(ra, aa):
     # brk()
     aa *= 10
     min_a = ra * 9
     max_a = ra * 11
     v = int(aa // max_a)
     s = set()
     mn = 1e8
     mx = -1
     while v * min_a <= aa:
         if v * max_a >= aa >= v * min_a:
             mx = v
             mn = min(mn, v)
             #s.add(v)
         v += 1
     if len(s) > 0:
         assert min(s) == mn
         assert max(s) == mx
     debug(""%2.1f %d %2.1f %d %2.1f"" % (aa / max_a, mn, float(aa) / float(ra), mx, aa / min_a))
     return (mn, mx)
 
 
 def fixup(s):
     l = []
     for s1 in s:
         l.append(sorted((a, b) for (a, b) in s1 if a <= b))
     return l
 
 
 def do_trial(recipe, lines):
     debug(recipe, lines)
     servings = [[size_to_servings(ra, ps) for ps in line] for ra, line in zip(recipe, lines)]
     servings = fixup(servings)
     for s in servings:
         debug(""***** "", s)
     count = 0
     while min(len(s) for s in servings) > 0:
         mn, mx = min(s[0] for s in servings)
         debug(""CHECKING %d, %d"" % (mn, mx))
         for s in servings:
             a, b = s[0]
             if b < mn or a > mx:
                 break
         else:
             debug(""GOT IT"")
             count += 1
             for s in servings:
                 s[:] = s[1:]
             continue
         for s in servings:
             if s[0] == (mn, mx):
                 debug(""REMOVING from %s"" % s)
                 s[:] = s[1:]
     return count
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, P = [int(x) for x in f.readline().split()]
     recipe = [int(x) for x in f.readline().split()]
     lines = []
     for _ in range(N):
         lines.append([int(x) for x in f.readline().split()])
     # if i == 84: brk()
     v = do_trial(recipe, lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/5304486/gizzywump/5697460110360576/1/extracted/go.py,2646,109,352,Python,5304486,1,5697460110360576,gizzywump,2017
333,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import pdb
 from pdb import set_trace as brk
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""B-large.in""
 INPUT = ""B-small-attempt2.in""
 
 
 def debug(*args):
     # return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
 
     def __init__(self, function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args, **kwds)
         try:
             return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args, **kwds)
             return cachedValue
 
     def _getKey(self, *args, **kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def size_to_servings(ra, aa):
     # brk()
     aa *= 10
     min_a = ra * 9
     max_a = ra * 11
     v = int(aa // max_a)
     s = set()
     mn = 1e8
     mx = -1
     while v * min_a <= aa:
         if v * max_a >= aa >= v * min_a:
             mx = v
             mn = min(mn, v)
             #s.add(v)
         v += 1
     if len(s) > 0:
         assert min(s) == mn
         assert max(s) == mx
     debug(""%2.1f %d %2.1f %d %2.1f"" % (aa / max_a, mn, float(aa) / float(ra), mx, aa / min_a))
     return (mn, mx)
 
 
 def fixup(s):
     l = []
     for s1 in s:
         l.append(sorted((a, b) for (a, b) in s1 if a <= b))
     return l
 
 
 def do_trial(recipe, lines):
     debug(recipe, lines)
     servings = [[size_to_servings(ra, ps) for ps in line] for ra, line in zip(recipe, lines)]
     servings = fixup(servings)
     for s in servings:
         debug(""***** "", s)
     count = 0
     while min(len(s) for s in servings) > 0:
         mn, mx = min(s[0] for s in servings)
         debug(""CHECKING %d, %d"" % (mn, mx))
         for s in servings:
             a, b = s[0]
             if b < mn or a > mx:
                 break
         else:
             debug(""GOT IT"")
             count += 1
             for s in servings:
                 s[:] = s[1:]
             continue
         for s in servings:
             if s[0] == (mn, mx):
                 debug(""REMOVING from %s"" % s)
                 s[:] = s[1:]
     return count
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, P = [int(x) for x in f.readline().split()]
     recipe = [int(x) for x in f.readline().split()]
     lines = []
     for _ in range(N):
         lines.append([int(x) for x in f.readline().split()])
     # if i == 84: brk()
     v = do_trial(recipe, lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/5304486/gizzywump/5697460110360576/0/extracted/go.py,2646,109,352,Python,5304486,0,5697460110360576,gizzywump,2017
334,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import pdb
 from pdb import set_trace as brk
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-large.in""
 #INPUT = ""A-small-attempt1.in""
 
 
 def debug(*args):
     # return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
 
     def __init__(self, function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args, **kwds)
         try:
             return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args, **kwds)
             return cachedValue
 
     def _getKey(self, *args, **kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def horz_exp(l):
     #brk()
     if all(c=='?' for c in l):
         return l
     for _ in range(len(l)):
         if l[_] != '?':
             break
     fl = l[_]
     l = (fl * _) + l[_:]
     for _ in range(_, len(l)):
         if l[_] == '?':
             l = l[:_] + fl + l[_+1:]
         else:
             fl = l[_]
     return l
 
 
 def vert_exp(lines):
     for _ in range(len(lines)):
         if lines[_][0] != '?':
             fl = lines[_]
             break
 
     l = []
     for _ in range(len(lines)):
         if lines[_][0] != '?':
             fl = lines[_]
         l.append(fl)
     return l
 
 
 def do_trial(lines):
     debug(lines)
     lines = [horz_exp(l) for l in lines]
     lines = vert_exp(lines)
     return '\n' + '\n'.join(lines)
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, C = [int(x) for x in f.readline().split()]
     lines = []
     for _ in range(R):
         lines.append(f.readline()[:-1])
     v = do_trial(lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/5304486/gizzywump/5760761888505856/1/extracted/go.py,1856,89,217,Python,5304486,1,5760761888505856,gizzywump,2017
335,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import pdb
 from pdb import set_trace as brk
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""A-large.in""
 INPUT = ""A-small-attempt1.in""
 
 
 def debug(*args):
     # return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
 
     def __init__(self, function):
         self._cache = {}
         self._callable = function
 
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args, **kwds)
         try:
             return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args, **kwds)
             return cachedValue
 
     def _getKey(self, *args, **kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def horz_exp(l):
     #brk()
     if all(c=='?' for c in l):
         return l
     for _ in range(len(l)):
         if l[_] != '?':
             break
     fl = l[_]
     l = (fl * _) + l[_:]
     for _ in range(_, len(l)):
         if l[_] == '?':
             l = l[:_] + fl + l[_+1:]
         else:
             fl = l[_]
     return l
 
 
 def vert_exp(lines):
     for _ in range(len(lines)):
         if lines[_][0] != '?':
             fl = lines[_]
             break
 
     l = []
     for _ in range(len(lines)):
         if lines[_][0] != '?':
             fl = lines[_]
         l.append(fl)
     return l
 
 
 def do_trial(lines):
     debug(lines)
     lines = [horz_exp(l) for l in lines]
     lines = vert_exp(lines)
     return '\n' + '\n'.join(lines)
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     R, C = [int(x) for x in f.readline().split()]
     lines = []
     for _ in range(R):
         lines.append(f.readline()[:-1])
     v = do_trial(lines)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/5304486/gizzywump/5760761888505856/0/extracted/go.py,1856,89,217,Python,5304486,0,5760761888505856,gizzywump,2017
336,go.py,"#!/usr/bin/env python3
 
 import collections
 
 import math
 import pdb
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-large.in""
 #INPUT = ""A-small-attempt1.in""
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def do_trial(N, P, G):
     G = collections.Counter((g % P) for g in G)
     if P == 2:
         debug(P, G)
         return G[0] + (G[1] + 1) // 2
     if P == 3:
         m1 = min(G[1], G[2])
         m2 = max(G[1], G[2]) - m1
         debug(P, m1, m2, G)
         return G[0] + m1 + (m2 + 2) // 3
     if P == 4:
         m1 = min(G[1], G[3])
         m2 = max(G[1], G[3]) - m1
         debug(P, m1, m2, G)
         extra_1 = m2 % 4
         extra_2 = G[2] % 2
         extra = 0
         if extra_1 >= 2 and extra_2:
             extra = 1
         return G[0] + m1 + (m2 + 3) // 4 + ((G[2] + 1) // 2) + extra
     return 0
 
 
 def p(f, t):
     return [t(x) for x in f.readline().split()]
 
 
 f = open(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, P = p(f, int)
     G = p(f, int)
     v = do_trial(N, P, G)
     print(""Case #%d: %s"" % (i+1, v))
",gcj/2017/5314486/gizzywump/5700919488413696/1/extracted/go.py,1637,72,221,Python,5314486,1,5700919488413696,gizzywump,2017
337,go.py,"#!/usr/bin/env python3
 
 import collections
 
 import math
 import pdb
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""A-large.in""
 INPUT = ""A-small-attempt1.in""
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def do_trial(N, P, G):
     G = collections.Counter((g % P) for g in G)
     if P == 2:
         debug(P, G)
         return G[0] + (G[1] + 1) // 2
     if P == 3:
         m1 = min(G[1], G[2])
         m2 = max(G[1], G[2]) - m1
         debug(P, m1, m2, G)
         return G[0] + m1 + (m2 + 2) // 3
     return 0
 
 
 def p(f, t):
     return [t(x) for x in f.readline().split()]
 
 
 f = open(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, P = p(f, int)
     G = p(f, int)
     v = do_trial(N, P, G)
     print(""Case #%d: %s"" % (i+1, v))
",gcj/2017/5314486/gizzywump/5700919488413696/0/extracted/go.py,1323,62,163,Python,5314486,0,5700919488413696,gizzywump,2017
338,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""B-large.in""
 #INPUT = ""B-small-attempt0.in""
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def is_tidy(n):
     if n < 10:
         return True
     n, last_digit = divmod(n, 10)
     ld = n % 10
     if ld > last_digit:
         return False
     return is_tidy(n)
 
 
 def do_trial(N):
     if is_tidy(N):
         return N
     return do_trial((N // 10) - 1) * 10 + 9
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     v = do_trial(N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/3264486/gizzywump/5633382285312000/1/extracted/go.py,1210,60,132,Python,3264486,1,5633382285312000,gizzywump,2017
339,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""B-large.in""
 INPUT = ""B-small-attempt0.in""
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def is_tidy(n):
     if n < 10:
         return True
     n, last_digit = divmod(n, 10)
     ld = n % 10
     if ld > last_digit:
         return False
     return is_tidy(n)
 
 
 def do_trial(N):
     while not is_tidy(N):
         N -= 1
     return N
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N = int(f.readline()[:-1])
     v = do_trial(N)
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/3264486/gizzywump/5633382285312000/0/extracted/go.py,1184,60,126,Python,3264486,0,5633382285312000,gizzywump,2017
340,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""A-large.in""
 #INPUT = ""A-small-attempt0.in""
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def flip(s):
     s1 = ''
     for c in s:
         s1 += '-' if c == '+' else ""+""
     return s1
 
 
 def do_trial(s, c):
     flips = 0
     while len(s) >= c:
         if s[0] == '+':
             s = s[1:]
             continue
         s = flip(s[:c]) + s[c:]
         flips += 1
     if '-' in s:
         return 'IMPOSSIBLE'
     return flips
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     s, t = f.readline().split()
     v = do_trial(s, int(t))
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/3264486/gizzywump/5736519012712448/1/extracted/go.py,1289,64,146,Python,3264486,1,5736519012712448,gizzywump,2017
341,go.py,"#!/usr/bin/env python
 
 import collections
 
 import math
 import re
 import sys
 
 #sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""A-large.in""
 INPUT = ""A-small-attempt0.in""
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 class Memoize:
     def __init__(self,function):
         self._cache = {}
         self._callable = function
             
     def __call__(self, *args, **kwds):
         cache = self._cache
         key = self._getKey(*args,**kwds)
         try: return cache[key]
         except KeyError:
             cachedValue = cache[key] = self._callable(*args,**kwds)
             return cachedValue
     
     def _getKey(self,*args,**kwds):
         return kwds and (args, ImmutableDict(kwds)) or args    
 
 
 def flip(s):
     s1 = ''
     for c in s:
         s1 += '-' if c == '+' else ""+""
     return s1
 
 
 def do_trial(s, c):
     flips = 0
     while len(s) >= c:
         if s[0] == '+':
             s = s[1:]
             continue
         s = flip(s[:c]) + s[c:]
         flips += 1
     if '-' in s:
         return 'IMPOSSIBLE'
     return flips
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     s, t = f.readline().split()
     v = do_trial(s, int(t))
     print ""Case #%d: %s"" % (i+1, v)
",gcj/2017/3264486/gizzywump/5736519012712448/0/extracted/go.py,1289,64,146,Python,3264486,0,5736519012712448,gizzywump,2017
342,go.py,"#!/usr/bin/env python
 
 import collections
 import heapq
 import sys
 
 sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 INPUT = ""C-large.in""
 #INPUT = ""C-small-1-attempt0.in""
 #INPUT = ""C-small-2-attempt0.in""
 
 
 def debug(*args):
     # return
     sys.stderr.write(str(args) + ""\n"")
 
 
 def do_trial(N, K):
     c = collections.Counter()
     c[N] = 1
     while K > 0:
         debug(""*** %s"" % c)
         v = max(t for t in c.keys() if c[t] > 0)
         v1, v2 = v // 2, (v-1) // 2
         cnt = min(c[v], K)
         c[v] -= cnt
         if c[v] == 0:
             del c[v]
         c[v1] += cnt
         c[v2] += cnt
         K -= cnt
     return v1, v2
     
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, K = [int(x) for x in f.readline().split()]
     v = do_trial(N, K)
     print ""Case #%d: %d %d"" % (i+1, v[0], v[1])
",gcj/2017/3264486/gizzywump/5654742835396608/2/extracted/go.py,862,44,121,Python,3264486,2,5654742835396608,gizzywump,2017
343,go.py,"#!/usr/bin/env python
 
 import heapq
 import sys
 
 sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 #INPUT = ""C-small-1-attempt0.in""
 INPUT = ""C-small-2-attempt0.in""
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 def do_trial(N, K):
     debug(""*** %s %s"" % (N, K))
     l = [-N]
     while K > 0:
         debug(l)
         K -= 1
         v = -heapq.heappop(l)
         v1, v2 = v // 2, (v-1) // 2
         heapq.heappush(l, -v1)
         heapq.heappush(l, -v2)
     return v1, v2
     
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, K = [int(x) for x in f.readline().split()]
     v = do_trial(N, K)
     print ""Case #%d: %d %d"" % (i+1, v[0], v[1])
",gcj/2017/3264486/gizzywump/5654742835396608/1/extracted/go.py,736,39,95,Python,3264486,1,5654742835396608,gizzywump,2017
344,go.py,"#!/usr/bin/env python
 
 import heapq
 import sys
 
 sys.setrecursionlimit(50)
 
 INPUT = ""tiny""
 #INPUT = ""C-large.in""
 INPUT = ""C-small-1-attempt0.in""
 
 
 def debug(*args):
     return
     sys.stderr.write(str(args) + ""\n"")
 
 
 def do_trial(N, K):
     debug(""*** %s %s"" % (N, K))
     l = [-N]
     while K > 0:
         debug(l)
         K -= 1
         v = -heapq.heappop(l)
         v1, v2 = v // 2, (v-1) // 2
         heapq.heappush(l, -v1)
         heapq.heappush(l, -v2)
     return v1, v2
     
 
 
 f = file(INPUT)
 T = int(f.readline()[:-1])
 for i in range(T):
     N, K = [int(x) for x in f.readline().split()]
     v = do_trial(N, K)
     print ""Case #%d: %d %d"" % (i+1, v[0], v[1])
",gcj/2017/3264486/gizzywump/5654742835396608/0/extracted/go.py,702,38,92,Python,3264486,0,5654742835396608,gizzywump,2017
345,00000000000494e5.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def check(r, vals):
    C = len(vals)
    t = [1] * C
    for row in r:
        new = [0] * C
        for _, (v, s) in enumerate(zip(t, row)):
            if s == ""."":
                new[_] += v
            if s == ""/"":
                new[_-1] += v
            if s == ""\\"":
                new[_+1] += v
        t = new

    if t != vals:
        debugger()
    return t == vals


def do_trial(vals):
    ov = list(vals)
    C = len(vals)
    if any(_ == 0 for _ in [vals[0], vals[-1]]) or sum(vals) != C:
        return ""IMPOSSIBLE""
    so_far = []
    so_far.append(""."" * C)

    while any(_ != 1 for _ in vals):
        assert sum(vals) == C
        c = 0
        line = ["".""] * C
        new_vals = list(vals)
        debug(line)
        debug(vals)
        for idx, v in enumerate(vals):
            c += v
            debug(""idx = %d, v = %d, c = %d"" % (idx, v, c))
            if c == idx + 1:
                continue
            elif c <= idx and line[idx] == ""."":
                need = min(idx + 1 - c, vals[idx+1])
                new_vals[idx] += need
                new_vals[idx+1] -= need
                line[idx] = ""\\""
            elif c > idx and line[idx+1] == ""."":
                need = min(c - idx + 1, vals[idx])
                new_vals[idx+1] += need
                new_vals[idx] -= need
                line[idx+1] = ""/""
            debug(new_vals)
            debug("""".join(line))
        so_far.append("""".join(line))
        vals = new_vals

    so_far.reverse()
    r = ""%d\n"" % len(so_far)
    r += ""\n"".join(so_far)
    if not check(so_far, ov):
        return ""IMPOSSIBLE""
    return r


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    C, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,2122,97,287,Python,7706,00000000000494e5,00000000000459f2,gizzywump,2018
346,0000000000048e6c.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def check(r, vals):
    C = len(vals)
    t = [1] * C
    for row in r:
        new = [0] * C
        for _, (v, s) in enumerate(zip(t, row)):
            if s == ""."":
                new[_] += v
            if s == ""/"":
                new[_-1] += v
            if s == ""\\"":
                new[_+1] += v
        t = new

    if t != vals:
        debugger()
    return t == vals


def do_trial(vals):
    ov = list(vals)
    C = len(vals)
    if any(_ == 0 for _ in [vals[0], vals[-1]]) or sum(vals) != C:
        return ""IMPOSSIBLE""
    so_far = []
    so_far.append(""."" * C)

    while any(_ != 1 for _ in vals):
        assert sum(vals) == C
        c = 0
        line = ["".""] * C
        new_vals = list(vals)
        debug(line)
        debug(vals)
        for idx, v in enumerate(vals):
            c += v
            debug(""idx = %d, v = %d, c = %d"" % (idx, v, c))
            if c == idx + 1:
                continue
            elif c <= idx and vals[idx+1] > 0 and line[idx] == ""."":
                new_vals[idx] += 1
                new_vals[idx+1] -= 1
                line[idx] = ""\\""
            elif c > idx and line[idx+1] == ""."" and vals[idx] > 0:
                new_vals[idx+1] += 1
                new_vals[idx] -= 1
                line[idx+1] = ""/""
            debug(new_vals)
            debug("""".join(line))
        so_far.append("""".join(line))
        vals = new_vals

    so_far.reverse()
    r = ""%d\n"" % len(so_far)
    r += ""\n"".join(so_far)
    if not check(so_far, ov):
        return ""IMPOSSIBLE""
    return r


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    C, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,2044,95,279,Python,7706,0000000000048e6c,00000000000459f2,gizzywump,2018
347,00000000000480a4.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(R, B):
    R, B = min(R, B), max(R, B)
    count = 0
    mv = 1
    found = set()
    debugger()
    while True:
        for r in range(mv+1):
            b = mv - r
            if B < b or R < r:
                continue
            R -= r
            B -= b
            count += 1
            found.add((r, b))
        mv += 1
        if R + B < mv:
            break
    debug(""R, B leftover: "", R, B)
    debug(sorted(found))
    assert len(found) == count
    return count



def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    R, B = read(f)
    v = do_trial(R, B)
    print(""Case #%d: %s"" % (i+1, v))
",,973,59,145,Python,7706,00000000000480a4,00000000000459f3,gizzywump,2018
348,0000000000047e1e.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(R, B):
    R, B = min(R, B), max(R, B)
    count = 0
    mv = 1
    found = set()
    debugger()
    while True:
        for r in range(mv+1):
            b = mv - r
            if B < b or R < r:
                break
            R -= r
            B -= b
            count += 1
            found.add((r, b))
        mv += 1
        if R + B < mv:
            break
    debug(sorted(found))
    return count



def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    R, B = read(f)
    v = do_trial(R, B)
    print(""Case #%d: %s"" % (i+1, v))
",,904,57,135,Python,7706,0000000000047e1e,00000000000459f3,gizzywump,2018
349,0000000000047b80.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    C = len(vals)
    if any(_ == 0 for _ in [vals[0], vals[-1]]) or sum(vals) != C:
        return ""IMPOSSIBLE""
    so_far = []
    so_far.append(""."" * C)

    while any(_ != 1 for _ in vals):
        assert sum(vals) == C
        c = 0
        line = ["".""] * C
        new_vals = list(vals)
        debug(line)
        debug(vals)
        for idx, v in enumerate(vals):
            c += v
            debug(""idx = %d, v = %d, c = %d"" % (idx, v, c))
            if c == idx + 1:
                continue
            elif c <= idx and vals[idx+1] > 0 and line[idx] == ""."":
                new_vals[idx] += 1
                new_vals[idx+1] -= 1
                line[idx] = ""\\""
            elif c > idx and line[idx+1] == ""."" and vals[idx] > 0:
                debugger()
                new_vals[idx+1] += 1
                new_vals[idx] -= 1
                line[idx+1] = ""/""
            debug(new_vals)
            debug("""".join(line))
        so_far.append("""".join(line))
        vals = new_vals

    so_far.reverse()
    r = ""%d\n"" % len(so_far)
    r += ""\n"".join(so_far)
    return r


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    C, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1609,74,211,Python,7706,0000000000047b80,00000000000459f2,gizzywump,2018
350,0000000000046fc8.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    C = len(vals)
    if any(_ == 0 for _ in [vals[0], vals[-1]]) or sum(vals) != C:
        return ""IMPOSSIBLE""
    so_far = [""."" * C]

    while any(_ != 1 for _ in vals):
        assert sum(vals) == C
        c = 0
        line = ["".""] * C
        new_vals = list(vals)
        debug(line)
        debug(vals)
        for idx, v in enumerate(vals):
            #debugger()
            c += v
            debug(""idx = %d, v = %d, c = %d"" % (idx, v, c))
            if c == idx + 1:
                continue
            elif c <= idx and vals[idx+1] > 0 and line[idx] == ""."":
                new_vals[idx] += 1
                new_vals[idx+1] -= 1
                line[idx] = ""\\""
            elif line[idx+1] == ""."" and vals[idx] > 0:
                new_vals[idx+1] += 1
                new_vals[idx] -= 1
                line[idx+1] = ""/""
            debug(new_vals)
            debug("""".join(line))
        so_far.append("""".join(line))
        vals = new_vals

    r = ""%d\n"" % len(so_far)
    r += ""\n"".join(reversed(so_far))
    return r


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    C, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1563,72,205,Python,7706,0000000000046fc8,00000000000459f2,gizzywump,2018
351,00000000000463ad.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    C = len(vals)
    if any(_ == 0 for _ in [vals[0], vals[-1]]) or sum(vals) != C:
        return ""IMPOSSIBLE""
    so_far = [""."" * C]

    while any(_ != 1 for _ in vals):
        assert sum(vals) == C
        c = 0
        line = ["".""] * C
        new_vals = list(vals)
        debug(line)
        for idx, v in enumerate(vals):
            #debugger()
            c += v
            debug(""idx = %d, v = %d, c = %d"" % (idx, v, c))
            if c == idx + 1 or v == 0:
                continue
            elif c < idx and line[idx-1] == ""."":
                new_vals[idx-1] += 1
                new_vals[idx] -= 1
                line[idx-1] = ""\\""
            elif c > idx and line[idx+1] == ""."":
                new_vals[idx+1] += 1
                new_vals[idx] -= 1
                line[idx+1] = ""/""
            debug(new_vals)
            debug(line)
        so_far.append("""".join(line))
        vals = new_vals

    r = ""%d\n"" % len(so_far)
    r += ""\n"".join(reversed(so_far))
    return r


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    C, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1521,71,204,Python,7706,00000000000463ad,00000000000459f2,gizzywump,2018
352,0000000000040bcb.PYTHON3,"#!/usr/bin/env python3

import itertools
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    debugger()
    best_weights = [0]
    for v in vals:
        for length, weight in reversed(list(enumerate(best_weights))):
            if weight <= 6 * v:
                new_weight = weight + v
                if len(best_weights) <= length + 1:
                    best_weights.append(new_weight)
                else:
                    best_weights[length+1] = min(best_weights[length+1], new_weight)
    debugger()
    return len(best_weights) - 1


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,981,50,115,Python,7765,0000000000040bcb,000000000003e0a8,gizzywump,2018
353,00000000000402e9.PYTHON3,"#!/usr/bin/env python3

import itertools
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    lws = set([(0, 0)])
    for v in vals:
        extra_lws = []
        for length, weight in lws:
            if weight <= 6 * v:
                extra_lws.append((length+1, weight+v))
        lws.update(extra_lws)
    debugger()
    item = max(lws, key=lambda x: x[0])
    return item[0]


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, = read(f)
    vals = read(f)
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,814,48,108,Python,7765,00000000000402e9,000000000003e0a8,gizzywump,2018
354,000000000003fe9d.PYTHON3,"#!/usr/bin/env python3

from collections import Counter

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def go(T):
    debugger()
    for _ in range(T):
        n = read()[0]
        counts = Counter()
        available = set(range(n))
        for _ in range(n):
            vals = read()[1:]
            wants = set(vals)
            debug(""wants="", wants)
            could_buy = wants.intersection(available)
            debug(""could_buy="", could_buy)
            counts.update(vals)
            debug(""counts="", counts)
            mc = counts.most_common()
            mc.reverse()
            debug(""mc="", mc)
            for c, v in mc:
                if c in could_buy:
                    print(c)
                    debug(""selling c="", c)
                    available.discard(c)
                    break
            else:
                debug(""can't sell anything"")
                print(-1)
            sys.stdout.flush()

    return 0



def read(f=sys.stdin, t=int):
    v = [t(_) for _ in f.readline().split()]
    if v[0] == -1:
        raise ValueError(""oops"")
    return v


if FINAL:
    debugger = lambda *a, **kw: None

f = sys.stdin

T = read(f)[0]
go(T)
",,1285,65,125,Python,7765,000000000003fe9d,000000000003e068,gizzywump,2018
355,000000000003fd13.PYTHON3,"#!/usr/bin/env python3

from collections import Counter

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def go(T):
    debugger()
    for _ in range(T):
        n = read()[0]
        counts = Counter()
        available = set(range(n))
        for _ in range(n):
            vals = read()[1:]
            wants = set(vals)
            debug(""wants="", wants)
            could_buy = wants.intersection(available)
            debug(""could_buy="", could_buy)
            counts.update(vals)
            debug(""counts="", counts)
            mc = counts.most_common()
            mc.reverse()
            debug(""mc="", mc)
            for c, v in mc:
                if c in could_buy:
                    print(c)
                    debug(""selling c="", c)
                    available.discard(c)
                    break
            else:
                debug(""can't sell anything"")
                print(-1)
            sys.stdout.flush()

    return 0



def read(f=sys.stdin, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    debugger = lambda *a, **kw: None

f = sys.stdin

T = read(f)[0]
go(T)
",,1223,62,116,Python,7765,000000000003fd13,000000000003e068,gizzywump,2018
356,000000000003e3a1.PYTHON3,"#!/usr/bin/env python3

from collections import Counter
import itertools
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, words):
    L = len(words[0])
    letter_count = [Counter() for _ in range(L)]
    for c_idx, count in enumerate(letter_count):
        for _, word in enumerate(words):
            count[word[c_idx]] += 1
    lcs = [list(reversed([_[0] for _ in s.most_common()])) for s in letter_count]
    word_set = set(words)
    perms = 1
    for lc in lcs:
        perms *= len(lc)
    if len(word_set) == perms:
        return ""-""
    for _ in (''.join(_) for _ in itertools.product(*lcs)):
        if _ not in word_set:
            return _
    return ""-""


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, L = read(f)
    vals = []
    for _ in range(N):
        vals.append(read(f, str)[0])
    v = do_trial(N, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1157,57,157,Python,7765,000000000003e3a1,000000000003e064,gizzywump,2018
357,000000000003b81e.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    mn_vals = [(d+a, d-b) for d, a, b in vals]
    debug(""mn_vals "", mn_vals)

    runs = []
    mn_runs = {}

    for idx, (m, n) in enumerate(mn_vals):
        debug(""idx m n = %d (%d, %d)"" % (idx, m, n))
        debug(""mn_runs"", mn_runs)
        for k, v in list(mn_runs.items()):
            debug(""k v "", k, v)
            if k[0] != m and k[1] != n:
                if k[0] == None:
                    mn_runs[(m, k[1])] = mn_runs.get((m, k[1]), v)
                elif k[1] == None:
                    mn_runs[(k[0], n)] = mn_runs.get((k[0], n), v)
                else:
                    debug(""adding run (%d, %d) %d to %d"" % (k[0], k[1], v, idx))
                    runs.append((v, idx))
                del mn_runs[k]
        if (m, None) not in mn_runs:
            mn_runs[(m, None)] = idx
        if (None, n) not in mn_runs:
            mn_runs[(None, n)] = idx

    idx = len(mn_vals)
    for k, v in list(mn_runs.items()):
        debug(""adding run (%s, %s) %d to %d"" % (k[0], k[1], v, idx))
        runs.append((v, idx))

    debug(""runs "", runs)
    runs1 = set((r[0], r[1]) for r in runs)
    debug(""runs1 "", runs1)
    sizes = [r[1] - r[0] for r in runs1]
    debug(""sizes "", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,2060,87,282,Python,7764,000000000003b81e,000000000003675b,gizzywump,2018
358,000000000003b6fb.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 0
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    mn_vals = [(d+a, d-b) for d, a, b in vals]
    debug(""mn_vals "", mn_vals)

    runs = []
    mn_runs = {}

    for idx, (m, n) in enumerate(mn_vals):
        debug(""idx m n = %d (%d, %d)"" % (idx, m, n))
        debug(""mn_runs"", mn_runs)
        for k, v in list(mn_runs.items()):
            debug(""k v "", k, v)
            if k[0] != m and k[1] != n:
                if k[0] == None:
                    mn_runs[(m, k[1])] = mn_runs.get((m, k[1]), v)
                elif k[1] == None:
                    mn_runs[(k[0], n)] = mn_runs.get((k[0], n), v)
                else:
                    debug(""adding run (%d, %d) %d to %d"" % (k[0], k[1], v, idx))
                    runs.append((v, idx))
                del mn_runs[k]
        if (m, None) not in mn_runs:
            mn_runs[(m, None)] = idx
        if (None, n) not in mn_runs:
            mn_runs[(None, n)] = idx

    idx = len(mn_vals)
    for k, v in list(mn_runs.items()):
        debug(""adding run (%s, %s) %d to %d"" % (k[0], k[1], v, idx))
        runs.append((v, idx))

    debug(""runs "", runs)
    runs1 = set((r[0], r[1]) for r in runs)
    debug(""runs1 "", runs1)
    sizes = [r[1] - r[0] for r in runs1]
    debug(""sizes "", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,2060,87,282,Python,7764,000000000003b6fb,000000000003675b,gizzywump,2018
359,000000000003b430.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, vals):
    debug(""vals "", vals)
    debug(""N "", N)
    remaining = N - sum(vals)
    debug(""remaining "", remaining)

    max_to_add = 0
    for _ in range(N):
        if 2 * ((_ * 100) % N) >= N:
            max_to_add = _
            break

    debug(""max_to_add "", max_to_add)

    #debugger()
    to_adds = []
    for idx, v in enumerate(vals):
        for to_add in range(max_to_add):
            if 2 * (((v + to_add) * 100) % N) >= N:
                break
        else:
            to_add = 0
        to_adds.append((to_add, idx))
    to_adds.sort(key=lambda x: x[0])
    for to_add, idx in to_adds:
        v = vals[idx]
        to_add = min(to_add, remaining)
        debug(""incrementing %d by %d"" % (v, to_add))
        vals[idx] += to_add
        remaining -= to_add
        debug(""remaining "", remaining)
        if remaining == 0:
            break
    half_percent = max(1, max_to_add)
    debug(""half_percent "", half_percent)
    extra_count = remaining // half_percent
    vals.extend([half_percent] * extra_count)
    debug(""extra_count "", extra_count)
    remaining -= half_percent * extra_count
    debug(""remaining "", remaining)
    vals.append(remaining)
    debug(""vals "", vals)
    percents = [int(_ * 100. / N + 0.5) for _ in vals]
    debug(""percents "", percents)
    total = sum(percents)
    return total


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, L = read(f)
    vals = read(f)
    v = do_trial(N, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1851,83,234,Python,7764,000000000003b430,0000000000036601,gizzywump,2018
360,000000000003b442.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, vals):
    debug(""vals "", vals)
    debug(""N "", N)
    remaining = N - sum(vals)
    debug(""remaining "", remaining)

    max_to_add = 0
    for _ in range(N):
        if 2 * ((_ * 100) % N) >= N:
            max_to_add = _
            break

    debug(""max_to_add "", max_to_add)

    #debugger()
    to_adds = []
    for idx, v in enumerate(vals):
        for to_add in range(max_to_add):
            if 2 * (((v + to_add) * 100) % N) >= N:
                break
        else:
            to_add = 0
        to_adds.append((to_add, idx))
    to_adds.sort(key=lambda x: -x[0])
    for to_add, idx in to_adds:
        v = vals[idx]
        to_add = min(to_add, remaining)
        debug(""incrementing %d by %d"" % (v, to_add))
        vals[idx] += to_add
        remaining -= to_add
        debug(""remaining "", remaining)
        if remaining == 0:
            break
    half_percent = max(1, max_to_add)
    debug(""half_percent "", half_percent)
    extra_count = remaining // half_percent
    vals.extend([half_percent] * extra_count)
    debug(""extra_count "", extra_count)
    remaining -= half_percent * extra_count
    debug(""remaining "", remaining)
    vals.append(remaining)
    debug(""vals "", vals)
    percents = [int(_ * 100. / N + 0.5) for _ in vals]
    debug(""percents "", percents)
    total = sum(percents)
    return total


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, L = read(f)
    vals = read(f)
    v = do_trial(N, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1852,83,234,Python,7764,000000000003b442,0000000000036601,gizzywump,2018
361,000000000003ad6a.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""

#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    mn_vals = [(d+a, d-b) for d, a, b in vals]
    debug(""mn_vals "", mn_vals)

    runs = []
    mn_runs = {}

    for idx, (m, n) in enumerate(mn_vals):
        debug(""idx m n = %d (%d, %d)"" % (idx, m, n))
        debug(""mn_runs"", mn_runs)
        for k, v in list(mn_runs.items()):
            debug(""k v "", k, v)
            if k[0] != m and k[1] != n:
                if k[0] == None:
                    mn_runs[(m, k[1])] = mn_runs.get((m, k[1]), v)
                elif k[1] == None:
                    mn_runs[(k[0], n)] = mn_runs.get((k[0], n), v)
                else:
                    debug(""adding run (%d, %d) %d to %d"" % (k[0], k[1], v, idx))
                    runs.append((v, idx))
                del mn_runs[k]
        if (m, None) not in mn_runs:
            mn_runs[(m, None)] = idx
        if (None, n) not in mn_runs:
            mn_runs[(None, n)] = idx
        mn_runs[(None, n)] = idx

    idx = len(mn_vals)
    for k, v in list(mn_runs.items()):
        debug(""adding run (%s, %s) %d to %d"" % (k[0], k[1], v, idx))
        runs.append((v, idx))

    debug(""runs "", runs)
    runs1 = set((r[0], r[1]) for r in runs)
    debug(""runs1 "", runs1)
    sizes = [r[1] - r[0] for r in runs1]
    debug(""sizes "", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))

def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    mn_vals = [(d+a, d-b) for d, a, b in vals]
    debug(""mn_vals "", mn_vals)

    runs = []
    mn_runs = {}

    for idx, (m, n) in enumerate(mn_vals):
        debug(""idx m n = %d (%d, %d)"" % (idx, m, n))
        debug(""mn_runs"", mn_runs)
        for k, v in list(mn_runs.items()):
            debug(""k v "", k, v)
            if k[0] != m and k[1] != n:
                if k[0] == None:
                    mn_runs[(m, k[1])] = v
                elif k[1] == None:
                    mn_runs[(k[0], n)] = v
                else:
                    debug(""adding run (%d, %d) %d to %d"" % (k[0], k[1], v, idx))
                    runs.append((v, idx))
                del mn_runs[k]
        if (m, None) not in mn_runs:
            mn_runs[(m, None)] = idx
        if (None, n) not in mn_runs:
            mn_runs[(None, n)] = idx
        mn_runs[(None, n)] = idx

    idx = len(mn_vals)
    for k, v in list(mn_runs.items()):
        debug(""adding run (%s, %s) %d to %d"" % (k[0], k[1], v, idx))
        runs.append((v, idx))

    debug(""runs "", runs)
    runs1 = set((r[0], r[1]) for r in runs)
    debug(""runs1 "", runs1)
    sizes = [r[1] - r[0] for r in runs1]
    debug(""sizes "", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,4138,175,568,Python,7764,000000000003ad6a,000000000003675b,gizzywump,2018
362,000000000003a82f.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    mn_vals = [(d+a, d-b) for d, a, b in vals]
    debug(""mn_vals "", mn_vals)

    runs = []
    mn_runs = {}

    for idx, (m, n) in enumerate(mn_vals):
        debug(""idx m n = %d (%d, %d)"" % (idx, m, n))
        debug(""mn_runs"", mn_runs)
        for k, v in list(mn_runs.items()):
            debug(""k v "", k, v)
            if k[0] != m and k[1] != n:
                if k[0] == None:
                    mn_runs[(m, k[1])] = v
                elif k[1] == None:
                    mn_runs[(k[0], n)] = v
                else:
                    debug(""adding run (%d, %d) %d to %d"" % (k[0], k[1], v, idx))
                    runs.append((v, idx))
                del mn_runs[k]
        if (m, None) not in mn_runs:
            mn_runs[(m, None)] = idx
        if (None, n) not in mn_runs:
            mn_runs[(None, n)] = idx
        mn_runs[(None, n)] = idx

    idx = len(mn_vals)
    for k, v in list(mn_runs.items()):
        debug(""adding run (%s, %s) %d to %d"" % (k[0], k[1], v, idx))
        runs.append((v, idx))

    debug(""runs "", runs)
    runs1 = set((r[0], r[1]) for r in runs)
    debug(""runs1 "", runs1)
    sizes = [r[1] - r[0] for r in runs1]
    debug(""sizes "", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,2045,88,282,Python,7764,000000000003a82f,000000000003675b,gizzywump,2018
363,0000000000038402.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 0
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    eq1 = make_eq_classes(vals, lambda d, a, b: d + a)
    debug(""eq1 "", eq1)
    eq2 = make_eq_classes(vals, lambda d, a, b: d - b)
    debug(""eq2 "", eq2)

    runs = set()
    for e1 in eq1.values():
        for e2 in eq2.values():
            e = e1.union(e2)
            r = tuple(sorted(e))
            if r == tuple(range(r[0], r[-1]+1)):
                runs.add(r)
    debug(""runs"", runs)
    sizes = [len(r) for r in runs]
    debug(""sizes"", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1309,67,181,Python,7764,0000000000038402,000000000003675b,gizzywump,2018
364,000000000003817a.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, vals):
    debug(""vals "", vals)
    debug(""N "", N)
    remaining = N - sum(vals)
    debug(""remaining "", remaining)

    max_to_add = 0
    for _ in range(N):
        if 2 * ((_ * 100) % N) >= N:
            max_to_add = _
            break

    debug(""max_to_add "", max_to_add)

    #debugger()
    for idx, v in enumerate(vals):
        for to_add in range(min(remaining+1, max_to_add)):
            if 2 * (((v + to_add) * 100) % N) >= N:
                break
        else:
            to_add = 0
        debug(""incrementing %d by %d"" % (v, to_add))
        vals[idx] += to_add
        remaining -= to_add
        debug(""remaining "", remaining)
    half_percent = max(1, max_to_add)
    debug(""half_percent "", half_percent)
    extra_count = remaining // half_percent
    vals.extend([half_percent] * extra_count)
    debug(""extra_count "", extra_count)
    remaining -= half_percent * extra_count
    debug(""remaining "", remaining)
    vals.append(remaining)
    debug(""vals "", vals)
    percents = [int(_ * 100. / N + 0.5) for _ in vals]
    debug(""percents "", percents)
    total = sum(percents)
    return total


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, L = read(f)
    vals = read(f)
    v = do_trial(N, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1638,75,210,Python,7764,000000000003817a,0000000000036601,gizzywump,2018
365,0000000000037e8b.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, vals):
    debug(""vals "", vals)
    debug(""N "", N)
    remaining = N - sum(vals)
    debug(""remaining "", remaining)

    max_to_add = 0
    for _ in range(N):
        if 2 * ((_ * 100) % N) >= N:
            max_to_add = _
            break

    debug(""max_to_add "", max_to_add)

    debugger()
    for idx, v in enumerate(vals):
        for to_add in range(min(remaining, max_to_add) + 1):
            if 2 * (((v + to_add) * 100) % N) >= N:
                break
        else:
            to_add = 0
        debug(""incrementing %d by %d"" % (v, to_add))
        vals[idx] += to_add
        remaining -= to_add
        debug(""remaining "", remaining)
    half_percent = max(1, max_to_add)
    extra_count = remaining // half_percent
    vals.extend([half_percent] * extra_count)
    remaining -= half_percent * extra_count
    debug(""remaining "", remaining)
    vals.append(remaining)
    debug(""vals "", vals)
    percents = [int(_ * 100. / N + 0.5) for _ in vals]
    debug(""percents "", percents)
    total = sum(percents)
    return total


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, L = read(f)
    vals = read(f)
    v = do_trial(N, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1559,73,206,Python,7764,0000000000037e8b,0000000000036601,gizzywump,2018
366,0000000000037ba4.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def make_eq_classes(vals, f):
    d = collections.defaultdict(set)
    for idx, v in enumerate(vals):
        d[f(*v)].add(idx)
    return d


def do_trial(S, vals):
    debug(""S "", S)
    debug(""vals "", vals)

    eq1 = make_eq_classes(vals, lambda d, a, b: d + a)
    debug(""eq1 "", eq1)
    eq2 = make_eq_classes(vals, lambda d, a, b: d - b)
    debug(""eq2 "", eq2)

    runs = set()
    for e1 in eq1.values():
        for e2 in eq2.values():
            e = e1.union(e2)
            if len(e) + min(e) == max(e) + 1:
                runs.add(tuple(sorted(e)))
    debug(""runs"", runs)
    sizes = [len(r) for r in runs]
    debug(""sizes"", sizes)
    m = max(sizes)
    c = sum(1 for _ in sizes if _ == m)
    return ""%s %s"" % (m, c)


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)
T = read(f)[0]
for i in range(T):
    S, = read(f)
    vals = []
    for _ in range(S):
        vals.append(read(f))
    v = do_trial(S, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1288,66,181,Python,7764,0000000000037ba4,000000000003675b,gizzywump,2018
367,0000000000036e2b.PYTHON3,"#!/usr/bin/env python3

import heapq
import sys

from pdb import set_trace as debugger


FINAL = 1
INPUT = ""tiny""


def debug(*args):
    if FINAL:
        return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, vals):
    debug(""vals "", vals)
    debug(""N "", N)
    remaining = N - sum(vals)
    debug(""remaining "", remaining)

    max_to_add = 0
    for _ in range(N):
        if 2 * ((_ * 100) % N) >= N:
            max_to_add = _
            break

    debug(""max_to_add "", max_to_add)

    debugger()
    for idx, v in enumerate(vals):
        for to_add in range(min(remaining, max_to_add) + 1):
            if 2 * (((v + to_add) * 100) % N) >= N:
                break
        else:
            to_add = 0
        debug(""incrementing %d by %d"" % (v, to_add))
        vals[idx] += to_add
        remaining -= to_add
        debug(""remaining "", remaining)
    half_percent = max(1, max_to_add)
    extra_count = remaining // half_percent
    vals.extend([half_percent] * extra_count)
    remaining -= half_percent * extra_count
    debug(""remaining "", remaining)
    vals.append(remaining)
    debug(""vals "", vals)
    percents = [int(_ * 100 / N + 0.5) for _ in vals]
    debug(""percents "", percents)
    total = sum(percents)
    return total


def read(f, t=int):
    return [t(_) for _ in f.readline().split()]


if FINAL:
    f = sys.stdin
    debugger = lambda *a, **kw: None
else:
    f = open(INPUT)

T = read(f)[0]
for i in range(T):
    N, L = read(f)
    vals = read(f)
    v = do_trial(N, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1558,73,206,Python,7764,0000000000036e2b,0000000000036601,gizzywump,2018
368,0000000000035303.PYTHON3,"#!/usr/bin/env python3

import collections

import heapq
import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def times_for_ic(items, cashiers):
    return [p + s * i if i > 0 else 0 for i, (m, s, p) in zip(items, cashiers)]


def do_trial(R, B, cashiers):
    cashiers.sort(key=lambda c: -c[1])
    items = [min(m, B) for m, s, p in cashiers]

    while 1:
        times = times_for_ic(items, cashiers)
        total = sum(heapq.nlargest(R, items))
        debug(""R "", R)
        debug(""B "", B)
        debug(""items "", items)
        debug(""times "", times)
        debug(""total "", total)
        biggest_time = max(times)
        debug(""biggest_time "", biggest_time)
        item_remove_count = total - B
        debug(""item_remove_count "", item_remove_count)
        if item_remove_count == 0:
            break
        for _, (m, s, p) in enumerate(cashiers):
            if times[_] == biggest_time:
                items[_] -= 1
                item_remove_count -= 1
                debug(""removing from "", _)
                if item_remove_count == 0:
                    break
    return max(times)


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    R, B, C = [int(_) for _ in f.readline().split()]
    cashiers = []
    for _ in range(C):
        cashiers.append([int(_) for _ in f.readline().split()])
    v = do_trial(R, B, cashiers)
    print(""Case #%d: %s"" % (i+1, v))
",,2058,81,228,Python,0000000000007883,0000000000035303,000000000002fff6,gizzywump,2018
369,0000000000034d87.PYTHON3,"#!/usr/bin/env python3

import collections

import heapq
import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def times_for_ic(items, cashiers):
    return [p + s * i if i > 0 else 0 for i, (m, s, p) in zip(items, cashiers)]


def do_trial(R, B, cashiers):
    items = [min(m, B) for m, s, p in cashiers]

    while 1:
        times = times_for_ic(items, cashiers)
        total = sum(heapq.nlargest(R, items))
        debug(""R "", R)
        debug(""B "", B)
        debug(""items "", items)
        debug(""times "", times)
        debug(""total "", total)
        time_set = set(times)
        biggest_time = max(time_set)
        debug(""biggest_time "", biggest_time)
        item_remove_count = total - B
        debug(""item_remove_count "", item_remove_count)
        if item_remove_count == 0:
            break
        for _, (m, s, p) in enumerate(cashiers):
            if times[_] == biggest_time:
                items[_] -= 1
                item_remove_count -= 1
                debug(""removing from "", _)
                if item_remove_count == 0:
                    break
    return max(times)


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    R, B, C = [int(_) for _ in f.readline().split()]
    cashiers = []
    for _ in range(C):
        cashiers.append([int(_) for _ in f.readline().split()])
    v = do_trial(R, B, cashiers)
    print(""Case #%d: %s"" % (i+1, v))
",,2052,81,228,Python,0000000000007883,0000000000034d87,000000000002fff6,gizzywump,2018
370,0000000000034572.PYTHON3,"#!/usr/bin/env python3

import collections

import heapq
import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def times_for_ic(items, cashiers):
    return [p + s * i if i > 0 else 0 for i, (m, s, p) in zip(items, cashiers)]


def do_trial(R, B, cashiers):
    #debugger()

    items = [min(m, B) for m, s, p in cashiers]

    while 1:
        times = times_for_ic(items, cashiers)
        total = sum(heapq.nlargest(R, items))
        debug(""R "", R)
        debug(""B "", B)
        debug(""items "", items)
        debug(""times "", times)
        debug(""total "", total)
        time_set = set(times)
        biggest_time, second_biggest = heapq.nlargest(2, time_set)
        debug(""biggest_time "", biggest_time)
        debug(""second_biggest "", second_biggest)
        difference = biggest_time - second_biggest
        item_remove_count = (total - B) // sum(1 if t == biggest_time else 0 for t in times)
        debug(""item_remove_count "", item_remove_count)
        if item_remove_count == 0:
            break
        for _, (m, s, p) in enumerate(cashiers):
            if times[_] == biggest_time:
                items[_] -= 1
                debug(""removing from "", _)
    return max(times)


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    R, B, C = [int(_) for _ in f.readline().split()]
    cashiers = []
    for _ in range(C):
        cashiers.append([int(_) for _ in f.readline().split()])
    v = do_trial(R, B, cashiers)
    print(""Case #%d: %s"" % (i+1, v))
",,2146,82,243,Python,0000000000007883,0000000000034572,000000000002fff6,gizzywump,2018
371,0000000000033708.PYTHON3,"#!/usr/bin/env python3

import collections

import heapq
import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def times_for_ic(items, cashiers):
    return [p + s * i if i > 0 else 0 for i, (m, s, p) in zip(items, cashiers)]


def do_trial(R, B, cashiers):
    #debugger()

    items = [min(m, B) for m, s, p in cashiers]

    while 1:
        times = times_for_ic(items, cashiers)
        total = sum(heapq.nlargest(R, items))
        debug(""R "", R)
        debug(""B "", B)
        debug(""items "", items)
        debug(""times "", times)
        debug(""total "", total)
        biggest_time_idx = max(range(len(times)), key=lambda _: times[_])
        _, second = heapq.nlargest(2, times)
        difference = times[biggest_time_idx] - second
        m, s, p = cashiers[biggest_time_idx]
        item_diff = min(total - B, (difference + s - 1) // s)
        items[biggest_time_idx] -= item_diff
        if item_diff == 0:
            break
    return max(times)


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    R, B, C = [int(_) for _ in f.readline().split()]
    cashiers = []
    for _ in range(C):
        cashiers.append([int(_) for _ in f.readline().split()])
    v = do_trial(R, B, cashiers)
    print(""Case #%d: %s"" % (i+1, v))
",,1910,77,222,Python,0000000000007883,0000000000033708,000000000002fff6,gizzywump,2018
372,0000000000030771.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def validate(h_list, v_list, lines, each):
    pass


def do_trial(H, V, lines):
    pieces = (H + 1) * (V + 1)
    line_counts = [collections.Counter(line) for line in lines]
    c = collections.Counter()
    for line in line_counts:
        c[""@""] += line[""@""]
    each, leftover = divmod(c[""@""], pieces)

    if c[""@""] == 0 and each == 0:
        return ""POSSIBLE""

    row_counts = [collections.Counter() for _ in range(len(lines[0]))]
    for _, rc in enumerate(row_counts):
        for line in lines:
            rc.update(line[_])

    if leftover != 0:
        return ""IMPOSSIBLE""

    h_list = []
    target = each * (V + 1)
    so_far = 0
    for v in range(len(lines)):
        so_far += line_counts[v][""@""]
        if so_far == target:
            so_far = 0
            h_list.append(v)
    for _ in lines:
        debug(_)
    debug(""h list : "", h_list)
    if so_far != 0 or len(h_list) != H + 1:
        return ""IMPOSSIBLE""

    v_list = []
    target = each
    so_far = [0] * len(h_list)
    for h in range(len(row_counts)):
        sf_idx = 0
        for v in range(len(lines)):
            if lines[v][h] == ""@"":
                so_far[sf_idx] += 1
            if v in h_list:
                sf_idx += 1
        debug(""so_far : "", so_far)
        if all(_ == each for _ in so_far):
            v_list.append(v)
            so_far = [0] * len(h_list)
    debug(""v list : "", v_list)
    if all(_ == each for _ in so_far) or len(v_list) != V + 1:
        return ""IMPOSSIBLE""

    return ""POSSIBLE""


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    R, C, H, V = [int(_) for _ in f.readline().split()]
    lines = [f.readline()[:-1] for _ in range(R)]
    v = do_trial(H, V, lines)
    print(""Case #%d: %s"" % (i+1, v))
",,2561,105,317,Python,0000000000007883,0000000000030771,000000000003005a,gizzywump,2018
373,00000000000306af.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def validate(h_list, v_list, lines, each):
    pass


def do_trial(H, V, lines):
    pieces = (H + 1) * (V + 1)
    line_counts = [collections.Counter(line) for line in lines]
    c = collections.Counter()
    for line in line_counts:
        c[""@""] += line[""@""]
    each, leftover = divmod(c[""@""], pieces)

    if c[""@""] == 0 and each == 0:
        return ""POSSIBLE""

    row_counts = [collections.Counter() for _ in range(len(lines[0]))]
    for _, rc in enumerate(row_counts):
        for line in lines:
            rc.update(line[_])

    if leftover != 0:
        return ""IMPOSSIBLE""

    h_list = []
    target = each * (V + 1)
    so_far = 0
    for v in range(len(lines)):
        so_far += line_counts[v][""@""]
        if so_far == target:
            so_far = 0
            h_list.append(v)
    for _ in lines:
        debug(_)
    debug(""h list : "", h_list)
    if so_far != 0 or len(h_list) != H + 1:
        return ""IMPOSSIBLE""

    v_list = []
    target = each
    so_far = [0] * len(h_list)
    for h in range(len(row_counts)):
        sf_idx = 0
        for v in range(len(lines)):
            if lines[v][h] == ""@"":
                so_far[sf_idx] += 1
            if v in h_list:
                sf_idx += 1
        debug(""so_far : "", so_far)
        if all(_ == each for _ in so_far):
            v_list.append(v)
            so_far = [0] * len(h_list)
    debug(""v list : "", v_list)
    if all(_ == each for _ in so_far) or len(v_list) != V + 1:
        return ""IMPOSSIBLE""

    return ""POSSIBLE""


f = sys.stdin #open(INPUT, ""rb"")
f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    R, C, H, V = [int(_) for _ in f.readline().split()]
    lines = [f.readline()[:-1] for _ in range(R)]
    v = do_trial(H, V, lines)
    print(""Case #%d: %s"" % (i+1, v))
",,2560,105,317,Python,0000000000007883,00000000000306af,000000000003005a,gizzywump,2018
374,000000000000a025.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


SQRT2 = math.sqrt(2)

def do_trial(A):
    theta = math.asin(A / SQRT2)
    alpha = theta - math.pi / 4
    ca = math.cos(alpha) / 2.0
    sa = math.sin(alpha) / 2.0
    matrix = [[ca, sa, 0], [-sa, ca, 0], [0, 0, 1.0/2]]
    lines = ["" "".join(""%f"" % m for m in row) for row in matrix]
    return ""\n"" + ""\n"".join(lines)


f_in = sys.stdin
T = int(f_in.readline()[:-1])
for i in range(T):
    A = float(f_in.readline()[:-1])
    v = do_trial(A)
    print(""Case #%d: %s"" % (i+1, v))
",,670,35,100,Python,00000000000000cb,000000000000a025,00000000000079cc,gizzywump,2018
375,0000000000009aa7.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def read_two_int(f_in):
    return tuple(int(_) for _ in f_in.readline().split())


def find_best(convolution, X0, Y0, width, height):
    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    p = max(points, key=lambda p: convolution[p[0]*1000+p[1]])
    #print(p, file=sys.stderr)
    #debugger()
    return p


def do_trial(A, f_in, f_out):
    used = set()
    width, height = {20: (4, 5), 200: (20, 10), 10:(5, 3)}[A]
    X0, Y0 = 40, 40

    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    inner_points = [p for p in points if p[0] not in (X0, X0+width-1) and p[1] not in (Y0, Y0+height-1)]
    convolution = { p: 0 for p in points }
    for (x, y) in points:
        for x0 in range(x-1, x+2):
            for y0 in range(y-1, y+2):
                p = (x0, y0)
                if p in convolution:
                    convolution[p] += 1

    debug(""A = "", A)
    debug(""convolution = "", convolution)
    debug(""points = "", points)
    while True: #any(p not in used for p in points):
        debug(""used = "", used)
        debug(""convolution = "", convolution)
        debug(""missing ="", set(points).difference(used))
        #debugger()
        x, y = max(inner_points, key=convolution.get)
        debug(""x,y  = "", x, y)
        print(""%s %s"" % (x, y))
        sys.stdout.flush()
        p = read_two_int(f_in)
        debug(""prepared p = "", p)
        if p in ((0, 0), (-1, -1)):
            return
        if p in points and p not in used:
            used.add(p)
            x, y = p
            for x0 in range(x-1, x+2):
                for y0 in range(y-1, y+2):
                    p = (x0, y0)
                    if p in convolution:
                        convolution[p] -= 1
    #print(""%s %s"" % (X0, Y0))
    return 0


f_in = sys.stdin #open(INPUT, ""rb"")
f_out = sys.stdout
#f = open(INPUT)
T = int(f_in.readline()[:-1])
for i in range(T):
    A = int(f_in.readline()[:-1])
    v = do_trial(A, f_in, f_out)
    #print(""Case #%d: %s"" % (i+1, v))
",,2811,102,352,Python,00000000000000cb,0000000000009aa7,0000000000007a30,gizzywump,2018
376,00000000000096ca.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def read_two_int(f_in):
    return tuple(int(_) for _ in f_in.readline().split())


def find_best(convolution, X0, Y0, width, height):
    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    p = max(points, key=lambda p: convolution[p[0]*1000+p[1]])
    #print(p, file=sys.stderr)
    #debugger()
    return p


def do_trial(A, f_in, f_out):
    used = set()
    width, height = {20: (4, 5), 200: (20, 10), 10:(5, 2)}[A]
    X0, Y0 = 40, 40

    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    convolution = { p: 0 for p in points }
    for (x, y) in points:
        for x0 in range(x-1, x+2):
            for y0 in range(y-1, y+2):
                p = (x0, y0)
                if p in convolution:
                    convolution[p] += 1

    debug(""A = "", A)
    debug(""convolution = "", convolution)
    debug(""points = "", points)
    while any(p not in used for p in points):
        debug(""used = "", used)
        debug(""convolution = "", convolution)
        debug(""missing ="", set(points).difference(used))
        #debugger()
        x, y = max(points, key=convolution.get)
        debug(""x,y  = "", x, y)
        print(""%s %s"" % (x, y))
        sys.stdout.flush()
        p = read_two_int(f_in)
        debug(""prepared p = "", p)
        if p in ((0, 0), (-1, -1)):
            return
        if p in points and p not in used:
            used.add(p)
            x, y = p
            for x0 in range(x-1, x+2):
                for y0 in range(y-1, y+2):
                    p = (x0, y0)
                    if p in convolution:
                        convolution[p] -= 1
    return 0


f_in = sys.stdin #open(INPUT, ""rb"")
f_out = sys.stdout
#f = open(INPUT)
T = int(f_in.readline()[:-1])
for i in range(T):
    A = int(f_in.readline()[:-1])
    v = do_trial(A, f_in, f_out)
    #print(""Case #%d: %s"" % (i+1, v))
",,2662,100,327,Python,00000000000000cb,00000000000096ca,0000000000007a30,gizzywump,2018
377,0000000000009500.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def read_two_int(f_in):
    return tuple(int(_) for _ in f_in.readline().split())


def find_best(convolution, X0, Y0, width, height):
    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    p = max(points, key=lambda p: convolution[p[0]*1000+p[1]])
    #print(p, file=sys.stderr)
    #debugger()
    return p


def do_trial(A, f_in, f_out):
    used = set()
    width, height = {20: (4, 5), 200: (20, 10), 10:(5, 2)}[A]
    X0, Y0 = 40, 40

    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    convolution = { p: 0 for p in points }
    for (x, y) in points:
        for x0 in range(x-1, x+2):
            for y0 in range(y-1, y+2):
                p = (x0, y0)
                if p in convolution:
                    convolution[p] += 1

    while any(p not in used for p in points):
        #debugger()
        x, y = max(points, key=convolution.get)
        print(""%s %s"" % (x, y))
        p = read_two_int(f_in)
        if p in ((0, 0), (-1, -1)):
            return
        if p not in used:
            used.add(p)
            x, y = p
            for x0 in range(x-1, x+2):
                for y0 in range(y-1, y+2):
                    p = (x0, y0)
                    if p in convolution:
                        convolution[p] -= 1
    return 0


f_in = sys.stdin #open(INPUT, ""rb"")
f_out = sys.stdout
#f = open(INPUT)
T = int(f_in.readline()[:-1])
for i in range(T):
    A = int(f_in.readline()[:-1])
    v = do_trial(A, f_in, f_out)
    print(""Case #%d: %s"" % (i+1, v))
",,2327,91,289,Python,00000000000000cb,0000000000009500,0000000000007a30,gizzywump,2018
378,000000000000831c.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def do_trial(N):
    l1 = N[::2]
    l2 = N[1::2]
    l1.sort()
    l2.sort()
    N1 = []
    for a, b in zip(l1, l2):
        N1.append(a)
        N1.append(b)
    if len(l1) > len(l2):
        N1.append(l1[-1])
    for _, v in enumerate(N1[:-1]):
        if v > N1[_+1]:
            return _
    return ""OK""


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline()[:-1])
    V = [int(_) for _ in f.readline().split()]
    v = do_trial(V)
    print(""Case #%d: %s"" % (i+1, v))
",,1317,64,146,Python,00000000000000cb,000000000000831c,00000000000079cb,gizzywump,2018
379,000000000000822b.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def damage(P):
    total = 0
    d = 1
    for c in P:
        if c == 'S':
            total += d
        else:
            d += d
    return total


def do_swap(P):
    last_s = P.rfind(""S"")
    next_c = P.rfind(""C"", 0, last_s)
    assert last_s > 0
    assert next_c >= 0
    return P[:next_c] + ""SC"" + P[next_c+2:]


def do_trial(D, P):
    c = collections.Counter(P)
    if c[""S""] > D:
        return ""IMPOSSIBLE""
    swaps = 0
    while damage(P) > D:
        P = do_swap(P)
        swaps += 1
    return swaps


f = sys.stdin #open(INPUT, ""rb"")
#f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    D, P = f.readline().split()
    v = do_trial(int(D), P)
    print(""Case #%d: %s"" % (i+1, v))
",,1486,76,178,Python,00000000000000cb,000000000000822b,0000000000007966,gizzywump,2018
380,0000000000008050.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def damage(P):
    total = 0
    d = 1
    for c in P:
        if c == 'S':
            total += d
        else:
            d += d
    return total


def do_swap(P):
    last_s = P.rfind(""S"")
    next_c = P.rfind(""C"", 0, last_s)
    assert last_s > 0
    assert next_c >= 0
    return P[:next_c] + ""SC"" + P[next_c+2:]


def do_trial(D, P):
    c = collections.Counter(P)
    if c[""S""] >= D:
        return ""IMPOSSIBLE""
    swaps = 0
    while damage(P) > D:
        P = do_swap(P)
        swaps += 1
    return swaps


f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    D, P = f.readline().split()
    v = do_trial(int(D), P)
    print(""Case #%d: %s"" % (i+1, v))
",,1454,76,173,Python,00000000000000cb,0000000000008050,0000000000007966,gizzywump,2018
381,0000000000008045.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def damage(P):
    total = 0
    d = 1
    for c in P:
        if c == 'S':
            total += d
        else:
            d += d
    return total


def do_swap(P):
    last_s = P.rfind(""S"")
    next_c = P.rfind(""C"", 0, last_s)
    assert last_s > 0
    assert next_c >= 0
    return P[:next_c] + ""SC"" + P[next_c+2:]


def do_trial(D, P):
    c = collections.Counter(P)
    if c[""S""] > D:
        return ""IMPOSSIBLE""
    swaps = 0
    while damage(P) > D:
        P = do_swap(P)
        swaps += 1
    return swaps


f = open(INPUT)
T = int(f.readline()[:-1])
for i in range(T):
    D, P = f.readline().split()
    v = do_trial(int(D), P)
    print(""Case #%d: %s"" % (i+1, v))
",,1453,76,173,Python,00000000000000cb,0000000000008045,0000000000007966,gizzywump,2018
382,000000000014c68f.PYTHON3,"#!/usr/bin/env python3

import collections
import math
import sys

from fractions import Fraction


INPUT = ""tiny1""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    min_v, max_v = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    for _ in range(len(vals) - 1):
        a, b = vals[_:_+2]
        delta_x = b[0] - a[0]
        delta_y = b[1] - a[1]
        if delta_y * delta_x == 0:
            continue
        debug(min_v, max_v)
        frac = Fraction(delta_x, -delta_y)
        if delta_x < 0:
            min_v = max(min_v, frac)
        else:
            max_v = min(max_v, frac)
    if min_v > max_v:
        return ""IMPOSSIBLE""
    d = 1
    while True:
        n = int(min_v * d + 1)
        if n < max_v * d:
            break
        d += 1
    last = -1
    for _ in vals:
        w = d * _[0] + n * _[1]
        #if w <= last:
        #    breakpoint()
        last = w
    return ""%d %d"" % (d, n)


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1205,57,174,Python,0000000000051679,000000000014c68f,0000000000146184,gizzywump,2019
383,000000000014c501.PYTHON3,"#!/usr/bin/env python3

import collections
import math
import sys

from fractions import Fraction


INPUT = ""tiny1""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    min_v, max_v = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    for _ in range(len(vals) - 1):
        a, b = vals[_:_+2]
        delta_x = b[0] - a[0]
        delta_y = b[1] - a[1]
        if delta_y * delta_x == 0:
            continue
        debug(min_v, max_v)
        frac = Fraction(delta_x, -delta_y)
        if delta_x < 0:
            min_v = max(min_v, frac)
        else:
            max_v = min(max_v, frac)
    if min_v > max_v:
        return ""IMPOSSIBLE""
    d = 1
    while True:
        n = int(min_v * d + 1)
        if n < max_v * d:
            break
        d += 1
    last = -1
    for _ in vals:
        w = d * _[0] + n * _[1]
        if w <= last:
            breakpoint()
        last = w
    return ""%d %d"" % (d, n)


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1203,57,173,Python,0000000000051679,000000000014c501,0000000000146184,gizzywump,2019
384,000000000014b63c.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from fractions import Fraction


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def do_trial(vals):
    min_v, max_v = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    for _ in range(len(vals) - 1):
        a, b = vals[_:_+2]
        delta_x = b[0] - a[0]
        delta_y = b[1] - a[1]
        if delta_y * delta_x == 0:
            continue
        debug(min_v, max_v)
        frac = Fraction(delta_x, -delta_y)
        if delta_x < 0:
            min_v = max(min_v, frac)
        else:
            max_v = min(max_v, frac)
    if min_v > max_v:
        return ""IMPOSSIBLE""
    d = 1
    while True:
        n = int(min_v * d) + 1
        if n / d < max_v:
            return ""%d %d"" % (d, n)
        d += 1


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1051,49,146,Python,0000000000051679,000000000014b63c,0000000000146184,gizzywump,2019
385,000000000014a911.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from fractions import Fraction


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def r(by_x, by_y, y_min, y_max, so_far):
    debug(""%s %s %s %s %s"" % (so_far, y_min, y_max, by_x, by_y))
    if y_min >= y_max:
        return 0
    if len(by_x) == 0 or len(by_y) == 0:
        debug(""found path %s"" % so_far)
        return 1
    if by_x[0] in so_far:
        return r(by_x[1:], by_y, y_min, y_max, so_far)
    if by_y[0] in so_far:
        return r(by_x, by_y[1:], y_min, y_max, so_far)
    if by_x[0] == by_y[0]:
        return r(by_x[1:], by_y[1:], y_min, y_max, so_far + [by_x[0]])

    bx, by = by_x[0], by_y[0]

    if by[0] == bx[0]:
        return 0

    y_limit = Fraction(bx[1] - by[1], by[0] - bx[0])

    # choose bx
    count = 0
    count += r(by_x[1:], by_y, max(y_min, y_limit), y_max, so_far + [bx])
    count += r(by_x, by_y[1:], y_min, min(y_max, y_limit), so_far + [by])
    return count

def do_trial(vals):
    by_x = sorted(vals)
    by_y = sorted(vals, key=lambda x:x[1])
    so_far = []
    y_min, y_max = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    count = r(by_x, by_y, y_min, y_max, so_far)
    return count


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1481,61,204,Python,0000000000051679,000000000014a911,0000000000146183,gizzywump,2019
386,000000000014a691.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from fractions import Fraction


INPUT = ""tiny""

#f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def r(by_x, by_y, y_min, y_max, so_far):
    debug(""%s %s %s %s %s"" % (so_far, y_min, y_max, by_x, by_y))
    if y_min >= y_max:
        return 0
    if len(by_x) == 0 or len(by_y) == 0:
        debug(""found path %s"" % so_far)
        return 1
    if by_x[0] in so_far:
        return r(by_x[1:], by_y, y_min, y_max, so_far)
    if by_y[0] in so_far:
        return r(by_x, by_y[1:], y_min, y_max, so_far)
    if by_x[0] == by_y[0]:
        return r(by_x[1:], by_y[1:], y_min, y_max, so_far + [by_x[0]])

    bx, by = by_x[0], by_y[0]

    if by[0] == bx[0]:
        return 0

    y_limit = Fraction(bx[1] - by[1], by[0] - bx[0])

    # choose bx
    count = 0
    count += r(by_x[1:], by_y, max(y_min, y_limit), y_max, so_far + [bx])
    count += r(by_x, by_y[1:], y_min, min(y_max, y_limit), so_far + [by])
    return count

def do_trial(vals):
    by_x = sorted(vals)
    by_y = sorted(vals, key=lambda x:x[1])
    so_far = []
    y_min, y_max = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    count = r(by_x, by_y, y_min, y_max, so_far)
    return count


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1481,61,204,Python,0000000000051679,000000000014a691,0000000000146183,gizzywump,2019
387,000000000014a551.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from fractions import Fraction


INPUT = ""tiny""

#f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def r(by_x, by_y, y_min, y_max, so_far):
    debug(""%s %s %s %s %s"" % (so_far, y_min, y_max, by_x, by_y))
    if y_min >= y_max:
        return 0
    if len(by_x) == 0 or len(by_y) == 0:
        debug(""found path %s"" % so_far)
        return 1
    if by_x[0] in so_far:
        return r(by_x[1:], by_y, y_min, y_max, so_far)
    if by_y[0] in so_far:
        return r(by_x, by_y[1:], y_min, y_max, so_far)
    if by_x[0] == by_y[0]:
        return r(by_x[1:], by_y[1:], y_min, y_max, so_far + [by_x[0]])

    bx, by = by_x[0], by_y[0]

    y_limit = Fraction(bx[1] - by[1], by[0] - bx[0])

    # choose bx
    count = 0
    count += r(by_x[1:], by_y, max(y_min, y_limit), y_max, so_far + [bx])
    count += r(by_x, by_y[1:], y_min, min(y_max, y_limit), so_far + [by])
    return count

def do_trial(vals):
    by_x = sorted(vals)
    by_y = sorted(vals, key=lambda x:x[1])
    so_far = []
    y_min, y_max = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    count = r(by_x, by_y, y_min, y_max, so_far)
    return count


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1440,58,198,Python,0000000000051679,000000000014a551,0000000000146183,gizzywump,2019
388,000000000014a013.PYTHON3,"#!/usr/bin/env python3

import collections
import sys

from fractions import Fraction


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def r(by_x, by_y, y_min, y_max, so_far):
    debug(""%s %s %s %s %s"" % (so_far, y_min, y_max, by_x, by_y))
    if y_min >= y_max:
        return 0
    if len(by_x) == 0 or len(by_y) == 0:
        debug(""found path %s"" % so_far)
        return 1
    if by_x[0] in so_far:
        return r(by_x[1:], by_y, y_min, y_max, so_far)
    if by_y[0] in so_far:
        return r(by_x, by_y[1:], y_min, y_max, so_far)
    if by_x[0] == by_y[0]:
        return r(by_x[1:], by_y[1:], y_min, y_max, so_far + [by_x[0]])

    bx, by = by_x[0], by_y[0]

    y_limit = Fraction(bx[1] - bx[0], by[0] - by[1])

    # choose bx
    count = 0
    count += r(by_x[1:], by_y, max(y_min, y_limit), y_max, so_far + [bx])
    count += r(by_x, by_y[1:], y_min, min(y_max, y_limit), so_far + [by])
    return count

def do_trial(vals):
    by_x = sorted(vals)
    by_y = sorted(vals, key=lambda x:x[1])
    so_far = []
    y_min, y_max = Fraction(1, int(1e9)), Fraction(int(1e9), 1)
    count = r(by_x, by_y, y_min, y_max, so_far)
    return count


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [[int(_) for _ in f.readline().split()] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1440,58,198,Python,0000000000051679,000000000014a013,0000000000146183,gizzywump,2019
389,000000000011040f.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys


#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def read_two_int(f_in):
    return tuple(int(_) for _ in f_in.readline().split())


def find_best(convolution, X0, Y0, width, height):
    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    p = max(points, key=lambda p: convolution[p[0]*1000+p[1]])
    #print(p, file=sys.stderr)
    #debugger()
    return p

import collections


def do_trial1(f_in, f_out, N, M):
    primes = [18, 17, 16, 15, 14, 13, 12]
    totals = []
    for p in primes:
        f_out.write("" "".join(""%s"" % _ for _ in ([p] * 18)))
        f_out.write(""\n"")
        f_out.flush()
        counts = [int(_) for _ in f_in.readline().split()]
        total = sum(counts)
        totals.append(total)
    debug(totals)

    # now solve
    for i in range(1, M+1):
        for p, t in zip(primes, totals):
            if i%p != t%p:
                break
        else:
            debug(""GUESSING %d for %s"" % (i, totals))
            f_out.write(""%d\n"" % i)
            f_out.flush()
            verdict = f_in.readline()
            debug(""VERDICT: %s"" % verdict)
            return
    else:
        debug(""CAN'T SOLVE"")


def do_trial(f_in, f_out, N, M):
    if N == 7:
        return do_trial1(f_in, f_out, N, M)
    totals = []
    while True:
        f_out.write("" "".join(""%s"" % _ for _ in ([18] * 18)))
        f_out.write(""\n"")
        f_out.flush()
        counts = [int(_) for _ in f_in.readline().split()]
        total = sum(counts)
        totals.append(total)
        c = collections.Counter(totals)
        debug(c)
        for k, v in c.items():
            if v > 5:
                f_out.write(""%d\n"" % k)
                f_out.flush()
                verdict = f_in.readline()
                debug(""VERDICT: %s"" % verdict)
                return


f_in = sys.stdin #open(INPUT, ""rb"")
f_out = sys.stdout
#f = open(INPUT)
T, N, M = (int(_) for _ in f_in.readline().split())
for i in range(T):
    v = do_trial(f_in, f_out, N, M)
    #print(""Case #%d: %s"" % (i+1, v))
",,2711,108,301,Python,51635,000000000011040f,0000000000104f1a,gizzywump,2019
390,000000000010eee3.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys


#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def read_two_int(f_in):
    return tuple(int(_) for _ in f_in.readline().split())


def find_best(convolution, X0, Y0, width, height):
    points = [(x, y) for x in range(X0, X0 + width) for y in range(Y0, Y0 + height)]
    p = max(points, key=lambda p: convolution[p[0]*1000+p[1]])
    #print(p, file=sys.stderr)
    #debugger()
    return p

import collections

def do_trial(f_in, f_out, N, M):
    totals = []
    while True:
        f_out.write("" "".join(""%s"" % _ for _ in ([18] * 18)))
        f_out.write(""\n"")
        f_out.flush()
        counts = [int(_) for _ in f_in.readline().split()]
        total = sum(counts)
        totals.append(total)
        c = collections.Counter(totals)
        debug(c)
        for k, v in c.items():
            if v > 5:
                f_out.write(""%d\n"" % k)
                f_out.flush()
                verdict = f_in.readline()
                debug(""VERDICT: %s"" % verdict)
                return


f_in = sys.stdin #open(INPUT, ""rb"")
f_out = sys.stdout
#f = open(INPUT)
T, N, M = (int(_) for _ in f_in.readline().split())
for i in range(T):
    v = do_trial(f_in, f_out, N, M)
    #print(""Case #%d: %s"" % (i+1, v))
",,1890,77,205,Python,51635,000000000010eee3,0000000000104f1a,gizzywump,2019
391,000000000010c06a.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def build_graph(R, C):
    size = R * C
    g = []
    for r0 in range(R):
        for c0 in range(C):
            P0 = r0*C + c0
            row = []
            for r1 in range(R):
                for c1 in range(C):
                    v = 1
                    if c0 == c1 or r0 == r1:
                        v = 0
                    if r0 - c0 == r1 - c1 or r0 + c0 == r1 + c1:
                        v = 0
                    row.append(v)
            g.append(row)
    return g


def find_circuit(g, C, circuit=(0,)):
    size = len(g)
    if len(circuit) >= size:
        return circuit
    next_hint = circuit[-1] + 2 + C
    next_hint %= size
    for n in (next_hint,) + tuple(range(size)):
        if n in circuit:
            continue
        if g[circuit[-1]][n] == 0:
            continue
        r = find_circuit(g, C, circuit + (n,))
        if r:
            return r
    return None


def circuit_to_coords(_, C):
    q, r = divmod(_, C)
    return (1 + q, 1 + r)
    


def do_trial(R, C):
    graph = build_graph(R, C)
    debug(graph)
    circuit = find_circuit(graph, C)
    if circuit is None:
        return ""IMPOSSIBLE""
    coords = [circuit_to_coords(_, C) for _ in circuit]
    debug(coords)
    return ""POSSIBLE\n%s"" % ""\n"".join(""%d %d"" % _ for _ in coords)
    return R * C


T = int(f.readline()[:-1])
for i in range(T):
    R, C = (int(_) for _ in f.readline().split())
    v = do_trial(R, C)
    print(""Case #%d: %s"" % (i+1, v))
",,1628,76,226,Python,51635,000000000010c06a,0000000000104e03,gizzywump,2019
392,000000000010bbc2.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def build_graph(R, C):
    size = R * C
    g = []
    for r0 in range(R):
        for c0 in range(C):
            P0 = r0*C + c0
            row = []
            for r1 in range(R):
                for c1 in range(C):
                    v = 1
                    if c0 == c1 or r0 == r1:
                        v = 0
                    if r0 - c0 == r1 - c1 or r0 + c0 == r1 + c1:
                        v = 0
                    row.append(v)
            g.append(row)
    return g


def find_circuit(g, C, circuit=(0,)):
    size = len(g)
    if size - len(circuit) > 5:
        next = circuit[-1] + 2 + C
        next %= size
        if g[circuit[-1]][next] != 0:
            circuit += (next,)
            return find_circuit(g, C, circuit)
    if len(circuit) >= size:
        return circuit
    for n in range(size):
        if n in circuit:
            continue
        if g[circuit[-1]][n] == 0:
            continue
        r = find_circuit(g, C, circuit + (n,))
        if r:
            return r
    return None


def circuit_to_coords(_, C):
    q, r = divmod(_, C)
    return (1 + q, 1 + r)
    


def do_trial(R, C):
    graph = build_graph(R, C)
    debug(graph)
    circuit = find_circuit(graph, C)
    if circuit is None:
        return ""IMPOSSIBLE""
    coords = [circuit_to_coords(_, C) for _ in circuit]
    debug(coords)
    return ""POSSIBLE\n%s"" % ""\n"".join(""%d %d"" % _ for _ in coords)
    return R * C


T = int(f.readline()[:-1])
for i in range(T):
    R, C = (int(_) for _ in f.readline().split())
    v = do_trial(R, C)
    print(""Case #%d: %s"" % (i+1, v))
",,1752,80,241,Python,51635,000000000010bbc2,0000000000104e03,gizzywump,2019
393,000000000010adaf.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def build_graph(R, C):
    size = R * C
    g = []
    for r0 in range(R):
        for c0 in range(C):
            P0 = r0*C + c0
            row = []
            for r1 in range(R):
                for c1 in range(C):
                    v = 1
                    if c0 == c1 or r0 == r1:
                        v = 0
                    if r0 - c0 == r1 - c1 or r0 + c0 == r1 + c1:
                        v = 0
                    row.append(v)
            g.append(row)
    return g


def find_circuit(g, circuit=(0,)):
    size = len(g)
    if len(circuit) >= size:
        return circuit
    for n in range(size):
        if n in circuit:
            continue
        if g[circuit[-1]][n] == 0:
            continue
        r = find_circuit(g, circuit + (n,))
        if r:
            return r
    return None


def circuit_to_coords(_, C):
    q, r = divmod(_, C)
    return (1 + q, 1 + r)
    


def do_trial(R, C):
    graph = build_graph(R, C)
    debug(graph)
    circuit = find_circuit(graph)
    if circuit is None:
        return ""IMPOSSIBLE""
    coords = [circuit_to_coords(_, C) for _ in circuit]
    debug(coords)
    return ""POSSIBLE\n%s"" % ""\n"".join(""%d %d"" % _ for _ in coords)
    return R * C


T = int(f.readline()[:-1])
for i in range(T):
    R, C = (int(_) for _ in f.readline().split())
    v = do_trial(R, C)
    print(""Case #%d: %s"" % (i+1, v))
",,1539,74,211,Python,51635,000000000010adaf,0000000000104e03,gizzywump,2019
394,000000000010ad06.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def build_graph(R, C):
    size = R * C
    g = []
    for r0 in range(R):
        for c0 in range(C):
            P0 = r0*C + c0
            row = []
            for r1 in range(R):
                for c1 in range(C):
                    v = 1
                    if c0 == c1 or r0 == r1:
                        v = 0
                    if r0 - c0 == r1 - c1 or r0 + c0 == r1 + c1:
                        v = 0
                    row.append(v)
            g.append(row)
    return g


def find_circuit(g, circuit=(0,)):
    size = len(g)
    if len(circuit) >= size:
        return circuit
    for n in range(size):
        if n in circuit:
            continue
        if g[circuit[-1]][n] == 0:
            continue
        r = find_circuit(g, circuit + (n,))
        if r:
            return r
    return None


def circuit_to_coords(_, C):
    q, r = divmod(_, C)
    return (1 + q, 1 + r)
    


def do_trial(R, C):
    graph = build_graph(R, C)
    debug(graph)
    circuit = find_circuit(graph)
    if circuit is None:
        return ""IMPOSSIBLE""
    coords = [circuit_to_coords(_, C) for _ in circuit]
    debug(coords)
    return ""POSSIBLE\n%s"" % ""\n"".join(""%d %d"" % _ for _ in coords)
    return R * C


T = int(f.readline()[:-1])
for i in range(T):
    R, C = (int(_) for _ in f.readline().split())
    v = do_trial(R, C)
    print(""Case #%d: %s"" % (i+1, v))
",,1538,74,211,Python,51635,000000000010ad06,0000000000104e03,gizzywump,2019
395,0000000000108ae9.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def do_partition(words):
    max_size = max(len(_) for _ in words)
    p = collections.defaultdict(set)
    for s in range(1, max_size+1):
        for _ in words:
            if len(_) < s:
                continue
            p[_[-s:]].add(_)
    return p


def rwp(p, words):
    for w in list(words):
        for s in range(1, len(w)+1):
            p[w[-s:]].discard(w)


def do_trial(words):
    paired = 0
    words = set(words)
    pairs = []
    while len(words) > 0:
        partition = do_partition(words)
        for p in pairs:
            if p in partition:
                del partition[p]
        debug(partition)
        restart = 0
        debug({k: len(v) for k, v in partition.items()})

        large_enough = [_ for _ in partition.items() if len(_[1]) > 1]
        if len(large_enough) == 0:
            break
        k, v = min(large_enough, key=lambda p: (-len(p[0]), len(p[1])))
        v = sorted(v, key=lambda w: -len(w))
        debug(""choosing %s"" % v[:2])
        pairs.append(k)
        words.discard(v[0])
        words.discard(v[1])

    debug(pairs)
    return 2 * len(pairs)


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [f.readline()[:-1] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1478,67,173,Python,51635,0000000000108ae9,0000000000104e05,gizzywump,2019
396,00000000001079d2.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def do_partition(words):
    max_size = max(len(_) for _ in words)
    p = collections.defaultdict(set)
    for s in range(1, max_size+1):
        for _ in words:
            if len(_) < s:
                continue
            p[_[-s:]].add(_)
    return p


def rwp(p, words):
    for w in list(words):
        for s in range(1, len(w)+1):
            p[w[-s:]].discard(w)


def do_trial(words):
    paired = 0
    words = set(words)
    pairs = []
    while len(words) > 0:
        partition = do_partition(words)
        restart = 0
        debug({k: len(v) for k, v in partition.items()})

        large_enough = [_ for _ in partition.items() if len(_[1]) > 1]
        if len(large_enough) == 0:
            break
        k, v = min(large_enough, key=lambda p: (-len(p[0]), len(p[1])))
        v = sorted(v, key=lambda w: len(w))
        debug(""choosing %s"" % v[:2])
        pairs.append(k)
        words.discard(v[0])
        words.discard(v[1])

    debug(pairs)
    return 2 * len(pairs)


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [f.readline()[:-1] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1364,63,162,Python,51635,00000000001079d2,0000000000104e05,gizzywump,2019
397,0000000000106ee0.PYTHON3,"#!/usr/bin/env python3

import collections
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    pass #sys.stderr.write(str(args) + ""\n"")


def do_partition(words):
    max_size = max(len(_) for _ in words)
    p = collections.defaultdict(set)
    for s in range(1, max_size+1):
        for _ in words:
            if len(_) < s:
                continue
            p[_[-s:]].add(_)
    return p


def rwp(p, words):
    for w in list(words):
        for s in range(1, len(w)+1):
            p[w[-s:]].discard(w)


def do_trial(words):
    paired = 0
    words = set(words)
    pairs = []
    while len(words) > 0:
        partition = do_partition(words)
        restart = 0
        debug({k: len(v) for k, v in partition.items()})

        large_enough = [_ for _ in partition.items() if len(_[1]) > 1]
        if len(large_enough) == 0:
            break
        k, v = min(large_enough, key=lambda p: len(p[1]))
        v = sorted(v, key=lambda w: len(w))
        pairs.append(k)
        words.discard(v[0])
        words.discard(v[1])

    debug(pairs)
    return 2 * len(pairs)


T = int(f.readline()[:-1])
for i in range(T):
    N, = (int(_) for _ in f.readline().split())
    vals = [f.readline()[:-1] for _ in range(N)]
    v = do_trial(vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1319,62,158,Python,51635,0000000000106ee0,0000000000104e05,gizzywump,2019
398,00000000000f9397.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
#def = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    last = None
    for _ in vals:
        if _ != last:
            yield _
            last = _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    f0 = vals[0] // gcd(*dd[:2])
    f1 = vals[0] // f0

    rest = [f0]
    for _ in vals[1:]:
        n = _ // f1
        rest.append(f1)
        f0, f1 = f1, n
    rest.append(f1)
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1024,55,155,Python,51705,00000000000f9397,000000000008830b,gizzywump,2019
399,00000000000f93a5.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    last = None
    for _ in vals:
        if _ != last:
            yield _
            last = _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    f0 = vals[0] // gcd(*dd[:2])
    f1 = vals[0] // f0

    rest = [f0]
    for _ in vals[1:]:
        n = _ // f1
        rest.append(f1)
        f0, f1 = f1, n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1002,54,154,Python,51705,00000000000f93a5,000000000008830b,gizzywump,2019
400,00000000000f928e.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    last = None
    for _ in vals:
        if _ != last:
            yield _
            last = _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    f0 = vals[0] // gcd(*dd[:2])
    f1 = vals[0] // f0

    rest = [f0]
    for _ in vals[1:]:
        n = _ // f1
        rest.append(f1)
        f0, f1 = f1, n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,1001,54,154,Python,51705,00000000000f928e,000000000008830b,gizzywump,2019
401,00000000000f8e23.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    last = None
    for _ in vals:
        if _ != last:
            yield _
            last = _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    f0 = vals[0] // gcd(*dd[:2])
    f1 = vals[0] // f0

    rest = [f0]
    for _ in vals:
        n = _ // f1
        rest.append(n)
        f0, f1 = f1, n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,997,54,154,Python,51705,00000000000f8e23,000000000008830b,gizzywump,2019
402,00000000000f8ee1.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    last = None
    for _ in vals:
        if _ != last:
            yield _
            last = _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    f0 = vals[0] // gcd(*dd[:2])
    f1 = vals[0] // f0

    rest = [f0]
    for _ in vals:
        n = _ // f1
        rest.append(n)
        f0, f1 = f1, n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,996,54,154,Python,51705,00000000000f8ee1,000000000008830b,gizzywump,2019
403,00000000000f8047.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    for _ in vals:
        q = int(math.sqrt(_))
        if q * q != _:
            yield _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    last = dd[0] // gcd(*dd[:2])
    rest = [last]
    for _ in vals:
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,965,51,146,Python,51705,00000000000f8047,000000000008830b,gizzywump,2019
404,00000000000f7ef7.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    for _ in vals:
        q = int(math.sqrt(_))
        if q * q != _:
            yield _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    last = dd[0] // gcd(*dd[:2])
    rest = [last]
    for _ in vals:
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,964,51,146,Python,51705,00000000000f7ef7,000000000008830b,gizzywump,2019
405,00000000000f7dc0.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    for _ in vals:
        q = int(math.sqrt(_))
        if q * q != _:
            yield _


def do_trial(N, L, vals):
    dd = list(dedup(vals))
    last = dd[0] // gcd(*dd[:2])
    rest = [last]
    for _ in dd:
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,962,51,146,Python,51705,00000000000f7dc0,000000000008830b,gizzywump,2019
406,00000000000f78fe.PYTHON3,"#!/usr/bin/env python3

import math
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    for _ in vals:
        q = int(math.sqrt(_))
        if q * q != _:
            yield _


def do_trial(N, L, vals):
    last = vals[0] // gcd(*vals[:2])
    rest = [last]
    for _ in dedup(vals):
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,949,50,143,Python,51705,00000000000f78fe,000000000008830b,gizzywump,2019
407,00000000000f77be.PYTHON3,"#!/usr/bin/env python3

import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def dedup(vals):
    last = None
    for _ in vals:
        if _ != last:
            yield _
        last = _


def do_trial(N, L, vals):
    last = vals[0] // gcd(*vals[:2])
    rest = [last]
    for _ in dedup(vals):
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,939,50,142,Python,51705,00000000000f77be,000000000008830b,gizzywump,2019
408,00000000000f73f6.PYPY2,"#!/usr/bin/env python3

import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def do_trial(N, L, vals):
    last = vals[0] // gcd(*vals[:2])
    rest = [last]
    for _ in vals:
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    try:
        v = do_trial(N, L, vals)
    except:
        v = ""?""
    print(""Case #%d: %s"" % (i+1, v))
",,860,45,129,Python,51705,00000000000f73f6,000000000008830b,gizzywump,2019
409,00000000000f759d.PYPY2,"#!/usr/bin/env python2

import collections

import math
import re
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def do_trial(N, L, vals):
    last = vals[0] // gcd(*vals[:2])
    rest = [last]
    for _ in vals:
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,861,46,130,Python,51705,00000000000f759d,000000000008830b,gizzywump,2019
410,00000000000f7193.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def gcd(a, b):
    while min(a, b) > 0:
        a, b = min(a, b), max(a, b)
        a, b = b % a, a
    return max(a, b)


def do_trial(N, L, vals):
    last = vals[0] // gcd(*vals[:2])
    rest = [last]
    for _ in vals:
        n = _ // last
        rest.append(n)
        last = n
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,861,46,130,Python,51705,00000000000f7193,000000000008830b,gizzywump,2019
411,00000000000f679b.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys


INPUT = ""tiny""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def do_trial(N, L, vals):
    last = vals[0] // math.gcd(*vals[:2])
    rest = [last]
    for _ in vals:
        next = _ // last
        rest.append(next)
        last = next
    all_primes = sorted(set(rest))
    pairs = [(p, chr(ord(""A"") + i)) for i, p in enumerate(all_primes)]
    lookup = dict(pairs)
    return ''.join(lookup[_] for _ in rest)


T = int(f.readline()[:-1])
for i in range(T):
    N, L = (int(_) for _ in f.readline().split())
    vals = [int(_) for _ in f.readline().split()]
    v = do_trial(N, L, vals)
    print(""Case #%d: %s"" % (i+1, v))
",,752,39,105,Python,51705,00000000000f679b,000000000008830b,gizzywump,2019
412,00000000000f5927.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    sys.stderr.write(str(args) + ""\n"")


def swap(c):
    if c == ""E"":
        return ""S""
    return ""E""


def do_trial(path):
    return ''.join(swap(_) for _ in path)


T = int(f.readline()[:-1])
for i in range(T):
    D = int(f.readline())
    path = f.readline()[:-1]
    v = do_trial(path)
    print(""Case #%d: %s"" % (i+1, v))
",,597,41,77,Python,51705,00000000000f5927,00000000000881da,gizzywump,2019
413,00000000000f4e05.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

f = sys.stdin
#f = open(INPUT)


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def do_split(N):
    if N == 0:
        return 0, 0
    if N < 10:
        if N == 4:
            return 2, 2
        return N, 0
    a, b = do_split(N // 10)
    a1, b1 = do_split(N % 10)
    return 10 * a + a1, 10 * b + b1


def do_trial(D):
    a, b = do_split(D)
    return ""%s %s"" % (a, b)


T = int(f.readline()[:-1])
for i in range(T):
    D = f.readline()
    v = do_trial(int(D))
    print(""Case #%d: %s"" % (i+1, v))
",,1233,65,156,Python,51705,00000000000f4e05,0000000000088231,gizzywump,2019
414,00000000000f4ceb.PYTHON3,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = ""tiny""
#INPUT = ""A-large.in""
#INPUT = ""A-small-attempt0.in""

f = sys.stdin
f = open(INPUT)


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


class Memoize:
    def __init__(self,function):
        self._cache = {}
        self._callable = function
            
    def __call__(self, *args, **kwds):
        cache = self._cache
        key = self._getKey(*args,**kwds)
        try: return cache[key]
        except KeyError:
            cachedValue = cache[key] = self._callable(*args,**kwds)
            return cachedValue
    
    def _getKey(self,*args,**kwds):
        return kwds and (args, ImmutableDict(kwds)) or args    


def do_split(N):
    if N == 0:
        return 0, 0
    if N < 10:
        if N == 4:
            return 2, 2
        return N, 0
    a, b = do_split(N // 10)
    a1, b1 = do_split(N % 10)
    return 10 * a + a1, 10 * b + b1


def do_trial(D):
    a, b = do_split(D)
    return ""%s %s"" % (a, b)


T = int(f.readline()[:-1])
for i in range(T):
    D = f.readline()
    v = do_trial(int(D))
    print(""Case #%d: %s"" % (i+1, v))
",,1232,65,156,Python,51705,00000000000f4ceb,0000000000088231,gizzywump,2019
415,00000000002196e0,"#!/usr/bin/env python3

import sys


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


def query(f, index):
    dprint(""QUERYING %d"" % index)
    print(index + 1)
    sys.stdout.flush()
    r = int(f.readline())
    dprint(""%d => %d"" % (index, r))
    return r


def bit_cmp(bits, _):
    N = len(bits)
    b0 = bits[_]
    b1 = bits[N - 1 - _]
    if None in (b0, b1):
        return None
    return b0 == b1


def find_same(bits):
    N = len(bits)
    for _ in range(N >> 1):
        if bit_cmp(bits, _) == True:
            return _
    return None


def find_diff(bits):
    dprint(""FIND DIFF %s"" % bits)
    N = len(bits)
    for _ in range(N >> 1):
        dprint(""bit_cmp %d = %s"" % (_, bit_cmp(bits, _)))
        if bit_cmp(bits, _) == False:
            return _
    return None


def tweak_same_bits(bits):
    N = len(bits)
    for _ in range(N >> 1):
        r = bit_cmp(bits, _)
        if r == True:
            bits[_] = 1 - bits[_]
            bits[N - 1 - _] = 1 - bits[N - 1 - _]


def tweak_diff_bits(bits):
    N = len(bits)
    for _ in range(N >> 1):
        r = bit_cmp(bits, _)
        if r == False:
            bits[_] = 1 - bits[_]
            bits[N - 1 - _] = 1 - bits[N - 1 - _]


def null_bits(bits):
    N = len(bits)
    for _ in range(N >> 1):
        b0 = bits[_]
        b1 = bits[N - 1 - _]
        if None in (b0, b1):
            bits[_] = bits[N - 1 - _] = None


def do_trial(f, N):
    q_count = 0

    # first, we need bits that differ
    # and bits that are the same

    bits = [None] * N
    dprint(bits)

    while None in bits:
        same_bits_changed = diff_bits_changed = None

        # merge the old and new bits
        same_index = find_same(bits)
        if same_index is not None:
            dprint(""checking same bits %d"" % same_index)
            q_count += 1
            r = query(f, same_index)
            same_bits_changed = bits[same_index] != r

        diff_index = find_diff(bits)
        if diff_index is not None:
            dprint(""checking diff bits %d"" % diff_index)
            q_count += 1
            r = query(f, diff_index)
            diff_bits_changed = bits[diff_index] != r

        if same_bits_changed:
            tweak_same_bits(bits)

        if diff_bits_changed:
            tweak_diff_bits(bits)

        null_bits(bits)

        while None in bits:
            none_index = bits.index(None)
            bits[none_index] = query(f, none_index)
            q_count += 1
            if q_count % 10 == 0:
                break
            _ = N - 1 - none_index
            bits[_] = query(f, _)
            q_count += 1
            if q_count % 10 == 0:
                break
        dprint(""bits = %s"" % """".join([str(_) for _ in bits]))

    soln = """".join([str(_) for _ in bits])
    print(soln)
    sys.stdout.flush()
    ok = f.readline()
    dprint(ok)


def main():
    f = sys.stdin
    t, b = [int(_) for _ in f.readline().split()]
    dprint(""T B => %s %s"" % (t, b))
    for _ in range(t):
        do_trial(f, b)


if __name__ == ""__main__"":
    main()
",00000000002196e0.PYTHON3,3098,139,420,Python,000000000019fd27,00000000002196e0,0000000000209a9e,gizzywump,2020
416,0000000000215627,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


def loop(c_until, j_until, trips):
    so_far = []

    while len(trips) > 0:
        index, (start_time, end_time) = trips[0]

        trips = trips[1:]

        if c_until <= start_time:
            so_far.append((index, ""C""))
            c_until = end_time
            continue

        if j_until <= start_time:
            so_far.append((index, ""J""))
            j_until = end_time
            continue

        return ""IMPOSSIBLE""

    r = so_far
    r.sort()
    r = [_[1] for _ in r]
    r = """".join(r)
    return r


def do_trial(pairs):
    trips = list(enumerate(pairs))
    trips.sort(key=lambda x: x[1])
    r = loop(0, 0, trips)
    return r


f = sys.stdin
if INPUT:
    try:
        f = open(INPUT)
    except:
        pass


T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    pairs = []
    for _ in range(N):
        pairs.append([int(_) for _ in f.readline().split()])
    v = do_trial(pairs)
    print(""Case #%d: %s"" % (i + 1, v))
",0000000000215627.PYTHON3,1223,72,146,Python,000000000019fd27,0000000000215627,000000000020bdf9,gizzywump,2020
417,0000000000215459,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
INPUT = ""tiny""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


def loop(c_until, j_until, trips):
    so_far = []

    while len(trips) > 0:
        index, (start_time, end_time) = trips[0]

        trips = trips[1:]

        if c_until <= start_time:
            so_far.append((index, ""C""))
            c_until = end_time
            continue

        if j_until <= start_time:
            so_far.append((index, ""J""))
            j_until = end_time
            continue

        return ""IMPOSSIBLE""

    r = so_far
    r.sort()
    r = [_[1] for _ in r]
    r = """".join(r)
    return r


def do_trial(pairs):
    trips = list(enumerate(pairs))
    trips.sort(key=lambda x: x[1])
    r = loop(0, 0, trips)
    return r


if INPUT:
    f = open(INPUT)
else:
    f = sys.stdin

T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    pairs = []
    for _ in range(N):
        pairs.append([int(_) for _ in f.readline().split()])
    v = do_trial(pairs)
    print(""Case #%d: %s"" % (i + 1, v))
",0000000000215459.PYTHON3,1193,69,144,Python,000000000019fd27,0000000000215459,000000000020bdf9,gizzywump,2020
418,0000000000214d35,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


def loop(c_until, j_until, trips):
    if len(trips) < 1:
        return []
    index, (start_time, end_time) = trips[0]
    if c_until <= start_time:
        return [(index, ""C"")] + loop(end_time, j_until, trips[1:])

    if j_until <= start_time:
        return [(index, ""J"")] + loop(c_until, end_time, trips[1:])

    raise ValueError()


def do_trial(pairs):
    trips = list(enumerate(pairs))
    trips.sort(key=lambda x: x[1])
    try:
        r = loop(0, 0, trips)
        r.sort()
        r = [_[1] for _ in r]
        r = ''.join(r)
        return r
    except ValueError:
        return ""IMPOSSIBLE""


if INPUT:
    f = open(INPUT)
else:
    f = sys.stdin

T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    pairs = []
    for _ in range(N):
        pairs.append([int(_) for _ in f.readline().split()])
    v = do_trial(pairs)
    print(""Case #%d: %s"" % (i+1, v))
",0000000000214d35.PYTHON3,1144,60,139,Python,000000000019fd27,0000000000214d35,000000000020bdf9,gizzywump,2020
419,00000000002137c7,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

#sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""

def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


def do_trial(S):
    new_s = []
    depth = 0
    for _ in S:
        if _ == '(':
            depth += 1
            new_s.append(_)
            continue
        if _ == ')':
            depth -= 1
            new_s.append(_)
            continue
        v = int(_)
        while depth < v:
            new_s.append(""("")
            depth += 1
        while depth > v:
            new_s.append("")"")
            depth -= 1
        new_s.append(_)
    while depth > 0:
        new_s.append("")"")
        depth -= 1
    return ''.join(new_s)


if INPUT:
    f = open(INPUT)
else:
    f = sys.stdin

T = int(f.readline()[:-1])
for i in range(T):
    S = f.readline()[:-1]
    v = do_trial(S)
    print(""Case #%d: %s"" % (i+1, v))
",00000000002137c7.PYTHON3,970,57,117,Python,000000000019fd27,00000000002137c7,0000000000209a9f,gizzywump,2020
420,00000000002129ee,"#!/usr/bin/env python3

import collections

import math
import re
import sys

# sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""
# INPUT = ""A-large.in""
# INPUT = ""A-small-attempt0.in""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


def do_dup(items):
    c = collections.Counter(items)
    c1 = [1 if max(c.values()) > 1 else 0]
    return sum(c1)


def do_trial(M):
    N = list(range(len(M)))
    trace = sum(M[_][_] for _ in N)
    row_dups = [do_dup(M[r]) for r in N]
    col_dups = [do_dup([M[c][_] for c in N]) for _ in N]
    return ""%s %s %s"" % (trace, sum(row_dups), sum(col_dups))


if INPUT:
    f = open(INPUT)
else:
    f = sys.stdin

T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    matrix = []
    for _ in range(N):
        matrix.append([int(_) for _ in f.readline().split()])
    v = do_trial(matrix)
    print(""Case #%d: %s"" % (i + 1, v))
",00000000002129ee.PYTHON3,916,49,128,Python,000000000019fd27,00000000002129ee,000000000020993c,gizzywump,2020
421,0000000000212929,"#!/usr/bin/env python3

import collections

import math
import re
import sys

# sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""
# INPUT = ""A-large.in""
# INPUT = ""A-small-attempt0.in""


def debug(*args):
    return
    sys.stderr.write(str(args) + ""\n"")


def do_dup(items):
    c = collections.Counter(items)
    c1 = [1 if max(c.values()) > 1 else 0]
    return sum(c1)


def do_trial(M):
    N = list(range(len(M)))
    trace = sum(M[_][_] for _ in N)
    row_dups = [do_dup(M[r]) for r in N]
    col_dups = [do_dup([M[c][_] for c in N]) for _ in N]
    return trace, sum(row_dups), sum(col_dups)


if INPUT:
    f = open(INPUT)
else:
    f = sys.stdin

T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    matrix = []
    for _ in range(N):
        matrix.append([int(_) for _ in f.readline().split()])
    v = do_trial(matrix)
    print(""Case #%d: %s"" % (i + 1, v))
",0000000000212929.PYTHON3,901,49,124,Python,000000000019fd27,0000000000212929,000000000020993c,gizzywump,2020
422,00000000002c35f6,"#!/usr/bin/env python3

import io

import collections
import functools

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


def choose(N, K):
    return fact(N) // (fact(K) * fact(N-K))


def fact(N):
    if N == 0:
        return 1
    r = 1
    for _ in range(1, N+1):
        r *= _
    return r


def cost(path):
    return sum(choose(a, b) for a, b in path)


def short(T):
    return [(_, 0) for _ in range(T)]


def long(T):
    path = set()
    row = 2
    while choose(row, 3) + choose(row, 2) + choose(row, 1) + row + 1 < T:
        row += 1
    row -= 1

    p = (row, 3)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    # stay in col 3

    while choose(row, 3) + choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 3)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    p = (row, 2)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    # stay in col 2

    while choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 2)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    p = (row, 1)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    while T >= 0 and row >= 0:
        p = (row, 1)
        if choose(*p) + row < T:
            path.add(p)
            T -= choose(*p)
            dprint(""adding %s so %d remaining"" % (p, T))
        p = (row, 0)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    #breakpoint()

    assert T == 0
    path = sorted(path)
    return path


def do_trial(T):
    if T < 100:
        path = short(T)
    else:
        #breakpoint()
        path = long(T)

    real_total = sum(choose(a, b) for a, b in path)
    if real_total != T:
        print(""%d vs %d"" % (real_total, T))
        breakpoint()

    final_path = [(a+1, b+1) for (a, b) in path]
    s = io.StringIO()
    for _ in final_path:
        s.write(""\n%d %d"" % _)
    return s.getvalue()


def main():

    f = sys.stdin
    if INPUT:
        try:
            f = open(INPUT)
        except:
            pass


    T = int(f.readline()[:-1])
    for i in range(T):
        N = int(f.readline())
        v = do_trial(N)
        print(""Case #%d: %s"" % (i + 1, v))


if __name__ == ""__main__"":
    main()
",00000000002c35f6.PYTHON3,2758,146,408,Python,000000000019fd74,00000000002c35f6,00000000002b1353,gizzywump,2020
423,00000000002c2e86,"#!/usr/bin/env python3

import io

import collections
import functools

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


def choose(N, K):
    return fact(N) // (fact(K) * fact(N-K))


@functools.lru_cache(maxsize=500)
def fact(N):
    if N == 0:
        return 1
    r = 1
    for _ in range(1, N+1):
        r *= _
    return r


def cost(path):
    return sum(choose(a, b) for a, b in path)


def short(T):
    return [(_, 0) for _ in range(T)]


def long(T):
    path = set()
    row = 2
    while choose(row, 3) + choose(row, 2) + choose(row, 1) + row + 1 < T:
        row += 1
    row -= 1

    p = (row, 3)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    # stay in col 3

    while choose(row, 3) + choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 3)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    p = (row, 2)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    # stay in col 2

    while choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 2)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    p = (row, 1)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    while T >= 0 and row >= 0:
        p = (row, 1)
        if choose(*p) + row < T:
            path.add(p)
            T -= choose(*p)
            dprint(""adding %s so %d remaining"" % (p, T))
        p = (row, 0)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    #breakpoint()

    assert T == 0
    path = sorted(path)
    return path


def do_trial(T):
    if T < 100:
        path = short(T)
    else:
        #breakpoint()
        path = long(T)

    real_total = sum(choose(a, b) for a, b in path)
    if real_total != T:
        print(""%d vs %d"" % (real_total, T))
        breakpoint()

    final_path = [(a+1, b+1) for (a, b) in path]
    s = io.StringIO()
    for _ in final_path:
        s.write(""\n%d %d"" % _)
    return s.getvalue()


def main():

    f = sys.stdin
    if INPUT:
        try:
            f = open(INPUT)
        except:
            pass


    T = int(f.readline()[:-1])
    for i in range(T):
        N = int(f.readline())
        v = do_trial(N)
        print(""Case #%d: %s"" % (i + 1, v))


if __name__ == ""__main__"":
    main()
",00000000002c2e86.PYTHON3,2792,147,409,Python,000000000019fd74,00000000002c2e86,00000000002b1353,gizzywump,2020
424,00000000002c2941,"#!/usr/bin/env python3

import io

import collections
import functools

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
#INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


@functools.lru_cache(maxsize=5000)
def choose(N, K):
    return fact(N) // (fact(K) * fact(N-K))


@functools.lru_cache(maxsize=500)
def fact(N):
    if N == 0:
        return 1
    r = 1
    for _ in range(1, N+1):
        r *= _
    return r


def cost(path):
    return sum(choose(a, b) for a, b in path)


def short(T):
    return [(_, 0) for _ in range(T)]


def long(T):
    path = set()
    row = 2
    while choose(row, 3) + choose(row, 2) + choose(row, 1) + row + 1 < T:
        row += 1
    row -= 1

    p = (row, 3)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    # stay in col 3

    while choose(row, 3) + choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 3)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    p = (row, 2)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    # stay in col 2

    while choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 2)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    p = (row, 1)
    path.add(p)
    T -= choose(*p)
    row -= 1
    dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    while T >= 0 and row >= 0:
        p = (row, 1)
        if choose(*p) + row < T:
            path.add(p)
            T -= choose(*p)
            dprint(""adding %s so %d remaining"" % (p, T))
        p = (row, 0)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s (%d) so %d remaining"" % (p, choose(*p), T))

    #breakpoint()

    assert T == 0
    path = sorted(path)
    return path


def do_trial(T):
    if T < 100:
        path = short(T)
    else:
        #breakpoint()
        path = long(T)

    real_total = sum(choose(a, b) for a, b in path)
    if real_total != T:
        print(""%d vs %d"" % (real_total, T))
        breakpoint()

    final_path = [(a+1, b+1) for (a, b) in path]
    s = io.StringIO()
    for _ in final_path:
        s.write(""\n%d %d"" % _)
    return s.getvalue()


def main():

    f = sys.stdin
    if INPUT:
        try:
            f = open(INPUT)
        except:
            pass


    T = int(f.readline()[:-1])
    for i in range(T):
        N = int(f.readline())
        v = do_trial(N)
        print(""Case #%d: %s"" % (i + 1, v))


if __name__ == ""__main__"":
    main()
",00000000002c2941.PYTHON3,2827,148,410,Python,000000000019fd74,00000000002c2941,00000000002b1353,gizzywump,2020
425,00000000002bda73,"#!/usr/bin/env python3

import collections
import functools

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


@functools.lru_cache(maxsize=5000)
def choose(N, K):
    return fact(N) // (fact(K) * fact(N-K))


@functools.lru_cache(maxsize=500)
def fact(N):
    if N == 0:
        return 1
    r = 1
    for _ in range(1, N+1):
        r *= _
    return r


def cost(path):
    return sum(choose(a, b) for a, b in path)

def short(T):
    return [(_, _) for _ in range(T)]


def long(T):
    path = set()
    row = 2
    while choose(row, 2) + choose(row, 1) + row < T:
        row += 1
    row -= 1

    p = (row, 2)
    path.add(p)
    T -= choose(*p)
    row -= 1

    # stay in col 2

    while choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 2)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s so %d remaining"" % (p, T))

    p = (row, 1)
    path.add(p)
    T -= choose(*p)
    row -= 1

    for r in range(0, row+1):
        p = (r, 0)
        path.add(p)
        T -= choose(*p)

    dprint(""%d remaining after basic path"" % T)
    #breakpoint()

    while T > 0 and row >= 0:
        p = (row, 1)
        if choose(*p) <= T:
            path.add(p)
            T -= choose(*p)
            dprint(""adding %s so %d remaining"" % (p, T))
        row -= 1

    #breakpoint()

    assert T == 0
    path = sorted(path)
    return path


def do_trial(T):
    if T < 100:
        path = short(T)
    else:
        #breakpoint()
        path = long(T)

    real_total = sum(choose(a, b) for a, b in path)
    if real_total != T:
        print(""%d vs %d"" % (real_total, T))
        breakpoint()

    final_path = [(a+1, b+1) for a, b in path]
    s = """".join([""\n%d %d"" % _ for _ in final_path])
    return s


f = sys.stdin
if INPUT:
    try:
        f = open(INPUT)
    except:
        pass


T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    v = do_trial(N)
    print(""Case #%d: %s"" % (i + 1, v))
",00000000002bda73.PYTHON3,2151,124,314,Python,000000000019fd74,00000000002bda73,00000000002b1353,gizzywump,2020
426,00000000002bd3e8,"#!/usr/bin/env python3

import collections
import functools

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


@functools.lru_cache(maxsize=5000)
def choose(N, K):
    return fact(N) // (fact(K) * fact(N-K))


@functools.lru_cache(maxsize=500)
def fact(N):
    if N == 0:
        return 1
    r = 1
    for _ in range(1, N+1):
        r *= _
    return r


def cost(path):
    return sum(choose(a, b) for a, b in path)

def short(T):
    return [(_, _) for _ in range(T)]


def long(T):
    path = set()
    row = 2
    while choose(row, 2) + choose(row, 1) + row < T:
        row += 1
    row -= 1

    p = (row, 2)
    path.add(p)
    T -= choose(*p)
    row -= 1

    # stay in col 2

    while choose(row, 2) + choose(row, 1) + row <= T:
        p = (row, 2)
        path.add(p)
        T -= choose(*p)
        row -= 1
        dprint(""adding %s so %d remaining"" % (p, T))

    p = (row, 1)
    path.add(p)
    T -= choose(*p)
    row -= 1

    for r in range(0, row+1):
        p = (r, 0)
        path.add(p)
        T -= choose(*p)

    dprint(""%d remaining after basic path"" % T)
    #breakpoint()

    while T > 0 and row >= 0:
        p = (row, 1)
        if choose(*p) <= T:
            path.add(p)
            T -= choose(*p)
            dprint(""adding %s so %d remaining"" % (p, T))
        row -= 1

    #breakpoint()

    assert T == 0
    path = sorted(path)
    return path


def do_trial(T):
    if T < 100:
        path = short(T)
    else:
        #breakpoint()
        path = long(T)

    real_total = sum(choose(a, b) for a, b in path)
    if real_total != T:
        print(""%d vs %d"" % (real_total, T))
        breakpoint()

    final_path = [(a+1, b+1) for a, b in path]
    s = ""\n"".join([""%d %d"" % _ for _ in final_path])
    return s


f = sys.stdin
if INPUT:
    try:
        f = open(INPUT)
    except:
        pass


T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    v = do_trial(N)
    print(""Case #%d: %s"" % (i + 1, v))
",00000000002bd3e8.PYTHON3,2151,124,314,Python,000000000019fd74,00000000002bd3e8,00000000002b1353,gizzywump,2020
427,00000000002b5f52,"#!/usr/bin/env python3

import collections

import math
import re
import sys

# sys.setrecursionlimit(50)

INPUT = None
INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


def rev(word):
    return ''.join(reversed(list(word)))


def remove_prefix(prefix, word):
    while len(prefix) > 0 and len(word) > 0 and word[0] == prefix[0]:
        word, prefix = word[1:], prefix[1:]
    return word


def best_prefix(words):
    prefixes = [_.split(""*"")[0] for _ in words]
    prefix = """"
    for _ in prefixes:
        if not _.startswith(prefix[:len(_)]):
            return ""*""
        if len(_) > len(prefix):
            prefix = _
    return prefix


def best_match(words):
    # first, let's wittle away the ends
    words = [rev(_) for _ in words]
    suffix = best_prefix(words)
    if suffix == ""*"":
        return suffix
    words = [remove_prefix(suffix, _) for _ in words]

    words = [rev(_) for _ in words]
    prefix = best_prefix(words)
    if prefix == ""*"":
        return prefix
    words = [remove_prefix(prefix, _) for _ in words]

    suffix = rev(suffix)

    middle = []
    for word in words:
        middle.append(word.replace(""*"", """"))
    r = prefix + ''.join(middle) + suffix
    return r


def do_trial(words):
    return best_match(words)


f = sys.stdin
if INPUT:
    try:
        f = open(INPUT)
    except:
        pass


T = int(f.readline()[:-1])
for i in range(T):
    N = int(f.readline())
    words = []
    for _ in range(N):
        words.append(f.readline()[:-1])
    v = do_trial(words)
    print(""Case #%d: %s"" % (i + 1, v))
",00000000002b5f52.PYTHON3,1622,84,204,Python,000000000019fd74,00000000002b5f52,00000000002b3034,gizzywump,2020
428,0000000000300cac,"#!/usr/bin/env python3

import sys

MAX_COORD = int(1e9)


def dprint(*args, **kwargs):
    return print(file=sys.stderr, *args, **kwargs)


def throw_dart(f, x, y):
    print(""%d %d"" % (x, y))
    sys.stdout.flush()
    # breakpoint()
    msg = f.readline()
    dprint(""dart @ (%d, %d) %s"" % (x, y, msg))
    if msg.startswith(""CENTER""):
        raise ValueError()
    r = msg.startswith(""HIT"")
    return r


def find_y_max(f, x, y):
    a = y
    b = MAX_COORD
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, x, g):
            a = g
        else:
            b = g
    return g


def find_y_min(f, x, y):
    a = -MAX_COORD
    b = y
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, x, g):
            b = g
        else:
            a = g
    return g


def find_x_max(f, x, y):
    a = x
    b = MAX_COORD
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, g, y):
            a = g
        else:
            b = g
    return g


def find_x_min(f, x, y):
    a = -MAX_COORD
    b = x
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, g, y):
            b = g
        else:
            a = g
    return g


def do_trial(f, A, B):
    MIN_BOARD_SIZE = A

    x_min = -MAX_COORD + MIN_BOARD_SIZE
    x_max = MAX_COORD - MIN_BOARD_SIZE
    y_min = -MAX_COORD + MIN_BOARD_SIZE
    y_max = MAX_COORD - MIN_BOARD_SIZE

    # step 1: find a hit somewhere

    STEP = A // 2
    done = 0
    dprint(""STEP = %s"" % STEP)
    for x in range(-MAX_COORD+STEP, MAX_COORD + STEP, STEP):
        if done:
            break
        for y in range(-MAX_COORD+STEP, MAX_COORD + STEP, STEP):
            hit = throw_dart(f, x, y)
            if hit:
                done = 1
                break

    for _ in range(1):
        # step 2: figure out Y boundaries of circle
        dprint(""step 2 with hit at %s %s"" % (x, y))

        y_max = find_y_max(f, x, y)
        dprint(""y_max is %s"" % y_max)

        y_min = find_y_min(f, x, y)
        dprint(""y_min is %s"" % y_min)

        y = (y_min + y_max + 1) // 2

        # step 3: figure out X boundaries of circle (center Y)

        x_max = find_x_max(f, x, y)
        dprint(""x_max is %d"" % x_max)

        x_min = find_x_min(f, x, y)
        dprint(""x_min is %d"" % x_min)

        x = (x_min + x_max + 1) // 2

    for x0 in range(x-3, x+4):
        for y0 in range(y-3, y+4):
            throw_dart(f, x0, y0)


def main():
    f = sys.stdin
    T, A, B = [int(_) for _ in f.readline().split()]
    dprint(""T A B => %s %s %s"" % (T, A, B))
    for _ in range(T):
        try:
            do_trial(f, A, B)
        except ValueError:
            pass


if __name__ == ""__main__"":
    main()
",0000000000300cac.PYTHON3,2731,134,422,Python,000000000019fef2,0000000000300cac,00000000002d5b63,gizzywump,2020
429,00000000003001b2,"#!/usr/bin/env python3

import sys

MAX_COORD = int(1e9)


def dprint(*args, **kwargs):
    return print(file=sys.stderr, *args, **kwargs)


def throw_dart(f, x, y):
    print(f""{x} {y}"")
    sys.stdout.flush()
    #breakpoint()
    msg = f.readline()
    dprint(f""dart @ ({x}, {y}) {msg}"")
    if msg.startswith(""CENTER""):
        raise ValueError()
    r = msg.startswith(""HIT"")
    return r


def find_y_max(f, x, y):
    a = y
    b = MAX_COORD
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, x, g):
            a = g
        else:
            b = g
    return g


def find_y_min(f, x, y):
    a = -MAX_COORD
    b = y
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, x, g):
            b = g
        else:
            a = g
    return g


def find_x_max(f, x, y):
    a = x
    b = MAX_COORD
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, g, y):
            a = g
        else:
            b = g
    return g


def find_x_min(f, x, y):
    a = -MAX_COORD
    b = x
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, g, y):
            b = g
        else:
            a = g
    return g


def do_trial(f, A, B):
    MIN_BOARD_SIZE = A
    MAX_BOARD_SIZE = B

    x_min = -MAX_COORD + MIN_BOARD_SIZE
    x_max = MAX_COORD - MIN_BOARD_SIZE
    y_min = -MAX_COORD + MIN_BOARD_SIZE
    y_max = MAX_COORD - MIN_BOARD_SIZE

    hits = []
    misses = []

    # step 1: find a hit somewhere

    STEP = A // 2
    done = 0
    dprint(f""STEP = {STEP}"")
    for x in range(-MAX_COORD+STEP, MAX_COORD + STEP, STEP):
        if done:
            break
        for y in range(-MAX_COORD+STEP, MAX_COORD + STEP, STEP):
            hit = throw_dart(f, x, y)
            if hit:
                done = 1
                break

    for _ in range(1):
        # step 2: figure out Y boundaries of circle
        dprint(f""step 2 with hit at {x} {y}"")

        y_max = find_y_max(f, x, y)
        dprint(f""y_max is {y_max}"")

        y_min = find_y_min(f, x, y)
        dprint(f""y_min is {y_min}"")

        y = (y_min + y_max + 1) // 2

        # step 3: figure out X boundaries of circle (center Y)

        x_max = find_x_max(f, x, y)
        dprint(f""x_max is {y_max}"")

        x_min = find_x_min(f, x, y)
        dprint(f""x_min is {x_min}"")

        x = (x_min + x_max + 1) // 2

    for x0 in range(x-3, x+4):
        for y0 in range(y-3, y+4):
            h = throw_dart(f, x0, y0)


def main():
    f = sys.stdin
    T, A, B = [int(_) for _ in f.readline().split()]
    dprint(""T A B => %s %s %s"" % (T, A, B))
    for _ in range(T):
        try:
            do_trial(f, A, B)
        except ValueError:
            pass


if __name__ == ""__main__"":
    main()
",00000000003001b2.PYTHON3,2758,138,412,Python,000000000019fef2,00000000003001b2,00000000002d5b63,gizzywump,2020
430,00000000002fecc7,"#!/usr/bin/env python3

import sys

MAX_COORD = int(1e9)


def dprint(*args, **kwargs):
    return print(file=sys.stderr, *args, **kwargs)


def throw_dart(f, x, y):
    print(f""{x} {y}"")
    sys.stdout.flush()
    #breakpoint()
    msg = f.readline()
    r = msg.startswith(""HIT"")
    dprint(f""dart @ ({x}, {y}) {msg}"")
    if msg.startswith(""CENTER""):
        raise ValueError(""got it"")
    return r


def find_y_max(f, x, y):
    a = y
    b = MAX_COORD
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, x, g):
            a = g
        else:
            b = g
    return g


def find_y_min(f, x, y):
    a = -MAX_COORD
    b = y
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, x, g):
            b = g
        else:
            a = g
    return g


def find_x_max(f, x, y):
    a = x
    b = MAX_COORD
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, g, y):
            a = g
        else:
            b = g
    return g


def find_x_min(f, x, y):
    a = -MAX_COORD
    b = x
    while a + 1 < b:
        g = (a + b + 1) // 2
        if throw_dart(f, g, y):
            b = g
        else:
            a = g
    return g


def do_trial(f, A, B):
    MIN_BOARD_SIZE = A
    MAX_BOARD_SIZE = B

    x_min = -MAX_COORD + MIN_BOARD_SIZE
    x_max = MAX_COORD - MIN_BOARD_SIZE
    y_min = -MAX_COORD + MIN_BOARD_SIZE
    y_max = MAX_COORD - MIN_BOARD_SIZE

    hits = []
    misses = []

    # step 1: find a hit somewhere

    STEP = A // 2
    done = 0
    dprint(f""STEP = {STEP}"")
    for x in range(-MAX_COORD+STEP, MAX_COORD + STEP, STEP):
        if done:
            break
        for y in range(-MAX_COORD+STEP, MAX_COORD + STEP, STEP):
            hit = throw_dart(f, x, y)
            if hit:
                done = 1
                break

    for _ in range(2):
        # step 2: figure out Y boundaries of circle
        dprint(f""step 2 with hit at {x} {y}"")

        y_max = find_y_max(f, x, y)
        dprint(f""y_max is {y_max}"")

        y_min = find_y_min(f, x, y)
        dprint(f""y_min is {y_min}"")

        y = (y_min + y_max + 1) // 2

        # step 3: figure out X boundaries of circle (center Y)

        x_max = find_x_max(f, x, y)
        dprint(f""x_max is {y_max}"")

        x_min = find_x_min(f, x, y)
        dprint(f""x_min is {x_min}"")

        x = (x_min + x_max + 1) // 2

    for x0 in range(x-3, x+4):
        for y0 in range(y-3, y+4):
            h = throw_dart(f, x0, y0)


def main():
    f = sys.stdin
    T, A, B = [int(_) for _ in f.readline().split()]
    dprint(""T A B => %s %s %s"" % (T, A, B))
    for _ in range(T):
        try:
            do_trial(f, A, B)
        except ValueError:
            pass


if __name__ == ""__main__"":
    main()
",00000000002fecc7.PYTHON3,2766,138,413,Python,000000000019fef2,00000000002fecc7,00000000002d5b63,gizzywump,2020
431,00000000002f9c50,"#!/usr/bin/env python3

import collections

import math
import re
import sys

# sys.setrecursionlimit(50)

INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


def is_possible(X, Y):
    if X == Y == 0:
        return True
    odd_count = 0
    for _ in [X, Y]:
        if abs(_) % 2 == 1:
            odd_count += 1
    if odd_count == 1:
        return True


def directions_to_try(X, Y):
    if X == Y == 0:
        return
    if abs(X) % 2 == 1:
        yield ""W"", (-1, 0)
        yield ""E"", (1, 0)
    if abs(Y) % 2 == 1:
        yield ""N"", (0, 1)
        yield ""S"", (0, -1)


def do_trial(X, Y):
    so_far = []
    while True:
        dprint(""XY = %d, %d"" % (X, Y))
        if X == Y == 0:
            return ''.join(so_far)
        if not is_possible(X, Y):
            return ""IMPOSSIBLE""
        d_possible = None
        d_done = None
        for d, offset in directions_to_try(X, Y):
            new_x = (X - offset[0]) // 2
            new_y = (Y - offset[1]) // 2
            if new_x == new_y == 0:
                d_done = d
                offset_done = offset
                break
            if is_possible(new_x, new_y):
                d_possible = d
                offset_possible = offset
        if d_done:
            so_far.append(d_done)
            offset = offset_done
        elif d_possible:
            so_far.append(d_possible)
            offset = offset_possible
        else:
            return ""IMPOSSIBLE""
        X = (X - offset[0]) // 2
        Y = (Y - offset[1]) // 2


f = sys.stdin
if INPUT:
    try:
        f = open(INPUT)
    except:
        pass


T = int(f.readline()[:-1])
for i in range(T):
    X, Y = [int(_) for _ in f.readline().split()]
    v = do_trial(X, Y)
    print(""Case #%d: %s"" % (i + 1, v))
",00000000002f9c50.PYTHON3,1813,86,239,Python,000000000019fef2,00000000002f9c50,00000000002d5b62,gizzywump,2020
432,000000000033e6de,"#!/usr/bin/env python3

import collections

import math
import re
import sys

from pdb import set_trace as debugger

# sys.setrecursionlimit(50)

INPUT = None
INPUT = ""tiny""


def dprint(*args, **kwargs):
    return
    return print(file=sys.stderr, *args, **kwargs)


def do_trial(L, R):
    i = 1
    while max(L, R) >= i:
        if L >= R:
            L -= i
        else:
            R -= i
        i += 1
    return ""%d %d %d"" % (i-1, L, R)


f = sys.stdin
if INPUT:
    try:
        f = open(INPUT)
    except:
        pass


T = int(f.readline()[:-1])
for i in range(T):
    L, R = [int(_) for _ in f.readline().split()]
    v = do_trial(L, R)
    print(""Case #%d: %s"" % (i + 1, v))
",000000000033e6de.PYTHON3,691,46,103,Python,000000000019ffb9,000000000033e6de,00000000003384ea,gizzywump,2020
433,C-large-0.py,"import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def xorsum(x):
 	r = 0
 	for a in x:
 		r = r ^ a
 	return r
 
 def diff(a,b):
 	a = list(tuple(a))
 	b = list(tuple(b))
 	for x in b:
 		if x in a:
 			a.remove(x)
 	return a
 
 for t in range(T):
 	n = int(sys.stdin.readline())
 	x = readlist()
 	
 	if xorsum(x) != 0:
 		ans = ""NO""
 	else:
 		x.sort()
 		ans = sum(x[1:])
 	print ""Case #%d: %s"" % (t+1, ans)
",gcj/2011/975485/a1ex/1059486/1/extracted/C-large-0.py,520,33,81,Python,975485,1,1059486,a1ex,2011
434,C-small-1.py,"import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def xorsum(x):
 	r = 0
 	for a in x:
 		r = r ^ a
 	return r
 
 def diff(a,b):
 	a = list(tuple(a))
 	b = list(tuple(b))
 	for x in b:
 		if x in a:
 			a.remove(x)
 	return a
 
 for t in range(T):
 	n = int(sys.stdin.readline())
 	x = readlist()
 	
 	ans = ""NO""
 	best = 0
 	for i in range(n):
 		print >> sys.stderr, i
 		for S in itertools.combinations(x,i):
 			K = diff(x,S)
 			sS = sum(S)
 			xS = xorsum(S)
 			xK = xorsum(K)
 			#~ print S,K,sS,xS,xK
 			if xS == xK:
 				if sS > best:
 					best = sS
 					ans = ""%d"" % sS
 	print ""Case #%d: %s"" % (t+1, ans)
",gcj/2011/975485/a1ex/1059486/0/extracted/C-small-1.py,729,42,118,Python,975485,0,1059486,a1ex,2011
435,A-large-0.py,"import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 P = int(sys.stdin.readline())
 
 for p in range(P):
 	L = sys.stdin.readline().strip().split("" "")[1:]
 	
 	to,tb = 0,0
 	po,pb = 1,1
 	rp = L[0]
 	first=1
 	for r,k in zip(L[0::2],L[1::2]):
 		#~ print r,k
 		k = int(k)
 
 		if r == 'O':
 			to += abs(k-po)
 			po = k
 		else:
 			tb += abs(k-pb)
 			pb = k
 
 		if rp != r:
 			#~ if first:
 				#~ first = 0
 			#~ else:
 				if r == 'O':
 					to = max(to,tb)
 				else:
 					tb = max(to,tb)
 				
 
 		if r == 'O':
 			to += 1
 			po = k
 		else:
 			tb += 1
 			pb = k
 		rp = r
 		#~ print to,po,tb,pb
 
 	ans = max(to,tb)
 	print ""Case #%d: %d"" % (p+1, ans)
",gcj/2011/975485/a1ex/1080487/1/extracted/A-large-0.py,743,48,119,Python,975485,1,1080487,a1ex,2011
436,D-small-2.py,"from __future__ import division
 import sys, string
 import itertools
 import math
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def key(element):
     return element
 
 def find_cycles(l):
     seen = set()
     cycles = []
     for i in range(len(l)):
         if i != key(l[i]) and not i in seen:
             cycle = []
             n = i
             while 1: 
                 cycle.append(n)
                 n = key(l[n])
                 if n == i:
                     break
             seen = seen.union(set(cycle))
             cycles.append(list(reversed(cycle)))
     return cycles
 
 cL = {}
 cP = {}
 def P(n,k): # prob sa pice i bune din n (nu mai multe)
 	try:
 		L = cL[n]
 	except:
 		L = list(itertools.permutations(range(n)))
 		cL[n] = L
 	
 	if (n,k) in cP:
 		return cP[n,k]
 
 	print >> sys.stderr, ""P(%d,%d)"" % (n,k)
 
 	S = [ sum([1 if i==x else 0 for i,x in enumerate(a)]) for a in L ]
 	ans = len(filter(lambda x:x==k, S)) / float(len(L))
 	cP[n,k] = ans
 	return ans
 
 cQ = {}
 def Q(n): # cat timp imi trebuie
 	if n < 1: return 0
 	if n == 1: return 0
 	if n == 2: return 2
 
 	if n in cQ:
 		return cQ[n]
 
 	print >> sys.stderr, ""Q(%d)"" % n
 
 	r = 1
 	for i in range(1,n+1):
 		r += P(n,i) * Q(n-i)
 	q = r / (1 - P(n,0))
 	
 	cQ[n] = q
 	return q
 
 for t in range(T):
 	N = int(sys.stdin.readline())
 	print >> sys.stderr, t, N
 	L = readlist()
 	S = list(L)
 	S.sort()
 	p = [S.index(x) for x in L]
 	#~ print p
 	C = find_cycles(p)
 	#~ print C
 	g = 0
 	s = 0
 	for c in C:
 		s += len(c)
 		#~ print len(c)
 	g = Q(s)
 	ans = ""%.10f"" % g
 	print ""Case #%d: %s"" % (t+1, ans)
",gcj/2011/975485/a1ex/992486/0/extracted/D-small-2.py,1694,86,272,Python,975485,0,992486,a1ex,2011
437,B-large-0.py,"import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 Oppo = {}
 
 def checkoppo(L,e):
 	for o in L:
 		if Oppo.get((o,e)):
 			return 1
 	return 0
 
 for t in range(T):
 	Comb = {} # combine rules
 	Oppo = {} # opposite elements
 	L = sys.stdin.readline().strip().split("" "") # num of base elements => third element
 	
 	C = int(L[0])
 	B = L[1:C+1]
 	D = int(L[C+1])
 	O = L[C+2:C+2+D]
 	N = int(L[C+2+D])
 	E = L[C+2+D+1]
 	#~ print C,B,D,O,N,len(E),E
 	
 	for b1,b2,r in B:
 		Comb[b1,b2] = r
 		Comb[b2,b1] = r
 	
 	for o1,o2 in O:
 		Oppo[o1,o2] = 1
 		Oppo[o2,o1] = 1
 	
 	L = []
 	#~ print Comb, Oppo
 	for e in E:
 		#~ print L
 		if len(L):
 			c = Comb.get((L[-1], e))
 			if c:
 				L = L[:-1] + [c]
 				continue
 		
 		if checkoppo(L,e):
 			L = []
 			continue
 		
 		L.append(e)
 
 	#~ print L
 	ans = ""["" + string.join(L,"", "") + ""]""
 	print ""Case #%d: %s"" % (t+1, ans)
",gcj/2011/975485/a1ex/1026487/1/extracted/B-large-0.py,990,57,154,Python,975485,1,1026487,a1ex,2011
438,A-large-0.py,"from __future__ import division
 import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 A = []
 R,C = 0,0
 
 def chk():
 	for r in range(R):
 		for c in range(C):
 			if A[r][c] == '#':
 				return 1
 	return 0
 	
 def red():
 	for r in range(R-1):
 		for c in range(C-1):
 			if A[r][c] == '#' and A[r+1][c] == '#' and A[r][c+1] == '#' and A[r+1][c+1] == '#':
 				A[r][c], A[r+1][c], A[r][c+1], A[r+1][c+1] = ""/"", ""\\"", ""\\"", ""/""
 				return 1
 	return 0
 	
 for t in range(T):
 	R, C = readlist()
 	A = []
 	for i in range(R):
 		ln = list(sys.stdin.readline().strip())
 		A.append(ln)
 	
 	#~ print A
 	
 	while red():
 		pass
 	print ""Case #%d:"" % (t+1)
 	if chk():
 		print ""Impossible""
 	else:
 		for i in range(R):
 			print string.join(A[i], '')
",gcj/2011/1128486/a1ex/1060485/1/extracted/A-large-0.py,859,45,126,Python,1128486,1,1060485,a1ex,2011
439,B-small-1.py,"#~ from __future__ import division
 import sys, string
 import itertools
 
 sys.setrecursionlimit(1e6)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 D = []
 N = 0
 C = 0
 
 cache = {}
 def fun(i,L,tsb):
 	if i == N: 
 		return 0 # am ajuns :)
 
 	if (i,L,tsb) in cache: return cache[i,L,tsb]
 	dnext = D[i % C]
 	
 	# sans booster
 	a = dnext * 2 + fun(i+1, L, max(tsb - dnext*2, 0))
 	
 	#~ print >> sys.stderr, i,L,tsb,""sans"", dnext * 2 
 	if L:
 		dslow = tsb/2
 		dfast = dnext - dslow
 		if dfast > 0: # castig ceva daca fac speed buster
 			b = tsb + dfast + fun(i+1, L-1, 0) # with booster
 			#~ print >> sys.stderr, i,L,tsb,""with"", tsb + dfast
 			a = min(a,b)
 	
 	cache[i,L,tsb] = a
 	return a
 
 for k in range(T):
 	data = readlist()
 	L,t,N,C = data[0:4]
 	D = data[4:]
 	cache = {}
 	print >> sys.stderr, data[0:4]
 
 	m = fun(0, L, t)
 	print ""Case #%d: %s"" % (k+1, m)
",gcj/2011/1128486/a1ex/1003485/0/extracted/B-small-1.py,961,48,162,Python,1128486,0,1003485,a1ex,2011
440,C-small-0.py,"import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def har(i,notes):
 	for n in notes:
 		if n % i != 0 and i % n != 0:
 			return 0
 	return 1
 
 for t in range(T):
 	N,L,H = readlist()
 	notes = readlist()
 	
 	print >> sys.stderr, N,L,H,notes
 	ans = ""NO""
 	for i in range(L,H+1):
 		if har(i,notes):
 			ans = str(i)
 			break
 	print ""Case #%d: %s"" % (t+1, ans)
",gcj/2011/1128486/a1ex/1076485/0/extracted/C-small-0.py,475,26,73,Python,1128486,0,1076485,a1ex,2011
441,A-large-0.py,"from __future__ import division
 import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 for kkk in range(T):
 	X,S,R,t,N = readlist()
 	
 	seg = []
 	for i in range(N):
 		b,e,w = readlist()
 		seg.append((e-b, w + S))
 		X -= e-b;
 	seg.append((X, S));
 	seg.sort(key=lambda x: x[1])
 	#~ print seg
 	
 	total_time = 0
 	for dist,speed in seg:
 		time = dist/speed
 		speedrun = (R + speed - S)
 		# primii t pasi ii alerg
 		trun = min(dist / speedrun, t)
 		#~ print t,dist,speed,time,trun
 		t -= trun
 		dist -= trun * speedrun
 		total_time += trun
 		# acu merg incet
 		total_time += dist / speed
 		#~ print total_time
 	# v = d/t => t = d/v
 	
 	print ""Case #%d: %.10g"" % (kkk+1, total_time)
",gcj/2011/1150486/a1ex/1163489/1/extracted/A-large-0.py,806,38,123,Python,1150486,1,1163489,a1ex,2011
442,B-small-1.py,"from __future__ import division
 import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 A = []
 def check(R0,C0,R,D):
 	mi = 0
 	mj = 0
 	for i in range(R0, R0+R):
 		for j in range(C0, C0+R):
 			d = D + A[i][j]
 			if (i,j) == (R0,C0) or (i,j) == (R0+R-1,C0+R-1): continue
 			if (i,j) == (R0+R-1,C0) or (i,j) == (R0,C0+R-1): continue
 			mi += d * (i - R0 - (R-1)/2)
 			mj += d * (j - C0 - (R-1)/2)
 			#~ print A[i][j],
 		#~ print """"
 	mi /= R
 	mj /= C
 	#~ print mi,mj
 	return abs(mi) < 1e-5 and abs(mj) < 1e-5
 
 
 def incerc(R,C,D,A):
 	sol = ""IMPOSSIBLE""
 	for r in range(min(R,C), 2, -1):
 		for i in range(R - r + 1):
 			for j in range(C - r + 1):
 				#~ print i,j,r
 				if check(i,j,r,D):
 					sol = r
 					return sol
 	return sol
 
 for kkk in range(T):
 	R,C,D = readlist()
 	A = []
 	for i in range(R):
 		A.append([int(c) for c in sys.stdin.readline().strip()])
 	
 	sol = incerc(R,C,D,A)
 	
 	print ""Case #%d: %s"" % (kkk+1, sol)
",gcj/2011/1150486/a1ex/1160486/0/extracted/B-small-1.py,1058,49,174,Python,1150486,0,1160486,a1ex,2011
443,B-small-0.py,"from __future__ import division
 import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 D = 0
 
 # 0 1 2 3 4
 # p,v,t,l,r
 def grp(p,v):
 	t = D * (v-1)/2
 	return p,v,t,p-t,p+t
 
 def overlaps(a,b):
 	pa = a[0]
 	pb = b[0]
 	if pa > pb: return overlaps(b,a)
 	
 	if b[3] - a[4] < D: return D - (b[3] - a[4])
 	return 0
 
 def shift(b,db):
 	#~ print ""shift"", db
 	return (b[0] + db, b[1], b[2], b[3]+db, b[4]+db)
 	
 def join(a,b):
 	pa = a[0]
 	pb = b[0]
 	if pa > pb: return join(b,a)
 	
 	ta,tb = a[2], b[2]
 	if ta > tb:
 		db = min(ta - tb, overlaps(a,b))
 		b = shift(b,db)
 	elif tb > ta:
 		da = min(ta - tb, -overlaps(a,b))
 		a = shift(a,da)
 	
 	d = overlaps(a,b)/2;
 	p1 = a[0] - d
 	p2 = b[0] + d
 	a = shift(a,-d)
 	b = shift(b,d)
 	return (a[0]+b[0])/2, a[1]+b[1], max(a[2],b[2])+d, a[1], b[2]
 	
 
 def get_overlap(G):
 	for i in range(len(G)):
 		for j in range(i+1, len(G)):
 			a,b = G[i], G[j]
 			if overlaps(a, b):
 				#~ print >> sys.stderr, ""overlap: %s, %s"" % (a,b)
 				G.remove(a)
 				G.remove(b)
 				G.append(join(a,b))
 				return 1
 	#~ print >> sys.stderr, ""no more overlaps""
 	return 0
 
 for t in range(T):
 	C, D = readlist()
 	G = []
 	for i in range(C):
 		p,v = readlist()
 		G.append(grp(p,v))
 	
 	#~ print G
 	while get_overlap(G):
 		pass
 	
 	m = 0
 	for g in G:
 		m = max(m, g[2])
 	
 	print ""Case #%d: %s"" % (t+1, m)
",gcj/2011/1150485/a1ex/1058489/0/extracted/B-small-0.py,1470,80,236,Python,1150485,0,1058489,a1ex,2011
444,A-large-0.py,"from __future__ import division
 import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 A = [];
 N = 0;
 
 def WP(i):
 	line = A[i]
 	w = len([x for x in line if x == '1'])
 	l = len([x for x in line if x == '0'])
 	#~ print i, w, l, line
 	try: ans = w / (w + l)
 	except: ans = 0
 	#~ print ""WP(%d) = %g"" % (i, ans)
 	return ans
 
 def WPx(i, you):
 	line = list(A[i])
 	line[you] = '.'
 	w = len([x for x in line if x == '1'])
 	l = len([x for x in line if x == '0'])
 	#~ print i, you, line, w, l
 	try: ans = w / (w + l)
 	except: ans = 0
 	#~ print ""WPx(%d,%d) = %g"" % (i, you, ans)
 	return ans
 
 owp = {}
 def OWP(i):
 	
 	if i in owp: return owp[i]
 	
 	s = 0
 	n = 0
 	for k in range(N):
 		#~ print i,k,A[i],A[i][k]
 		if A[i][k] != '.':
 			s += WPx(k, i)
 			n += 1
 	try: s /= n
 	except: s = 0
 	owp[i] = s
 	print >> sys.stderr, ""OWP(%d) = %g"" % (i, s)
 	return s
 
 def OOWP(i):
 	s = 0
 	n = 0
 	for k in range(N):
 		if A[i][k] != '.':
 			s += OWP(k)
 			n += 1
 	try: s /= n
 	except: s = 0
 	return s
 
 def RPI(i):
 	return 0.25 * WP(i) + 0.50 * OWP(i) + 0.25 * OOWP(i)
 
 for t in range(T):
 	N = int(sys.stdin.readline())
 	print >> sys.stderr, t, N
 	A = []
 	owp = {}
 	for i in range(N):
 		l = sys.stdin.readline().strip()
 		A.append(l)
 	#~ print A
 	
 	#~ for i in range(N):
 		#~ print ""oowp(%g) = %g"" % (i, OOWP(i))
 	
 	print ""Case #%d:"" % (t+1)
 	for i in range(N):
 		print RPI(i)
",gcj/2011/1150485/a1ex/1048486/1/extracted/A-large-0.py,1523,82,299,Python,1150485,1,1048486,a1ex,2011
445,A-small-0.py,"from __future__ import division
 import sys, string
 import itertools
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 A = [];
 N = 0;
 
 def WP(i):
 	line = A[i]
 	w = len([x for x in line if x == '1'])
 	l = len([x for x in line if x == '0'])
 	#~ print i, w, l, line
 	try: ans = w / (w + l)
 	except: ans = 0
 	#~ print ""WP(%d) = %g"" % (i, ans)
 	return ans
 
 def WPx(i, you):
 	line = list(A[i])
 	line[you] = '.'
 	w = len([x for x in line if x == '1'])
 	l = len([x for x in line if x == '0'])
 	#~ print i, you, line, w, l
 	try: ans = w / (w + l)
 	except: ans = 0
 	#~ print ""WPx(%d,%d) = %g"" % (i, you, ans)
 	return ans
 
 def OWP(i):
 	s = 0
 	n = 0
 	for k in range(N):
 		#~ print i,k,A[i],A[i][k]
 		if A[i][k] != '.':
 			s += WPx(k, i)
 			n += 1
 	try: s /= n
 	except: s = 0
 	return s
 
 def OOWP(i):
 	s = 0
 	n = 0
 	for k in range(N):
 		if A[i][k] != '.':
 			s += OWP(k)
 			n += 1
 	try: s /= n
 	except: s = 0
 	return s
 
 def RPI(i):
 	return 0.25 * WP(i) + 0.50 * OWP(i) + 0.25 * OOWP(i)
 
 for t in range(T):
 	N = int(sys.stdin.readline())
 	A = []
 	for i in range(N):
 		l = sys.stdin.readline().strip()
 		A.append(l)
 	#~ print A
 	
 	#~ for i in range(N):
 		#~ print ""oowp(%g) = %g"" % (i, OOWP(i))
 	
 	print ""Case #%d:"" % (t+1)
 	for i in range(N):
 		print RPI(i)
",gcj/2011/1150485/a1ex/1048486/0/extracted/A-small-0.py,1379,74,270,Python,1150485,0,1048486,a1ex,2011
446,C.py,"from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def try_increment(N,H,L):
     #~ print N,H
     for i in range(N-1): # L[i] e varful cel mai de sus, vazut din i
         #~ print i, L[i]
         lhs = (H[L[i]-1] - H[i]) / (L[i]-1 - i)
         for j in range(i+1, N):  # adica, (H[L[i]] - H[i]) / (L[i]-i) > (H[j] - H[i]) / (j-i) oricare ar fi j != L[i]
             if j != L[i]-1:
                 rhs = (H[j] - H[i]) / (j-i)
                 if lhs <= rhs:
                     H[L[i]-1] += 1
                     return 1
     return 0
 
 for k in range(T):
     print >> sys.stderr, k
     N = int(sys.stdin.readline());
     L = readlist()
     
     
     H = [0] * N
     
     found=0
     for a in range(20):
         if not try_increment(N,H,L):
             found=1
             break
 
     if not found:
         ans = ""Impossible""
     else:
         ans = string.join([""%s""%h for h in H])
     
     print ""Case #%d: %s"" % ((k+1), ans)
     
     
",gcj/2012/1842485/a1ex/1486492/1/extracted/C.py,1130,46,154,Python,1842485,1,1486492,a1ex,2012
447,C.py,"from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def try_increment(N,H,L):
     #~ print N,H
     for i in range(N-1): # L[i] e varful cel mai de sus, vazut din i
         #~ print i, L[i]
         lhs = (H[L[i]-1] - H[i]) / (L[i]-1 - i)
         for j in range(i+1, N):  # adica, (H[L[i]] - H[i]) / (L[i]-i) > (H[j] - H[i]) / (j-i) oricare ar fi j != L[i]
             if j != L[i]-1:
                 rhs = (H[j] - H[i]) / (j-i)
                 if lhs <= rhs:
                     H[L[i]-1] += 1
                     return 1
     return 0
 
 for k in range(T):
     
     N = int(sys.stdin.readline());
     L = readlist()
     
     
     H = [0] * N
     
     found=0
     for a in range(100000):
         if not try_increment(N,H,L):
             found=1
             break
 
     if not found:
         ans = ""Impossible""
     else:
         ans = string.join([""%s""%h for h in H])
     
     print ""Case #%d: %s"" % ((k+1), ans)
     
     
",gcj/2012/1842485/a1ex/1486492/0/extracted/C.py,1112,46,150,Python,1842485,0,1486492,a1ex,2012
448,A.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 global LB, LT, N, M
 
 for k in range(T):
     
     N = int(sys.stdin.readline());
     D = []
     L = []
     for i in range(N):
         DL = readlist();
         D.append(DL[0]);
         L.append(DL[1]);
     Dtotal = int(sys.stdin.readline());
     print >> sys.stderr, D, L, Dtotal
 
     s0 = (0, D[0])
     Q = [s0]
     i = 0;
     ans = ""NO""
     while i < len(Q):
         #~ print >> sys.stderr, i,Q
         s = Q[i]
         pos, leng = s  
         # aici sunt acum
         # pot sa ajung pana la pos+len*2
         if pos + leng*2 >= Dtotal:
             ans = ""YES""
             break
         # sau pot sa prind lianele aflate intre pos+leng si pos+leng*2
         for j in range(N):
             if D[j] > pos+leng and D[j] <= pos+leng*2:
                 newpos = D[j] - min(L[j], D[j] - pos-leng)
                 newleng = D[j] - newpos
                 #print newpos, D[j], newleng
                 new = (newpos, newleng)
                 #~ print >> sys.stderr, ""s: %s, d:%d => %s"" % (s, D[j], new)
                 #~ if L[j] >= newleng:
                 if new not in Q:
                     Q.append(new)
                 #~ else: print ""too short""
         i += 1
         
     
     print ""Case #%d: %s"" % ((k+1), ans)
     
     
",gcj/2012/1842485/a1ex/1481486/0/extracted/A.py,1476,55,194,Python,1842485,0,1481486,a1ex,2012
449,C-small-2.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def sum(A, bits):
     s = 0
     for i in range(20):
         if bits & (1<<i):
             s += A[i]
     return s
 
 def print_sum(A, bits):
     for i in range(20):
         if bits & (1<<i):
             print A[i],
     print """"
 
 for k in range(T):
     A = readlist()[1:]
     #print >> sys.stderr, A
     print ""Case #%d:"" % (k+1)
     
     S = {};
     N = 1<<20;
     for i in range(N):
         s = sum(A, i)
         if s in S:
             j = S[s]
             print_sum(A, i)
             print_sum(A, j)
             break
         else:
             S[s] = i
     
",gcj/2012/1836486/a1ex/1484496/0/extracted/C-small-2.py,799,41,105,Python,1836486,0,1484496,a1ex,2012
450,C-small-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def shl(x,n):
     s = str(x)
     s = s[n:] + s[:n]
     return int(s)
 
 def recycled(a,b):
     n = len(str(a))
     for i in range(n):
         if b == shl(a,i):
            return 1
     return 0
 
 def num_recycled(A,B):
     n = 0
     for i in range(A,B):
         for j in range(i+1, B+1):
             if recycled(i,j):
                 n += 1;
     return n
 
 for k in range(T):
     A,B = readlist()
     print >> sys.stderr, k
     print ""Case #%d: %d"" % (k+1, num_recycled(A,B))
",gcj/2012/1460488/a1ex/1483488/0/extracted/C-small-1.py,707,35,93,Python,1460488,0,1483488,a1ex,2012
451,A.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 f = open(""A-map.in"", ""r"")
 A = f.readline()
 B = f.readline()
 
 M = {}
 for i in range(len(A)):
     M[A[i]] = B[i]
 
 T = int(sys.stdin.readline())
 
 for k in range(T):
     coded = sys.stdin.readline().strip(""\n"")
     decoded = """"
     for c in coded:
         decoded += M.get(c, ""*"")
         
     print >> sys.stderr, k
     print ""Case #%d: %s"" % (k+1, decoded)
",gcj/2012/1460488/a1ex/1483485/0/extracted/A.py,552,27,74,Python,1460488,0,1483485,a1ex,2012
452,B-large-2.py,"from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [float(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def pad0(X):
     Y = {}
     for i in range(len(X)):
         Y[i] = X[i]
     Y[-1] = 0
     return Y
 
 for k in range(T):
     
     print ""Case #%d:"" % (k+1)
     
     D, N, A = readlist()
     N = int(N); A = int(A);
     #~ print D, N, A
     
     X = []
     T = []
     for i in range(N):
         t,x = readlist()
         X.append(x)
         T.append(t)
     Accs = readlist()
     
     # avem grija ca masina cealalta sa se opreasca unde vrem noi
     for i in range(N):
         if X[i] > D:
             if i > 0:
                 v = (X[i] - X[i-1]) / (T[i] - T[i-1])
                 #~ print ""viteza: "", v
                 T[i] = T[i] - (X[i] - D) / v
             X[i] = D
             N = i+1
             break
     
     X = X[:N]
     T = T[:N]
     
     
     #~ X = pad0(X)
     #~ T = pad0(T)
     #~ print X, T
     
     for a in Accs:
         x0 = 0
         v0 = 0
         t = 0
         
         for i in range(1,N): # pe fiecare segment
             dt = T[i] - T[i-1]
             Xend = x0 + v0*dt + a*dt*dt/2
             Xother = X[i]
             Vother = (X[i] - X[i-1]) / (T[i] - T[i-1])
             #~ print Vother
             if Xend < Xother:
                 x0 = Xend # yay, nu m-am ciocnit
                 v0 = v0 + a*dt
                 t = T[i]
                 #~ print ""nu m-am ciocnit""
             else:
                 x0 = Xother
 
                 # in cat timp pot sa parcurg dx?
                 dx = X[i] - X[i-1]
                 dtx1 = (-v0 + sqrt(v0**2 + 2*a*dx))/a
                 dtx2 = -(v0 + sqrt(v0**2 + 2*a*dx))/a
                 dtx = max(dtx1,dtx2)
     
                 v0 = v0 + a*dtx
                 #~ print ""vother, vmy"", Vother, v0
                 t = T[i]
             #~ print i, x0, v0, t
     
         # sa vedem cat mai avem
         dt = 0
         if x0 < D:
             dx = D-x0
             #~ print ""mai avem: "", dx, v0, t
 
             dt1 = (-v0 + sqrt(v0**2 + 2*a*dx))/a
             dt2 = -(v0 + sqrt(v0**2 + 2*a*dx))/a
             dt = max(dt1,dt2)
             #~ print dt1, dt2
         
         print t+dt
",gcj/2012/1781488/a1ex/1482492/1/extracted/B-large-2.py,2334,95,331,Python,1781488,1,1482492,a1ex,2012
453,A-large-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 for k in range(T):
     
     N = int(sys.stdin.readline())
     V = {}
     for i in range(N):
         L = readlist()
         V[i+1] = L[1:]
     
     print ""Case #%d:"" % (k+1),
     
     found=0
     for X in range(1,N+1):
         Q = [X]
         N = {}
         N[X] = 1;
         i = 0
         while i < len(Q):
             for v in V[Q[i]]:
                 Q.append(v)
                 if v in N:
                     print ""Yes""
                     found=1
                     break
                 else:
                     N[v] = 1
             if found:
                 break
             i += 1
     if not found:
         print ""No""
     
     
     #print >> sys.stderr, A
     
     
",gcj/2012/1781488/a1ex/1674486/1/extracted/A-large-1.py,924,46,103,Python,1781488,1,1674486,a1ex,2012
454,C-small-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def solve(Lb, Lt):
     # aici luam decizii
     # D1: nu arunc primul tip de cutii
     # D2: le arunc
     
     if not Lt: return 0
     if not Lb: return 0
     
     # daca nu arunc: sa vedem cate pot sa produc
     bn, bt = Lb[0]
     ans1 = 0
     for i, (tn, tt) in enumerate(Lt):
         if tt == bt:
             prod = min(bn, tn)
             bnr = bn - prod
             tnr = tn - prod
             Lbr = Lb[1:]
             Ltr = Lt[i+1:]
             
             if bnr:
                 Lbr = [(bnr, bt)] + Lbr
 
             if tnr:
                 Ltr = [(tnr, bt)] + Ltr
             
             ans1 = prod + solve(Lbr, Ltr)
             break
     
     # daca le arunc: nu produc nimic, sa vedem ce iese la urmatoarea
     # pastrez jucariile, arunc doar cutiile
     ans2 = solve(Lb[1:], Lt)
     return max(ans1,ans2)
     
 
 for k in range(T):
     
     N, M = readlist()
     Lb = readlist()
     Lt = readlist()
     LB = []
     LT = []
     for i in range(N):
         LB.append((Lb[2*i], Lb[2*i+1]))
     for i in range(M):
         LT.append((Lt[2*i], Lt[2*i+1]))
     
     #~ print LB
     #~ print LT
     
     ans = solve(LB, LT)
     print ""Case #%d: %d"" % ((k+1), ans)
     
     
",gcj/2012/1781488/a1ex/1485490/0/extracted/C-small-1.py,1441,64,198,Python,1781488,0,1485490,a1ex,2012
455,A-large-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def isvowel(c):
     return c in ['a', 'e', 'i', 'o', 'u']
     
 def consec(s):
     x = 0
     m = 0
     for c in s:
         if isvowel(c):
             m = max(m, x)
             x = 0
         else: x += 1
     m = max(m, x)
     return m;
     
 for k in range(T):
     print >> sys.stderr, k
     
     w, n = sys.stdin.readline().strip().split("" "")
     n = int(n)
     L = len(w)
     
     ans = 0
     count = 0
     C = []
     lastj = 1+n-3
     for j in range(L):
         c = w[j]
         if isvowel(c):
             count = 0
         else:
             count += 1
             if count >= n:
                 a,b = lastj-1 +3-n , j+1
                 mul = b - a - n + 1
                 #~ print L-j, a, b, mul
                 delta = (L - j) * mul
                 ans += delta
                 C.append(delta)
                 lastj = j
     #~ print C
     
     print ""Case #%d: %s"" % ((k+1), ans)
 
",gcj/2013/2437488/a1ex/2751486/1/extracted/A-large-1.py,1138,54,162,Python,2437488,1,2751486,a1ex,2013
456,A-small-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def isvowel(c):
     return c in ['a', 'e', 'i', 'o', 'u']
     
 def consec(s):
     x = 0
     m = 0
     for c in s:
         if isvowel(c):
             m = max(m, x)
             x = 0
         else: x += 1
     m = max(m, x)
     return m;
     
 for k in range(T):
     print >> sys.stderr, k
     
     w, n = sys.stdin.readline().strip().split("" "")
     n = int(n)
     L = len(w)
     
     ans = 0
     for i in range(L+1):
         for j in range(i+1,L+1):
             if consec(w[i:j]) >= n:
                 ans += 1
     
     print ""Case #%d: %s"" % ((k+1), ans)
 
",gcj/2013/2437488/a1ex/2751486/0/extracted/A-small-1.py,794,40,110,Python,2437488,0,2751486,a1ex,2013
457,B-small-3.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 D = {}
 def add(Q, elem):
     global D
     X,Y,FOO,BAR = elem
     if (X,Y) not in D:
         D[X,Y] = True
         Q.append(elem)
 
 for k in range(T):
     
     X,Y = readlist()
     print >> sys.stderr, k,X,Y
     
     Q = [(0,0,1,-1)]
     i = 0
     D = {}
     
     ans=""""
     while i < len(Q):
          current = Q[i]
          x,y,d,p = current
          #~ print >> sys.stderr, k,x,y
          
          if (x,y) == (X,Y):
              #~ print ""bingo""
              ans = """"
              while p >= 0:
                  elem = Q[p]
                  xn,yn = x,y
                  x,y,d,p = elem
                  #~ print x,y
                  
                  move = ""X""
                  if xn>x: move = ""E""
                  elif xn<x: move = ""W""
                  elif yn>y: move = ""N""
                  elif yn<y: move = ""S""
                  ans = move + ans
              break
          
          if abs(x - X) < 1000 and abs(y - Y) < 1000:
              
              add(Q, (x + d, y, d+1, i))
              add(Q, (x - d, y, d+1, i))
              add(Q, (x, y+d, d+1, i))
              add(Q, (x, y-d, d+1, i))
              #~ print len(Q)
          
          i += 1
     
     
     print ""Case #%d: %s"" % ((k+1), ans)
 
",gcj/2013/2437488/a1ex/2749486/0/extracted/B-small-3.py,1475,64,185,Python,2437488,0,2749486,a1ex,2013
458,B-small-3.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 E = None
 R = None
 N = None
 V = None
 
 def sim(energy):
     Elev = E
     total = 0
     for i,e in enumerate(energy): # direct sim
         if e > Elev:
             print ""whoops"", i, e, Elev
             return None
         total += e * V[i]
         Elev -= e
         Elev += R
         Elev = min(Elev, E)
     return total, Elev
 
 cache = {}
 
 ES = []
 def solve(e0, i0):
     global cache
     
     if i0 == N-1:
         return e0 * V[i0]
     
     if e0 < 0: return 0
     
     if (e0,i0) in cache:
         return cache[e0,i0]
     
     G = []
     for i in range(e0+1):
         G.append(solve(min(E,e0-i+R), i0+1) + i * V[i0])
     #~ print G
     ans = max(G)
     cache[e0,i0] = ans
     ES[i0] = G.index(ans)
     return ans
 
 
 for k in range(T):
     print >> sys.stderr, k
     
     E, R, N = readlist()
     V = readlist()
     cache = {}
     ES = range(N)
     
     ans = solve(E, 0)
     #~ print ES, sim(ES)
     
     print ""Case #%d: %s"" % ((k+1), ans)
 
",gcj/2013/2418487/a1ex/2645486/0/extracted/B-small-3.py,1208,66,176,Python,2418487,0,2645486,a1ex,2013
459,A-large-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def area(i):
     return i*2-1
 
 def suma(n, a, d):
     return n * (2*a + (n-1)*d) / 2
 
 # how much paint we need for n circles starting at R?
 def paint(n, R):
     if R % 2:
         return suma(n+R/2, 3, 4) - suma(R/2, 3, 4)
     else:
         return suma(n+R/2, 1, 4) - suma(R/2, 1, 4)
 
 def bins(lo, hi, R, T):
     if hi <= lo+1:
         return lo
     
     m = int((lo+hi)/2)
     enough = paint(m, R) <= T
     #~ print lo, hi, m, enough
     if enough:
         return bins(m, hi, R, T)
     else:
         return bins(lo, m, R, T)
 
 for k in range(T):
     print >> sys.stderr, k
     
     R, T = readlist()
     
     #~ print R,T
     
     ans = bins(1, 1e300, R, T)
     
     print ""Case #%d: %s"" % ((k+1), ans)
 
",gcj/2013/2418487/a1ex/2464487/1/extracted/A-large-1.py,951,47,144,Python,2418487,1,2464487,a1ex,2013
460,A-small-1.py,"#from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def area(i):
     return i*2-1
 
 def suma(n, a, d):
     return n * (2*a + (n-1)*d) / 2
 
 # how much paint we need for n circles starting at R?
 def paint(n, R):
     if R % 2:
         return suma(n+R/2, 3, 4) - suma(R/2, 3, 4)
     else:
         return suma(n+R/2, 1, 4) - suma(R/2, 1, 4)
 
 def bins(lo, hi, R, T):
     if hi <= lo+1:
         return lo
     
     m = int((lo+hi)/2)
     enough = paint(m, R) <= T
     #~ print lo, hi, m, enough
     if enough:
         return bins(m, hi, R, T)
     else:
         return bins(lo, m, R, T)
 
 for k in range(T):
     print >> sys.stderr, k
     
     R, T = readlist()
     
     #~ print R,T
     
     ans = bins(1, 1e100, R, T)
     
     print ""Case #%d: %s"" % ((k+1), ans)
 
",gcj/2013/2418487/a1ex/2464487/0/extracted/A-small-1.py,951,47,144,Python,2418487,0,2464487,a1ex,2013
461,A-large-0.py,"from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def pal(x):
     return str(x) == str(x)[::-1]
 
 def check(M):
     for m in M:
         x = m.replace(""T"", ""X"").count('X')
         if x >= 4:
             return ""X won""
         o = m.replace(""T"", ""O"").count('O')
         if o >= 4:
             return ""O won""
     
     return ""Game has not completed"" if ""."" in """".join(M) else ""Draw""
     
 for k in range(T):
     print >> sys.stderr, k
     
     A = sys.stdin.readline().strip()
     B = sys.stdin.readline().strip()
     C = sys.stdin.readline().strip()
     D = sys.stdin.readline().strip()
     empty = sys.stdin.readline().strip()
 
     cols = [A[i] + B[i] + C[i] + D[i] for i in range(4)]
     
     d1 = A[0] + B[1] + C[2] + D[3]
     d2 = A[3] + B[2] + C[1] + D[0]
     
     ans = check([A,B,C,D,d1,d2] + cols)
     
     print ""Case #%d: %s"" % ((k+1), ans)
",gcj/2013/2270488/a1ex/2453486/1/extracted/A-large-0.py,1039,42,136,Python,2270488,1,2453486,a1ex,2013
462,C-small-0.py,"from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def pal(x):
     return str(x) == str(x)[::-1]
 
 for k in range(T):
     print >> sys.stderr, k
     a,b = readlist()
     
     c = 0
     for x in range(int(sqrt(b))+1):
         xs = x*x
         if pal(x) and pal(xs):
             if xs >= a and xs <= b:
                 print >> sys.stderr, x, x*x
                 c += 1
 
     ans = c
     print ""Case #%d: %s"" % ((k+1), ans)
",gcj/2013/2270488/a1ex/2463486/0/extracted/C-small-0.py,597,28,82,Python,2270488,0,2463486,a1ex,2013
463,B-large-0.py,"from __future__ import division
 import sys, string
 import itertools
 from math import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 T = int(sys.stdin.readline())
 
 def transpose(M):
     return map(list, zip(*M))
 
 def try_mow(S, M, i):
     line = M[i]
     H = max(line)
     
     # let's mow
     for j,h in enumerate(S[i]):
         if h > H:
             S[i][j] = H
 
 for k in range(T):
     print >> sys.stderr, k
     m,n = readlist()
     M = []
     S = []
     for i in range(m):
         M.append(readlist())
         S.append([100] * n)
     
     for i in range(m):
         try_mow(S, M, i)
     
     M = transpose(M)
     S = transpose(S)
 
     for i in range(n):
         try_mow(S, M, i)
 
     M = transpose(M)
     S = transpose(S)
 
     for i in range(m):
         try_mow(S, M, i)
         
     print >> sys.stderr, ""\n"".join([str(x) for x in S])
     #print ""\n"".join([str(x) for x in S])
     
     ans = ""YES"" if S == M else ""NO""
     print ""Case #%d: %s"" % ((k+1), ans)
",gcj/2013/2270488/a1ex/2449486/1/extracted/B-large-0.py,1051,52,142,Python,2270488,1,2449486,a1ex,2013
464,C-small-0.py,"import sys, string
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def goodalg(N):
     a = range(N)
     for k in range(N):
         p = randint(k, N-1)
         aux = a[k]
         a[k] = a[p]
         a[p] = aux
     return a
 
 def badalg(N):
     a = range(N)
     for k in range(N):
         p = randint(0, N-1)
         aux = a[k]
         a[k] = a[p]
         a[p] = aux
     return a
 
 def testalg(alg, N, M):
     cnt = [0]*N
     for i in range(M):
         r = alg(N)
         cnt = [cnt[i] + r[i] for i in range(N)]
     return cnt
 
 def count_inversion(lst):
     return merge_count_inversion(lst)[1]
 
 def merge_count_inversion(lst):
     if len(lst) <= 1:
         return lst, 0
     middle = int( len(lst) / 2 )
     left, a = merge_count_inversion(lst[:middle])
     right, b = merge_count_inversion(lst[middle:])
     result, c = merge_count_split_inversion(left, right)
     return result, (a + b + c)
 
 def merge_count_split_inversion(left, right):
     result = []
     count = 0
     i, j = 0, 0
     left_len = len(left)
     while i < left_len and j < len(right):
         if left[i] <= right[j]:
             result.append(left[i])
             i += 1
         else:
             result.append(right[j])
             count += left_len - i
             j += 1
     result += left[i:]
     result += right[j:]
     return result, count        
 
 def testinv(alg, N, M):
     inv = []
     for i in range(M):
         r = alg(N)
         inv.append(count_inversion(r))
     return inv
 
 for t in range(T):
     N = readint()
     P = readlist()
     
     np = count_inversion(P)
     thr = 249765
     print ""Case #%d: %s"" % (t+1, ""BAD"" if np < thr else ""GOOD"")
",gcj/2014/2984486/a1ex/5752104073297920/0/extracted/C-small-0.py,1836,80,235,Python,2984486,0,5752104073297920,a1ex,2014
465,A-small-0.py,"import sys, string
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def flip(cfg, bit):
     new = []
     for c in cfg:
         new.append(c ^ (1 << bit))
     return sorted(new)
 
 def expand(cfg, nbits):
     cfgs = []
     for b in range(nbits):
         cfgs.append(flip(cfg, b))
     return cfgs
     
 for t in range(T):
     N, L = readlist()
     init = readbinlist()
     goal = readbinlist()
     init = sorted(init)
     goal = sorted(goal)
     
     print (""Case #%d:"" % (t+1)),
     #~ print N,L,init,goal
     
     if init == goal:
         print ""0""
         continue
 
     Q = [init]
     S = [0]
     i = 0
     solved = False
     while i < len(Q) and not solved:
         cfg = Q[i]
         s = S[i]
         for c in expand(cfg, L):
             if c == goal:
                 print s+1
                 #~ print c
                 solved = True
                 break
             if c not in Q:
                 Q.append(c)
                 S.append(s+1)
         #~ print Q
         
         i += 1
     if not solved:
         print ""NOT POSSIBLE""
",gcj/2014/2984486/a1ex/5634947029139456/0/extracted/A-small-0.py,1313,62,161,Python,2984486,0,5634947029139456,a1ex,2014
466,B-large-0.py,"from __future__ import division
 import sys, string
 
 def readlist():
 	return [float(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def sim(C,F,X):
     #~ print C,F,X
     t = 0
     r = 2
 
     tbest = 1e10
     
     while 1:
         tfarm = t + C/r
         twin = t + X/r
         #~ print t, tfarm, twin
         tbest = min(tbest, twin)
         if tfarm > tbest:
             break
         t = tfarm
         r += F
     return tbest
     
 
 T = readint()
 
 for t in range(T):
     C,F,X = readlist()
     print ""Case #%d: %s"" % (t+1, sim(C,F,X))
",gcj/2014/2974486/a1ex/5709773144064000/1/extracted/B-large-0.py,624,34,85,Python,2974486,1,5709773144064000,a1ex,2014
467,C-small-3.py,"import sys, string
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def full(R,C):
     A = []
     for i in range(R):
         A.append(['*'] * C)
     return A
 
 def dump(A):
     R = len(A)
     C = len(A[0])
     for i in range(R):
         s = """"
         for j in range(C):
             s += A[i][j]
         print s
     #~ print
 
 def clean(A):
     A = deepcopy(A)
     R = len(A)
     C = len(A[0])
     for i in range(R):
         for j in range(C):
             if A[i][j] != '*':
                 A[i][j] = '.'
     return A
 
 def count(A,printsol):
     A = deepcopy(A)
     R = len(A)
     C = len(A[0])
     for i in range(R):
         for j in range(C):
             if A[i][j] == '.':
                 for ii in range(i-1,i+2):
                     for jj in range(j-1,j+2):
                         if ii >= 0 and jj >= 0 and ii < R and jj < C:
                             if A[ii][jj] == '*':
                                 A[ii][jj] = ','
     n = 0
     for i in range(R):
         for j in range(C):
             if A[i][j] != '*':
                 n += 1
 
     if printsol:
         A = clean(A)
         A[printsol[0]][printsol[1]] = 'c'
         dump(A)
         return A
         
     return n
 
 def expand(A):
     A = deepcopy(A)
     R = len(A)
     C = len(A[0])
     for i in range(R):
         for j in range(C):
             if A[i][j] == '.':
                 for ii,jj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:
                     if ii >= 0 and jj >= 0 and ii < R and jj < C:
                             if A[ii][jj] == '*':
                                 X = deepcopy(A)
                                 X[ii][jj] = '.'
                                 yield X
 
 def click(A,i,j):
     R = len(A)
     C = len(A[0])
 
     n = 0
     for ii in range(i-1,i+2):
         for jj in range(j-1,j+2):
             if ii >= 0 and jj >= 0 and ii < R and jj < C:
                 if A[ii][jj] == '*':
                     n += 1
     A[i][j] = ""%d"" % n
     if n == 0:
         for ii in range(i-1,i+2):
             for jj in range(j-1,j+2):
                 if ii >= 0 and jj >= 0 and ii < R and jj < C:
                     if A[ii][jj] == '.':
                         click(A,ii,jj)
 
 def is_solved(A):
     R = len(A)
     C = len(A[0])
     for i in range(R):
         for j in range(C):
             if A[i][j] == '.':
                 return False
     return True
 
 def solve(R,C,M):
     Q = [full(R,C)]
     Q[0][0][0] = '.'
     i = 0
     
     if 0:
         ex = list(expand(Q[0]))
         ex = list(expand(ex[0]))
         for e in ex:
             dump(e)
             print
         return
 
     if R*C-M == 1:
         Q[0][0][0] = 'c'
         dump(Q[0])
         return
     
     while i < len(Q):
         c = Q[i]
         #~ dump(c)
         #~ print
         cnt = count(c,0)
         if cnt == R*C - M:
             sol = count(c,(0,0))
             click(sol,0,0)
             #~ print is_solved(sol)
             #~ dump(sol)
             return
         
         if cnt < R*C - M:
             for d in expand(c):
                 if d not in Q:
                     Q.append(d)
         i += 1
 
 
 
 
 
 
 
     Q = [full(R,C)]
     Q[0][R/2][C/2] = '.'
     i = 0
     
     if R*C-M == 1:
         Q[0][R/2][C/2] = 'c'
         dump(Q[0])
         return
     
     while i < len(Q):
         c = Q[i]
         
         cnt = count(c,0)
         if cnt == R*C - M:
             sol = count(c,(R/2,C/2))
             click(sol,R/2,C/2)
             #~ print is_solved(sol)
             #~ dump(sol)
             return
 
         if cnt < R*C - M:
             for d in expand(c):
                 if d not in Q:
                     Q.append(d)
         i += 1
     
     print ""Impossible""
 
 T = readint()
 
 for t in range(T):
     
     R,C,M = readlist()
     print >> sys.stderr, ""Case #%d:"" % (t+1)
     print ""Case #%d:"" % (t+1)
     solve(R,C,M)
",gcj/2014/2974486/a1ex/5690574640250880/0/extracted/C-small-3.py,4064,181,508,Python,2974486,0,5690574640250880,a1ex,2014
468,A-small-0.py,"import sys, string
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     a = readint()
     
     for i in range(a):
         na = readlist()
     for i in range(4-a):
         readlist()
     
     b = readint()
     for i in range(b):
         nb = readlist()
     for i in range(4-b):
         readlist()
     
     nc = list(set(na) & set(nb))
     
     if len(nc) == 1:
         print ""Case #%d: %d"" % (t+1, nc[0])
     elif len(nc) > 1:
         print ""Case #%d: Bad magician!"" % (t+1)
     else:
         print ""Case #%d: Volunteer cheated!"" % (t+1)
",gcj/2014/2974486/a1ex/5756407898963968/0/extracted/A-small-0.py,687,33,88,Python,2974486,0,5756407898963968,a1ex,2014
469,A-large-0.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def uniq(s):
     prev = ""?""
     d = """"
     for c in s:
         if c != prev:
             d += c
         prev = c
     return d
 
 def makeid(strings):
     ind = [0] * len(strings)
     u = """"
     cost = 0
     while 1:
         #~ print ind
         for i,s in zip(ind,strings):
             if i >= len(s):
                 return cost
 
         allok = True
         for i,s in zip(ind,strings):
             if s[i] != strings[0][ind[0]]:
                 allok = False
                 break
         #~ print allok, strings[0][ind[0]]
         if allok:
             u += strings[0][ind[0]]
             ind = [x+1 for x in ind]
         else:
             costx = len(strings)
             for k in range(len(strings)):
                 s = strings[k]
                 i = ind[k]
                 #~ print s, i, s[i] == s[i-1]
                 if s[i] == s[i-1]:
                     ind[k] += 1
                     costx -= 1
 
             cost += min(costx,len(strings)-costx)
             #~ print cost
     return cost
 
 for t in range(T):
     N = readint()
     strings = []
     for i in range(N):
         strings.append(sys.stdin.readline().strip() + ""$"")
     
     suniq = []
     for s in strings:
         suniq.append(uniq(s))
     
     print (""Case #%d:"" % (t+1)),
     #~ print >> sys.stderr, t
 
     nope = False
     for su in suniq:
         if su != suniq[0]:
             nope = True
     if nope:
         print ""Fegla Won""
         continue
     
     print makeid(strings)
",gcj/2014/2994486/a1ex/5751500831719424/1/extracted/A-large-0.py,1754,78,207,Python,2994486,1,5751500831719424,a1ex,2014
470,A-small-1.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def uniq(s):
     prev = ""?""
     d = """"
     for c in s:
         if c != prev:
             d += c
         prev = c
     return d
 
 def makeid(a,b):
     i = 0
     j = 0
     u = """"
     a += ""?""
     b += ""?""
     cost = 0
     while 1:
         if i >= len(a) and j >= len(b):
             cost += len(a) - i + len(b) - j
             break
         if a[i] == b[j]:
             u += a[i]
             i += 1
             j += 1
         else:
             if a[i] == a[i-1]:
                 i += 1
                 cost += 1
             else:
                 j += 1
                 cost += 1
     return cost
 
 for t in range(T):
     N = readint()
     strings = []
     for i in range(N):
         strings.append(sys.stdin.readline().strip())
     
     s1 = strings[0]
     s2 = strings[1]
     sc1 = uniq(s1)
     sc2 = uniq(s2)
     
     print (""Case #%d:"" % (t+1)),
     #~ print >> sys.stderr, t
 
     if sc1 != sc2:
         print ""Fegla Won""
     else:
         print makeid(s1,s2)
         #~ print strings
     
",gcj/2014/2994486/a1ex/5751500831719424/0/extracted/A-small-1.py,1276,67,175,Python,2994486,0,5751500831719424,a1ex,2014
471,B-small-0.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def solveb(A,B,K):
     x = 0
     for a in range(A):
         for b in range(B):
             if a & b < K:
                 x+=1
     return x
 
 for t in range(T):
     A,B,K = readlist()
 
     print (""Case #%d:"" % (t+1)),
     #~ print >> sys.stderr, t
 
     x = 0
     for a in range(A):
         for b in range(B):
             if a & b < K:
                 x+=1
     print x
",gcj/2014/2994486/a1ex/5658282861527040/1/extracted/B-small-0.py,622,34,87,Python,2994486,1,5658282861527040,a1ex,2014
472,B-small-0.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     A,B,K = readlist()
 
     print (""Case #%d:"" % (t+1)),
     #~ print >> sys.stderr, t
 
     x = 0
     for a in range(A):
         for b in range(B):
             if a & b < K:
                 x+=1
     print x
",gcj/2014/2994486/a1ex/5658282861527040/0/extracted/B-small-0.py,474,26,65,Python,2994486,0,5658282861527040,a1ex,2014
473,C-small-1.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 from fractions import gcd
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def printmaze(M):
     for c in M:
         print """".join(c)
     
 def maze(x, n, m):
     M = []
     for i in range(n):
         col = []
         for j in range(m):
             pos = j + i * m
             bit = x & (1 << pos)
             col += '*' if bit else '.'
         M.append(col)
     return M
 
 def score(M):
     n = len(M)
     m = len(M[0])
     for i in range(n):
         for j in range(m):
             if M[i][j] != '.':
                 M[i][j] = 'O'
                 break
         for j in range(m-1,-1,-1):
             if M[i][j] != '.':
                 M[i][j] = 'O'
                 break
     for j in range(m):
         for i in range(n):
             if M[i][j] != '.':
                 M[i][j] = 'O'
                 break
         for i in range(n-1,-1,-1):
             if M[i][j] != '.':
                 M[i][j] = 'O'
                 break
     s = 0
     for j in range(m):
         for i in range(n):
             if M[i][j] == '*':
                 s += 1
 
     #~ printmaze(M)
     #~ print s
     return s
 
     
 for t in range(T):
     N,M,K = readlist()
     
     mz = [
         ['.', '*', '*', '.', '.'],
         ['*', '*', '*', '*', '.'],
         ['.', '*', '*', '.', '.'],
         ['.', '.', '.', '.', '.']];
     #~ printmaze(mz)
     #~ print score(mz)
 
     #~ continue
     print >> sys.stderr, t
     print (""Case #%d:"" % (t+1)),
     
     best = -1
     for i in range(1 << (N*M)):
         #~ print i, gmpy.popcount(i)
         if gmpy.popcount(i) == K:
             mz = maze(i, N, M)
             s = score(mz)
             #~ print i
             if s > best:
                 #~ printmaze(mz)
                 #~ print s
                 best = s
     print K-best
",gcj/2014/3004486/a1ex/5658068650033152/0/extracted/C-small-1.py,2001,89,259,Python,3004486,0,5658068650033152,a1ex,2014
474,A-large-0.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 from fractions import gcd
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readfrac():
 	return [int(x) for x in sys.stdin.readline().strip().split(""/"")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def bits(n):
     b = 0
     while n > 0:
         n >>= 1
         b += 1
     return b
 
 cache = {}
 def solve(a,b):
 
     g = gcd(a,b)
     a = a/g
     b = b/g
     
     if (a,b) in cache:
         return cache[(a,b)]
         
     #~ print a,b
 
     bi = bits(b)-1
     if b != 1<<bi:
         cache[(a,b)] = None
         return None
     
     if a == b:
         cache[(a,b)] = 0
         return 0
     
     best = None
     d = min(a,b-a)
     sol = solve(a+d, b)
     if sol is not None:
         sol += 1
     best = sol
     #~ print best
     cache[(a,b)] = best
     return best
         
 
 for t in range(T):
     a,b = readfrac()
     
     print >> sys.stderr, t, a, b
     print (""Case #%d:"" % (t+1)),
     
     s = solve(a,b)
     if s == None:
         print ""impossible""
     else:
         print s
     #~ print >> sys.stderr, s
     #~ print a, b, bi, 1<<bi
",gcj/2014/3004486/a1ex/5706278382862336/1/extracted/A-large-0.py,1239,70,171,Python,3004486,1,5706278382862336,a1ex,2014
475,A-small-4.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 from fractions import gcd
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readfrac():
 	return [int(x) for x in sys.stdin.readline().strip().split(""/"")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def bits(n):
     b = 0
     while n > 0:
         n >>= 1
         b += 1
     return b
 
 cache = {}
 def solve(a,b):
 
     g = gcd(a,b)
     a = a/g
     b = b/g
     
     if (a,b) in cache:
         return cache[(a,b)]
         
     #~ print a,b
 
     bi = bits(b)-1
     if b != 1<<bi:
         cache[(a,b)] = None
         return None
     
     if a == b:
         cache[(a,b)] = 0
         return 0
     
     best = None
     for d in range(1, min(a,b-a)+1):
         sol = solve(a+d, b)
         if sol is not None:
             sol += 1
         if sol < best or best is None:
             best = sol
     #~ print best
     cache[(a,b)] = best
     return best
         
 
 for t in range(T):
     a,b = readfrac()
     
     #~ print >> sys.stderr, t, a, b
     print (""Case #%d:"" % (t+1)),
     
     s = solve(a,b)
     if s == None:
         print ""impossible""
     else:
         print s
     #~ print >> sys.stderr, s
     #~ print a, b, bi, 1<<bi
",gcj/2014/3004486/a1ex/5706278382862336/0/extracted/A-small-4.py,1320,71,182,Python,3004486,0,5706278382862336,a1ex,2014
476,B-small-8.py,"import sys, string, bisect
 from copy import copy, deepcopy
 import gmpy
 import time
 import random
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def is_updown(A):
     #~ return False
     M = max(A)
     im = A.index(M)
     for i in range(1,im+1):
         if A[i] < A[i-1]:
             return False
     for i in range(len(A)-2,im,-1):
         if A[i] < A[i+1]:
             return False
     return True
 
 def sgn(x):
     return 1 if x > 0 else -1
 
 def inversions(a):
     b = sorted(a)
     r = 0
     for d in a:
         p = bisect.bisect_left(b,d)
         r += p
         b.pop(p)
     return r
 
 def solve(A, maxpos):
     #~ print A, A[:maxpos+1], A[maxpos:], inversions(A[:maxpos]), inversions(list(reversed(A[maxpos:])))
     return inversions(A[:maxpos]) + inversions(list(reversed(A[maxpos:])))
 
 def solveb(A, maxpos):
     M = max(A)
     im = A.index(M)
     
     if len(A) <= 2:
         return 0
 
     swaps = 0
     done = False
     while not done:
         done = True
         for k in range(100):
             i = random.randint(0, len(A)-2)
             if (i < maxpos and A[i] > A[i+1]) or (i >= maxpos and A[i] < A[i+1]):
                 aux = A[i]; A[i] = A[i+1]; A[i+1] = aux
                 swaps += 1
                 done = False
     
     #~ print A, ""after"", swaps, is_updown(A)
     
     return swaps
 
 for t in range(T):
     N = readint()
     A = readlist()
 
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     #~ if len(A) > 8:
         #~ print ""x""
         #~ continue
 
     
     sol = 1000
     for i in range(len(A)):
         for k in range(100):
             s = solveb(copy(A),i)
             sol = min(sol, s)
         s = solve(copy(A),i)
         sol = min(sol, s)
     
     print sol
",gcj/2014/3014486/a1ex/5721094409420800/0/extracted/B-small-8.py,2005,89,252,Python,3014486,0,5721094409420800,a1ex,2014
477,A-large-0.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def solve(S,X):
     
     if len(S) == 0:
         return 0
     
     sol = 1 + solve(S[1:], X)
     
     for i in range(1,len(S)):
         if S[0] + S[i] <= X:
             tryx = 1 + solve(S[1:i] + S[i+1:], X)
             sol = min(sol, tryx)
     return sol
 
 def qsolve(S,X):
 
     if len(S) == 0:
         return 0
     
     for i in range(1,len(S)):
         if S[0] + S[i] <= X:
             return 1 + qsolve(S[1:i] + S[i+1:], X)
 
     return 1 + qsolve(S[1:], X)
 
 
 for t in range(T):
     N,X = readlist()
     S = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     S.sort(reverse=True)
 
     print qsolve(S,X)
",gcj/2014/3014486/a1ex/5737429512224768/1/extracted/A-large-0.py,1068,54,134,Python,3014486,1,5737429512224768,a1ex,2014
478,A-small-1.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def solve(S,X):
     
     if len(S) == 0:
         return 0
     
     sol = 1 + solve(S[1:], X)
     
     for i in range(1,len(S)):
         if S[0] + S[i] <= X:
             tryx = 1 + solve(S[1:i] + S[i+1:], X)
             sol = min(sol, tryx)
     return sol
             
 
 for t in range(T):
     N,X = readlist()
     S = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     print solve(S,X)
",gcj/2014/3014486/a1ex/5737429512224768/0/extracted/A-small-1.py,796,39,100,Python,3014486,0,5737429512224768,a1ex,2014
479,B.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [float(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     N, V, X = readlist()
     R = []
     C = []
     for i in range(N):
         r,c = readlist()
         R.append(r)
         C.append(c)
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     if N > 2:
         tbig = 0
         rbig = 0
         tsmall = 0
         rsmall = 0
         for i in range(int(N)):
             if C[i] >= X:
                 tbig += C[i] * R[i]
                 rbig += R[i]
             else:
                 tsmall += C[i] * R[i]
                 rsmall += R[i]
         if rbig: tbig /= rbig
         if rsmall: tsmall /= rsmall
         C[0] = tbig
         R[0] = rbig
         C[1] = tsmall
         R[1] = rsmall
         N = 2
         #~ print R, C
     
     #~ print N, V, X, R, C
     if N == 2 and C[0] == C[1]:
         N = 1
         R[0] += R[1]
     
     if N == 2 and R[1] == 0:
         N = 1
 
     if N == 2 and R[0] == 0:
         N = 1
         R[0] = R[1]
         C[0] = C[1]
 
     if N == 1:
         if C[0] == X:
             print ""%.9f"" % (V / R[0])
         else:
             print ""IMPOSSIBLE""
     if N == 2:
         v0 = V*(C[1]-X)/(C[1]-C[0])
         v1 = V*(X-C[0])/(C[1]-C[0])
         #~ print v0,v1
         if v0 < -1e-7 or v1 < -1e-7:
             print ""IMPOSSIBLE""
             continue
         try:
             t0 = v0 / R[0]
             t1 = v1 / R[1]
             print ""%.9f"" % max(t0, t1)
         except:
             print ""IMPOSSIBLE""
             continue
         #~ print t0, t1
",gcj/2015/8234486/a1ex/5750872826970112/1/extracted/B.py,1924,86,261,Python,8234486,1,5750872826970112,a1ex,2015
480,B.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [float(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     N, V, X = readlist()
     R = []
     C = []
     for i in range(N):
         r,c = readlist()
         R.append(r)
         C.append(c)
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     #~ print N, V, X, R, C
     if N == 2 and C[0] == C[1]:
         N = 1
         R[0] += R[1]
 
     if N == 1:
         if C[0] == X:
             print ""%.9f"" % (V / R[0])
         else:
             print ""IMPOSSIBLE""
     if N == 2:
         v0 = V*(C[1]-X)/(C[1]-C[0])
         v1 = V*(X-C[0])/(C[1]-C[0])
         #~ print v0,v1
         if v0 < -1e-7 or v1 < -1e-7:
             print ""IMPOSSIBLE""
             continue
         t0 = v0 / R[0]
         t1 = v1 / R[1]
         #~ print t0, t1
         print ""%.9f"" % max(t0, t1)
",gcj/2015/8234486/a1ex/5750872826970112/0/extracted/B.py,1179,53,158,Python,8234486,0,5750872826970112,a1ex,2015
481,C.py,"import sys, string
 from copy import copy, deepcopy
 #~ import gmpy
 import time
 import random
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def cost(phrase, en0, fr0):
     common = len(en0 & fr0)
     en1 = copy(en0)
     fr1 = copy(fr0)
     en2 = copy(en0)
     fr2 = copy(fr0)
     en1 |= phrase
     fr2 |= phrase
     return min(len(en1 & fr1), len(en2 & fr2)) - common
 
 def is_eng(phrase, en0, fr0):
     #~ common = len(en0 & fr0)
     en1 = copy(en0)
     fr1 = copy(fr0)
     en2 = copy(en0)
     fr2 = copy(fr0)
     en1 |= phrase
     fr2 |= phrase
     return len(en1 & fr1) < len(en2 & fr2)
 
 for t in range(T):
     N = readint()
     
     P = []
     for i in range(N):
         p = sys.stdin.readline().strip()
         P.append(set(p.split()))
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     en0 = P[0]
     fr0 = P[1]
     
     if N == 2:
         print len(en0 & fr0)
         continue
     
     Q = P[2:]
     
     best = 1e10
     for q in range(200):
         en = copy(en0)
         fr = copy(fr0)
         
         random.shuffle(Q)
         
         for i in range(N-2):
             if is_eng(Q[i], en, fr):
                 en |= Q[i]
             else:
                 fr |= Q[i]
         
         best = min(best, len(en & fr))
     
     print best
",gcj/2015/8234486/a1ex/5759940174020608/1/extracted/C.py,1598,77,201,Python,8234486,1,5759940174020608,a1ex,2015
482,C.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 import random
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def cost(phrase, en0, fr0):
     common = len(en0 & fr0)
     en1 = copy(en0)
     fr1 = copy(fr0)
     en2 = copy(en0)
     fr2 = copy(fr0)
     en1 |= phrase
     fr2 |= phrase
     return min(len(en1 & fr1), len(en2 & fr2)) - common
 
 def is_eng(phrase, en0, fr0):
     #~ common = len(en0 & fr0)
     en1 = copy(en0)
     fr1 = copy(fr0)
     en2 = copy(en0)
     fr2 = copy(fr0)
     en1 |= phrase
     fr2 |= phrase
     return len(en1 & fr1) < len(en2 & fr2)
 
 for t in range(T):
     N = readint()
     
     P = []
     for i in range(N):
         p = sys.stdin.readline().strip()
         P.append(set(p.split()))
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     en0 = P[0]
     fr0 = P[1]
     
     if N == 2:
         print len(en0 & fr0)
         continue
     
     Q = P[2:]
     
     best = 1e10
     for q in range(1000):
         en = copy(en0)
         fr = copy(fr0)
         
         random.shuffle(Q)
         
         for i in range(N-2):
             if is_eng(Q[i], en, fr):
                 en |= Q[i]
             else:
                 fr |= Q[i]
         
         best = min(best, len(en & fr))
     
     print best
",gcj/2015/8234486/a1ex/5759940174020608/0/extracted/C.py,1596,77,200,Python,8234486,0,5759940174020608,a1ex,2015
483,B-small-0.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def pr(M):
     for r in M:
         print r
 
 def score(i,R,C):
     s = 0
     b = bin(i)[3:]
     
     M = []
     for i in range(R):
         M.append(b[i*C : (i+1)*C])
 
     #~ print b
     #~ pr(M)
     #~ print R, C
     for i in range(R):
         for j in range(C):
             if j < C-1 and M[i][j] == '1' and M[i][j+1] == '1':
                 s += 1
             if i < R-1 and M[i][j] == '1' and M[i+1][j] == '1':
                 s += 1
     return s
 
 for t in range(T):
     R, C, N = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     A = R*C
     
     s = 1e10
     for i in range(1<<A):
         if gmpy.popcount(i) == N:
             s = min(s, score(i | (1<<A), R, C))
             if s == 0: break
     print s
",gcj/2015/8224486/a1ex/5769900270288896/0/extracted/B-small-0.py,1177,57,166,Python,8224486,0,5769900270288896,a1ex,2015
484,A.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def rev(x):
     return int(str(x)[::-1])
 
 T = readint()
 
 for t in range(T):
     N = readint()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     Q = [1]
     C = [1]
     QS = set(Q)
     k = 0
     while k < len(Q):
         s = Q[k]
         c = C[k]
         if s == N:
             print c
             break
 
         if s+1 not in QS and s+1 <= N:
             Q.append(s+1)
             C.append(c+1)
             QS.add(s+1)
         
         r = rev(s)
         if r not in QS and r <= N:
             Q.append(r)
             QS.add(r)
             C.append(c+1)
         
         k += 1
     
",gcj/2015/8224486/a1ex/5688567749672960/0/extracted/A.py,1022,53,123,Python,8224486,0,5688567749672960,a1ex,2015
485,B.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def expand(S):
     m, p = S
     
     yield (m+1, [max(x-1,0) for x in p])
     
     M = max(p)
     for i in range(len(p)):
         if p[i] == M:
             for j in range(len(p)+1):
                 if i != j:
                     for k in range(p[i]/2-1, p[i]/2+2):
                     #~ for k in [p[i]/2, (p[i]+1)/2]:
                         if k >= 2:
                             #~ k = p[i]/2
                             #~ print >> sys.stderr, i, j, k
                             pc = copy(p)
                             if j == len(pc): pc.append(0)
                             pc[i] -= k
                             pc[j] += k
                             if pc[j] <= M - 1:
                                 yield (m+1, sorted(pc))
 
 for t in range(T):
     D = readint()
     P = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     P = sorted(P)
     s = (0,P)
     Q = [s]
     best = max(P)
     
     i = 0
     while i < len(Q):
         s = Q[i]
         for c in expand(s):
             if c not in Q:
                 if c[0] >= best:
                     continue
 
                 if max(c[1]) == 0:
                     print >> sys.stderr, c
                     best = min(best, c[0])
                     continue
 
                 worst_case = c[0] + max(c[1])
                 if worst_case < best:
                     print >> sys.stderr, worst_case, c
                     best = worst_case
                 
                 #~ print >> sys.stderr, c
                 Q.append(c)
         i += 1
     print best
",gcj/2015/6224486/a1ex/5686275109552128/0/extracted/B.py,1995,76,221,Python,6224486,0,5686275109552128,a1ex,2015
486,C.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def quatmul(a,b):
 
     if a[0] == '-':
         q = quatmul(a[1], b)
         return q[1:] if q[0] == '-' else ""-"" + q
 
     if b[0] == '-':
         q = quatmul(a, b[1])
         return q[1:] if q[0] == '-' else ""-"" + q
     
     if a == '1':
         return b
     
     if b == '1':
         return a
 
     if a == 'i':
         return ""-1"" if b == 'i' else ""k"" if b == 'j' else ""-j""
 
     if a == 'j':
         return ""-k"" if b == 'i' else ""-1"" if b == 'j' else ""i""
 
     if a == 'k':
         return ""j"" if b == 'i' else ""-i"" if b == 'j' else ""-1""
 
 msg = """"
 L = 0
 eval_left = []
 eval_right = []
 
 def precompute():
     acc = ""1""
     for i in range(L):
         acc = quatmul(acc, msg[i])
         eval_left.append(acc)
         eval_right.append(acc)
     
     acc = ""1""
     for i in range(L-1,-1,-1):
         acc = quatmul(msg[i], acc)
         eval_right[i] = acc
     
     #~ print eval_left
     #~ print eval_right
 
 def eval(a,b):
     if a == 0:
         return eval_left[b-1]
     if b == L:
         return eval_right[a]
     
     A = eval_left[a-1]
     B = eval_right[b]
     C = eval_left[-1]
     
     for x in ['1', 'i', 'j', 'k', '-1', '-i', '-j', '-k']:
         if quatmul(quatmul(A,x),B) == C:
             return x
 
 for t in range(T):
     L, X = readlist()
     msg = sys.stdin.readline()[:L] * X
     L = L * X
     eval_left = []
     eval_right = []
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     ans = ""NO""
     
     if L <= 2:
         print ans
         continue
     
     precompute()
     #~ if L == 12:
         #~ print msg[0:3], eval(0,3)
         #~ print msg[3:6], eval(3,6)
         #~ print msg[6:], eval(6,L)
     
     for i in range(1,L):
         if i > 500:
             break
         if eval(0,i) == 'i':
             for j in range(i+1,L):
                 if eval(j,L) == 'k' and eval(i,j) == 'j':
                     ans = ""YES""
                     #~ print msg[:i], msg[i:j], msg[j:]
                     break
         if ans == ""YES"":
             break
     print ans
",gcj/2015/6224486/a1ex/5670465267826688/0/extracted/C.py,2480,113,337,Python,6224486,0,5670465267826688,a1ex,2015
487,A.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     Smax, S = sys.stdin.readline().strip().split("" "")
     Smax = int(Smax)
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     #print S
     
     extras = 0
     standing = 0
     for i in range(Smax+1):
         shy = int(S[i])
         if standing >= i:
             standing += shy
         elif shy:
             extras += (i - standing)
             standing += shy + extras
     print extras
",gcj/2015/6224486/a1ex/5639104758808576/1/extracted/A.py,843,38,101,Python,6224486,1,5639104758808576,a1ex,2015
488,C-small-1.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def check(D, V):
     S = set()
     for b in range(1 << len(D)):
         s = 0
         for i in range(len(D)):
             if b & (1<<i):
                 s += D[i]
         S.add(s)
     
     missing = []
     for i in range(V+1):
         if i not in S:
             missing.append(i)
     return missing
 
 for t in range(T):
     C,D,V = readlist()
     D = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     #~ print D
     missing = check(D,V)
     
     if not missing:
         print 0
         continue
     
     Q = [sorted(D)]
     C = [0]
     k = 0
     while k < len(Q):
         d = Q[k]
         c = C[k]
         missing = check(d,V)
         if not missing:
             print c
             break
         
         for m in missing[:1]:
             new = sorted(d+[m])
             if new not in Q:
                 Q.append(new)
                 C.append(c+1)
             
         k += 1
",gcj/2015/4244486/a1ex/5646553574277120/0/extracted/C-small-1.py,1359,67,162,Python,4244486,0,5646553574277120,a1ex,2015
489,B-large-1.py,"from __future__ import division
 import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 import itertools
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def count(typed, word):
     L = len(typed)
     l = len(word)
     c = 0
     for i in range(L-l+1):
         s = typed[i:i+l]
         if s == word:
             c += 1
     return c
 
 def overlap(word):
     for i in range(1, len(word)+1):
         prefix = word[:-i]
         suffix = word[i:]
         if prefix == suffix:
             return i
 
 for t in range(T):
     K,L,S = readlist()
     keyb = sys.stdin.readline().strip()
     word = sys.stdin.readline().strip()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     impossible = False
     for l in word:
         if l not in keyb:
             impossible = True
             break
     
     if impossible:
         print ""0.0""
         continue
     
     p = 1 + S - L
     for l in word:
         p *= keyb.count(l) / len(keyb)
     #~ print p
     
     ovr = overlap(word)
     max = 1 + (S - L) // ovr
     print max - p
",gcj/2015/4244486/a1ex/5708284669460480/1/extracted/B-large-1.py,1373,65,175,Python,4244486,1,5708284669460480,a1ex,2015
490,B-small-1.py,"#from __future__ import division
 import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 import itertools
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 def count(typed, word):
     L = len(typed)
     l = len(word)
     c = 0
     for i in range(L-l+1):
         s = typed[i:i+l]
         if s == word:
             c += 1
     return c
 
 def numberToBase(n, b, d):
     digits = []
     for i in range(d):
         digits.append(int(n % b))
         n /= b
     return digits[::-1]
 
 def combinations_with_replacement(str, r):
     C = []
     L = len(str)
     for i in range(L ** r):
         b = numberToBase(i, L, r)
         #~ print b
         s = """"
         for k in b:
             s += str[k]
         C.append(s)
     
     return C
 
 #~ print combinations_with_replacement(""ABC"", 2)
 #~ raise SystemExit
 
 for t in range(T):
     K,L,S = readlist()
     keyb = sys.stdin.readline().strip()
     word = sys.stdin.readline().strip()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     #~ while len(keyb) < len(word):
         #~ keyb += keyb
     
     #~ print keyb, word
     
     cmax = 0
     ctotal = 0
     num = 0
     for b in combinations_with_replacement(keyb, S):
         b = """".join(b)
         #~ print b
         c = count(b, word)
         cmax = max(cmax, c)
         ctotal += c
         num += 1
     
     cavg = 1.0 * ctotal / num
     #~ print cmax, cavg, num, ctotal, cmax - cavg
     print cmax - cavg
",gcj/2015/4244486/a1ex/5708284669460480/0/extracted/B-small-1.py,1771,82,229,Python,4244486,0,5708284669460480,a1ex,2015
491,A-large-1.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     R,C,W = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     score = (R-1) * C/W
     
     while C > W:
         score += 1
         C -= W
     
     print score + W
",gcj/2015/4244486/a1ex/5640146288377856/1/extracted/A-large-1.py,631,33,79,Python,4244486,1,5640146288377856,a1ex,2015
492,A-small-3.py,"import sys, string
 from copy import copy, deepcopy
 import gmpy
 import time
 
 import sys
 sys.setrecursionlimit(1000000)
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readbinlist():
 	return [int(x,2) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 
 for t in range(T):
     R,C,W = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     score = 0
     while C > W:
         score += 1
         C -= W
     
     print score + W
",gcj/2015/4244486/a1ex/5640146288377856/0/extracted/A-small-3.py,615,32,77,Python,4244486,0,5640146288377856,a1ex,2015
493,A.py,"import os, sys
 
 
 def solve(N):
     digits = set()
     
     for i in range(1,1000000):
         digits = digits.union(set(str(i*N)))
         
         if len(digits) == 10:
             print i*N
             return
     
     print ""INSOMNIA""
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 for t in range(T):
     N = readint()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     solve(N)
",gcj/2016/6254486/a1ex/5652388522229760/1/extracted/A.py,561,30,61,Python,6254486,1,5652388522229760,a1ex,2016
494,A.py,"import os, sys
 
 
 def solve(N):
     digits = set()
     
     for i in range(1,100):
         digits = digits.union(set(str(i*N)))
         
         if len(digits) == 10:
             print i*N
             return
     
     print ""INSOMNIA""
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 for t in range(T):
     N = readint()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     solve(N)
",gcj/2016/6254486/a1ex/5652388522229760/0/extracted/A.py,557,30,61,Python,6254486,0,5652388522229760,a1ex,2016
495,D.py,"import sys, string
 import time
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def expand(seq, orig_seq):
     new = """"
     for ch in seq:
         if ch == ""G"":
             new += ""G"" * len(orig_seq)
         else:
             new += orig_seq
     return new
 
 T = readint()
 
 # try a few numbers to figure out how the sequence behaves
 def experiment(K,C,S):
     C += 2
     print
     
     # consider only the worst cases: only one tile is golden
     for i in range(K):
         orig_seq = ""L"" * K
         orig_seq = orig_seq[:i] + ""G"" + orig_seq[i+1:]
         seq = orig_seq
         for j in range(C-1):
             seq = expand(seq, orig_seq)
         print seq
     
     s0 = seq
     # level 1: original seq
     # level 2: G on i == j/K, and on i == j%K
     # level 3: G on i == j/K/K, on i == (j/K)%K, and j%K
     # and so on
     print C,K
     for i in range(K):
         seq = """"
         for j in range(K**C):
             if C==2 and (i == j/K or i == j%K):
                 seq += ""G""
             elif C==3 and (i == j/K/K or i == (j/K)%K or i == j%K):
                 seq += ""G""
             elif C==4 and (i == j/K/K/K or i == (j/K/K)%K or i == (j/K)%K or i == j%K):
                 seq += ""G""
             else:
                 seq += ""L""
         print seq
     s1 = seq
     print s1 == s0
 
 # pick j (which tile to clean) so that it covers
 # the cases where tile i is golden, for each i in i_list
 # we need to satisfy the div/mod conditions from the above experiment
 def pick(K,C,S,i_list):
     
     j = 0
     p = 1
     for i in i_list:
         j += i * p
         p *= K
     
     max = K**C
     return j+1 if j < max else None
 
 for t in range(T):
     K,C,S = readlist()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     print >> sys.stderr, K, C, S
     last = 0
     out = []
     while last < K:
         # with one tile, we can cover at most C ""worst cases""
         # (worst case ""i"" is where only tile ""i"" is golden)
         next = min(last+C, K)
         worst_cases = range(last, next)
         sol = pick(K,C,S, worst_cases)
         print >> sys.stderr, worst_cases, sol, ""<="", K**C
         out.append(str(sol))
         last = next
     
     if len(out) <= S:
         print "" "".join(out)
     else:
         print ""IMPOSSIBLE""
",gcj/2016/6254486/a1ex/5636311922769920/1/extracted/D.py,2443,92,379,Python,6254486,1,5636311922769920,a1ex,2016
496,B.py,"import os, sys
 
 def neg(S):
     S = [""+"" if x == ""-"" else ""-"" for x in S]
     return """".join(S)
 
 def solve(S):
     # ignore good pancakes at bottom
     S = S.rstrip(""+"")
     
     # empty string? nothing to do
     if S == """":
         return 0
     
     # now we have one (or more) minus(es) at the bottom,
     # so we must flip the stack once;
     # before that, let's try to put all the items on the negative side
     # with minimal number of moves
     S = S.rstrip(""-"")
     return 1 + solve(neg(S))
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 for t in range(T):
     S = sys.stdin.readline().strip()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     print solve(S)
",gcj/2016/6254486/a1ex/5634697451274240/1/extracted/B.py,768,33,118,Python,6254486,1,5634697451274240,a1ex,2016
497,B.py,"import os, sys
 
 def move(S,i):
     top = S[:i]
     bot = S[i:]
     top = [""+"" if x == ""-"" else ""-"" for x in top]
     top.reverse()
     return """".join(top) + bot
 
 def solve(S):
     if ""-"" not in S:
         print 0
         return
     
     Q = [S]
     N = [0]
     i = 0
     while i < len(Q):
         s = Q[i]
         for k in range(1,len(S)+1):
             m = move(s,k)
             if ""-"" not in m:
                 print N[i]+1
                 return
             if m not in Q:
                 Q.append(m)
                 N.append(N[i]+1)
         i += 1
     print ""oops""
 
 def readint():
 	return int(sys.stdin.readline())
 
 T = readint()
 for t in range(T):
     S = sys.stdin.readline().strip()
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     
     solve(S)
",gcj/2016/6254486/a1ex/5634697451274240/0/extracted/B.py,841,42,110,Python,6254486,0,5634697451274240,a1ex,2016
498,B.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def validn(kit,P,n):
     for i in range(len(kit)):
         if kit[i] < P[i]*n*0.9:
             #~ print ""ovf"", kit[i], P[i], P[i]*n*0.9
             return None
         if kit[i] > P[i]*n*1.1:
             #~ print ""nai"", kit[i], P[i], P[i]*n*1.1
             return False
 
     return True
 
 # 0 = overflow
 def valid(kit,P):
     #~ print kit,P
     nmin = min([math.ceil(kit[i] / (P[i] * 1.1)) for i in range(len(P))])
     nmax = max([math.floor(kit[i] / (P[i] * 0.9)) for i in range(len(P))])
     #~ return nmax >= nmin
     
     for n in range(int(nmin), int(nmax+1)):
     #~ while 1:
         #~ n += 1
         #~ print n
         v = validn(kit,P,n)
         #~ print v, v==0
         if v:
             return n
         if v == None:
             return 0
     # unreachable
 
 def solve(N,P,M):
     #~ print R
     #~ print M
     #~ print P
     #~ print valid([M[0][0], M[1][0]], P)
     #~ print valid([1500,809], [500,300])
     ans = 0
     if N == 1:
         assert len(M) == N
         assert len(P) == N
         for i in range(len(M[0])):
             #~ print M[0][i], P
             if valid([M[0][i]], P):
                 #~ print ""v""
                 ans += 1
     elif N == 2:
         best = 0
         M0 = M
         for k in range(100):
             M = deepcopy(M0)
             #~ print M
             ans = 0
             ri = range(len(M[0]))
             rj = range(len(M[1]))
             random.shuffle(ri)
             random.shuffle(rj)
             for i in ri:
                 for j in rj:
                     if M[0][i] and M[1][j]:
                         v = valid([M[0][i], M[1][j]], P)
                         if v:
                             #~ print M[0][i], M[1][j], v
                             ans += 1
                             M[0][i] = 0
                             M[1][j] = 0
             best = max(best, ans)
         ans = best
             
         pass
     else:
         print N
         assert 0
     return ans        
 
 T = readint()
 for t in range(T):
     N,P = readlist()
     R = readlist()
     assert len(R) == N
     M = []
     for i in range(N):
         M.append(readlist())
         assert len(M[-1]) == P
 
     #~ if t+1 != 93:
         #~ continue
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     print solve(N,R,M)
",gcj/2017/5304486/a1ex/5697460110360576/0/extracted/B.py,2606,103,311,Python,5304486,0,5697460110360576,a1ex,2017
499,A.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def pm(M):
     for l in M:
         print l
 
 def done(M):
     for l in M:
         if ""?"" in l:
             return False
     return True
 
 def letters(M):
     for l in M:
         for c in l:
             if c != ""?"":
                 yield c
 
 def expand(M,ch,dx,dy):
     N = []
     if dx:
         for l in M:
             row = list(l)
             for i in range(len(row)):
                 if row[i] == ch and not(i+dx >= 0 and i+dx < len(row) and row[i+dx] in ['?',ch]):
                     #~ print ""wtf"", i, i+dx, row[i], row[i+dx]
                     return False
 
         for l in M:
             row = list(l)
             #~ print(row,dx,len(row))
             for i in range(len(row)):
                 if row[i] == ch and i+dx >= 0 and i+dx < len(row) and row[i+dx] == '?':
                     row[i+dx] = ch.lower()
             N.append(row)
     if dy:
         for l in M:
             N.append(list(l))
         for i in range(len(N)):
             for j in range(len(N[i])):
                 if N[i][j] == ch and not(i+dy >= 0 and i+dy < len(N) and N[i+dy][j] in ['?',ch]):
                     return False
         for i in range(len(N)):
             for j in range(len(N[i])):
                 if N[i][j] == ch and i+dy >= 0 and i+dy < len(N) and N[i+dy][j] == '?':
                     N[i+dy][j] = ch.lower()
 
     for i in range(len(N)):
         N[i] = ("""".join(N[i])).upper()
 
     return N
 
 def solve(M):
     #~ pm(M)
     #~ print
     #~ pm(expand(M,'J',-1,0))
     
     #~ pm(expand(expand(expand(M,'C',-1,0),'C', 0,1),'G',1,0))
     #~ return 0
     
     Q = [M]
     i = 0
     while i < len(Q):
         M = Q[i]
         if done(M):
             pm(M)
             return
         
         for c in letters(M):
             for dx,dy in [(1,0), (-1,0), (0,1), (0,-1)]:
                 #~ print c,dx,dy
                 n = expand(M,c,dx,dy)
                 if n and n not in Q:
                     #~ pm(n)
                     #~ print
                     Q.append(n)
         
         i += 1
     return ""IMPOSSIBLE""
 
 T = readint()
 for t in range(T):
     R, C = readlist()
     M = []
     for i in range(R):
         row = sys.stdin.readline().strip()
         assert len(row) == C
         M.append(row)
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1))
     solve(M)
",gcj/2017/5304486/a1ex/5760761888505856/0/extracted/A.py,2618,103,315,Python,5304486,0,5760761888505856,a1ex,2017
500,B.py,"import sys, string
 import time
 import random
 import math
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def tidy(N):
     z = 1
     while str(N) != """".join(sorted(str(N))):
         N -= z * ((N/z) % 10 + 1)
         z *= 10
         #~ print(N)
     return N
 
 T = readint()
 for t in range(T):
     N = readint()
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     print tidy(N)
",gcj/2017/3264486/a1ex/5633382285312000/1/extracted/B.py,526,27,72,Python,3264486,1,5633382285312000,a1ex,2017
501,A.py,"import sys, string
 import time
 import random
 import math
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def flip(S,i0,K):
     S = list(S)
     for i in range(i0,i0+K):
         S[i] = ""-"" if S[i] == ""+"" else ""+""
     S = """".join(S)
     return S
 
 def solve(S, K):
     #~ print S, K
     Q = [S]
     L = [0]
     i = 0
     while i < len(Q):
         s,l = Q[i],L[i]
         #~ print s
         if ""-"" not in s:
             return l
         for i0 in range(0, len(S)-K+1):
             m = flip(s, i0, K)
             #~ print s, i0, m
             if m not in Q:
                 Q.append(m)
                 L.append(l+1)
         i += 1
     return ""IMPOSSIBLE""
 
 T = readint()
 for t in range(T):
     S, K = sys.stdin.readline().strip().split("" "")
     K = int(K)
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     print solve(S, K)
",gcj/2017/3264486/a1ex/5736519012712448/0/extracted/A.py,990,46,136,Python,3264486,0,5736519012712448,a1ex,2017
502,C.py,"import sys, string
 import time
 import random
 import math
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def sol(N):
     if N == 0: return 0,0
     return (N/2,N/2) if N % 2 else (N/2,N/2-1)
 
 def solve(N, K):
     Q = [N]
 
     while K:
         N = Q[0]
         Q = Q[1:]
         if N % 2:
             Q.append(N/2)
             Q.append(N/2)
         else:
             Q.append(N/2)
             Q.append(N/2-1)
         Q.sort(reverse=True)
         #~ print Q
 
         K -= 1
 
     return N
     return sol(N)
 
 def xsolve(N,K):
     ff = 2**int(math.log(N+1,2))-1
     off = N-ff
     num = 1
     while K > 0:
         N = (N-1) / 2.
         num *= 2
         K -= num
     K += num
 
     #~ return N, K*1.0/num
     return int(N)+1 if K*1.0/num <= N-int(N) else int(N)
 
 def ysolve(N,K):
     if K == 0:
         return solve(N,K)
     return xsolve(N,K-1)
 
 T = readint()
 for t in range(T):
     N, K = readlist()
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     s = sol(ysolve(N, K))
     print s[0], s[1]
",gcj/2017/3264486/a1ex/5654742835396608/2/extracted/C.py,1177,62,154,Python,3264486,2,5654742835396608,a1ex,2017
503,C.py,"import sys, string
 import time
 import random
 from collections import defaultdict
 import math
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def sol(N):
     if N == 0: return 0,0
     return (N/2,N/2) if N % 2 else (N/2,N/2-1)
 
 def solve(N, K):
     Q = [N]
 
     while K:
         N = Q[0]
         Q = Q[1:]
         if N % 2:
             Q.append(N/2)
             Q.append(N/2)
         else:
             Q.append(N/2)
             Q.append(N/2-1)
         Q.sort(reverse=True)
         #~ print Q
 
         K -= 1
 
     return N
     return sol(N)
 
 def solveD(N, K):
     Q = defaultdict(int)
     Q[N] += 1
 
     while K:
         N = max(Q.keys())
         Q[N] -= 1
         if Q[N] == 0:
             del Q[N]
         
         #~ print N
         if N % 2:
             Q[N/2] += 1
             Q[N/2] += 1
         else:
             Q[N/2] += 1
             Q[N/2-1] += 1
         #~ print Q
 
         K -= 1
 
     #~ return sol(N)    
     return N
 
 def xsolve(N,K):
     ff = 2**int(math.log(N+1,2))-1
     off = N-ff
     num = 1
     while K > 0:
         N = (N-1) / 2.
         num *= 2
         K -= num
     K += num
 
     #~ return N, K*1.0/num
     return int(N)+1 if K*1.0/num <= N-int(N) else int(N)
 
 def ysolve(N,K):
     if K == 0:
         return solve(N,K)
     return xsolve(N,K-1)
 
 T = readint()
 for t in range(T):
     N, K = readlist()
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     s = sol(ysolve(N, K))
     print s[0], s[1]
 
     continue
     N=77
     print
     for i in range(1,N):
         print solve(N,i),
     print
     for i in range(1,N):
         print ysolve(N,i),
     #~ print xsolve(34,)
     #~ print xsolve(100001,7), solve(100001,7)
",gcj/2017/3264486/a1ex/5654742835396608/1/extracted/C.py,1858,98,235,Python,3264486,1,5654742835396608,a1ex,2017
504,C.py,"import sys, string
 import time
 import random
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def sol(N):
     if N == 0: return 0,0
     return (N/2,N/2) if N % 2 else (N/2,N/2-1)
 
 def solve(N, K):
     Q = [N]
 
     while K:
         N = Q[0]
         Q = Q[1:]
         if N % 2:
             Q.append(N/2)
             Q.append(N/2)
         else:
             Q.append(N/2)
             Q.append(N/2-1)
         Q.sort(reverse=True)
         #~ print Q
 
         K -= 1
 
     return sol(N)
 
 T = readint()
 for t in range(T):
     N, K = readlist()
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     s = solve(N, K)
     print s[0], s[1]
 
",gcj/2017/3264486/a1ex/5654742835396608/0/extracted/C.py,792,43,99,Python,3264486,0,5654742835396608,a1ex,2017
505,A.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def solve(M):
     return 0
 
 T = readint()
 for t in range(T):
     D, N = readlist()
     
     K = []
     S = []
     for i in range(N):
         k,s = readlist()
         K.append(k)
         S.append(s)
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     #~ print >> sys.stderr, D, N, K, S
     tmin = 0
     for i in range(N):
         t = (1.0 * D - K[i]) / S[i]
         tmin = max(tmin, t)
     #~ print >> sys.stderr, tmin
     print ""%.06f"" % (1.0 * D / tmin)
",gcj/2017/8294486/a1ex/5630967708385280/1/extracted/A.py,755,37,111,Python,8294486,1,5630967708385280,a1ex,2017
506,B.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def solve(M):
     return 0
 
 def reorder(inp, N):
     ring = """"
     Q = [x for x in inp]
     R = []
     i = 0
     prev_len = N
     while len(ring) < N:
         for c in Q:
             if len(ring) == 0 or \
               (len(ring) < N-1 and c != ring[-1]) or \
               (len(ring) == N-1 and c != ring[-1] and c != ring[0]):
                 ring += c
             else:
                 R.append(c)
         #~ print ring + (""?"" * (N - len(ring))), len(R)
         
         #~ print """".join(R)
         #~ print len(R)
         if len(R) == prev_len:
             #~ print >> sys.stderr, ""no progress"", len(R)
             break
         prev_len = len(R)
         random.shuffle(R)
         R.sort(key=lambda x: 0 if x==ring[0] else 1)
         Q = [x for x in R]
         R = []
 
     if len(ring) == N:
         return ring
 
     return None
 
 def fits(ring, c):
     if len(ring) == 0 or \
       (len(ring) < N-1 and c != ring[-1]) or \
       (len(ring) == N-1 and c != ring[-1] and c != ring[0]):
         return True
     return False
 
 def tryx(L):
     a,x = L[0]
     b,y = L[1]
     c,z = L[2]
     
     ring = """"
     
     print >> sys.stderr, ring, a, b, c
     for i in range(a):
         if c and fits(ring, z):
             ring += z
             c -= 1
         if a and fits(ring, x):
             ring += x
             a -= 1
     #~ print >> sys.stderr, ring, a, b, c
 
     for i in range(b):
         if b and fits(ring, y):
             ring += y
             b -= 1
         if c and fits(ring, z):
             ring += z
             c -= 1
     #~ print >> sys.stderr, ring, a, b, c
     #~ print >> sys.stderr, len(ring), N
 
     if len(ring) == N:
         return ring
     else:
         return None
 
 
 def tryy(L):
     ring = """"
 
     for i in range(N):
         L.sort(key=lambda x: x[0])
         if L[2][0] and fits(ring, L[2][1]):
             ring += L[2][1]
             L[2] = (L[2][0]-1, L[2][1])
         elif L[1][0] and ring[0] == L[1][1] and fits(ring, L[1][1]):
             ring += L[1][1]
             L[1] = (L[1][0]-1, L[1][1])
         elif L[0][0] and ring[0] == L[0][1] and fits(ring, L[0][1]):
             ring += L[0][1]
             L[0] = (L[0][0]-1, L[0][1])
         elif L[1][0] and fits(ring, L[1][1]):
             ring += L[1][1]
             L[1] = (L[1][0]-1, L[1][1])
         elif L[0][0] and fits(ring, L[0][1]):
             ring += L[0][1]
             L[0] = (L[0][0]-1, L[0][1])
         else:
             pass
             #~ print >> sys.stderr, ""wtf""
         #~ print ring, L
     #~ print L
 
     if len(ring) == N:
         return ring
     else:
         return None
 
 T = readint()
 for t in range(T):
     L = readlist()
     N = L[0]
     R, O, Y, G, B, V = L[1:]
     assert sum(L[1:]) == N
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     inp = ""R"" * R + ""O"" * O + ""Y"" * Y + ""G"" * G + ""B"" * B + ""V"" * V
 
     L = [(R,'R'), (B,'B'), (Y,'Y')]
     L.sort(key=lambda x: x[0])
 
     sol = tryx(L)
     if sol:
         assert len(sol) == N
         print sol
         continue
     print >> sys.stderr, ""IMPOSSIBLE?""
 
     sol = tryy(L)
     if sol:
         print sol
         continue
     print >> sys.stderr, ""IMPOSSIBLE?""
 
     print >> sys.stderr, ""IMPOSSIBLE!""
     print ""IMPOSSIBLE""
",gcj/2017/8294486/a1ex/5654117850546176/0/extracted/B.py,3595,149,494,Python,8294486,0,5654117850546176,a1ex,2017
507,C.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def solve(M):
     return 0
 
 T = readint()
 for t in range(T):
     N, Q = readlist()
     
     E = []
     S = []
     for i in range(N):
         e,s = readlist()
         E.append(e)
         S.append(s)
 
     D = []
     for i in range(N):
         d = readlist()
         if i < N-1:
             d = d[i+1]
             D.append(d)
 
     for i in range(Q):
         U,V = readlist()
         assert U == 1
         assert V == N
     
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     print >> sys.stderr, N, Q, E, S, D
     dend = 0
 
 
     tbest = [float(""inf"")]*N
     dcums = [float(""inf"")]*N
     tbest[N-1] = 0
     dcums[0] = 0
 
     dacc = 0
     for i in range(N-1):
         dacc += D[i]
         dcums[i+1] = dacc
     #~ print dcums
 
     for i in range(N-2, -1, -1):
         print >> sys.stderr, i
         e, s, d = E[i], S[i], D[i]
         dend += d
         print >> sys.stderr, e, s, d
         # can we take this horse?
         tbl = 1e1000
         for j in range(i+1,N):
             dij = dcums[j]-dcums[i]
             print >> sys.stderr, ""(%d->%d) d=%d"" % (i+1,j+1,dij)
             if e >= dij:
                 # yes!
                 tl = 1.0 * dij / s + tbest[j]
                 print >> sys.stderr, ""   "", j, dij, tl, 1.0 * dij / s, tbest[j]
                 tbl = min(tbl, tl)
         tbest[i] = tbl
 
     print >> sys.stderr, tbest
     print >> sys.stderr, dcums
     print ""%.9f"" % tbest[0]
",gcj/2017/8294486/a1ex/5681755159789568/0/extracted/C.py,1732,78,239,Python,8294486,0,5681755159789568,a1ex,2017
508,B.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 from decimal import *
 from mpmath import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def solve(M):
     return 0
 
 def use(U, mmap, p, s, e):
     print >> sys.stderr,  ""use"", p, s, e
     assert e >= s
     assert e <= 1440
     #~ print """".join(mmap[s:e])
     #~ print '.' * (e-s)
     #~ print s, e, e-s, len(mmap), len(mmap[s:e]), len('.' * (e-s))
     assert """".join(mmap[s:e]) == '.' * (e-s)
     mmap[s:e] = [p.lower()] * (e-s)
     U[p] -= e - s
     assert len(mmap) == 1440
 
 T = readint()
 for t in range(T):
     Ac, Aj = readlist()
 
     C = []
     J = []
     A = []
     for i in range(Ac):
         c,d = readlist()
         C.append((c,d))
         A.append((c,d,'C'))
     for i in range(Aj):
         j,k = readlist()
         J.append((j,k))
         A.append((j,k,'J'))
 
     #~ if t+1 != 5:
         #~ continue
 
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
     #~ print >> sys.stderr, C, J
 
     mmap = ['.'] * 60 * 24
 
     U = {'C': 720, 'J': 720}
     A.sort()
     off = A[0][0]
     print >> sys.stderr,  A, off
     B = [a for a in A]
     A = []
     for a in B:
         A.append((a[0]-off, a[1]-off, a[2]))
     A.append((1440, 1440, B[0][2]))
     print >> sys.stderr, A
 
     for s,e,p in A:
         mmap[s:e] = [p] * (e-s)
         U[p] -= (e-s)
 
     #~ print len(mmap)
     assert len(mmap) == 60*24
     print >> sys.stderr,  """".join(mmap)
 
     gapz = []
     for i in range(len(A)-1):
         a1 = A[i]
         a2 = A[i+1]
         if a1[2] != a2[2]:
             gapz.append((a2[0] - a1[1], a1, a2))
     print >> sys.stderr,  gapz
 
 #--------------------------
     gaps = []
     for i in range(len(A)-1):
         a1 = A[i]
         a2 = A[i+1]
         if a1[2] == a2[2]:
             gaps.append((a2[0] - a1[1], a1, a2))
     print >> sys.stderr,  gaps
 
     N = {'C': 0, 'J': 0}
     for g in sorted(gaps):
         d, a1, a2 = g
         p = a1[2]
         #~ print p, d, a1, a2, U[p]
         if d <= U[p]:
             s, e = a1[1], a2[0]
             #~ print ""need"", p, s, e, e-s
             N[p] += e-s
     print >> sys.stderr,  ""need:"", N
 
     for g in sorted(gapz):
         d, a1, a2 = g
         p,q = a1[2], a2[2]
         print >> sys.stderr,  p, q, d, a1, a2, ""unused"", U[p], U[q], ""need"", N[p], N[q]
         if U[p] + U[q] >= d:
             fp, fq = 0, 0
             while fp + fq < d:
                 if U[p] - N[p] - fp > U[q] - N[q] - fq:
                     fp += 1
                 else:
                     fq += 1
             print >> sys.stderr, ""=> "", fp, fq, d
             assert fp + fq == d
             use(U, mmap, p, a1[1], a1[1] + fp)
             use(U, mmap, q, a2[0] - fq, a2[0])
 
     for g in sorted(gaps):
         d, a1, a2 = g
         p = a1[2]
         print >> sys.stderr,  p, d, a1, a2, U[p]
         if d <= U[p]:
             s, e = a1[1], a2[0]
             use(U, mmap, p, s, e)
 
     print >> sys.stderr, """".join(mmap)
 
     swaps = 0
     pc = mmap[-1].upper()
     for c in mmap:
         c = c.upper()
         if c != pc:
             swaps += 1
         pc = c
     print swaps
",gcj/2017/3274486/a1ex/5706636844859392/1/extracted/B.py,3350,136,487,Python,3274486,1,5706636844859392,a1ex,2017
509,A.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 from decimal import *
 from mpmath import *
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def solve(M):
     return 0
 
 def calc(RH):
     pi = mpf(math.pi)
     R = mpf(RH[-1][0])
     A = pi * R * R
     N = len(RH)
     for i in range(N):
         r,h = RH[i]
         #~ print >> sys.stderr, r, lastr, h
         A += mpf(2) * pi * mpf(r) * mpf(h)
     return A
 
 T = readint()
 for t in range(T):
     N, K = readlist()
     RH = []
     for i in range(N):
         r, h = readlist()
         RH.append((r,h))
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     RHa = sorted(RH, key = lambda x: -x[0])
 
     #~ if t+1 != 97:
         #~ continue
 
     print >> sys.stderr, RHa
     #~ for rh in RHa:
         #~ print rh[0]*rh[1]
 
     best = 0
     for i in range(min(N, 100 if t+1 == 74 else 50)):
         big = RHa[i]
         #~ print >> sys.stderr, RHa[i:]
         RHh = sorted(RHa[i+1:], key = lambda x: -x[1]*x[0])
         #~ print >> sys.stderr, RHh
         sel = [big] + RHh[:K-1]
         c =  calc(sorted(sel, key = lambda x: x[0]))
         #~ print >> sys.stderr, sel, ""%.9f"" % c
         best = max(best, c)
     #~ print
     print ""%.9f"" % best
     #~ print ""10655404072419.027343750""
     #~ print [(409349, 778548), (413889, 686271), (550135, 877492), (965584, 149347)]
",gcj/2017/3274486/a1ex/5768968631484416/1/extracted/A.py,1544,63,224,Python,3274486,1,5768968631484416,a1ex,2017
510,A.py,"import sys, string
 import time
 import random
 import math
 from copy import copy, deepcopy
 
 def readlist():
 	return [int(x) for x in sys.stdin.readline().strip().split("" "")]
 
 def readint():
 	return int(sys.stdin.readline())
 
 def solve(M):
     return 0
 
 def calc(RH):
     A = 0
     N = len(RH)
     pi = math.pi
     lastr = 0
     for i in range(N):
         r,h = RH[i]
         #~ print >> sys.stderr, r, lastr, h
         A += pi * r * r - pi * lastr * lastr + 2 * pi * r * h
         lastr = r
     return A
 
 T = readint()
 for t in range(T):
     N, K = readlist()
     RH = []
     for i in range(N):
         r, h = readlist()
         RH.append((r,h))
     
     print >> sys.stderr, ""Solving case #%d..."" % (t+1)
     print (""Case #%d:"" % (t+1)),
 
     RH.sort(key=lambda x: x[0])
     #~ print RH
     #~ print calc(RH)
     best = 0
     for b in range(1 << N):
         RHs = []
         for i in range(N):
             if b & (1 << i):
                 RHs.append(RH[i])
         if len(RHs) == K:
             print >> sys.stderr, RHs, calc(RHs)
             c = calc(RHs)
             best = max(best, c)
     print ""%.9f"" % best
",gcj/2017/3274486/a1ex/5768968631484416/0/extracted/A.py,1163,53,173,Python,3274486,0,5768968631484416,a1ex,2017
511,000000000004a266.PYTHON,"import os, sys
from itertools import permutations
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(R,B):
    pairs = [(0,0)]

    tries = []
    for N in range(R+B+1):
        for r in range(R+1):
            b = N-r
            #~ print r,b
            if r >= 0 and b >= 0 and r <= R and b <= B:
                tries.append((r,b))
    random.shuffle(tries)
    for r,b in tries:
        if r <= R and b <= B:
            if (r,b) not in pairs:
                R -= r
                B -= b
                pairs.append((r,b))
    
    return len(pairs) - 1

def solve2(R,B):
    pairs = [(0,0)]

    for N in range(R+B+1):
        for r in range(R,-1,-1):
            b = N-r
            if r >= 0 and b >= 0 and r <= R and b <= B:
                #~ print r,b
                if (r,b) not in pairs:
                    pairs.append((r,b))
                    R -= r
                    B -= b
    #~ print pairs
    return len(pairs) - 1

T = readint()
for t in range(T):
    R,B = readlist()
    
    best = solve2(R,B)
    for k in range(100000):
        s = solve(R,B)
        best = max(best, s)

    print ""Case #%d: %s"" % (t+1, best)
",,1292,59,178,Python,7706,000000000004a266,00000000000459f3,a1ex,2018
512,0000000000049f27.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(R,B):
    pairs = [(0,0)]

    for N in range(R+B+1):
        for r in range(R+1):
            b = N-r
            #~ print r,b
            if r >= 0 and b >= 0 and r <= R and b <= B:
                if (r,b) not in pairs:
                    pairs.append((r,b))
                    R -= r
                    B -= b
    #~ print pairs
    return len(pairs) - 1

def solve2(R,B):
    pairs = [(0,0)]

    for N in range(R+B+1):
        for r in range(R,-1,-1):
            b = N-r
            if r >= 0 and b >= 0 and r <= R and b <= B:
                #~ print r,b
                if (r,b) not in pairs:
                    pairs.append((r,b))
                    R -= r
                    B -= b
    #~ print pairs
    return len(pairs) - 1

T = readint()
for t in range(T):
    R,B = readlist()

    print ""Case #%d: %s"" % (t+1, max(solve(R,B), solve2(R,B)))
",,1091,48,149,Python,7706,0000000000049f27,00000000000459f3,a1ex,2018
513,0000000000049a14.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(R,B):
    pairs = [(0,0)]

    for N in range(R+B+1):
        for r in range(N+1):
            b = N-r
            #~ print r,b
            if r >= 0 and b >= 0 and r <= R and b <= B:
                if (r,b) not in pairs:
                    pairs.append((r,b))
                    R -= r
                    B -= b
    #~ print pairs
    return len(pairs) - 1

T = readint()
for t in range(T):
    R,B = readlist()

    print ""Case #%d: %s"" % (t+1, solve(R,B))
",,691,33,94,Python,7706,0000000000049a14,00000000000459f3,a1ex,2018
514,0000000000049518.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def pr(M):
    for m in M:
        print("""".join(m))

def findzero(B,i):
    N = len(B)
    for d in range(N):
        if i+d < N and B[i+d] == 0:
            return i+d
        if i-d >= 0 and B[i-d] == 0:
            return i-d
    return -1

def solve(B):
    if B[0] == 0 or B[-1] == 0:
        return ""IMPOSSIBLE"", False

    N = len(B)
    M = [ i for i in range(N) ]

    h = max(B)
    J = []
    for i in range(h):
        J.append(["".""] * N)

    for i in range(N):
        y = h-2
        while B[i] > 1:
            j = findzero(B, i)
            assert j >= 0
            #~ print i,j
            ch = '/' if i < j else '\\'
            if i < j:
                for k in range(i+1, j+1):
                    if J[y][k] != '.':
                        y -= 1
                for k in range(i+1, j+1):
                    J[y][k] = ch
            else:
                for k in range(j, i):
                    if J[y][k] != '.':
                        y -= 1
                for k in range(j, i):
                    J[y][k] = ch
            B[i] -= 1
            B[j] = 1
            #~ print """"; pr(J); print """";
    return h, J
        

T = readint()
for t in range(T):
    C = readint()
    B = readlist()
    assert len(B) == C
    assert sum(B) == C

    sol, J = solve(B)
    print ""Case #%d: %s"" % (t+1, sol)
    if J != False:
        pr(J)
",,1583,74,227,Python,7706,0000000000049518,00000000000459f2,a1ex,2018
515,0000000000048def.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def pr(M):
    for m in M:
        print("""".join(m))

def findzero(B,i):
    N = len(B)
    for d in range(N):
        if i+d < N and B[i+d] == 0:
            return i+d
        if i-d >= 0 and B[i-d] == 0:
            return i-d
    return -1

def solve(B):
    if B[0] == 0 or B[-1] == 0:
        return ""IMPOSSIBLE"", False

    N = len(B)
    M = [ i for i in range(N) ]

    h = max(B)
    J = []
    for i in range(h):
        J.append(["".""] * N)

    for i in range(N):
        while B[i] > 1:
            j = findzero(B, i)
            assert j >= 0
            #~ print i,j
            ch = '/' if i < j else '\\'
            if i < j:
                for k in range(i+1, j+1):
                    J[B[i]-2][k] = ch
            else:
                for k in range(j, i):
                    J[B[i]-2][k] = ch
            B[i] -= 1
            B[j] = 1
            #~ print """"; pr(J); print """";
    return h, J
        

T = readint()
for t in range(T):
    C = readint()
    B = readlist()
    assert len(B) == C
    assert sum(B) == C

    sol, J = solve(B)
    print ""Case #%d: %s"" % (t+1, sol)
    if J != False:
        pr(J)
",,1357,67,200,Python,7706,0000000000048def,00000000000459f2,a1ex,2018
516,0000000000048050.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def pr(M):
    for m in M:
        print("""".join(m))

def solve(B):
    if B[0] == 0 or B[-1] == 0:
        return ""IMPOSSIBLE"", False

    N = len(B)
    M = [ i for i in range(N) ]
    #~ print B
    h = 1
    for i in range(N):
        while B[i] > 1:
            j = B.index(0)
            #~ print i,j
            B[i] -= 1
            B[j] = 1
            M[j] = i
            h = max(h, abs(j-i)+1)
    J = []
    for i in range(h):
        J.append(["".""] * N)
    #~ pr(J)
    #~ print M
    for i in range(N):
        j = M[i]
        if j != i:
            y = h - abs(i-j) - 1
            #~ print(i,y,len(J), len(J[0]))
            ch = '\\' if i < j else '/'
            J[y][i] = ch
    return h, J
        

T = readint()
for t in range(T):
    C = readint()
    B = readlist()
    assert len(B) == C

    sol, J = solve(B)
    print ""Case #%d: %s"" % (t+1, sol)
    if J != False:
        pr(J)
",,1128,58,172,Python,7706,0000000000048050,00000000000459f2,a1ex,2018
517,0000000000047437.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def num_conflicts(M):
    N = len(M)
    C = []
    for i in range(N):
        C.append([0] * N)

    ok = True
    mx = 0
    pos = False
    for i in range(N):
        for j in range(N):
            for k in range(N):
                if j != k and M[i][j] == M[i][k] and M[i][j] != 'x':
                    C[i][j] += 1
                    ok = False
                    if C[i][j] > mx:
                        mx = C[i][j]
                        pos = (i,j)
                if i != k and M[i][j] == M[k][j] and M[i][j] != 'x':
                    C[i][j] += 1
                    ok = False
                    if C[i][j] > mx:
                        mx = C[i][j]
                        pos = (i,j)
    return C, ok, pos

def solve(M):
    num = 0
    while True:
        C, ok, pos = num_conflicts(M)
        if not ok:
            M[pos[0]][pos[1]] = 'x'
            num += 1
        else:
            break
    return num

T = readint()
for t in range(T):
    N = readint()
    M = []
    for i in range(N):
        m = readlist()
        assert len(m) == N
        M.append(m)

    print ""Case #%d: %s"" % (t+1, solve(M))
",,1350,60,176,Python,7706,0000000000047437,0000000000045875,a1ex,2018
518,00000000000465b9.PYTHON,"import os, sys
from itertools import product

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(R,B):
    pairs = [(0,0)]
    changed = True
    while (R or B) and changed:
        changed = False
        for p in [p for p in pairs]:
            if R >= p[0]+1 and B >= p[1]:
                if (p[0]+1, p[1]) not in pairs:
                    pairs.append((p[0]+1, p[1]))
                    R -= p[0]+1
                    B -= p[1]
                    changed = True
            if R >= p[0] and B >= p[1]+1:
                if (p[0], p[1]+1) not in pairs:
                    pairs.append((p[0], p[1]+1))
                    R -= p[0]
                    B -= p[1]+1
                    changed = True
        #~ print pairs
    return len(pairs) - 1

T = readint()
for t in range(T):
    R,B = readlist()

    print ""Case #%d: %s"" % (t+1, solve(R,B))
",,988,39,122,Python,7706,00000000000465b9,00000000000459f3,a1ex,2018
519,000000000003b3fe.PYTHON,"import os, sys
from collections import defaultdict

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def xscan(D, A, B, i):
    S = len(D)
    j = i+1
    M = D[i] + A[i]
    N = D[j] - B[j]
    #~ print >> sys.stderr, i, M, N
    while i >= 0 and (D[i] + A[i] == M or D[i] - B[i] == N):
        #~ print >> sys.stderr, "">"", i, M
        i -= 1
    i += 1

    while j < S and (D[j] - B[j] == N or D[j] + A[j] == M):
        #~ print >> sys.stderr, ""<"", j, N
        j += 1
    j -= 1
    #~ print >> sys.stderr, j-i+1, i, j, M, N, ""*""
    return i, j

def yscan(D, A, B, i):
    S = len(D)
    j = i+1
    N = D[i] - B[i]
    M = D[j] + A[j]
    #~ print >> sys.stderr, i, M, N, ""*""
    while i >= 0 and (D[i] - B[i] == N or D[i] + A[i] == M):
        #~ print >> sys.stderr, "">>"", i, N
        i -= 1
    i += 1

    while j < S and (D[j] + A[j] == M or D[j] - B[j] == N):
        #~ print >> sys.stderr, ""<<"", j, M
        j += 1
    j -= 1
    #~ print >> sys.stderr, j-i+1, i, j, M, N
    return i, j

def solve(S, D, A, B):
    if S == 1:
        return 1,1

    mB = [-b for b in B]
    assert S == len(D)
    best = 0
    bp = []
    for i in range(S-1):
        r = xscan(D, A, B, i)
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)

        r = yscan(D, A, B, i)
        #~ print >> sys.stderr, r, ""?""
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)
    bp = list(set(bp))
    return best, len(bp)

T = readint()
for t in range(T):
    S = readint()
    D = []
    A = []
    B = []
    for i in range(S):
        d, a, b = readlist()
        D.append(d)
        A.append(a)
        B.append(b)

    sol = solve(S, D, A, B)
    print ""Case #%d: %d %d"" % (t+1, sol[0], sol[1])
",,2144,95,387,Python,7764,000000000003b3fe,000000000003675b,a1ex,2018
520,000000000003aff7.PYTHON,"import os, sys
from collections import defaultdict

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def xscan(D, A, B, i):
    S = len(D)
    j = i+1
    M = D[i] + A[i]
    N = D[j] - B[j]
    #~ print >> sys.stderr, i, M, N
    while i >= 0 and (D[i] + A[i] == M or D[i] - B[i] == N):
        #~ print >> sys.stderr, "">"", i, M
        i -= 1
    i += 1

    while j < S and (D[j] - B[j] == N or D[j] + A[j] == M):
        #~ print >> sys.stderr, ""<"", j, N
        j += 1
    j -= 1
    print >> sys.stderr, j-i+1, i, j, M, N, ""*""
    return i, j

def yscan(D, A, B, i):
    S = len(D)
    j = i+1
    N = D[i] - B[i]
    M = D[j] + A[j]
    #~ print >> sys.stderr, i, M, N, ""*""
    while i >= 0 and (D[i] - B[i] == N or D[i] + A[i] == M):
        #~ print >> sys.stderr, "">>"", i, N
        i -= 1
    i += 1

    while j < S and (D[j] + A[j] == M or D[j] - B[j] == N):
        #~ print >> sys.stderr, ""<<"", j, M
        j += 1
    j -= 1
    print >> sys.stderr, j-i+1, i, j, M, N
    return i, j

def solve(S, D, A, B):
    if S == 1:
        return 1,1

    mB = [-b for b in B]
    assert S == len(D)
    best = 0
    bp = []
    for i in range(S-1):
        r = xscan(D, A, B, i)
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)

        r = yscan(D, A, B, i)
        #~ print >> sys.stderr, r, ""?""
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)
    bp = list(set(bp))
    return best, len(bp)

T = readint()
for t in range(T):
    S = readint()
    D = []
    A = []
    B = []
    for i in range(S):
        d, a, b = readlist()
        D.append(d)
        A.append(a)
        B.append(b)

    sol = solve(S, D, A, B)
    print ""Case #%d: %d %d"" % (t+1, sol[0], sol[1])
",,2138,95,385,Python,7764,000000000003aff7,000000000003675b,a1ex,2018
521,000000000003ad81.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def F(N,c):
    p = c * 100.0 / N
    pi = c * 100 / N
    f = p - pi
    return f

gc = {}

def G(N, c):
    if c in gc:
        return gc[c]
    f = F(N, c)
    d = 0
    c0 = c
    while f > 0 and f < 0.5:
        d += 1
        c += 1
        f = F(N, c)
    for k in range(d+1):
        #~ print c0+k, d-k
        gc[c0+k] = d-k
    return d

def solve(N, L, C):
    K = []
    global gc
    gc = {}

    for c in C:
        K.append((c, G(N,c)))

    U = N - sum(C)
    for i in range(U):
        g0 = 1 + G(N,1)
        K.append((0, g0))

    K.sort(key=lambda x: x[1])
    #~ print >> sys.stderr, K, U

    S = 0
    for c, g in K:
        d = min(U, g)
        #~ print >> sys.stderr, c, ""+"", d, (c + d) * 100.0 / N
        S += round((c + d) * 100.0 / N)
        U -= d
    return int(S)

T = readint()
for t in range(T):
    N,L = readlist()
    C = readlist()
    assert len(C) == L

    print ""Case #%d: %s"" % (t+1, solve(N, L, C))
",,1133,66,204,Python,7764,000000000003ad81,0000000000036601,a1ex,2018
522,000000000003add0.PYTHON,"import os, sys
from collections import defaultdict

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def xscan(D, A, B, i):
    S = len(D)
    j = i+1
    M = D[i] + A[i]
    N = D[j] - B[j]
    #~ print >> sys.stderr, i, M, N
    while i >= 0 and D[i] + A[i] == M:
        #~ print >> sys.stderr, "">"", i, M
        i -= 1
    i += 1

    while j < S and D[j] - B[j] == N:
        #~ print >> sys.stderr, ""<"", j, N
        j += 1
    j -= 1
    print >> sys.stderr, j-i+1, i, j, M, N, ""*""
    return i, j

def yscan(D, A, B, i):
    S = len(D)
    j = i+1
    N = D[i] - B[i]
    M = D[j] + A[j]
    #~ print >> sys.stderr, i, M, N, ""*""
    while i >= 0 and D[i] - B[i] == N:
        #~ print >> sys.stderr, "">>"", i, N
        i -= 1
    i += 1

    while j < S and D[j] + A[j] == M:
        #~ print >> sys.stderr, ""<<"", j, M
        j += 1
    j -= 1
    print >> sys.stderr, j-i+1, i, j, M, N
    return i, j

def solve(S, D, A, B):
    if S == 1:
        return 1,1

    mB = [-b for b in B]
    assert S == len(D)
    best = 0
    bp = []
    for i in range(S-1):
        r = xscan(D, A, B, i)
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)

        r = yscan(D, A, B, i)
        #~ print >> sys.stderr, r, ""?""
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)
    bp = list(set(bp))
    return best, len(bp)

T = readint()
for t in range(T):
    S = readint()
    D = []
    A = []
    B = []
    for i in range(S):
        d, a, b = readlist()
        D.append(d)
        A.append(a)
        B.append(b)

    sol = solve(S, D, A, B)
    print ""Case #%d: %d %d"" % (t+1, sol[0], sol[1])
",,2050,95,361,Python,7764,000000000003add0,000000000003675b,a1ex,2018
523,000000000003ab0f.PYTHON,"import os, sys
from collections import defaultdict

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def xscan(D, A, B, i):
    S = len(D)
    j = i+1
    M = D[i] + A[i]
    N = D[j] - B[j]
    #~ print >> sys.stderr, i, M, N
    while i >= 0 and D[i] + A[i] == M:
        #~ print >> sys.stderr, "">"", i, M
        i -= 1
    i += 1

    while j < S and D[j] - B[j] == N:
        #~ print >> sys.stderr, ""<"", j, N
        j += 1
    j -= 1
    return i, j

def yscan(D, A, B, i):
    S = len(D)
    j = i+1
    N = D[i] - B[i]
    M = D[j] + A[j]
    #~ print >> sys.stderr, i, M, N, ""*""
    while i >= 0 and D[i] - B[i] == N:
        #~ print >> sys.stderr, "">>"", i, N
        i -= 1
    i += 1

    while j < S and D[j] + A[j] == M:
        #~ print >> sys.stderr, ""<<"", j, M
        j += 1
    j -= 1
    return i, j

def solve(S, D, A, B):
    if S == 1:
        return 1,1

    mB = [-b for b in B]
    assert S == len(D)
    best = 0
    bp = []
    for i in range(S-1):
        r = xscan(D, A, B, i)
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)

        r = yscan(D, A, B, i)
        #~ print >> sys.stderr, r, ""?""
        d = r[1] - r[0] + 1
        if d > best:
            #~ print >> sys.stderr, r
            best = d
            bp = [r]
        elif d == best:
            #~ print >> sys.stderr, r
            bp.append(r)
    bp = list(set(bp))
    return best, len(bp)

T = readint()
for t in range(T):
    S = readint()
    D = []
    A = []
    B = []
    for i in range(S):
        d, a, b = readlist()
        D.append(d)
        A.append(a)
        B.append(b)

    sol = solve(S, D, A, B)
    print ""Case #%d: %d %d"" % (t+1, sol[0], sol[1])
",,1959,93,344,Python,7764,000000000003ab0f,000000000003675b,a1ex,2018
524,0000000000039f6d.PYTHON,"import os, sys
from collections import defaultdict

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def xscan(D, A, B, i):
    S = len(D)
    j = i+1
    M = D[i] + A[i]
    N = D[j] - B[j]
    #~ print >> sys.stderr, i, M, N
    while i >= 0 and D[i] + A[i] == M:
        #~ print >> sys.stderr, "">"", i
        i -= 1
    i += 1

    while j < S and D[j] - B[j] == N:
        #~ print >> sys.stderr, "">"", j
        j += 1
    j -= 1
    return i, j

def solve(S, D, A, B):
    if S == 1:
        return 1,1

    mB = [-b for b in B]
    assert S == len(D)
    best = 0
    bp = []
    for i in range(S-1):
        r = xscan(D, A, B, i)
        #~ print >> sys.stderr, r
        d = r[1] - r[0] + 1
        if d > best:
            best = d
            bp = [r]
        elif d == best:
            bp.append(r)
    bp = list(set(bp))
    return best, len(bp)

def solve_v(S, D, A, B):
    votes_m = defaultdict(int)
    votes_n = defaultdict(int)
    for i in range(S):
        votes_m[D[i] + A[i]] += 1
        votes_n[D[i] - B[i]] += 1
    print votes_m
    print votes_n

T = readint()
for t in range(T):
    S = readint()
    D = []
    A = []
    B = []
    for i in range(S):
        d, a, b = readlist()
        D.append(d)
        A.append(a)
        B.append(b)

    sol = solve(S, D, A, B)
    print ""Case #%d: %d %d"" % (t+1, sol[0], sol[1])
",,1476,73,244,Python,7764,0000000000039f6d,000000000003675b,a1ex,2018
525,00000000000373cd.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def F(N,c):
    p = c * 100.0 / N
    pi = c * 100 / N
    f = p - pi
    return f

def solve_old(N, L, C):
    # unanswered
    U = N - L

    S = 0
    left = []

    print C, [c * 100.0 / N for c in C], U
    for c in C:
        f = F(N, c)
        if f > 0 and f < 0.5:
            left.append(c)
        else:
            print ""+"", c
            S += round(c * 100.0 / N)
    print left, S

    delta = 0
    while U > 0:
        delta += 1
        C = left + [0]
        left = []
        for c in C:
            if U > 0:
                U -= delta
                c += delta
                f = F(N, c)
                if f > 0 and f < 0.5:
                    left.append(c)
                else:
                    print ""*"", c
                    S += round(c * 100.0 / N)
            else:
                left.append(c)

    C = left
    for c in C:
        f = F(N, c)
        print ""-"", c
        S += round(c * 100.0 / N)

    print left, S
    return int(S)

def G(N, c):
    f = F(N, c)
    if f > 0 and f < 0.5:
        return 1 + G(N, c+1)
    return 0

def solve(N, L, C):
    K = []
    for c in C:
        K.append((c, G(N,c)))

    U = N - sum([c for c in C])
    for i in range(U):
        g0 = 1 + G(N,1)
        K.append((0, g0))

    K.sort(key=lambda x: x[1])
    print >> sys.stderr, K, U

    S = 0
    for c, g in K:
        d = min(U, g)
        print >> sys.stderr, c, ""+"", d, (c + d) * 100.0 / N
        S += round((c + d) * 100.0 / N)
        U -= d
    return int(S)

T = readint()
for t in range(T):
    N,L = readlist()
    C = readlist()
    assert len(C) == L

    print ""Case #%d: %s"" % (t+1, solve(N, L, C))
",,1841,96,314,Python,7764,00000000000373cd,0000000000036601,a1ex,2018
526,000000000003736b.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def F(N,c):
    p = c * 100.0 / N
    pi = c * 100 / N
    f = p - pi
    return f

def solve_old(N, L, C):
    # unanswered
    U = N - L

    S = 0
    left = []

    print C, [c * 100.0 / N for c in C], U
    for c in C:
        f = F(N, c)
        if f > 0 and f < 0.5:
            left.append(c)
        else:
            print ""+"", c
            S += round(c * 100.0 / N)
    print left, S

    delta = 0
    while U > 0:
        delta += 1
        C = left + [0]
        left = []
        for c in C:
            if U > 0:
                U -= delta
                c += delta
                f = F(N, c)
                if f > 0 and f < 0.5:
                    left.append(c)
                else:
                    print ""*"", c
                    S += round(c * 100.0 / N)
            else:
                left.append(c)

    C = left
    for c in C:
        f = F(N, c)
        print ""-"", c
        S += round(c * 100.0 / N)

    print left, S
    return int(S)

def G(N, c):
    f = F(N, c)
    if f > 0 and f < 0.5:
        return 1 + G(N, c+1)
    return 0

def solve(N, L, C):
    K = []
    for c in C:
        K.append((c, G(N,c)))

    U = N - sum([c for c in C])
    for i in range(U):
        g0 = 1 + G(N,1)
        K.append((0, g0))

    K.sort(key=lambda x: x[1])
    print >> sys.stderr, K, U

    S = 0
    for c, g in K:
        d = min(U, g)
        print >> sys.stderr, c, ""+"", d, (c + d) * 100.0 / N
        S += round((c + d) * 100.0 / N)
        U -= d
    return S

T = readint()
for t in range(T):
    N,L = readlist()
    C = readlist()
    assert len(C) == L

    print ""Case #%d: %s"" % (t+1, solve(N, L, C))
",,1836,96,314,Python,7764,000000000003736b,0000000000036601,a1ex,2018
527,0000000000035337.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def count(M, i1, j1, i2, j2):
    #~ print >> sys.stderr, M, i1, j1, i2, j2
    num = 0
    for i in range(i1, i2):
        #~ print >> sys.stderr, M[i][j1:j2]
        num += M[i][j1:j2].count('@')
    return num

def solve(M, R, C, H, V):
    if H == 1 and V == 1:
        for i in range(1, R):
            for j in range(1, C):
                a = count(M, 0, 0, i, j)
                b = count(M, 0, j, i, C)
                c = count(M, i, 0, R, j)
                d = count(M, i, j, R, C)
                if a == b == c == d:
                    print >> sys.stderr, i, j, a, b, c, d
                    return ""POSSIBLE""
    total = count(M, 0, 0, R, C)
    num = (H + 1) * (V + 1)
    per_cell = total // num
    per_line = total // (V + 1)
    per_col = total // (H + 1)
    print >> sys.stderr, ""need %d per cell, %d per line"" % (per_cell, per_line)
    if per_cell * num != total:
        print >> sys.stderr, ""nope""
        return ""IMPOSSIBLE""

    CV = [0]
    i, pi = 0, 0
    for nv in range(V):
        while count(M, pi, 0, i, C) < per_line * (nv+1):
            i += 1
        print >> sys.stderr, ""i%d=%d"" % (nv,i)
        CV.append(i)
    CV.append(R)

    CH = [0]
    j, pj = 0, 0
    for nh in range(V):
        while count(M, 0, pj, R, j) < per_col * (nh+1):
            j += 1
        print >> sys.stderr, ""j%d=%d"" % (nv,j)
        CH.append(j)
    CH.append(C)

    for i in range(1,H+2):
        for j in range(1,V+2):
            print >> sys.stderr, count(M, CV[i-1], CH[j-1], CV[i], CH[j]),
            if count(M, CV[i-1], CH[j-1], CV[i], CH[j]) != per_cell:
                #~ pass
                return ""IMPOSSIBLE""
        print >> sys.stderr, """"
        

    return ""POSSIBLE""

T = readint()
for t in range(T):
    R, C, H, V = readlist()
    print >> sys.stderr, R, C, H, V
    M = []
    for i in range(R):
        l = readstr().strip()
        print >> sys.stderr, l
        assert len(l) == C
        M.append(l)

    print ""Case #%d: %s"" % (t+1, solve(M, R, C, H, V))
",,2197,82,333,Python,0000000000007883,0000000000035337,000000000003005a,a1ex,2018
528,0000000000034688.PYTHON,"import os, sys
from itertools import combinations

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def slowest(A, S, P):
    tmax = 0
    for i in range(len(S)):
        if A[i] > 0:
            ti = P[i] + S[i] * A[i]
            if ti > tmax:
                tmax = ti
    print >> sys.stderr, A, S, P, tmax
    return tmax

def alloc(A, M, S, P):
    best = 0
    tmin = 1e10
    for i in range(len(M)):
        if M[i] > 0:
            ti = P[i] + S[i] * (A[i] + 1)
            if ti < tmin:
                best = i
                tmin = ti
    #~ print >> sys.stderr, ""alloc %d t=%d"" % (best, tmin)
    A[best] += 1
    M[best] -= 1

def try_solve_old(B, C, M, S, P):
    M = [ x for x in M ]
    A = [ 0 for x in M ]
    for i in range(B):
        alloc(A, M, S, P)
        #~ print >> sys.stderr, A

    return slowest(A, S, P)


def try_solve(B, C, M, S, P):
    assert C == len(M)
    assert C == len(S)
    assert C == len(P)
    
    best = 1e100
    if C == 1:
        A = [ B ]
        if B <= M[0]:
            best = slowest(A, S, P)

    elif C == 2:
        for b0 in range(0,B+1):
            b1 = B - b0
            if b0 <= M[0] and b1 <= M[1]:
                #~ print >> sys.stderr, b0, b1, slowest([b0,b1], S, P)
                best = min(best, slowest([b0,b1], S, P))
            #~ else:
                #~ print >> sys.stderr, b0, b1, ""nai"", M

    elif C == 3:
        for b0 in range(0,B+1):
            for b1 in range(0,B+1-b0):
                b2 = B - b0 - b1
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2]:
                    best = min(best, slowest([b0,b1,b2], S, P))

    elif C == 4:
        for b0 in range(0,B+1):
          for b1 in range(0,B+1-b0):
             for b2 in range(0,B+1-b0-b1):
                b3 = B - b0 - b1 - b2
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2] and b3 <= M[3]:
                    best = min(best, slowest([b0,b1,b2,b3], S, P))

    elif C == 5:
        for b0 in range(0,B+1):
          for b1 in range(0,B+1-b0):
            for b2 in range(0,B+1-b0-b1):
              for b3 in range(0,B+1-b0-b1-b2):
                b4 = B - b0 - b1 - b2 - b3
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2] and b3 <= M[3] and b4 <= M[4]:
                    best = min(best, slowest([b0,b1,b2,b3,b4], S, P))
    else:
        assert False

    return best
            

def solve(R, B, C, M, S, P):
    print >> sys.stderr, R, B, C, M, S, P
    #~ print try_solve(B, C, M, S, P)
    best = 1e100
    for X in combinations(range(C), R):
        m, s, p = [], [], []
        for x in X:
            m.append(M[x])
            s.append(S[x])
            p.append(P[x])
        t = try_solve(B, R, m, s, p)
        print >> sys.stderr, ""try"", m, s, p, X, t
        if t < best:
            best = t
    return best

T = readint()
for t in range(T):
    R, B, C = readlist()
    M = []
    S = []
    P = []
    for i in range(C):
        m, s, p = readlist()
        M.append(m)
        S.append(s)
        P.append(p)

    print ""Case #%d: %s"" % (t+1, solve(R, B, C, M, S, P))
",,3201,124,502,Python,0000000000007883,0000000000034688,000000000002fff6,a1ex,2018
529,00000000000345bc.PYTHON,"import os, sys
from itertools import combinations

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def slowest(A, S, P):
    tmax = 0
    for i in range(len(S)):
        ti = P[i] + S[i] * A[i]
        if ti > tmax:
            tmax = ti
    #~ print >> sys.stderr, A, S, P, tmax
    return tmax

def alloc(A, M, S, P):
    best = 0
    tmin = 1e10
    for i in range(len(M)):
        if M[i] > 0:
            ti = P[i] + S[i] * (A[i] + 1)
            if ti < tmin:
                best = i
                tmin = ti
    #~ print >> sys.stderr, ""alloc %d t=%d"" % (best, tmin)
    A[best] += 1
    M[best] -= 1

def try_solve_old(B, C, M, S, P):
    M = [ x for x in M ]
    A = [ 0 for x in M ]
    for i in range(B):
        alloc(A, M, S, P)
        #~ print >> sys.stderr, A

    return slowest(A, S, P)


def try_solve(B, C, M, S, P):
    assert C == len(M)
    assert C == len(S)
    assert C == len(P)
    
    best = 1e100
    if C == 1:
        A = [ B ]
        if B <= M[0]:
            best = slowest(A, S, P)

    elif C == 2:
        for b0 in range(0,B+1):
            b1 = B - b0
            if b0 <= M[0] and b1 <= M[1]:
                #~ print >> sys.stderr, b0, b1, slowest([b0,b1], S, P)
                best = min(best, slowest([b0,b1], S, P))
            #~ else:
                #~ print >> sys.stderr, b0, b1, ""nai"", M

    elif C == 3:
        for b0 in range(0,B+1):
            for b1 in range(0,B+1-b0):
                b2 = B - b0 - b1
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2]:
                    best = min(best, slowest([b0,b1,b2], S, P))

    elif C == 4:
        for b0 in range(0,B+1):
          for b1 in range(0,B+1-b0):
             for b2 in range(0,B+1-b0-b1):
                b3 = B - b0 - b1 - b2
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2] and b3 <= M[3]:
                    best = min(best, slowest([b0,b1,b2,b3], S, P))

    elif C == 5:
        for b0 in range(0,B+1):
          for b1 in range(0,B+1-b0):
            for b2 in range(0,B+1-b0-b1):
              for b3 in range(0,B+1-b0-b1-b2):
                b4 = B - b0 - b1 - b2 - b3
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2] and b3 <= M[3] and b4 <= M[4]:
                    best = min(best, slowest([b0,b1,b2,b3,b4], S, P))
    else:
        assert False

    return best
            

def solve(R, B, C, M, S, P):
    print >> sys.stderr, R, B, C, M, S, P
    #~ print try_solve(B, C, M, S, P)
    best = 1e100
    for X in combinations(range(C), R):
        m, s, p = [], [], []
        for x in X:
            m.append(M[x])
            s.append(S[x])
            p.append(P[x])
        t = try_solve(B, R, m, s, p)
        print >> sys.stderr, ""try"", m, s, p, X, t
        if t < best:
            best = t
    return best

T = readint()
for t in range(T):
    R, B, C = readlist()
    M = []
    S = []
    P = []
    for i in range(C):
        m, s, p = readlist()
        M.append(m)
        S.append(s)
        P.append(p)

    print ""Case #%d: %s"" % (t+1, solve(R, B, C, M, S, P))
",,3171,123,499,Python,0000000000007883,00000000000345bc,000000000002fff6,a1ex,2018
530,000000000003420b.PYTHON,"import os, sys
from itertools import combinations

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def slowest(A, S, P):
    #~ print >> sys.stderr, A, S, P
    tmax = 0
    for i in range(len(S)):
        ti = P[i] + S[i] * A[i]
        if ti > tmax:
            tmax = ti
    return tmax

def alloc(A, M, S, P):
    best = 0
    tmin = 1e10
    for i in range(len(M)):
        if M[i] > 0:
            ti = P[i] + S[i] * (A[i] + 1)
            if ti < tmin:
                best = i
                tmin = ti
    #~ print >> sys.stderr, ""alloc %d t=%d"" % (best, tmin)
    A[best] += 1
    M[best] -= 1

def try_solve_old(B, C, M, S, P):
    M = [ x for x in M ]
    A = [ 0 for x in M ]
    for i in range(B):
        alloc(A, M, S, P)
        #~ print >> sys.stderr, A

    return slowest(A, S, P)


def try_solve(B, C, M, S, P):

    best = 1e100
    if C == 1:
        A = [ B ]
        if B <= M[0]:
            best = slowest(A, S, P)

    if C == 2:
        for b0 in range(0,B+1):
            b1 = B - b0
            if b0 <= M[0] and b1 <= M[1]:
                #~ print >> sys.stderr, b0, b1, slowest([b0,b1], S, P)
                best = min(best, slowest([b0,b1], S, P))
            #~ else:
                #~ print >> sys.stderr, b0, b1, ""nai"", M

    if C == 3:
        for b0 in range(0,B+1):
            for b1 in range(0,B+1-b0):
                b2 = B - b0 - b1
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2]:
                    best = min(best, slowest([b0,b1,b2], S, P))

    if C == 4:
        for b0 in range(0,B+1):
          for b1 in range(0,B+1-b0):
             for b2 in range(0,B+1-b0-b1):
                b3 = B - b0 - b1 - b2
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2] and b3 <= M[3]:
                    best = min(best, slowest([b0,b1,b2,b3], S, P))

    if C == 5:
        for b0 in range(0,B+1):
          for b1 in range(0,B+1-b0):
            for b2 in range(0,B+1-b0-b1):
              for b3 in range(0,B+1-b0-b1-b2):
                b4 = B - b0 - b1 - b2 - b3
                if b0 <= M[0] and b1 <= M[1] and b2 <= M[2] and b3 <= M[3] and b4 <= M[4]:
                    best = min(best, slowest([b0,b1,b2,b3,b4], S, P))

    return best
            

def solve(R, B, C, M, S, P):
    print >> sys.stderr, R, B, C, M, S, P
    #~ print try_solve(B, C, M, S, P)
    best = 1e100
    for X in combinations(range(C), R):
        m, s, p = [], [], []
        for x in X:
            m.append(M[x])
            s.append(S[x])
            p.append(P[x])
        t = try_solve(B, R, m, s, p)
        print >> sys.stderr, ""try"", m, s, p, X, t
        if t < best:
            best = t
    return best

T = readint()
for t in range(T):
    R, B, C = readlist()
    M = []
    S = []
    P = []
    for i in range(C):
        m, s, p = readlist()
        M.append(m)
        S.append(s)
        P.append(p)

    print ""Case #%d: %s"" % (t+1, solve(R, B, C, M, S, P))
",,3053,118,483,Python,0000000000007883,000000000003420b,000000000002fff6,a1ex,2018
531,000000000003347a.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
#from numpy import matrix, mat

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readlistf():
    return [float(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readfloat():
    return readlistf()[0]

def solvex(N, P, W, H, so):
    WH = zip(W,H)
    if so:
        WH.sort(key=lambda wh: -2 * (wh[0] + 2*wh[1]) - 2 * (wh[0]+wh[1]))
    else:
        WH.sort(key=lambda wh: -2 * (wh[0] + wh[1] + sqrt(wh[0]*wh[0] + wh[1]*wh[1])) - 2 * (wh[0]+wh[1]))

    p_no_cut = 0
    for w,h in WH:
        p_no_cut += 2*(w+h)
    p_extra = P - p_no_cut
    print >> sys.stderr, p_no_cut, p_extra

    p_max = p_no_cut

    for w,h in WH:
        mh = 2 * (w + 2*h)
        Mh = 2 * (w + h + sqrt(w*w + h*h))
        cut_cost = mh - 2*(w+h)
        print >> sys.stderr, cut_cost, 2*(w+h), mh, Mh
        if cut_cost <= p_extra:
            p_extra -= cut_cost
            p_max += Mh - 2*(w+h)
            print >> sys.stderr, ""cut!"", p_max

    return min(P, p_max)
    
def solve(N, P, W, H):
    return max(solvex(N,P,W,H,False), solvex(N,P,W,H,True))

T = readint()
for t in range(T):
    N, P = readlist()
    W, H = [], []
    for i in range(N):
        w, h = readlistf()
        W.append(max(w,h))
        H.append(min(w,h))

    print ""Case #%d: %.6f"" % (t+1, solve(N, P, W, H))

",,1409,58,200,Python,0000000000007883,000000000003347a,000000000002fff7,a1ex,2018
532,000000000003265f.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
#from numpy import matrix, mat

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readlistf():
    return [float(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readfloat():
    return readlistf()[0]

def solve(N, P, W, H):
    # daca nu tai: 2w + 2h
    # daca tai v: min=2w+4h, max=(w+h+norm(w h)) * 2
    # daca tai h: ...
    w = W[0]
    h = H[0]
    mh = 2 * (w + 2*h)
    Mh = 2 * (w + h + sqrt(w*w + h*h))
    cut_cost = mh - 2*(w+h)
    p_no_cut = 2*(w+h) * N
    num_cuts = int((P - p_no_cut) / cut_cost)
    num_cuts = min(num_cuts, N)
    print >> sys.stderr, ""extrap, cut_cost, num_cuts"", P - p_no_cut, cut_cost, num_cuts
    print >> sys.stderr, ""p0, pmin, pmax"", 2*(w+h), mh, Mh
    max_area = 2*(w+h) * (N - num_cuts) + num_cuts * Mh
    min_area = 2*(w+h) * (N - num_cuts) + num_cuts * mh
    assert min_area <= P
    print >> sys.stderr, ""P, min, max"", P, min_area, max_area
    return min(P, max_area)
    
    return 0

T = readint()
for t in range(T):
    N, P = readlist()
    W, H = [], []
    for i in range(N):
        w, h = readlistf()
        W.append(max(w,h))
        H.append(min(w,h))

    print ""Case #%d: %.6f"" % (t+1, solve(N, P, W, H))

",,1305,50,208,Python,0000000000007883,000000000003265f,000000000002fff7,a1ex,2018
533,00000000000321f4.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
#from numpy import matrix, mat

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readlistf():
    return [float(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readfloat():
    return readlistf()[0]

def area(Cr):
    # assume rotx(0...45) * rotz(0...45)
    x = Cr[0]
    #~ w = max(x.A1) - min(x.A1)
    #~ h = Cr[2,1] * 2
    #~ H = Cr[2,0]
    w = max(x) - min(x)
    h = Cr[2][1] * 2
    H = Cr[2][0]
    #~ print(w, h, H)
    return w * h + w * (H - h / 2.0)

def solve(N, P, W, H):
    # daca nu tai: 2w + 2h
    # daca tai v: min=2w+4h, max=(w+h+norm(w h)) * 2
    # daca tai h: ...
    w = W[0]
    h = H[0]
    mh = 2 * (w + 2*h)
    Mh = 2 * (w + h + sqrt(w*w + h*h))
    cut_cost = mh - 2*(w+h)
    p_no_cut = 2*(w+h) * N
    num_cuts = int((P - p_no_cut) / cut_cost)
    print >> sys.stderr, P - p_no_cut, cut_cost, num_cuts
    print >> sys.stderr, 2*(w+h), mh, Mh
    max_area = 2*(w+h) * (N - num_cuts) + num_cuts * Mh
    min_area = 2*(w+h) * (N - num_cuts) + num_cuts * mh
    assert min_area <= P
    print >> sys.stderr, P, min_area, max_area
    return min(P, max_area)
    
    return 0

T = readint()
for t in range(T):
    N, P = readlist()
    W, H = [], []
    for i in range(N):
        w, h = readlistf()
        W.append(max(w,h))
        H.append(min(w,h))

    print ""Case #%d: %.6f"" % (t+1, solve(N, P, W, H))

",,1476,61,250,Python,0000000000007883,00000000000321f4,000000000002fff7,a1ex,2018
534,0000000000031735.PYTHON,"import os, sys
from itertools import combinations

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def slowest(A, S, P):
    #~ print >> sys.stderr, A, S, P
    tmax = 0
    for i in range(len(S)):
        ti = P[i] + S[i] * A[i]
        if ti > tmax:
            tmax = ti
    return tmax

def alloc(A, M, S, P):
    best = 0
    tmin = 1e10
    for i in range(len(M)):
        if M[i] > 0:
            ti = P[i] + S[i] * (A[i] + 1)
            if ti < tmin:
                best = i
                tmin = ti
    #~ print >> sys.stderr, ""alloc %d t=%d"" % (best, tmin)
    A[best] += 1
    M[best] -= 1

def try_solve(B, C, M, S, P):
    M = [ x for x in M ]
    A = [ 0 for x in M ]
    for i in range(B):
        alloc(A, M, S, P)
        #~ print >> sys.stderr, A

    return slowest(A, S, P)


def solve(R, B, C, M, S, P):
    print >> sys.stderr, R, B, C, M, S, P
    #~ print try_solve(B, C, M, S, P)
    best = 1e100
    for X in combinations(range(C), R):
        m, s, p = [], [], []
        for x in X:
            m.append(M[x])
            s.append(S[x])
            p.append(P[x])
        t = try_solve(B, C, m, s, p)
        print >> sys.stderr, ""try"", m, s, p, X, t
        if t < best:
            best = t
    return best

T = readint()
for t in range(T):
    R, B, C = readlist()
    M = []
    S = []
    P = []
    for i in range(C):
        m, s, p = readlist()
        M.append(m)
        S.append(s)
        P.append(p)

    print ""Case #%d: %s"" % (t+1, solve(R, B, C, M, S, P))
",,1627,74,267,Python,0000000000007883,0000000000031735,000000000002fff6,a1ex,2018
535,00000000000302cd.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def count(M, i1, j1, i2, j2):
    #~ print >> sys.stderr, M, i1, j1, i2, j2
    num = 0
    for i in range(i1, i2):
        #~ print >> sys.stderr, M[i][j1:j2]
        num += M[i][j1:j2].count('@')
    return num

def solve(M, R, C, H, V):
    if H == 1 and V == 1:
        for i in range(1, R):
            for j in range(1, C):
                a = count(M, 0, 0, i, j)
                b = count(M, 0, j, i, C)
                c = count(M, i, 0, R, j)
                d = count(M, i, j, R, C)
                if a == b == c == d:
                    print >> sys.stderr, i, j, a, b, c, d
                    return ""POSSIBLE""
    return ""IMPOSSIBLE""

T = readint()
for t in range(T):
    R, C, H, V = readlist()
    print >> sys.stderr, R, C, H, V
    M = []
    for i in range(R):
        l = readstr().strip()
        print >> sys.stderr, l
        assert len(l) == C
        M.append(l)

    print ""Case #%d: %s"" % (t+1, solve(M, R, C, H, V))
",,1135,45,175,Python,0000000000007883,00000000000302cd,000000000003005a,a1ex,2018
536,0000000000025b3f.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
#from numpy import matrix, mat

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readlistf():
    return [float(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readfloat():
    return readlistf()[0]

def mat(x):
    return x

def matrix(x):
    return x

def matmult(a,b):
    zip_b = zip(*b)
    # uncomment next line if python 3 : 
    # zip_b = list(zip_b)
    return [[sum(ele_a*ele_b for ele_a, ele_b in zip(row_a, col_b)) 
             for col_b in zip_b] for row_a in a]

def rotx(ang):
    c = cos(ang)
    s = sin(ang)
    return mat([[1,  0,  0], 
                [0,  c, -s], 
                [0,  s,  c]])

def roty(ang):
    c = cos(ang)
    s = sin(ang)
    return mat([[ c, 0,  s], 
                [ 0, 1,  0], 
                [-s, 0,  c]])

def rotz(ang):
    c = cos(ang)
    s = sin(ang)
    return mat([[c, -s,  0], 
                [s,  c,  0], 
                [0, 0, 1]])

def area(Cr):
    # assume rotx(0...45) * rotz(0...45)
    x = Cr[0]
    #~ w = max(x.A1) - min(x.A1)
    #~ h = Cr[2,1] * 2
    #~ H = Cr[2,0]
    w = max(x) - min(x)
    h = Cr[2][1] * 2
    H = Cr[2][0]
    #~ print(w, h, H)
    return w * h + w * (H - h / 2.0)

def solve(V):
    h = matrix([[0.5,   0,   0],
                [  0, 0.5,   0],
                [  0,   0, 0.5]])

    C = matrix([[ 0.5,-0.5, 0.5, 0.5,-0.5,-0.5, 0.5,-0.5],
                [ 0.5, 0.5,-0.5, 0.5,-0.5, 0.5,-0.5,-0.5],
                [ 0.5, 0.5, 0.5,-0.5, 0.5,-0.5,-0.5,-0.5]])

    magic_angle = asin(1/sqrt(3))

    if A <= sqrt(2):
        #~ f = lambda x: area(rotz(x) * C)
        #~ g = lambda x: rotz(x) * h
        f = lambda x: area(matmult(rotz(x), C))
        g = lambda x: matmult(rotz(x), h)
        lo, hi = 0, pi/4
    else:
        #~ f = lambda x: area(rotx(x) * rotz(pi/4) * C)
        #~ g = lambda x: rotx(x) * rotz(pi/4) * h
        f = lambda x: area(matmult(rotx(x), matmult(rotz(pi/4), C)))
        g = lambda x: matmult(rotx(x), matmult(rotz(pi/4), h))
        lo, hi = 0, magic_angle

    while hi - lo > 1e-10:
        m = (hi + lo) / 2.0
        a = f(m)
        if a < A:
            lo = m
        else:
            hi = m

    print >> sys.stderr, ""m"", m*180/pi, ""a"", f(m), ""g"", g(m)
    sol = g(m)
    
    #~ return (sol[0,0], sol[1,0], sol[2,0]), (sol[0,1], sol[1,1], sol[2,1]), (sol[0,2], sol[1,2], sol[2,2])
    return (sol[0][0], sol[1][0], sol[2][0]), (sol[0][1], sol[1][1], sol[2][1]), (sol[0][2], sol[1][2], sol[2][2])

T = readint()
for t in range(T):
    A = readfloat()
    print ""Case #%d: "" % (t+1)
    ux,uy,uz = solve(A)
    print("" "".join(str(x) for x in ux))
    print("" "".join(str(x) for x in uy))
    print("" "".join(str(x) for x in uz))
",,2799,109,402,Python,00000000000000cb,0000000000025b3f,00000000000079cc,a1ex,2018
537,00000000000257ec.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
#from numpy import matrix, mat
",,94,4,17,Python,00000000000000cb,00000000000257ec,00000000000079cc,a1ex,2018
538,0000000000025718.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
from numpy import matrix, mat
",,93,4,17,Python,00000000000000cb,0000000000025718,00000000000079cc,a1ex,2018
539,0000000000025704.PYTHON,"import os, sys, math
from math import pi, sin, cos, asin, sqrt
from numpy import matrix, mat

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readlistf():
    return [float(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readfloat():
    return readlistf()[0]

def rotx(ang):
    c = cos(ang)
    s = sin(ang)
    return mat([[1,  0,  0], 
                [0,  c, -s], 
                [0,  s,  c]])

def roty(ang):
    c = cos(ang)
    s = sin(ang)
    return mat([[ c, 0,  s], 
                [ 0, 1,  0], 
                [-s, 0,  c]])

def rotz(ang):
    c = cos(ang)
    s = sin(ang)
    return mat([[c, -s,  0], 
                [s,  c,  0], 
                [0, 0, 1]])

def area(Cr):
    # assume rotx(0...45) * rotz(0...45)
    x = Cr[0]
    w = max(x.A1) - min(x.A1)
    h = Cr[2,1] * 2
    H = Cr[2,0]
    #~ print(w, h, H)
    return w * h + w * (H - h / 2.0)

def solve(V):
    h = matrix([[1,0,0],
                [0,1,0],
                [0,0,1]]) / 2.0

    C = matrix([[ 1,-1, 1, 1,-1,-1, 1,-1],
                [ 1, 1,-1, 1,-1, 1,-1,-1],
                [ 1, 1, 1,-1, 1,-1,-1,-1]]) / 2.0

    magic_angle = asin(1/sqrt(3))

    if A <= sqrt(2):
        f = lambda x: area(rotz(x) * C)
        g = lambda x: rotz(x) * h
        lo, hi = 0, pi/4
    else:
        f = lambda x: area(rotx(x) * rotz(pi/4) * C)
        g = lambda x: rotx(x) * rotz(pi/4) * h
        lo, hi = 0, magic_angle

    while hi - lo > 1e-10:
        m = (hi + lo) / 2.0
        a = f(m)
        if a < A:
            lo = m
        else:
            hi = m

    print >> sys.stderr, ""m"", m*180/pi, ""a"", f(m), ""g"", g(m)
    sol = g(m)
    
    return (sol[0,0], sol[1,0], sol[2,0]), (sol[0,1], sol[1,1], sol[2,1]), (sol[0,2], sol[1,2], sol[2,2])

T = readint()
for t in range(T):
    A = readfloat()
    print ""Case #%d: "" % (t+1)
    ux,uy,uz = solve(A)
    print("" "".join(str(x) for x in ux))
    print("" "".join(str(x) for x in uy))
    print("" "".join(str(x) for x in uz))
",,2036,88,300,Python,00000000000000cb,0000000000025704,00000000000079cc,a1ex,2018
540,0000000000022d36.PYTHON,"import os, sys, math

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def find_div(A):
    for i in range(int(math.sqrt(A)), 3, -1):
        j = A // i
        if i * j == A:
            return i, j

    a = int(math.sqrt(A))
    b = A // a
    while a * b < A:
        b += 1

    return a, b

def pr(M):
    for l in M:
        ln = [ ""x"" if x else ""."" for x in l ]
        print >> sys.stderr, ln

def fini(M):
    H = len(M)
    W = len(M[0])
    for i in range(H):
        for j in range(W):
            if not M[i][j]:
                return False
    return True

def clamp(x, lo, hi):
    return max(min(x,hi),lo)

def pick(M):
    H = len(M)
    W = len(M[0])
    for i in range(H):
        for j in range(W):
            if not M[i][j]:
                return clamp(i+1, 2, H-1), clamp(j+1, 2, W-1)
    return True

T = readint()
for t in range(T):
    A = readint()
    W, H = find_div(A)
    print >> sys.stderr, A, W, H
    M = []
    for i in range(H):
        M.append([False] * W)

    while not fini(M):
        x,y = pick(M)
        #~ print >> sys.stderr, ""pick "", x, y
        print x, y; sys.stdout.flush()
        x, y = readlist()
        #~ print >> sys.stderr, ""got  "", x, y
        if x < 0:
            #~ print >> sys.stderr, ""oops""
            break
        if x == 0:
            #~ print >> sys.stderr, ""done""
            break

        M[x-1][y-1] = True
        #~ pr(M)
",,1472,72,223,Python,00000000000000cb,0000000000022d36,0000000000007a30,a1ex,2018
541,00000000000215eb.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

# when all else fails, brute force prevails
def TroubleSort(L):
    done = False
    while not done:
        done = True
        for i in range(len(L) - 2):
            if L[i] > L[i+2]:
                done = False
                L[i], L[i+2] = L[i+2], L[i]

def solve(V):
    # guess :)
    Ve = sorted(V[0::2])
    Vo = sorted(V[1::2])
    Vx = []
    for i in range(len(Ve)):
        Vx.append(Ve[i])
        if i < len(Vo):
            Vx.append(Vo[i])

    if 0:
        # check the hypothesis against brute-force version
        C = [x for x in V]
        TroubleSort(C)
        assert Vx == C

    V = sorted(V)

    if Vx == V:
        return ""OK""
    for i,(v,c) in enumerate(zip(V,Vx)):
        if v != c:
            return i

T = readint()
for t in range(T):
    N = readint()
    V = readlist()
    assert len(V) == N
    assert N > 2
    print ""Case #%d: %s"" % (t+1, solve(V))
",,1025,50,144,Python,00000000000000cb,00000000000215eb,00000000000079cb,a1ex,2018
542,000000000001f4bb.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def damage(P):
    d = 1
    t = 0
    for c in P:
        if c == ""C"":
            d *= 2
        else:
            assert c == ""S""
            t += d
    return t

def solve(D, P):
    print >> sys.stderr, D, P, damage(P)
    if P.count(""S"") > D:
        return ""IMPOSSIBLE""
    hacks = 0
    while damage(P) > D:
        i = P.rindex(""CS"")
        P = P[:i] + P[i+1] + P[i] + P[i+2:]
        hacks += 1
        #~ print >> sys.stderr, i, P
    return hacks
    

T = readint()
for t in range(T):
    D, P = sys.stdin.readline().strip().split()
    D = int(D)
    print ""Case #%d: %s"" % (t+1, solve(D, P))

",,741,39,111,Python,00000000000000cb,000000000001f4bb,0000000000007966,a1ex,2018
543,0000000000007621.PYTHON,"import os, sys
from collections import defaultdict
#from sortedcontainers import SortedDict
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(N, K):
    S = defaultdict(int)
    S[N] = 1
    C = 0
    while S:
        # process largest interval
        n = sorted(S.keys(), reverse=True)[0]
        c = S[n]
        sol = ((n - 1) / 2, (n - 1) / 2) if n % 2 else (n / 2, (n - 2) / 2)
        #~ print >> sys.stderr, S, c, n, sol
        C += c
        if C >= K:
            return sol
        del S[n]
        if n % 2:
            if n - 1:
                S[(n - 1) / 2] += 2 * c
        else:
            S[n / 2] += c
            if n - 2:
                S[(n - 2) / 2] += c
        #~ print >> sys.stderr, S, ""=>"", C

T = readint()
for t in range(T):
    N, K = readlist()

    sol = solve(N, K)
    print ""Case #%d: %d %d"" % (t+1, sol[0], sol[1])
",,1009,44,165,Python,0000000000000130,0000000000007621,0000000000000652,a1ex,2018
544,0000000000007112.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    for i in range(N):
        k, s = K[i], S[i]
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) * 1.0 / s
        t = max(t, a)
        #plot([0, a], [k, D])
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,771,39,128,Python,0000000000000130,0000000000007112,0000000000000524,a1ex,2018
545,00000000000070c9.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    for i in range(N):
        k, s = K[i], S[i]
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        assert (D - k) > 0
        t = max(t, a)
        #plot([0, a], [k, D])

    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,806,42,134,Python,0000000000000130,00000000000070c9,0000000000000524,a1ex,2018
546,000000000000702d.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    for i in range(N):
        k, s = K[i], S[i]
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        assert s > 0
        t = max(t, a)
        #plot([0, a], [k, D])

    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,800,42,132,Python,0000000000000130,000000000000702d,0000000000000524,a1ex,2018
547,0000000000007081.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    assert N > 0
    for i in range(N):
        k, s = K[i], S[i]
        assert k > 0
        assert k < D
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        assert a > 0
        t = max(t, a)
        #plot([0, a], [k, D])

    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,859,45,144,Python,0000000000000130,0000000000007081,0000000000000524,a1ex,2018
548,000000000000702a.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    assert N > 0
    for i in range(N):
        k, s = K[i], S[i]
        assert k > 0
        assert k < D
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])

    assert t > 0
    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,855,45,144,Python,0000000000000130,000000000000702a,0000000000000524,a1ex,2018
549,0000000000007102.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    assert N > 0
    for i in range(N):
        k, s = K[i], S[i]
        assert k > 0
        assert k < D
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])

    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,838,44,140,Python,0000000000000130,0000000000007102,0000000000000524,a1ex,2018
550,000000000000714e.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0
    assert N > 0
    for i in range(N):
        k, s = K[i], S[i]
        
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])

    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,805,43,132,Python,0000000000000130,000000000000714e,0000000000000524,a1ex,2018
551,0000000000007189.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0

    for i in range(N):
        k, s = K[i], S[i]
        
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])
    assert t != 0
    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,806,43,132,Python,0000000000000130,0000000000007189,0000000000000524,a1ex,2018
552,0000000000006fe1.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0

    for i in range(N):
        k, s = K[i], S[i]
        
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])
    return 0
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,788,42,128,Python,0000000000000130,0000000000006fe1,0000000000000524,a1ex,2018
553,0000000000007187.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    return 0
    print >> sys.stderr, D, N, K, S
    t = 0

    for i in range(N):
        k, s = K[i], S[i]
        
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,788,42,128,Python,0000000000000130,0000000000007187,0000000000000524,a1ex,2018
554,00000000000071d2.PYTHON,"import os, sys
#from pylab import *

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(D, N, K, S):
    print >> sys.stderr, D, N, K, S
    t = 0

    for i in range(N):
        k, s = K[i], S[i]
        
        # time of arrival for this horse
        # D = k + s t
        a = (D - k) / s
        t = max(t, a)
        #plot([0, a], [k, D])
    #plot([0, t], [0, D], 'r')
    #show()
    #clf()
    return D * 1.0 / t

T = readint()
for t in range(T):
    D, N = readlist()
    K = []
    S = []
    for i in range(N):
        k, s = readlist()
        K.append(k)
        S.append(s)

    print ""Case #%d: %.6f"" % (t+1, solve(D, N, K, S))
",,775,41,126,Python,0000000000000130,00000000000071d2,0000000000000524,a1ex,2018
555,0000000000006fac.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(P):
    S = []
    name = 'A';
    for p in P:
        S.append([p, name])
        name = chr(ord(name)+1)
    out = """"
    S.sort(key = lambda x: -x[0])
    N = sum([s[0] for s in S])
    print >> sys.stderr, S, N
    while S[0][0]:
        if S[0][0] == S[1][0] and S[0][0] - 1 <= (N-2)/2 and (len(S) < 3 or S[2][0] <= (N-2)/2):
            out += S[0][1] + S[1][1] + "" ""
            S[0][0] -= 1
            S[1][0] -= 1
            N -= 2
        elif S[0][0] > 1 and S[1][0] <= (N-2)/2:
            out += S[0][1] * 2 + "" ""
            S[0][0] -= 2
            N -= 2
        else:
            out += S[0][1] + "" ""
            S[0][0] -= 1
            N -= 1
        S.sort(key = lambda x: -x[0])
        print >> sys.stderr, S, S[0][0], sum([s[0] for s in S]), out
        assert N == sum([s[0] for s in S])
        assert S[0][0] <= N / 2
    return out
T = readint()
for t in range(T):
    N = readint()
    P = readlist()
    assert len(P) == N
    assert N > 1
    print ""Case #%d: %s"" % (t+1, solve(P))
",,1212,48,188,Python,0000000000000130,0000000000006fac,00000000000004c0,a1ex,2018
556,0000000000006e5d.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    try:
        A, B = readlist()
        N = readint()
    except:
        raise SystemExit
    B += 1
    print >> sys.stderr, A, B
    for i in range(N):
        m = (A + B) // 2
        print(m)
        sys.stdout.flush()
        ans = readstr()
        print >> sys.stderr, ans
        if ans == ""CORRECT"":
            break
        elif ans == ""TOO_SMALL"":
            A = m
        elif ans == ""TOO_BIG"":
            B = m
        elif ans == ""WRONG_ANSWER"":
            break
        else:
            assert False
",,745,37,92,Python,0000000000000130,0000000000006e5d,0000000000000523,a1ex,2018
557,0000000000006d83.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    try:
        A, B = readlist()
        N = readint()
    except:
        raise SystemExit
    print >> sys.stderr, A, B
    for i in range(N):
        m = (A + B) // 2
        print(m)
        sys.stdout.flush()
        ans = readstr()
        print >> sys.stderr, ans
        if ans == ""CORRECT"":
            break
        elif ans == ""TOO_SMALL"":
            A = m
        elif ans == ""TOO_BIG"":
            B = m
        elif ans == ""WRONG_ANSWER"":
            break
        else:
            assert False
",,734,36,89,Python,0000000000000130,0000000000006d83,0000000000000523,a1ex,2018
558,0000000000006ead.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    try:
        A, B = readlist()
        N = readint()
    except:
        raise SystemExit
    print >> sys.stderr, A, B
    for i in range(N):
        m = (A + B) // 2
        print(m)
        sys.stdout.flush()
        ans = readstr()
        print >> sys.stderr, ans
        if ans == ""CORRECT"":
            break
        elif ans == ""TOO_SMALL"":
            B = m
        elif ans == ""TOO_BIG"":
            A = m
        elif ans == ""WRONG_ANSWER"":
            break
        else:
            assert False
",,734,36,89,Python,0000000000000130,0000000000006ead,0000000000000523,a1ex,2018
559,0000000000006c94.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    A, B = readlist()
    N = readint()
    for i in range(N):
        m = (A + B) // 2
        print(m)
        sys.stdout.flush()
        ans = readstr()
        if ans == ""CORRECT"":
            break
        elif ans == ""TOO_SMALL"":
            A = m
        elif ans == ""TOO_BIG"":
            B = m
        else:
            assert False
",,563,29,71,Python,0000000000000130,0000000000006c94,0000000000000523,a1ex,2018
560,0000000000006c52.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    A, B = readlist()
    N = readint()
    for i in range(N):
        m = (A + B) / 2
        print m
        sys.stdout.flush()
        ans = readstr()
        if ans == ""CORRECT"":
            break
        elif ans == ""TOO_SMALL"":
            A = m
        elif ans == ""TOO_BIG"":
            B = m
        else:
            assert False
",,561,29,72,Python,0000000000000130,0000000000006c52,0000000000000523,a1ex,2018
561,000000000014c213.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(3000):
        wc = random.randint(1, 1000000000000000)
        wj = random.randint(1, 1000000000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = wc * molecule[0] + wj * molecule[1]
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1158,54,144,Python,0000000000051679,000000000014c213,0000000000146183,a1ex,2019
562,000000000014bfed.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(5000):
        wc = random.randint(1, 1000000000000000)
        wj = random.randint(1, 1000000000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = wc * molecule[0] + wj * molecule[1]
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1158,54,144,Python,0000000000051679,000000000014bfed,0000000000146183,a1ex,2019
563,000000000014be5b.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(2000):
        if k < 1000:
            wc = random.randint(1, 2000)
            wj = random.randint(1, 2000)
        else:
            wc = random.randint(1, 100000000000)
            wj = random.randint(1, 100000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = wc * molecule[0] + wj * molecule[1]
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1275,58,157,Python,0000000000051679,000000000014be5b,0000000000146183,a1ex,2019
564,000000000014bc71.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(10000):
        if k < 2000:
            wc = random.randint(1, 100)
            wj = random.randint(1, 100)
        else:
            wc = random.randint(1, 100000000000)
            wj = random.randint(1, 100000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = weight(molecule, wc, wj)
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1263,58,153,Python,0000000000051679,000000000014bc71,0000000000146183,a1ex,2019
565,000000000014bc1a.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(1000):
        if k < 500:
            wc = random.randint(1, 100)
            wj = random.randint(1, 100)
        else:
            wc = random.randint(1, 100000000000)
            wj = random.randint(1, 100000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = weight(molecule, wc, wj)
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1261,58,153,Python,0000000000051679,000000000014bc1a,0000000000146183,a1ex,2019
566,000000000014ba35.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for wc in range(1,2000):
        for wj in range(1,2000):
            if valid(CJ, wc, wj):
                #~ print wc, wj
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1060,53,144,Python,0000000000051679,000000000014ba35,0000000000146184,a1ex,2019
567,000000000014b907.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for wc in range(1,5000):
        for wj in range(1,5000):
            if valid(CJ, wc, wj):
                #~ print wc, wj
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1060,53,144,Python,0000000000051679,000000000014b907,0000000000146184,a1ex,2019
568,000000000014b82f.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for wc in range(1000):
        for wj in range(1000):
            if valid(CJ, wc, wj):
                #~ print wc, wj
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1056,53,144,Python,0000000000051679,000000000014b82f,0000000000146184,a1ex,2019
569,000000000014b318.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for sm in range(1000):
        for wc in range(sm):
            wj = sm - wc
            if valid(CJ, wc, wj):
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1047,53,145,Python,0000000000051679,000000000014b318,0000000000146184,a1ex,2019
570,000000000014b148.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for sm in range(1000):
        for wj in range(sm):
            wc = sm - wj
            if valid(CJ, wc, wj):
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1047,53,145,Python,0000000000051679,000000000014b148,0000000000146184,a1ex,2019
571,000000000014b0f6.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for sm in range(200):
        for wj in range(sm):
            wc = sm - wj
            if valid(CJ, wc, wj):
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1046,53,145,Python,0000000000051679,000000000014b0f6,0000000000146184,a1ex,2019
572,000000000014b171.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def valid(CJ, wc, wj):
    prev = 0
    for molecule in CJ:
        w = weight(molecule, wc, wj)
        if w <= prev:
            return False
        prev = w
    return True

def solve(C, J):
    N = len(C)
    CJ = zip(C, J)

    for sm in range(100):
        for wj in range(sm):
            wc = sm - wj
            if valid(CJ, wc, wj):
                return wc, wj

    return False, False
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    a, b = solve(C, J)
    if a:
        print(""Case #%d: %d %d"" % (t+1, a, b))
    else:
        print(""Case #%d: IMPOSSIBLE"" % (t+1))
",,1046,53,145,Python,0000000000051679,000000000014b171,0000000000146184,a1ex,2019
573,000000000014a9b8.PYPY2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(500):
        if k < 200:
            wc = random.randint(1, 100)
            wj = random.randint(1, 100)
        else:
            wc = random.randint(1, 100000000000)
            wj = random.randint(1, 100000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = weight(molecule, wc, wj)
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1260,58,153,Python,0000000000051679,000000000014a9b8,0000000000146183,a1ex,2019
574,000000000014a9d9.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(200):
        if k < 100:
            wc = random.randint(1, 100)
            wj = random.randint(1, 100)
        else:
            wc = random.randint(1, 100000000000)
            wj = random.randint(1, 100000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = weight(molecule, wc, wj)
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1260,58,153,Python,0000000000051679,000000000014a9d9,0000000000146183,a1ex,2019
575,000000000014a823.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(1000):
        wc = random.randint(1, 1000000000)
        wj = random.randint(1, 1000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = weight(molecule, wc, wj)
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1135,54,140,Python,0000000000051679,000000000014a823,0000000000146183,a1ex,2019
576,000000000014a5b0.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(2000):
        wc = random.randint(1, 1000000000)
        wj = random.randint(1, 1000000000)
        #~ print order, wc, wj
        prev = 0
        valid = True
        for molecule in order:
            w = weight(molecule, wc, wj)
            if w <= prev:
                valid = False
                break
            prev = w
        if valid:
            return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1135,54,140,Python,0000000000051679,000000000014a5b0,0000000000146183,a1ex,2019
577,000000000014a391.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    #~ print order
    constraint = 0
    for i in range(1, len(order)):
        ma = order[i]
        mb = order[i-1]
        wa = ma[0] - mb[0]
        wb = mb[1] - ma[1]
        #~ print wa, wb
        if wa == 0 and wb == 0:
            return False
        elif wa > 0 and wb > 0:
            if constraint == -1: return False
            constraint = 1
        elif wa < 0 and wb < 0:
            if constraint == 1: return False
            constraint = -1
        elif wa <= 0 and wb >= 0:
            return False
    #~ print ""ok""
    return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1298,60,183,Python,0000000000051679,000000000014a391,0000000000146183,a1ex,2019
578,000000000014a13d.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    #~ print order
    constraint = 0
    for i in range(1, len(order)):
        ma = order[i]
        mb = order[i-1]
        wa = ma[0] - mb[0]
        wb = mb[1] - ma[1]
        #~ print wa, wb
        #~ if wa == 0 and wb == 0:
            #~ return False
        if wa > 0 and wb > 0:
            if constraint == -1: return False
            constraint = 1
        elif wa < 0 and wb < 0:
            if constraint == 1: return False
            constraint = -1
        elif wa <= 0 and wb >= 0:
            return False
    #~ print ""ok""
    return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1302,60,185,Python,0000000000051679,000000000014a13d,0000000000146183,a1ex,2019
579,000000000014975a.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(100):
            wc = random.randint(1, 1000000)
            wj = random.randint(1, 1000000)
            #~ print order, wc, wj
            prev = 0
            valid = True
            for molecule in order:
                w = weight(molecule, wc, wj)
                if w <= prev:
                    valid = False
                    break
                prev = w
            if valid:
                return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1180,54,140,Python,0000000000051679,000000000014975a,0000000000146183,a1ex,2019
580,000000000014968b.PYTHON,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for k in range(1000):
            wc = random.randint(1, 1000000)
            wj = random.randint(1, 1000000)
            #~ print order, wc, wj
            prev = 0
            valid = True
            for molecule in order:
                w = weight(molecule, wc, wj)
                if w <= prev:
                    valid = False
                    break
                prev = w
            if valid:
                return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1181,54,140,Python,0000000000051679,000000000014968b,0000000000146183,a1ex,2019
581,0000000000147643.PYTHON,"import os, sys
from collections import defaultdict
import itertools

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for wc in range(1,10) + [100]:
        for wj in range(1,10) + [100]:
            #~ print order, wc, wj
            prev = 0
            valid = True
            for molecule in order:
                w = weight(molecule, wc, wj)
                if w <= prev:
                    valid = False
                    break
                prev = w
            if valid:
                return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1127,52,138,Python,0000000000051679,0000000000147643,0000000000146183,a1ex,2019
582,0000000000147362.PYTHON,"import os, sys
from collections import defaultdict
import itertools

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def check(order):
    for wc in range(1,100):
        for wj in range(1,100):
            #~ print order, wc, wj
            prev = 0
            valid = True
            for molecule in order:
                w = weight(molecule, wc, wj)
                if w <= prev:
                    valid = False
                    break
                prev = w
            if valid:
                return True

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        if check(order):
            found += 1

    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1113,52,134,Python,0000000000051679,0000000000147362,0000000000146183,a1ex,2019
583,0000000000147250.PYTHON,"import os, sys
from collections import defaultdict
import itertools

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def weight(molecule, wc, wj):
    return wc * molecule[0] + wj * molecule[1]

def solve(C, J):
    N = len(C)

    found = 0
    for order in itertools.permutations(zip(C,J)):
        for wc,wj in [(1,1), (2,1), (1,2)]:
            #~ print order, wc, wj
            prev = 0
            valid = True
            for molecule in order:
                w = weight(molecule, wc, wj)
                if w <= prev:
                    valid = False
                    break
                prev = w
            if valid:
                found += 1
                break
    return found
                
T = readint()
for t in range(T):
    N = readint()
    C = []
    J = []
    for i in range(N):
        c,j = readlist()
        C.append(c)
        J.append(j)
    print(""Case #%d: %s"" % (t+1, solve(C, J)))
",,1050,47,127,Python,0000000000051679,0000000000147250,0000000000146183,a1ex,2019
584,00000000001406ef.PYPY2,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy
import random
import time

t0 = 0

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir in ""Hh"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir in ""Vv"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(EC, player):
    if len(EC) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    if time.time() - t0 > 10:
        return 0

    EC = empty_cells(M)
    depth = len(EC)
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(EC, player)
        #~ print ""=>"", score
        return score

    random.shuffle(EC)
    for i,j in EC:
        for dir in (""HV"" if player > 0 else ""hv""):
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
            else:
                score = -player
            M = M0

            if player > 0:
                best = max(best, score)
                if best > 0: break
            else:
                best = min(best, score)
                if best < 0: break
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    global t0
    t0 = time.time()
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,3089,138,399,Python,00000000000516b9,00000000001406ef,0000000000134cdf,a1ex,2019
585,000000000014066d.PYPY2,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy
import random
import time

t0 = 0

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir in ""Hh"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir in ""Vv"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(EC, player):
    if len(EC) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    if time.time() - t0 > 1:
        return 0

    EC = empty_cells(M)
    depth = len(EC)
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(EC, player)
        #~ print ""=>"", score
        return score

    random.shuffle(EC)
    for i,j in EC:
        for dir in (""HV"" if player > 0 else ""hv""):
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
            else:
                score = -player
            M = M0

            if player > 0:
                best = max(best, score)
                if best > 0: break
            else:
                best = min(best, score)
                if best < 0: break
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    global t0
    t0 = time.time()
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,3088,138,399,Python,00000000000516b9,000000000014066d,0000000000134cdf,a1ex,2019
586,000000000013fe9f.PYPY2,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir in ""Hh"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir in ""Vv"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(EC, player):
    if len(EC) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    EC = empty_cells(M)
    depth = len(EC)
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(EC, player)
        #~ print ""=>"", score
        return score

    random.shuffle(EC)
    for i,j in EC:
        for dir in (""HV"" if player > 0 else ""hv""):
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
            else:
                score = -player
            M = M0

            if player > 0:
                best = max(best, score)
                if best > 0: break
            else:
                best = min(best, score)
                if best < 0: break
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,2986,130,381,Python,00000000000516b9,000000000013fe9f,0000000000134cdf,a1ex,2019
587,000000000013fa7b.PYPY2,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir in ""Hh"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir in ""Vv"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(EC, player):
    if len(EC) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    EC = empty_cells(M)
    depth = len(EC)
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(EC, player)
        #~ print ""=>"", score
        return score

    for i,j in EC:
        for dir in (""HV"" if player > 0 else ""hv""):
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
            else:
                score = -player
            M = M0

            if player > 0:
                best = max(best, score)
                if best > 0: break
            else:
                best = min(best, score)
                if best < 0: break
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,2949,128,378,Python,00000000000516b9,000000000013fa7b,0000000000134cdf,a1ex,2019
588,000000000013f5dd.PYPY2,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir in ""Hh"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir in ""Vv"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(EC, player):
    if len(EC) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    EC = empty_cells(M)
    depth = len(EC)
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(EC, player)
        #~ print ""=>"", score
        return score

    for i,j in EC:
        for dir in (""HV"" if player > 0 else ""hv""):
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
            else:
                score = -player

            if player > 0:
                best = max(best, score)
                if best > 0: break
            else:
                best = min(best, score)
                if best < 0: break

            M = M0
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,2950,129,378,Python,00000000000516b9,000000000013f5dd,0000000000134cdf,a1ex,2019
589,000000000013f051.PYPY2,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir == ""H"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir == ""V"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(state, player):
    if len(empty_cells(state)) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    depth = len(empty_cells(M))
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(M, player)
        #~ print ""=>"", score
        return score

    for i,j in empty_cells(M):
        for dir in ""HV"":
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
                if player > 0:
                    best = max(best, score)
                    if best > 0: break
                else:
                    best = min(best, score)
                    if best < 0: break
            M = M0
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,2912,124,365,Python,00000000000516b9,000000000013f051,0000000000134cdf,a1ex,2019
590,000000000013e69a.PYTHON,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import copy, deepcopy

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir == ""H"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir == ""V"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(state, player):
    if len(empty_cells(state)) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    depth = len(empty_cells(M))
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(M, player)
        #~ print ""=>"", score
        return score

    for i,j in empty_cells(M):
        for dir in ""HV"":
            #~ M0 = deepcopy(M)
            M0 = [copy(m) for m in M]
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
                if player > 0:
                    best = max(best, score)
                else:
                    best = min(best, score)
            M = M0
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,2834,122,355,Python,00000000000516b9,000000000013e69a,0000000000134cdf,a1ex,2019
591,000000000013dbc8.PYTHON,"import os, sys
from collections import defaultdict, Counter
import itertools
from copy import deepcopy

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def can_place(M, i0, j0, dir):
    i, j = i0, j0
    #~ print(""place"", i0, j0, dir)
    if dir == ""H"":
        while j >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j -= 1
        j = j0+1
        while j < len(M[0]):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            j += 1
    elif dir == ""V"":
        while i >= 0:
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i -= 1
        i = i0+1
        while i < len(M):
            if M[i][j] == '.':
                M[i][j] = dir
            elif M[i][j] == ""#"":
                return False
            else: break
            i += 1
    else:
        assert 0
    return True

def empty_cells(state):
    cells = []
    for i, row in enumerate(state):
        for j, cell in enumerate(row):
            if cell == '.':
                cells.append((i,j))
    return cells

def evaluate(state, player):
    if len(empty_cells(state)) == 0:
        return player
    return 0

def minimax(M, player):
    if player > 0:
        best = -1e100
    else:
        best = 1e100

    depth = len(empty_cells(M))
    #~ print ""minimax %d %d"" % (depth, player)
    if depth == 0:
        #~ pr(M)
        score = evaluate(M, player)
        #~ print ""=>"", score
        return score

    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                score = minimax(M, -player)
                if player > 0:
                    best = max(best, score)
                else:
                    best = min(best, score)
            M = M0
    return best

def pr(M):
    for m in M:
        print """".join(m)
    print

def solve(M):
    #~ pr(M)
    winners = 0
    for i,j in empty_cells(M):
        for dir in ""HV"":
            M0 = deepcopy(M)
            if can_place(M,i,j,dir):
                #~ pr(M)
                if minimax(M, 1) > 0:
                    winners += 1
            M = M0
    return winners

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        row = [x for x in readstr()]
        assert len(row) == C
        M.append(row)
    assert len(M) == R
    print ""Case #%d: %s"" % (t+1, solve(M))
",,2787,121,346,Python,00000000000516b9,000000000013dbc8,0000000000134cdf,a1ex,2019
592,000000000013a2c9.PYTHON3,"import os, sys
from math import log2
from collections import defaultdict, Counter
import itertools

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def match(A, B):
    #~ print(""match:"", A, B)
    for i in range(len(A) * len(B)):
        a = A[i % len(A)]
        b = B[i % len(B)]
        #~ print(""?"",a,b)
        if a == ""P"":
            if b == ""R"": return A
            if b == ""S"": return B

        if a == ""R"":
            if b == ""S"": return A
            if b == ""P"": return B

        if a == ""S"":
            if b == ""P"": return A
            if b == ""R"": return B

    return ""?""

def matches(my, C):

    for c in C:
        if match(my, c) != my:
            return False

    return True

def moves():
    for x in ""RSP"":
        yield x

    for x in ""RSP"":
        for y in ""RSP"":
            yield x + y

    for x in ""RSP"":
      for y in ""RSP"":
        for z in ""RSP"":
            yield x + y + z

    for x in ""RSP"":
      for y in ""RSP"":
        for z in ""RSP"":
          for t in ""RSP"":
            yield x + y + z + t

    for x in ""RSP"":
      for y in ""RSP"":
        for z in ""RSP"":
          for t in ""RSP"":
            for q in ""RSP"":
              for r in ""RSP"":
                yield x + y + z + t + q + r

    for x in ""RSP"":
      for y in ""RSP"":
        for z in ""RSP"":
          for t in ""RSP"":
            for q in ""RSP"":
              for r in ""RSP"":
                for s in ""RSP"":
                  yield x + y + z + t + q + r + s

def solve(C):
    for x in moves():
        if matches(x, C): return x

    return ""IMPOSSIBLE""

T = readint()
for t in range(T):
    A = readint()
    C = []
    for i in range(A):
        C.append(readstr())
    assert len(C) == A
    print(""Case #%d: %s"" % (t+1, solve(C)))
",,1874,93,302,Python,00000000000516b9,000000000013a2c9,0000000000134c90,a1ex,2019
593,000000000013959b.PYTHON3,"import os, sys
from math import log2
from collections import defaultdict, Counter
import itertools

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def match(A, B, allow_draw):
    #~ print(""match:"", A, B)
    for i in range(len(A) * len(B)):
        a = A[i % len(A)]
        b = B[i % len(B)]
        #~ print(""?"",a,b)
        if a == ""P"":
            if b == ""R"": return A
            if b == ""S"": return B

        if a == ""R"":
            if b == ""S"": return A
            if b == ""P"": return B

        if a == ""S"":
            if b == ""P"": return A
            if b == ""R"": return B
    #~ print(""draw"")
    if allow_draw:
        return A
    else:
        return ""?""

def matches(C):
    
    while len(C) > 1:
        #~ print(""matches:"", C)
        D = []
        for i in range(0,len(C)-1,2):
            m = match(C[i], C[i+1], i > 0)
            #~ print(i, i+1, C[i], C[i+1], m)
            D.append(m)
        C = D
    return C[0]

def solve(C):
    for x in ""RSP"":
        if matches([x] + C) == x:
            return x
    return ""IMPOSSIBLE""

T = readint()
for t in range(T):
    A = readint()
    C = []
    for i in range(A):
        C.append(readstr())
    assert len(C) == A
    print(""Case #%d: %s"" % (t+1, solve(C)))
",,1367,64,192,Python,00000000000516b9,000000000013959b,0000000000134c90,a1ex,2019
594,0000000000135f8e.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T, F = readlist()
print >> sys.stderr, ""got"", T, F
for t in range(T):
    nums = defaultdict(int)
    inds = defaultdict(list)
    for i in range(119):
        print 1 + i * 5
        sys.stdout.flush()
        figure = readstr()
        nums[figure] += 1
        inds[figure].append(1 + i * 5)

    print >> sys.stderr, nums
    for ch in ""ABCDE"":
        if nums[ch] == 23:
            missing = ch
    print >> sys.stderr, ""missing"", missing, inds[missing]

    nums2 = defaultdict(int)
    inds2 = defaultdict(list)
    for i in range(23):
        print inds[missing][i] + 1
        sys.stdout.flush()
        figure = readstr()
        nums2[figure] += 1
        inds2[figure].append(inds[missing][i] + 1)

    print >> sys.stderr, nums2
    for ch in ""ABCDE"":
        if nums2[ch] == 5:
            missing2 = ch
    print >> sys.stderr, ""missing"", missing2, inds2[missing2]

    nums3 = defaultdict(int)
    inds3 = defaultdict(list)
    for i in range(5):
        print inds2[missing2][i] + 1
        sys.stdout.flush()
        figure = readstr()
        nums3[figure] += 1
        inds3[figure].append(inds2[missing2][i] + 1)

    print >> sys.stderr, nums3
    for ch in ""ABCDE"":
        if nums3[ch] == 1:
            missing3 = ch
    print >> sys.stderr, ""missing"", missing3, inds3[missing3]

    print inds3[missing3][0] + 1
    sys.stdout.flush()
    figure4 = readstr()

    print inds3[missing3][0] + 2
    sys.stdout.flush()
    figure5 = readstr()

    print >> sys.stderr, ""missing"", missing, missing2, missing3, figure4, figure5

    print missing + missing2 + missing3 + figure5 + figure4
    sys.stdout.flush()
    verdict = readstr()
    print >> sys.stderr, ""verdict: %s"" % verdict
    if verdict != 'Y':
        raise SystemExit
",,1987,76,229,Python,00000000000516b9,0000000000135f8e,0000000000134e91,a1ex,2019
595,0000000000126144.PYTHON,"import os, sys
from collections import defaultdict, Counter
import itertools

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(N, C, D, K):
    fair = 0
    #~ print C, D
    for i in range(N):
        for j in range(i+1, N+1):
            mc = max(C[i:j])
            md = max(D[i:j])
            if abs(mc - md) <= K:
                #~ print i, j, mc, md
                fair += 1
    return fair

T = readint()
for t in range(T):
    N, K = readlist()
    C = readlist()
    D = readlist()
    assert len(C) == N
    assert len(D) == N
    print ""Case #%d: %d"" % (t+1, solve(N, C, D, K))
",,725,34,105,Python,51706,0000000000126144,0000000000122838,a1ex,2019
596,000000000011138f.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    for p in set(next):
        if len(p) > l and cnt[p] > 1:
            #~ print p, cnt[p]
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            found = True
            yield p, wds

    assert w.startswith(prefix)
    wds = [w for w in words if not used[w]]
    #~ print wds
    if len(wds) >= 2:
        yield prefix, wds[:2]

def xsplit(prefix, words):
    #~ print ""xsplit"", prefix, words
    for k,w in split(prefix, words):
        if len(w) > 2:
            for k,w in xsplit(k, w):
                #~ print ""~>"", k, w
                yield k, w
        else:
            #~ print ""=>"", k, w
            yield k, w

def solve(W):
    c = 0
    for x,w in xsplit("""", W):
        #~ print ""?"", x, w
        if len(w) >= 2 and len(x) > 0:
            #~ print >> sys.stderr, x[::-1], [a[::-1] for a in w]
            c += 2
    assert c <= len(W)
    return c

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,1545,63,226,Python,51635,000000000011138f,0000000000104e05,a1ex,2019
597,0000000000110f46.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    for p in set(next):
        if len(p) > l and cnt[p] > 1:
            #~ print p, cnt[p]
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            found = True
            yield p, wds

    wds = [w for w in words if w.startswith(prefix) and not used[w]]
    #~ print wds
    if len(wds) >= 2:
        yield prefix, wds[:2]

def xsplit(prefix, words):
    #~ print ""xsplit"", prefix, words
    for k,w in split(prefix, words):
        if len(w) > 2:
            for k,w in xsplit(k, w):
                #~ print ""~>"", k, w
                yield k, w
        else:
            #~ print ""=>"", k, w
            yield k, w

def solve(W):
    c = 0
    for x,w in xsplit("""", W):
        #~ print ""?"", x, w
        if len(w) >= 2 and len(x) > 0:
            #~ print >> sys.stderr, x[::-1], [a[::-1] for a in w]
            c += 2
    assert c <= len(W)
    return c

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,1538,62,226,Python,51635,0000000000110f46,0000000000104e05,a1ex,2019
598,00000000001104e7.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    for p in set(next):
        if cnt[p] > 1:
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            found = True
            yield p, wds

    for p in set(next):
        if cnt[p] == 1:
            wds = [w for w in words if w.startswith(prefix) and not used[w]]
            yield prefix, wds[:2]
            return

def xsplit(prefix, words):
    #~ print ""xsplit"", prefix, words
    for k,w in split(prefix, words):
        if len(w) > 2:
            for k,w in xsplit(k, w):
                #~ print ""~>"", k, w
                yield k, w
        else:
            #~ print ""=>"", k, w
            yield k, w

def solve(W):
    c = 0
    for x,w in xsplit("""", W):
        #~ print ""?"", x, w
        if len(w) >= 2 and len(x) > 0:
            #~ print >> sys.stderr, x[::-1], [a[::-1] for a in w]
            c += 2
    assert c <= len(W)
    return c

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,1532,62,220,Python,51635,00000000001104e7,0000000000104e05,a1ex,2019
599,000000000010efd6.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    found = False
    for p in set(next):
        if cnt[p] > 1:
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            found = True
            yield p, wds

    if not found:
        for p in set(next):
            if cnt[p] == 1:
                wds = [w for w in words if w.startswith(prefix) and not used[w]]
                yield prefix, wds[:2]
                return

def xsplit(prefix, words):
    for k,w in split(prefix, words):
        if len(w) > 2:
            for k,w in xsplit(k, w):
                #~ print ""~>"", k, w
                yield k, w
        else:
            #~ print ""=>"", k, w
            yield k, w

def solve(W):
    c = 0
    for x,w in xsplit("""", W):
        #~ print ""?"", x, w
        if len(w) >= 2 and len(x) > 0:
            #~ print x
            c += 2
    return c
    groups = defaultdict(list)
    for w in W:
        groups[w[0]].append(w)

    modified = True
    while modified:
        modified = False
        #~ print "">>>""
        gi = [x for x in groups.iteritems()]
        #~ print gi
        for g,ws in gi:
            if len(ws) < 2:
                del groups[g]
                modified = True

            if len(ws) > 2:
                del groups[g]
                for k,w in split(g, ws):
                    groups[k] += w
                    #~ print ""->"", k, w
                modified = True

        #~ print groups

    gi = [x for x in groups.iteritems()]
    return len(gi) * 2

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,2128,88,288,Python,51635,000000000010efd6,0000000000104e05,a1ex,2019
600,000000000010de9c.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(M, r, c, k):
    R = len(M)
    C = len(M[0])
    M[r][c] = k
    if k == R*C:
        sol = """"
        for i in range(R*C):
            for rr in range(R):
                for cc in range(C):
                    if M[rr][cc] == i+1:
                        sol += ""%d %d\n"" % (rr+1, cc+1)
        return sol
    for i in range(R):
        for j in range(C):
            if i != r and j != c and r - c != i - j and r + c != i + j:
                #~ print r, c, i, j
                if M[i][j] == 0:
                    s = solve(M, i, j, k+1)
                    if s:
                        return s
    M[r][c] = 0
                

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        M.append([0] * C)
    for r in range(R):
        for c in range(C):
            sol = solve(M, r, c, 1)
            if sol: break
        if sol: break
    if sol: ans = ""POSSIBLE""
    else: ans = ""IMPOSSIBLE""
    print ""Case #%d: %s"" % (t+1, ans)
    if sol: print sol.strip()
",,1254,50,186,Python,51635,000000000010de9c,0000000000104e03,a1ex,2019
601,000000000010dd14.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(M, r, c, k):
    R = len(M)
    C = len(M[0])
    M[r][c] = k
    if k == R*C:
        sol = """"
        for i in range(R*C):
            for rr in range(R):
                for cc in range(C):
                    if M[rr][cc] == i:
                        sol += ""%d %d\n"" % (rr+1, cc+1)
        return sol
    for i in range(R):
        for j in range(C):
            if i != r and j != c and r - c != i - j and r + c != i + j:
                #~ print r, c, i, j
                if M[i][j] == 0:
                    s = solve(M, i, j, k+1)
                    if s:
                        return s
    M[r][c] = 0
                

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        M.append([0] * C)
    for r in range(R):
        for c in range(C):
            sol = solve(M, r, c, 1)
            if sol: break
        if sol: break
    if sol: ans = ""POSSIBLE""
    else: ans = ""IMPOSSIBLE""
    print ""Case #%d: %s"" % (t+1, ans)
    if sol: print sol.strip()
",,1252,50,186,Python,51635,000000000010dd14,0000000000104e03,a1ex,2019
602,000000000010da3d.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(M, r, c, k):
    R = len(M)
    C = len(M[0])
    M[r][c] = k
    if k == R*C:
        sol = """"
        for i in range(R*C):
            for rr in range(R):
                for cc in range(C):
                    if M[rr][cc] == i:
                        sol += ""%d %d\n"" % (rr+1, cc+1)
        return sol
    for i in range(R):
        for j in range(C):
            if i != r and j != c and r - c != i - j and r + c != i + j:
                #~ print r, c, i, j
                if M[i][j] == 0:
                    s = solve(M, i, j, k+1)
                    if s:
                        return s
    M[r][c] = 0
                

T = readint()
for t in range(T):
    R, C = readlist()
    M = []
    for i in range(R):
        M.append([0] * C)
    sol = solve(M, 0, 0, 1)
    if sol: ans = ""POSSIBLE""
    else: ans = ""IMPOSSIBLE""
    print ""Case #%d: %s"" % (t+1, ans)
    if sol: print sol.strip()
",,1146,46,172,Python,51635,000000000010da3d,0000000000104e03,a1ex,2019
603,000000000010a9b5.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T, N, M = readlist()
#~ print >> sys.stderr, ""got"", T, N, M
for t in range(T):
    G = 0
    for i in range(N):
        guess = [18] * 18
        print "" "".join([str(x) for x in guess])
        sys.stdout.flush()
        turns = readlist()
        #~ print >> sys.stderr, turns, sum(turns)
        G = max(G, sum(turns))

    print G
    sys.stdout.flush()
    verdict = readint()
    if verdict != 1:
        raise SystemExit
",,659,29,86,Python,51635,000000000010a9b5,0000000000104f1a,a1ex,2019
604,00000000001074e1.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    for p in set(next):
        if cnt[p] > 1:
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            yield p, wds

    for p in set(next):
        if cnt[p] == 1:
            wds = [w for w in words if w.startswith(prefix) and not used[w]]
            yield prefix, wds[:2]
            return

def xsplit(prefix, words):
    for k,w in split(prefix, words):
        if len(w) > 2:
            for k,w in xsplit(k, w):
                #~ print ""~>"", k, w
                yield k, w
        else:
            #~ print ""=>"", k, w
            yield k, w

def solve(W):
    c = 0
    for x,w in xsplit("""", W):
        #~ print ""?"", x, w
        if len(w) >= 2 and len(x) > 0:
            #~ print x
            c += 2
    return c
    groups = defaultdict(list)
    for w in W:
        groups[w[0]].append(w)

    modified = True
    while modified:
        modified = False
        #~ print "">>>""
        gi = [x for x in groups.iteritems()]
        #~ print gi
        for g,ws in gi:
            if len(ws) < 2:
                del groups[g]
                modified = True

            if len(ws) > 2:
                del groups[g]
                for k,w in split(g, ws):
                    groups[k] += w
                    #~ print ""->"", k, w
                modified = True

        #~ print groups

    gi = [x for x in groups.iteritems()]
    return len(gi) * 2

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,2047,85,279,Python,51635,00000000001074e1,0000000000104e05,a1ex,2019
605,0000000000106971.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    for p in set(next):
        if cnt[p] > 1:
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            yield p, wds

    for p in set(next):
        if cnt[p] == 1:
            wds = [w for w in words if w.startswith(prefix) and not used[w]]
            yield prefix, wds[:2]
            return
            
    

def solve(W):
    
    groups = defaultdict(list)
    for w in W:
        groups[w[0]].append(w)

    modified = True
    while modified:
        modified = False
        #~ print "">>>""
        gi = [x for x in groups.iteritems()]
        #~ print gi
        for g,ws in gi:
            if len(ws) < 2:
                del groups[g]
                modified = True

            if len(ws) > 2:
                del groups[g]
                for k,w in split(g, ws):
                    groups[k] += w
                    #~ print ""->"", k, w
                modified = True

        #~ print groups

    gi = [x for x in groups.iteritems()]
    return len(gi) * 2

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,1652,71,216,Python,51635,0000000000106971,0000000000104e05,a1ex,2019
606,000000000010602f.PYTHON,"import os, sys
from collections import defaultdict, Counter
def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def split(prefix, words):
    #~ print ""split"", prefix, words
    l = len(prefix)
    next = [ w[:l+1] for w in words ]
    cnt = Counter(next)
    #~ print ""next"", next
    used = defaultdict(bool)
    for p in set(next):
        if cnt[p] > 1:
            wds = [w for w in words if w.startswith(p)]
            for w in wds: used[w] = True
            yield p, wds

    for p in set(next):
        if cnt[p] == 1:
            pp = p[:-1]
            assert pp == prefix
            wds = [w for w in words if w.startswith(pp) and not used[w]]
            yield pp, wds[:2]
            return
            
    

def solve(W):
    
    groups = defaultdict(list)
    for w in W:
        groups[w[0]].append(w)

    modified = True
    while modified:
        modified = False
        #~ print "">>>""
        gi = [x for x in groups.iteritems()]
        #~ print gi
        for g,ws in gi:
            if len(ws) < 2:
                del groups[g]
                modified = True

            if len(ws) > 2:
                del groups[g]
                for k,w in split(g, ws):
                    groups[k] += w
                    #~ print ""->"", k, w
                modified = True

        #~ print groups

    gi = [x for x in groups.iteritems()]
    #~ print gi
    for g,ws in gi:
        assert len(ws) == 2
    return len(gi) * 2

T = readint()
for t in range(T):
    N = readint()
    W = []
    for i in range(N):
        w = readstr()
        W.append(w[::-1])
    #~ print W
    print ""Case #%d: %d"" % (t+1, solve(W))
",,1764,76,234,Python,51635,000000000010602f,0000000000104e05,a1ex,2019
607,00000000000f1b9d.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    for k in range(L-1):
        if C[k] != C[k+1]:
            break

    f = gcd(C[k], C[k+1])
    f0 = f

    F = set([f, C[k]//f])
    for i in range(1,L):
        #assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    #assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    try:
        sol = solve(N, L, C)
    except:
        sol = ""???""
    print(""Case #%d: %s"" % (t+1, sol))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,1050,56,158,Python,51705,00000000000f1b9d,000000000008830b,a1ex,2019
608,00000000000f192c.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    for k in range(L-1):
        if C[k] != C[k+1]:
            break

    f = gcd(C[k], C[k+1])
    f0 = f

    F = set([f, C[k]//f])
    for i in range(1,L):
        #assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    #assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    print(""Case #%d: %s"" % (t+1, solve(N, L, C)))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,991,52,150,Python,51705,00000000000f192c,000000000008830b,a1ex,2019
609,00000000000f10d4.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    for k in range(L-1):
        if C[k] != C[k+1]:
            break

    f = gcd(C[k], C[k+1])
    f0 = f

    F = set([f, C[0]//f])
    for i in range(1,L):
        #assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    #assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    print(""Case #%d: %s"" % (t+1, solve(N, L, C)))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,991,52,150,Python,51705,00000000000f10d4,000000000008830b,a1ex,2019
610,00000000000f115c.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    for k in range(L-1):
        if C[k] != C[k+1]:
            break

    f = gcd(C[k], C[k+1])
    f0 = f

    F = set([f, C[0]//f])
    for i in range(1,L):
        assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    #assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    print(""Case #%d: %s"" % (t+1, solve(N, L, C)))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,990,52,150,Python,51705,00000000000f115c,000000000008830b,a1ex,2019
611,00000000000f1035.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    for k in range(L-1):
        if C[k] != C[k+1]:
            break

    f = gcd(C[k], C[k+1])
    f0 = f

    F = set([f, C[0]//f])
    for i in range(1,L):
        assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    print(""Case #%d: %s"" % (t+1, solve(N, L, C)))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,989,52,150,Python,51705,00000000000f1035,000000000008830b,a1ex,2019
612,00000000000f0d9f.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    f = gcd(C[0], C[1])
    f0 = f

    F = set([f, C[0]//f])
    for i in range(1,L):
        assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    #assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    print(""Case #%d: %s"" % (t+1, solve(N, L, C)))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,917,48,141,Python,51705,00000000000f0d9f,000000000008830b,a1ex,2019
613,00000000000f0a82.PYTHON3,"import os, sys
from math import gcd

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N, L, C):
    f = gcd(C[0], C[1])
    f0 = f

    F = set([f, C[0]//f])
    for i in range(1,L):
        assert C[i] % f == 0
        f = C[i] // f
        F.add(f)

    assert len(F) == 26
    F = sorted(F)

    f = f0

    msg = chr(ord('A') + F.index(C[0]//f))
    msg += chr(ord('A') + F.index(f))
    for i in range(1,L):
        f = C[i] // f
        msg += chr(ord('A') + F.index(f))

    return msg
    
    
T = readint()
for t in range(T):
    N, L = readlist()
    C = readlist()
    print(""Case #%d: %s"" % (t+1, solve(N, L, C)))

if 0:
    from math import factorial
    a = factorial(469) - 1
    b = factorial(546) - 1
    c = factorial(872) + 1
    assert(gcd(a*b, b*c) == b)
    assert(gcd(b*a, a*c) == a)
    assert(gcd(a*c, c*b) == c)
",,916,48,141,Python,51705,00000000000f0a82,000000000008830b,a1ex,2019
614,00000000000e7b87.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def sim(M):
    RC = set([])
    r, c = 0, 0
    for m in M:
        R, C = r, c
        if m == ""E"":
            C += 1
        elif m == ""S"":
            R += 1
        else:
            assert False
        RC.add((r,c,R,C))
        r, c = R, C
    return RC

def check(forbidden, X):
    path = sim(X)
    if path & forbidden:
        return False
    return True

def solve(M):
    forbidden = sim(M)
    for i in range(N):
        trial = ""E"" * i + ""S"" * (N-1) + ""E"" * (N-1-i)
        if check(forbidden, trial):
            return trial
        trial = ""S"" * i + ""E"" * (N-1) + ""S"" * (N-1-i)
        if check(forbidden, trial):
            return trial
    pass

T = readint()
for t in range(T):
    N = readint()
    M = readstr()
    assert len(M) == 2*N - 2
    print ""Case #%d: %s"" % (t+1, solve(M))
",,998,50,149,Python,51705,00000000000e7b87,00000000000881da,a1ex,2019
615,00000000000e2e29.PYTHON,"import os, sys

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def solve(N):
    s = str(N)
    a = """"
    b = """"
    for c in s:
        if c == ""4"":
            a += ""2""
            b += ""2""
        else:
            a += c
            b += ""0""
    return int(a), int(b)

T = readint()
for t in range(T):
    N = readint()
    a, b = solve(N)
    print ""Case #%d: %d %d"" % (t+1, a, b)
",,456,27,73,Python,51705,00000000000e2e29,0000000000088231,a1ex,2019
616,0000000000288aea,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if t1 == t2: return False
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    A = {}
    for i in range(N):
        if i in A:
            #~ print i, ""already assigned""
            continue
        A[i] = 'C'
        Q = [i]
        k = 0
        V = {}
        while k < len(Q):
          c = Q[k]
          for j in range(N):
            if O[c][j] and j not in V:
              Q.append(j)
              a = 'C' if A[c] == 'J' else 'J'
              if j in A: assert A[j] == a
              A[j] = a
              V[j] = True
              #~ print j, A[j]
          k += 1

    sol = """"
    for i in range(N):
        sol += A[i]

    for i in range(N):
        for j in range(N):
            if i != j and O[i][j] and A[i] == A[j]:
                sol = ""IMPOSSIBLE""
                break

    print(""Case #%d: %s"" % (t+1, sol))
    #~ if t == 691: break
",0000000000288aea.PYTHON,1497,72,223,Python,000000000019fd27,0000000000288aea,000000000020bdf9,a1ex,2020
617,00000000002879a2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if t1 == t2: return False
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    A = {}
    for i in range(N):
        if i in A:
            #~ print i, ""already assigned""
            continue
        A[i] = 'C'
        Q = [i]
        k = 0
        while k < len(Q):
          c = Q[k]
          for j in range(N):
            if O[c][j] and j not in A:
              Q.append(j)
              A[j] = 'C' if A[c] == 'J' else 'J'
              #~ print j, A[j]
          k += 1

    sol = """"
    for i in range(N):
        sol += A[i]

    for i in range(N):
        for j in range(N):
            if i != j and O[i][j] and A[i] == A[j]:
                sol = ""IMPOSSIBLE""
                break

    print(""Case #%d: %s"" % (t+1, sol))
    #~ if t == 691: break
",00000000002879a2.PYTHON,1394,68,206,Python,000000000019fd27,00000000002879a2,000000000020bdf9,a1ex,2020
618,0000000000286b33,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if t1 == t2: return False
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    A = {}
    for i in range(N):
        if i in A:
            #~ print i, ""already assigned""
            continue
        A[i] = 'C';
        #~ print i, ""charles""
        for j in range(i+1, N):
          if O[i][j]:
            #~ print j, ""jane""
            A[j] = 'J'
            for k in range(i+1, N):
              if O[j][k]:
                #~ print k, ""charles!""
                A[k] = 'C'
                for l in range(i+1, N):
                  if O[k][l]:
                    #~ print l, ""jane!""
                    A[l] = 'J'

    sol = """"
    for i in range(N):
        sol += A[i]

    for i in range(N):
        for j in range(N):
            if i != j and O[i][j] and A[i] == A[j]:
                sol = ""IMPOSSIBLE""
                break

    print(""Case #%d: %s"" % (t+1, sol))
    #~ if t == 691: break
",0000000000286b33.PYTHON,1536,71,211,Python,000000000019fd27,0000000000286b33,000000000020bdf9,a1ex,2020
619,00000000002835a9,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    A = {}
    for i in range(N):
        if i in A:
            continue
        A[i] = 'C';
        for j in range(i+1, N):
            if O[i][j]:
                assert j not in A or A[j] == 'J'
                A[j] = 'J'

    sol = """"
    for i in range(N):
        sol += A[i]

    for i in range(N):
        for j in range(N):
            if i != j and O[i][j] and A[i] == A[j]:
                sol = ""IMPOSSIBLE""
                break

    print(""Case #%d: %s"" % (t+1, sol))
",00000000002835a9.PYTHON,1162,59,167,Python,000000000019fd27,00000000002835a9,000000000020bdf9,a1ex,2020
620,000000000028333b,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    for x in range(1 << N):
        A = [""J"" if x & (1<<(N-i-1)) else ""C"" for i in range(N)]
        sol = """".join(A)

        for i in range(N):
            for j in range(N):
                if i != j and O[i][j] and A[i] == A[j]:
                    sol = ""IMPOSSIBLE""
                    break

        if sol != ""IMPOSSIBLE"":
            break

    print(""Case #%d: %s"" % (t+1, sol))
",000000000028333b.PYTHON,1068,52,150,Python,000000000019fd27,000000000028333b,000000000020bdf9,a1ex,2020
621,000000000028040c,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    A = {}
    for i in range(N):
        if i in A:
            continue
        A[i] = 'C';
        for j in range(i+1, N):
            if O[i][j]:
                A[j] = 'J'

    sol = """"
    for i in range(N):
        sol += A[i]

    for i in range(N):
        for j in range(N):
            if i != j and O[i][j] and A[i] == A[j]:
                sol = ""IMPOSSIBLE""
                break

    print(""Case #%d: %s"" % (t+1, sol))
",000000000028040c.PYTHON,1113,58,158,Python,000000000019fd27,000000000028040c,000000000020bdf9,a1ex,2020
622,000000000027f890,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    for x in range(1 << N):
        A = [""C"" if x & (1<<i) else ""J"" for i in range(N)]
        sol = """".join(A)

        for i in range(N):
            for j in range(N):
                if i != j and O[i][j] and A[i] == A[j]:
                    sol = ""IMPOSSIBLE""
                    break

        if sol != ""IMPOSSIBLE"":
            break

    print(""Case #%d: %s"" % (t+1, sol))
",000000000027f890.PYTHON,1062,52,150,Python,000000000019fd27,000000000027f890,000000000020bdf9,a1ex,2020
623,000000000027dbb2,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def overlaps(t1, t2):
    s1, e1 = t1
    s2, e2 = t2
    assert s1 < e1
    assert s2 < e2
    if e1 <= s2: return False
    if e2 <= s1: return False
    return True

T = readint()
for t in range(T):
    N = readint()
    T = []
    for i in range(N):
        T.append(readlist())

    O = []
    for i in range(N):
        o = []
        for j in range(N):
            o.append(overlaps(T[i], T[j]))
        O.append(o)

    A = {}
    for i in range(N):
        if i in A:
            continue
        A[i] = 'C';
        for j in range(i+1, N):
            if O[i][j]:
                A[j] = 'J'

    sol = """"
    for i in range(N):
        sol += A[i]

    for i in range(N):
        for j in range(i+1,N):
            if O[i][j] and A[i] == A[j]:
                sol = ""IMPOSSIBLE""
                break

    print(""Case #%d: %s"" % (t+1, sol))
",000000000027dbb2.PYTHON,1106,58,154,Python,000000000019fd27,000000000027dbb2,000000000020bdf9,a1ex,2020
624,000000000026a550,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

 
T = readint()
for t in range(T):
    S = readstr()
    level = 0
    sol = """"
    for c in S:
        while level < int(c):
            sol += ""(""
            level += 1
        while level > int(c):
            sol += "")""
            level -= 1
        sol += c
    while level > 0:
        sol += "")""
        level -= 1
    
    print(""Case #%d: %s"" % (t+1, sol))
",000000000026a550.PYTHON,623,34,86,Python,000000000019fd27,000000000026a550,0000000000209a9f,a1ex,2020
625,000000000026a2d3,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

 
T = readint()
for t in range(T):
    S = readstr()
    print S
    level = 0
    sol = """"
    for c in S:
        while level < int(c):
            sol += ""(""
            level += 1
        while level > int(c):
            sol += "")""
            level -= 1
        sol += c
    while level > 0:
        sol += "")""
        level -= 1
    
    print(""Case #%d: %s"" % (t+1, sol))
",000000000026a2d3.PYTHON,635,35,88,Python,000000000019fd27,000000000026a2d3,0000000000209a9f,a1ex,2020
626,00000000002694f3,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

 
T = readint()
for t in range(T):
    N = readint()
    M = []
    MT = []
    for i in range(N):
        MT.append([])
    T = 0
    R = 0
    C = 0
    for i in range(N):
        row = readlist()
        M.append(row)
        T += row[i]
        for j in range(N):
            MT[j].append(row[j])
    for row in M:
        if len(set(row)) < N:
            R += 1
    for col in MT:
        if len(set(col)) < N:
            C += 1
    
    print(""Case #%d: %d %d %d"" % (t+1, T, R, C))
",00000000002694f3.PYTHON,745,40,105,Python,000000000019fd27,00000000002694f3,000000000020993c,a1ex,2020
627,0000000000301df4,"import os, sys
import random
#~ from collections import defaultdict, Counter

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve():
    X = []
    Y = []
    O = []
    attempts = 0
    #~ right_margin, left_margin, top_margin, bot_margin = (0, 0, 0, 0)

    # first, try to hit something (anything!)
    hits = 0
    massX = 0
    massY = 0
    while hits < 20:
        x = random.randint(-1000000000, 1000000001)
        y = random.randint(-1000000000, 1000000001)
        attempts += 1
        print x, y
        sys.stdout.flush()
        o = readstr()
        print >> sys.stderr, ""guess"", x, y, o, ""mass"", massX, massY, ""hits"", hits
        if o == ""CENTER"":
            return
        elif o == ""HIT"":
            massX += x
            massY += y
            hits += 1
        elif o == ""MISS"":
            pass
        else:
            assert False

    massX /= 20
    massY /= 20
    print >> sys.stderr, ""att"", attempts
    #~ print >> sys.stderr, ""mass"", massX, massY

    print massX, massY
    sys.stdout.flush()
    attempts += 1
    o = readstr()
    print >> sys.stderr, ""inside"", massX, massY, o
    assert o == ""HIT""

    # right
    lo = massX - 1
    hi = 1000000001
    while lo+1 < hi:
        m = (lo+hi)/2
        #~ print >> sys.stderr, m, 0
        print m, massY
        sys.stdout.flush()
        attempts += 1
        o = readstr()
        print >> sys.stderr, ""right"", m, massY, o, ""interval"", lo, hi
        if o == ""CENTER"":
            return
        elif o == ""HIT"":
            right_margin = m
            lo = m
        elif o == ""MISS"":
            hi = m
        else:
            assert False

    print >> sys.stderr, ""att"", attempts

    # left
    lo = -massX - 1
    hi = 1000000001
    while lo+1 < hi:
        m = (lo+hi)/2
        #~ print >> sys.stderr, -m, 0
        print -m, massY
        sys.stdout.flush()
        attempts += 1
        o = readstr()
        print >> sys.stderr, ""left"", -m, massY, o, ""interval"", lo, hi
        if o == ""CENTER"":
            return
        elif o == ""HIT"":
            lo = m
            left_margin = -m
        elif o == ""MISS"":
            hi = m
        else:
            assert False
    print >> sys.stderr, ""att"", attempts

    # top
    lo = massY - 1
    hi = 1000000001
    while lo+1 < hi:
        m = (lo+hi)/2
        #~ print >> sys.stderr, m, 0
        print massX, m
        sys.stdout.flush()
        attempts += 1
        o = readstr()
        print >> sys.stderr, ""top"", massX, m, o, ""interval"", lo, hi
        if o == ""CENTER"":
            return
        elif o == ""HIT"":
            top_margin = m
            lo = m
        elif o == ""MISS"":
            hi = m
        else:
            assert False

    # bottom
    lo = -massY - 1
    hi = 1000000001
    while lo+1 < hi:
        m = (lo+hi)/2
        #~ print >> sys.stderr, m, 0
        print massX, -m
        sys.stdout.flush()
        attempts += 1
        o = readstr()
        print >> sys.stderr, ""bottom"", massX, -m, o, ""interval"", lo, hi
        if o == ""CENTER"":
            return
        elif o == ""HIT"":
            bot_margin = -m
            lo = m
        elif o == ""MISS"":
            hi = m
        else:
            assert False

    print >> sys.stderr, ""att"", attempts
    print >> sys.stderr, ""margins"", left_margin, right_margin, top_margin, bot_margin

    cenX = (right_margin + left_margin) / 2
    cenY = (top_margin + bot_margin) / 2

    print cenX, cenY
    sys.stdout.flush()
    o = readstr()
    print >> sys.stderr, ""trying center"", cenX, cenY, o
    if o == ""CENTER"": return

    for dx in range(-1, 1+1):
      for dy in range(-1, 1+1):
        print cenX + dx, cenY + dy
        sys.stdout.flush()
        o = readstr()
        print >> sys.stderr, ""trying"", dx, dy, ""i.e."", cenX + dx, cenY + dy, o
        if o == ""CENTER"": return

sys.stdout.flush()
T, A, B = readlist()
print >> sys.stderr, ""T:"", T, ""A:"", A, ""B:"", B
for t in range(T):
    solve()
",0000000000301df4.PYTHON,4084,168,555,Python,000000000019fef2,0000000000301df4,00000000002d5b63,a1ex,2020
628,00000000002f9303,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def sim(N, d, s):
  sol = """"
  X = 0
  Y = 0
  for i in range(N):
    if d & (1<<i):  # N or S
      if s & (1 << i):
        sol += ""N""
        Y += (1<<i)
      else:
        sol += ""S""
        Y -= (1<<i)
    else: # E or W
      if s & (1 << i):
        sol += ""E""
        X += (1<<i)
      else:
        sol += ""W""
        X -= (1<<i)
  return X, Y, sol

def solve(X, Y):
    sol = ""IMPOSSIBLE""
    for N in range(9):
      for d in range(2**N):
        for s in range(2**N):
           x, y, sl = sim(N, d, s)
           if x == X and y == Y:
             return sl
    return sol

T = readint()
for t in range(T):
    X, Y = readlist()
    print(""Case #%d: %s"" % (t+1, solve(X, Y)))
",00000000002f9303.PYTHON,945,50,154,Python,000000000019fef2,00000000002f9303,00000000002d5b62,a1ex,2020
629,00000000002f92e6,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def sim(N, d, s):
  sol = """"
  X = 0
  Y = 0
  for i in range(N):
    if d & (1<<i):  # N or S
      if s & (1 << i):
        sol += ""N""
        Y += (1<<i)
      else:
        sol += ""S""
        Y -= (1<<i)
    else: # E or W
      if s & (1 << i):
        sol += ""E""
        X += (1<<i)
      else:
        sol += ""W""
        X -= (1<<i)
  return X, Y, sol

def solve(X, Y):
    sol = ""IMPOSSIBLE""
    for N in range(10):
      for d in range(2**N):
        for s in range(2**N):
           x, y, sl = sim(N, d, s)
           if x == X and y == Y:
             return sl
    return sol

T = readint()
for t in range(T):
    X, Y = readlist()
    print(""Case #%d: %s"" % (t+1, solve(X, Y)))
",00000000002f92e6.PYTHON,946,50,154,Python,000000000019fef2,00000000002f92e6,00000000002d5b62,a1ex,2020
630,000000000033ed83,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    C, D = readlist()
    X = readlist()
    E = []
    V = defaultdict(list)
    for i in range(D):
        u,v = readlist()
        V[u].append(v)
        V[v].append(u)
        E.append((u,v))

    sol = [0] * C
    X = [-x for x in X]
    X = [0] + X
    #~ print X

    Q = [1]
    i = 0
    while i < len(Q):
        c = Q[i]
        for j,(u,v) in enumerate(E):
            if u == c or v == c:
                x = u if c == v else v
                t = X[x-1]
                if t == i+1:
                    #~ print x, t, j
                    sol[j] = 1
                    Q.append(x)
                #~ else:
                    #~ sol[j] = max(i+1, sol[j])
        i += 1
    sol = [x if x > 0 else C for x in sol]

    #~ print sol
    print(""Case #%d: %s"" % (t+1, "" "".join([str(x) for x in sol])))
",000000000033ed83.PYTHON,1102,51,164,Python,000000000019ffb9,000000000033ed83,000000000033871f,a1ex,2020
631,000000000033e809,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

T = readint()
for t in range(T):
    C, D = readlist()
    X = readlist()
    E = []
    V = defaultdict(list)
    for i in range(D):
        u,v = readlist()
        V[u].append(v)
        V[v].append(u)
        E.append((u,v))

    sol = [0] * C
    X = [-x for x in X]
    X = [0] + X
    #~ print X

    Q = [1]
    i = 0
    while i < len(Q):
        c = Q[i]
        for j,(u,v) in enumerate(E):
            if u == c or v == c:
                x = u if c == v else v
                t = X[x-1]
                if t == i+1:
                    #~ print x, t, j
                    sol[j] = 1 << (i+1)
                    Q.append(x)
        i += 1
    sol = [x if x > 0 else 1<<i for x in sol]

    #~ print sol
    print(""Case #%d: %s"" % (t+1, "" "".join([str(x) for x in sol])))
",000000000033e809.PYTHON,1040,49,159,Python,000000000019ffb9,000000000033e809,000000000033871f,a1ex,2020
632,000000000033ce2a,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def num(i,j):
    return j * (j+1) / 2 - i * (i+1) / 2

def num_e(i,j):
    return 2 * num(i/2,j/2)

def num_o(i,j):
    return num(i,j) - num_e(i,j)

def next_i(d, i0):
    lo = 0
    hi = 1000000000
    while lo < hi-1:
        m = (lo+hi)/2
        if num(i0, m) > d:
            hi = m
        else:
            lo = m
    return lo

def next_ip(d, i0):
    lo = 0
    hi = 1000000000
    while lo < hi-2:
        m = (lo+hi)/2
        m = (m/2)*2
        if num_o(i0, m) > d or num_e(i0, m) > d:
            hi = m
        else:
            lo = m
    return lo

def solve(L, R):
    n = 0
    i = 0

    if L > R:
        #~ print L - R + 1, ""?"", i
        i2 = next_i(L - R + 1, i)
        L -= num(i, i2)
        #~ print i, i2, num(i, i2), ""left"", L, R
        i = i2

    elif R > L:
        #~ print R - L, ""??"", i
        i2 = next_i(R - L, i)
        R -= num(i, i2)
        #~ print i, i2, num(i, i2), ""left"", L, R
        i = i2

    #~ print i, ""!""
    m = min(R,L) - 10000
    if m > 10:

        if i % 2:
            i += 1
            if R > L:
                R -= i
            else:
                L -= i

        #~ print ""alt"", m, i, L, R
        i3 = next_ip(m, i)
        i3 = i3/2*2 - 1
        #~ print i3
        if L >= R:
          #~ print ""Lfirst""
          L -= num_o(i, i3)
          R -= num_e(i, i3)
        else:
          #~ print ""Rfirst""
          R -= num_o(i, i3)
          L -= num_e(i, i3)
        
        i = i3

    #~ print i, L, R
    while i+1 <= max(L,R):
        i += 1
        if R > L:
            R -= i
            #~ print i, ""R"", L, R
        else:
            L -= i
            #~ print i, ""L"", L, R
    return i, L, R

T = readint()
for t in range(T):
    L, R = readlist()
    n, l, r = solve(L, R)
    print(""Case #%d: %d %d %d"" % (t+1, n, l, r))
",000000000033ce2a.PYPY2,2068,107,346,Python,000000000019ffb9,000000000033ce2a,00000000003384ea,a1ex,2020
633,000000000033c973,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def num(i,j):
    return j * (j+1) / 2 - i * (i+1) / 2

def num_e(i,j):
    return 2 * num(i/2,j/2)

def num_o(i,j):
    return num(i,j) - num_e(i,j)

def next_i(d, i0):
    lo = 0
    hi = 1000000000
    while lo < hi-1:
        m = (lo+hi)/2
        if num(i0, m) > d:
            hi = m
        else:
            lo = m
    return lo

def next_ip(d, i0):
    lo = 0
    hi = 1000000000
    while lo < hi-2:
        m = (lo+hi)/2
        m = (m/2)*2
        if num_o(i0, m) > d or num_e(i0, m) > d:
            hi = m
        else:
            lo = m
    return lo

def solve(L, R):
    n = 0
    i = 0

    if L > R:
        #~ print L - R + 1, ""?"", i
        i2 = next_i(L - R + 1, i)
        L -= num(i, i2)
        #~ print i, i2, num(i, i2), ""left"", L, R
        i = i2

    elif R > L:
        #~ print R - L, ""??"", i
        i2 = next_i(R - L, i)
        R -= num(i, i2)
        #~ print i, i2, num(i, i2), ""left"", L, R
        i = i2

    if i % 2:
        i += 1
        if R > L:
            R -= i
        else:
            L -= i

    #~ print i, ""!""
    if 1:
        m = min(R,L) - 10000
        #~ print ""alt"", m, i, L, R
        i3 = next_ip(m, i)
        i3 = i3/2*2 - 1
        #~ print i3
        if L >= R:
          #~ print ""Lfirst""
          L -= num_o(i, i3)
          R -= num_e(i, i3)
        else:
          #~ print ""Rfirst""
          R -= num_o(i, i3)
          L -= num_e(i, i3)
        
        i = i3
        #~ print i, L, R

    while i <= max(L,R):
        i += 1
        if R > L:
            R -= i
            #~ print i, ""R"", L, R
        else:
            L -= i
            #~ print i, ""L"", L, R
    return i, L, R

T = readint()
for t in range(T):
    L, R = readlist()
    n, l, r = solve(L, R)
    print(""Case #%d: %d %d %d"" % (t+1, n, l, r))
",000000000033c973.PYPY2,2044,106,344,Python,000000000019ffb9,000000000033c973,00000000003384ea,a1ex,2020
634,0000000000339c2b,"import os, sys
from collections import defaultdict
import itertools
import random

def readlist():
    return [int(x) for x in sys.stdin.readline().split()]

def readint():
    return readlist()[0]

def readstr():
    return sys.stdin.readline().strip()

def solve(L, R):
    n = 0
    i = 1
    while i <= max(L,R):
        n += 1
        if R > L:
            R -= i
            #~ print ""R""
        else:
            L -= i
            #~ print ""L""
        i += 1
    return n, L, R

T = readint()
for t in range(T):
    L, R = readlist()
    n, l, r = solve(L, R)
    print(""Case #%d: %d %d %d"" % (t+1, n, l, r))
",0000000000339c2b.PYPY2,617,34,94,Python,000000000019ffb9,0000000000339c2b,00000000003384ea,a1ex,2020
635,A.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 
 class Solver(object):
 
     @classmethod
     def setup(cls, infile):
         cls.data = {}
 
     def __init__(self, infile, tc):
         self.tc = tc
         self.I = I = map(int, infile.next().split())
 
     def solve(self):
         JJ = J = self.I[1:]
         X = float(sum(J))
         win = []
         lw = -1
         while len(win) > lw:
             lw = len(win)
             win.extend([j for j in J if j > ((X + sum(J)) / len(J))])
             J = [j for j in J if j <= ((X + sum(J)) / len(J))]
         res = dict((w,0.) for w in win)
         for j in J:
             res[j] = ((X + sum(J)) / len(J) - j) / X * 100.
         return 'Case #%s: %s\n' % (self.tc, ' '.join('%f' % res[j] for j in JJ))
 
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     Solver.setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(Solver(sys.stdin, t).solve())
",gcj/2012/1836486/alexamici/1480487/1/extracted/A.py,960,37,135,Python,1836486,1,1480487,alexamici,2012
636,C.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 
 class Solver(object):
 
     @classmethod
     def setup(cls, infile):
         cls.data = {}
 
     def __init__(self, infile, tc):
         self.tc = tc
         self.I = I = map(int, infile.next().split())
 
     def solve(self):
         import itertools as it
         S = self.I[1:]
         seen = {}
         for n in xrange(1,4):
             for s in it.combinations(S, n):
                 ss = sum(s)
                 if ss in seen:
                     return 'Case #%s:\n%s\n%s\n' % (self.tc, ' '.join('%d' %i for i in s), ' '.join('%d' %i for i in seen[ss]),)
                 seen[ss] = s
         return 'Case #%s: Impossible\n' % (self.tc,)
 
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     Solver.setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(Solver(sys.stdin, t).solve())
",gcj/2012/1836486/alexamici/1484496/1/extracted/C.py,898,35,102,Python,1836486,1,1484496,alexamici,2012
637,C.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 
 class Solver(object):
 
     @classmethod
     def setup(cls, infile):
         cls.data = {}
 
     def __init__(self, infile, tc):
         self.tc = tc
         self.I = I = map(int, infile.next().split())
 
     def solve(self):
         import itertools as it
         S = self.I[1:]
         seen = {}
         for n in xrange(1,20):
             for s in it.combinations(S, n):
                 ss = sum(s)
                 if ss in seen:
                     return 'Case #%s:\n%s\n%s\n' % (self.tc, ' '.join('%d' %i for i in s), ' '.join('%d' %i for i in seen[ss]),)
                 seen[ss] = s
         return 'Case #%s: Impossible\n' % (self.tc,)
 
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     Solver.setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(Solver(sys.stdin, t).solve())
",gcj/2012/1836486/alexamici/1484496/0/extracted/C.py,899,35,102,Python,1836486,0,1484496,alexamici,2012
638,B.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 import sys
 
 
 class Solver(object):
     cache = {}
 
     def __init__(self, infile, testcase):
         self.testcase = testcase
         self.P = P = map(int, infile.next().split())
 
     def init_cache(self):
         if 'main' in self.cache:
             return
         #self.cache['main'] = res
 
     def solve(self):
 
         N, S, p = self.P[:3]
         G = sorted(self.P[3:], reverse=True)
 
         r = 0
         s = 0
         for g in G:
             if g >= 3 * p - 2 and g >= p:
                 r += 1
             elif g >= 3 * p - 4 and g >= p:
                 if s == S:
                     break
                 r += 1
                 s += 1
 
         return r
 
 
 def main():
     T = int(sys.stdin.next())
     for t in xrange(T):
         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))
 
 
 if __name__ == '__main__':
     main()
",gcj/2012/1460488/alexamici/1595491/1/extracted/B.py,939,47,121,Python,1460488,1,1595491,alexamici,2012
639,C.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 import sys
 
 
 class Solver(object):
     cache = {}
 
     def __init__(self, infile, testcase):
         self.testcase = testcase
         #self.N = N = int(infile.next())
         #self.P = P = map(int, infile.next().split())
         self.I = I = map(int, infile.next().split())
         #self.T = T = infile.next().split()
         #self.S = S = [infile.next().strip() for i in range(N)]
 
         #self.init_cache()
 
     def init_cache(self):
         if 'main' in self.cache:
             return
         #self.cache['main'] = res
 
     def solve(self):
         #import collections as co
         #import functools as ft
         #import itertools as it
         #import operator as op
         #import math as ma
         #import re
         #import numpy as np
         #import scipy as sp
 
         #N = self.N
         #N, M = self.P
         I = self.I
         #T = self.T
         #S = self.S
         l = len(str(I[0]))
 
         r = 0
         for i in xrange(I[0], I[1]):
             ii = str(i)
             rr = set()
             for j in xrange(1, l):
                 if  i < int(ii[j:]+ii[:j]) <= I[1]:
                     rr.add(ii[j:]+ii[:j])
             r += len(rr)
 
         return r
 
 
 def main():
     T = int(sys.stdin.next())
     for t in xrange(T):
         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))
 
 
 if __name__ == '__main__':
     main()
",gcj/2012/1460488/alexamici/1483488/1/extracted/C.py,1468,63,168,Python,1460488,1,1483488,alexamici,2012
640,A.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 import sys
 
 ins = """"""ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jvqz
 """"""
 
 outs = """"""our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give upzq
 """"""
 
 class Solver(object):
     cache = {}
 
     def __init__(self, infile, testcase):
         self.testcase = testcase
         self.S = S = infile.next().strip()
 
         self.init_cache()
 
     def init_cache(self):
         if 'main' in self.cache:
             return
         t = {}
         for i in xrange(len(ins)):
             t[ins[i]] = outs[i]
         print t
         self.cache['main'] = t
 
     def solve(self):
 
         S = self.S
         
 
         return ''.join(self.cache['main'][c] for c in list(S))
 
 
 def main():
     T = int(sys.stdin.next())
     for t in xrange(T):
         sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))
 
 
 if __name__ == '__main__':
     main()
",gcj/2012/1460488/alexamici/1483485/0/extracted/A.py,1086,51,135,Python,1460488,0,1483485,alexamici,2012
641,A.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     #P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpypy as np
     #import scipy as sp
     #import networkx as nx
 
     name, n = T[0], int(T[1])
 
     N = []
     c = 0
     for i, l in enumerate(name):
         if l not in 'aeiou':
             c += 1
             if c >= n:
                 N.append(i)
         else:
             c = 0
     res = 0
     for i in range(len(name)):
         for j in range(i+n-1, len(name)):
             for k in range(i+n-1,j+1):
                 if k in N:
                     res += 1
                     break
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2437488/alexamici/2751486/0/extracted/A.py,1441,56,177,Python,2437488,0,2751486,alexamici,2013
642,B.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 # modified from http://code.activestate.com/recipes/117228/
 # Priority dictionary using binary heaps
 # David Eppstein, UC Irvine, 8 Mar 2002
 import heapq as hq
 class priorityDictionary(dict):
     def __init__(self):
         self.__heap = []
         dict.__init__(self)
     def smallest(self):
         heap = self.__heap
         while heap[0][1] not in self or self[heap[0][1]] != heap[0][0]:
             hq.heappop(heap)
         return heap[0][1]
     def __iter__(self):
         def iterfn():
             while len(self) > 0:
                 x = self.smallest()
                 yield x
                 del self[x]
         return iterfn()
     def __setitem__(self,key,val):
         dict.__setitem__(self,key,val)
         heap = self.__heap
         if len(heap) > 2 * len(self):
             self.__heap = [(v,k) for k,v in self.iteritems()]
             hq.heapify(self.__heap)
         else:
             hq.heappush(heap, (val,key))
 
 # adapted from http://code.activestate.com/recipes/119466/ (r1)
 # Dijkstra's algorithm for shortest paths
 # David Eppstein, UC Irvine, 4 April 2002
 def Dijkstra(G,start,end=None):
     """"""
     Find shortest paths from the start vertex to all
     vertices nearer than or equal to the end.
 
     The input graph G is assumed to have the following
     representation: A vertex can be any object that can
     be used as an index into a dictionary.  G is a
     dictionary, indexed by vertices.  For any vertex v,
     G[v] is itself a dictionary, indexed by the neighbors
     of v.  For any edge v->w, G[v][w] is the length of
     the edge.  This is related to the representation in
     <http://www.python.org/doc/essays/graphs.html>
     where Guido van Rossum suggests representing graphs
     as dictionaries mapping vertices to lists of neighbors,
     however dictionaries of edges have many advantages
     over lists: they can store extra information (here,
     the lengths), they support fast existence tests,
     and they allow easy modification of the graph by edge
     insertion and removal.  Such modifications are not
     needed here but are important in other graph algorithms.
     Since dictionaries obey iterator protocol, a graph
     represented as described here could be handed without
     modification to an algorithm using Guido's representation.
 
     Of course, G and G[v] need not be Python dict objects;
     they can be any other object that obeys dict protocol,
     for instance a wrapper in which vertices are URLs
     and a call to G[v] loads the web page and finds its links.
     
     The output is a pair (D,P) where D[v] is the distance
     from start to v and P[v] is the predecessor of v along
     the shortest path from s to v.
     
     Dijkstra's algorithm is only guaranteed to work correctly
     when all edge lengths are positive. This code does not
     verify this property for all edges (only the edges seen
     before the end vertex is reached), but will correctly
     compute shortest paths even for some graphs with negative
     edges, and will raise an exception if it discovers that
     a negative edge has caused it to make a mistake.
     """"""
 
     D = {}  # dictionary of final distances
     P = {}  # dictionary of predecessors
     Q = priorityDictionary()   # est.dist. of non-final vert.
     Q[start] = 0
     
     for v in Q:
         D[v] = Q[v]
         if v == end: break
         
         for w in G[v]:
             wLength = D[v] + G[v][w]
             if w in D:
                 if wLength < D[w]:
                     raise ValueError, ""Dijkstra: found better path to already-final vertex""
             elif w not in Q or wLength < Q[w]:
                 Q[w] = wLength
                 P[w] = v
     
     return (D,P)
             
 def shortestPath(G,start,end):
     """"""
     Find a single shortest path from the given start vertex
     to the given end vertex.
     The input has the same conventions as Dijkstra().
     The output is a list of the vertices in order along
     the shortest path.
     """"""
 
     D,P = Dijkstra(G,start,end)
     Path = []
     while 1:
         Path.append(end)
         if end == start: break
         end = P[end]
     Path.reverse()
     return Path
 ## end of http://code.activestate.com/recipes/119466/ }}}
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     #P = map(int, infile.next().split())
     I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpypy as np
     #import scipy as sp
     #import networkx as nx
 
     end = tuple(I)
 
     start = (0, 0)
     D = {}  # dictionary of final distances
     P = {}  # dictionary of predecessors
     Q = priorityDictionary()   # est.dist. of non-final vert.
     Q[start+('K',)] = 1
     
     for v in Q:
         #print v, Q[v]
         D[v] = Q[v]
         if v[:2] == end: break
         
         G = {v: [(-1,0,'W'), (+1,0,'E'),(0,-1,'S'),(0,+1,'N')]}
         for i, d in enumerate(G[v]):
             G[v][i] = (Q[v] * d[0] + v[0], Q[v] * d[1] + v[1], d[2])
         for w in G[v]:
             #print '-', w
             if abs(w[0]) > 100 or abs(w[1]) > 100:
                 continue
             wLength = D[v] + 1
             if w in D:
                 if wLength < D[w]:
                     raise ValueError, ""Dijkstra: found better path to already-final vertex""
             elif w not in Q or wLength < Q[w]:
                 Q[w] = wLength
                 P[w] = v
     #print P
     end = v
     Path = """"
     while 1:
         Path += end[2]
         if end[:2] == start[:2]: break
         end = P[end]
 
     return 'Case #%s: %s\n' % (testcase, Path[:-1][::-1])
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2437488/alexamici/2749486/0/extracted/B.py,6387,187,831,Python,2437488,0,2749486,alexamici,2013
643,A.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [map(int, infile.next().split()) for i in range(1)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
     
     A, N = P
     I.sort()
 
     for i in I[:]:
         if i < A:
             A += i
             I.pop(0)
         else:
             break
 
     if A == 1:
         return 'Case #%s: %s\n' % (testcase, len(I))
 
     res = [len(I)]
     while len(I):
         A = 2 * A - 1
         for i in I[:]:
             if i < A:
                 A += i
                 I.pop(0)
             else:
                 break
         res.append(len(I))
     
     resr = len(res) - 1
     for i, r in enumerate(res):
         if r < len(res)-1-i:
             resr = i+r
             break
 
     return 'Case #%s: %s\n' % (testcase, resr)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2434486/alexamici/2692487/1/extracted/A.py,1519,66,186,Python,2434486,1,2692487,alexamici,2013
644,B.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     import numpy as np
     #import scipy as sp
     #import networkx as nx
     
 
     e, R, N = P
     I = np.array(I)
     E = np.array([0]*len(I))
     E[0] = e
 
     nexts = reversed(I.argsort())
     res = 0
     for current in nexts:
         e_next = R
         for nex in xrange(current+1, len(E)):
             ediff = R*(nex-current-1)
             if ediff>=e:
                 break
             if E[nex] > 0:
                 e_next = max(R, E[nex] - ediff)
                 break
 
         if current+1 < len(E) and E[current+1] == 0:
             E[current+1] = e_next
 
         if E[current] == 0:
             for prev in xrange(current-1, -1, -1):
                 ediff = R*(current-prev)
                 if E[prev] > 0 or ediff >= e:
                     E[current] = min(e, E[prev] + ediff)
                     break
 
         res += (E[current]+R-e_next) * I[current]
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2418487/alexamici/2645486/1/extracted/B.py,1739,66,203,Python,2418487,1,2645486,alexamici,2013
645,B.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     import numpypy as np
     #import scipy as sp
     #import networkx as nx
     
 
     e, R, N = P
     I = np.array(I)
     E = np.array([0]*len(I))
     E[0] = e
 
     nexts = reversed(I.argsort())
     res = 0
     for current in nexts:
         e_next = R
         for nex in xrange(current+1, len(E)):
             ediff = R*(nex-current-1)
             if ediff>=e:
                 break
             if E[nex] > 0:
                 e_next = max(R, E[nex] - ediff)
                 break
 
         if current+1 < len(E) and E[current+1] == 0:
             E[current+1] = e_next
 
         if E[current] == 0:
             for prev in xrange(current-1, -1, -1):
                 ediff = R*(current-prev)
                 if E[prev] > 0 or ediff >= e:
                     E[current] = min(e, E[prev] + ediff)
                     break
 
         res += (E[current]+R-e_next) * I[current]
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2418487/alexamici/2645486/0/extracted/B.py,1741,66,203,Python,2418487,0,2645486,alexamici,2013
646,A.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
     
     r, t = P
 
 
     res = 0
     while t>=2*r+1:
         res += 1
         t -= 2*r +1
         r += 2
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2418487/alexamici/2464487/0/extracted/A.py,1029,44,129,Python,2418487,0,2464487,alexamici,2013
647,A.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     #P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     S = [infile.next().strip() for i in range(5)]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
     
     not_draw = False
     for line in S[:4]:
         not_win = set()
         if '.' in line:
             not_draw = True
             continue
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     ST = []
     for j in range(4):
         ST.append(''.join(S[i][j] for i in range(4)))
     for line in ST:
         not_win = set()
         if '.' in line:
             continue
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     line = ''.join(S[i][i] for i in range(4))
     not_win = set()
     if '.' not in line:   
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     line = ''.join(S[i][3-i] for i in range(4))
     not_win = set()
     if '.' not in line:
         if 'O' in line:
             not_win.add('X')
         if 'X' in line:
             not_win.add('O')
         if len(not_win) == 1:
             return 'Case #%s: %s\n' % (testcase, 'X won' if 'X' not in not_win else 'O won')
 
     if not_draw:
         return 'Case #%s: %s\n' % (testcase, 'Game has not completed')
     else:
         return 'Case #%s: %s\n' % (testcase, 'Draw')
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2270488/alexamici/2453486/1/extracted/A.py,2508,86,316,Python,2270488,1,2453486,alexamici,2013
648,C.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 # http://code.activestate.com/recipes/577821-integer-square-root-function/
 def isqrt(x):
     ""returns int(floor(sqrt(x))) using only integer math""
     assert x >= 0, 'Undefined %r' % locals()
     n = int(x)
     if n == 0:
         return 0
     a, b = divmod(n.bit_length(), 2)
     x = 2**(a+b)
     while True:
         y = (x + n//x)//2
         if y >= x:
             return x
         x = y
 
 def is_pal(n):
     n = str(n)
     for i in range(len(n)/2+1):
         if n[i]!=n[len(n)-1-i]:
             return False
     return True
 
 def all_fair_and_square(hl=25):
     """"""Off-line cache, build before downloading the large input""""""
     import itertools as it
     import cPickle
     retval = set()
     for n in range(1,hl):
         for first in ['1','2']:
             for dig in it.product(['0','1'], repeat=n):
                 cand = int(first+''.join(dig)+''.join(reversed(dig))+first)
                 if cand <= 10**50 and is_pal(cand*cand):
                     print cand
                     retval.add(cand)
                 for mid in ['0','1','2']:
                     cand = int(first+''.join(dig)+mid+''.join(reversed(dig))+first)
                     if cand <= 10**50 and is_pal(cand*cand):
                         print cand, len(str(cand))
                         retval.add(cand)
                     
 
     cPickle.dump(retval, open('cache.pk','w'))
 
     return retval
 
 
 def setup(infile):
     import cPickle
     C = cPickle.load(open('cache.pk'))
     return locals()
 
 def reader(testcase, infile, C, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
     import cPickle
 
     low = isqrt(P[0])
     high = isqrt(P[1])+1
 
     res = 0
     for i in C:
         if P[0]<=i*i<=P[1]:
             res += 1
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2270488/alexamici/2463486/2/extracted/C.py,2550,92,265,Python,2270488,2,2463486,alexamici,2013
649,C.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 # http://code.activestate.com/recipes/577821-integer-square-root-function/
 def isqrt(x):
     ""returns int(floor(sqrt(x))) using only integer math""
     assert x >= 0, 'Undefined %r' % locals()
     n = int(x)
     if n == 0:
         return 0
     a, b = divmod(n.bit_length(), 2)
     x = 2**(a+b)
     while True:
         y = (x + n//x)//2
         if y >= x:
             return x
         x = y
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
 
     low = isqrt(P[0])
     high = isqrt(P[1])+1
 
     def is_pal(n):
         n = str(n)
         for i in range(len(n)/2+1):
             if n[i]!=n[len(n)-1-i]:
                 return False
         return True
 
     res = 0
     for i in range(low, high+1):
         if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):
             print i*i, ',',
             res += 1
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2270488/alexamici/2463486/1/extracted/C.py,1708,67,203,Python,2270488,1,2463486,alexamici,2013
650,C.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 # http://code.activestate.com/recipes/577821-integer-square-root-function/
 def isqrt(x):
     ""returns int(floor(sqrt(x))) using only integer math""
     assert x >= 0, 'Undefined %r' % locals()
     n = int(x)
     if n == 0:
         return 0
     a, b = divmod(n.bit_length(), 2)
     x = 2**(a+b)
     while True:
         y = (x + n//x)//2
         if y >= x:
             return x
         x = y
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
 
     low = isqrt(P[0])
     high = isqrt(P[1])+1
 
     def is_pal(n):
         n = str(n)
         for i in range(len(n)/2+1):
             if n[i]!=n[len(n)-1-i]:
                 return False
         return True
 
     res = 0
     for i in range(low, high+1):
         if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):
             res += 1
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2270488/alexamici/2463486/0/extracted/C.py,1679,66,200,Python,2270488,0,2463486,alexamici,2013
651,B.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     S = [map(int, infile.next().split()) for i in range(P[0])]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     import numpypy as np
     #import scipy as sp
     #import networkx as nx
     
     S = np.array(S)
     done = np.zeros(P, dtype=int)
     for row in range(P[0]):
         m = S[row].max()
         done[row][S[row]==m] = 1
 
     for col in range(P[1]):
         m = S[:,col].max()
         done[:,col][S[:,col]==m] = 1
 
     res = 'YES' if done.sum() == P[0]*P[1] else 'NO'
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2270488/alexamici/2449486/1/extracted/B.py,1241,47,148,Python,2270488,1,2449486,alexamici,2013
652,D.py,"""""""Usage:
     X.py < X.in > X.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     I = map(int, infile.next().split())
     #T = infile.next().split()
     S = [map(int, infile.next().split()) for i in range(P[1])]
     return locals()
 
 def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpy as np
     #import scipy as sp
     #import networkx as nx
     import lrucache as lc
 
     K, N = P
 
     Ki = sorted(I)
 
     S = [[i]+t for i, t in enumerate(S,1)]
 
     T = [(t[1], tuple(t[3:]), t[0]) for t in S]
 
     def topen(t, Ki, T):
         Ki = list(Ki)
         Ki.remove(T[t][0])
         Ki.extend(T[t][1])
         Ki.sort()
         T = list(T)
         T.pop(t)
         return tuple(Ki), tuple(T)
 
     @lc.lru_cache(maxsize=None)
     def seq(Ki, T):
         #print Ki, T
         if len(T)==1 and T[0][0] in Ki:
             return [T[0][2]]
         todo = set(t[0] for t in T)
         if len(todo & set(Ki)) == 0:
             return None
         for t in range(len(T)):
             if T[t][0] not in Ki:
                 continue
             nKi, nT = topen(t, Ki, T)
             nexts = seq(nKi, nT)
             if nexts is None:
                 continue
             return [T[t][2]] + nexts
         return None
 
 
     res = seq(tuple(Ki), tuple(T))
     if res == None:
         res = 'IMPOSSIBLE'
     else:
         res =  ' '.join('%d'%n for n in res)
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2013/2270488/alexamici/2458486/0/extracted/D.py,1976,78,238,Python,2270488,0,2458486,alexamici,2013
653,D.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     N = int(infile.next())
     P = map(float, infile.next().split())
     I = map(float, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpypy as np
     #import scipy as sp
     #import networkx as nx
 
     N = sorted(P)
     K = sorted(I)
 
     W = 0
     ik = 0
     for n in N:
         while ik < len(K) and K[ik] < n:
             ik += 1
             W += 1
         ik += 1
 
     D = 0
     i = 0
     for k in K:
         while i < len(N) and N[i] < k:
             i += 1
         i += 1
         if i <= len(N):
             D += 1
 
     return 'Case #%s: %s %s\n' % (testcase, D, W)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2014/2974486/alexamici/5644738749267968/1/extracted/D.py,1351,58,186,Python,2974486,1,5644738749267968,alexamici,2014
654,B.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     #P = map(int, infile.next().split())
     I = map(float, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpypy as np
     #import scipy as sp
     #import networkx as nx
 
     C, F, X = I
     n = [0]
     r = 2.
 
     res = X / r
     while True:
         n.append(n[-1] + C / r)
         r += F
         nres = n[-1] + X / r
         if nres >= res:
             break
         res = nres
 
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2014/2974486/alexamici/5709773144064000/1/extracted/B.py,1226,51,161,Python,2974486,1,5709773144064000,alexamici,2014
655,C.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     import numpy as np
     #import scipy as sp
     #import networkx as nx
 
     R, C, M = P
     #print '--', R, C, M
     MM = M
 
     F = np.array([['.'] * C] * R)
     while M > 0:
         # reduce if possible
         if R >= C and M >= C and R > 2:
             M -= C
             R -= 1
             F[R] = '*'
         elif C > R  and M >= R and C > 2:
             M -= R
             C -= 1
             F[:, C] = '*'
         # solve simple
         elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):
             if M < C - 1:
                 R -= 1
                 F[R, C - M:C] = '*'
             elif M < R - 1:
                 C -= 1
                 F[R - M:R, C] = '*'
             elif M == C - 1:
                 R -= 1
                 F[R, C - M + 1:C] = '*'
                 F[R - 1, C - 1] = '*'
             else:
                 C -= 1
                 F[R - M + 1:R, C] = '*'
                 F[R - 1, C - 1] = '*'
             M = 0
         #special cases
         elif M == R * C - 1:
             F[:, :] = '*'
             M = 0
         else:
             #print F
             #print R, C, M
             return 'Case #%s:\n%s\n' % (testcase, 'Impossible')
 
     F[0, 0] = 'c'
     #assert (F == '*').sum() == MM
     return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2014/2974486/alexamici/5690574640250880/1/extracted/C.py,2220,81,336,Python,2974486,1,5690574640250880,alexamici,2014
656,C.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     #N = int(infile.next())
     P = map(int, infile.next().split())
     #I = map(int, infile.next().split())
     #T = infile.next().split()
     #S = [infile.next().strip() for i in range(N)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     import numpy as np
     #import scipy as sp
     #import networkx as nx
 
     R, C, M = P
     #print '--', R, C, M
     MM = M
 
     F = np.array([['.'] * C] * R)
     while M > 0:
         # reduce if possible
         if R >= C and M >= C and R > 2:
             M -= C
             R -= 1
             F[R] = '*'
         elif C > R  and M >= R and C > 2:
             M -= R
             C -= 1
             F[:, C] = '*'
         # solve simple
         elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):
             if M < C - 1:
                 R -= 1
                 F[R, C - M:C] = '*'
             elif M < R - 1:
                 C -= 1
                 F[R - M:R, C] = '*'
             elif M == C - 1:
                 R -= 1
                 F[R, C - M + 1:C] = '*'
                 F[R - 1, C - 1] = '*'
             else:
                 C -= 1
                 F[R - M + 1:R, C] = '*'
                 F[R - 1, C - 1] = '*'
             M = 0
         #special cases
         elif M == R * C - 1:
             F[:, :] = '*'
             M = 0
         else:
             #print F
             #print R, C, M
             return 'Case #%s:\n%s\n' % (testcase, 'Impossible')
 
     F[0, 0] = 'c'
     assert (F == '*').sum() == MM
     return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2014/2974486/alexamici/5690574640250880/0/extracted/C.py,2219,81,336,Python,2974486,0,5690574640250880,alexamici,2014
657,A.py,"""""""Usage:
     pypy X.py < X-size.in > X-size.out
 or sometimes
     python X.py < X-size.in > X-size.out
 """"""
 
 def setup(infile):
     #C = {}
     return locals()
 
 def reader(testcase, infile, C=None, **ignore):
     N = int(infile.next())
     #P = int(infile.next())
     #P = map(int, infile.next().split())
     I = [map(int, infile.next().split()) for i in range(4)]
     T = int(infile.next())
     #T = infile.next().split()
     S = [map(int, infile.next().split()) for i in range(4)]
     return locals()
 
 def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import operator as op
     #import math as ma
     #import re
     #import numpypy as np
     #import scipy as sp
     #import networkx as nx
 
     res = set(I[N-1]) & set(S[T-1])
     if len(res) == 1:
         res = res.pop()
     elif len(res) > 1:
         res = 'Bad magician!'
     else:
         res = 'Volunteer cheated!'
     return 'Case #%s: %s\n' % (testcase, res)
 
 if __name__ == '__main__':
     import sys
     T = int(sys.stdin.next())
     common = setup(sys.stdin)
     for t in xrange(1, T+1):
         sys.stdout.write(solver(**reader(t, **common)))
",gcj/2014/2974486/alexamici/5756407898963968/0/extracted/A.py,1273,47,156,Python,2974486,0,5756407898963968,alexamici,2014
658,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def reader(tc, infile):
     N = int(next(infile))
     #P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for i in range(N)]
     #T = next(infile).split()
     S = [next(infile).strip() for T in range(N)]
     return locals()
 
 
 def setupper(cases):
     #C = {}
     return locals()
 
 
 def solver(tc, infile=None, N=None, P=None, I=None, T=None, S=None, C={}):
     import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     #import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
 
     compact = []
     for j, s in enumerate(S):
         compact.append([])
         prev = ''
         count = 0
         for l in s:
             if prev and l != prev:
                 compact[j].append((prev, count))
                 count = 0
             prev = l
             count += 1
         else:
             compact[j].append((prev, count))
     for c in compact:
         if [a[0] for a in c] != [b[0] for b in compact[0]]:
             return 'Case #%s: %s' % (tc, 'Fegla Won')
     
     res = 0
     for i in range(len(compact[0])):
         target = int(round(sum([c[i][1] for c in compact]) / float(len(compact))))
         res += sum([abs(c[i][1] - target) for c in compact])
 
     return 'Case #%s: %s' % (tc, res)
 
 
 if __name__ == '__main__':
     T = int(next(sys.stdin))
     cases = [reader(tc, sys.stdin) for tc in range(1, T + 1)]
     caches = setupper(cases)
     for case in cases:
         print solver(C=caches, **case)
",gcj/2014/2994486/alexamici/5751500831719424/1/extracted/A.py,1795,69,230,Python,2994486,1,5751500831719424,alexamici,2014
659,C.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def reader(tc, infile):
     #N = int(next(infile))
     P = map(int, next(infile).split())
     S = [next(infile).strip() for T in range(P[0])]
     I = [map(int, next(infile).split()) for T in range(P[1])]
     #T = next(infile).split()
     return locals()
 
 
 def setupper(cases):
     #C = {}
     return locals()
 
 
 def solver(tc, infile=None, N=None, P=None, I=None, T=None, S=None, C={}):
     import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     #import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     import heapq as hq
 
     N, M = P
 
     G = co.defaultdict(list)
     for u, v in I:
         G[u - 1].append(v - 1)
         G[v - 1].append(u - 1)
 
     next = min((s, i) for i, s in enumerate(S))[1]
     Q = [(S[next], [next], frozenset([next]))]
     while len(Q):
         res, way, seen = hq.heappop(Q)
         if len(seen) == len(G):
             break
         if len(way) == 0:
             continue
         cur = way[-1]
         for v in G[cur]:
             if v not in seen:
                 hq.heappush(Q, (res + S[v], way + [v], seen | frozenset([v])))
         hq.heappush(Q, (res, way[:-1], seen))
 
     return 'Case #%s: %s' % (tc, res)
 
 
 if __name__ == '__main__':
     T = int(next(sys.stdin))
     cases = [reader(tc, sys.stdin) for tc in range(1, T + 1)]
     caches = setupper(cases)
     for case in cases:
         print solver(C=caches, **case)
",gcj/2014/2994486/alexamici/5731331665297408/0/extracted/C.py,1725,69,225,Python,2994486,0,5731331665297408,alexamici,2014
660,B.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def reader(tc, infile):
     #N = int(next(infile))
     P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for i in range(N)]
     #T = next(infile).split()
     #S = [next(infile).strip() for i in range(N)]
     return locals()
 
 
 def setupper(cases):
     #C = {}
     return locals()
 
 
 def solver(tc, infile=None, N=None, P=None, I=None, T=None, S=None, C={}):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     #import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
 
     A, B, K = P
 
     res = 0
     for i in range(A):
         res += sum(i & j < K for j in range(B))
     return 'Case #%s: %s' % (tc, res)
 
 
 if __name__ == '__main__':
     T = int(next(sys.stdin))
     cases = [reader(tc, sys.stdin) for tc in range(1, T + 1)]
     caches = setupper(cases)
     for case in cases:
         print solver(C=caches, **case)
",gcj/2014/2994486/alexamici/5658282861527040/0/extracted/B.py,1202,52,165,Python,2994486,0,5658282861527040,alexamici,2014
661,B.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     #N = int(next(infile))
     #P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for _ in range(P[0])]
     T = next(infile).split()
     S = [map(float, next(infile).split()) for _ in range(int(T[0]))]
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     #import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     #import heapq as hq
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
 
     N, V, T = int(T[0]), float(T[1]), float(T[2])
     if all(t > T for r, t in S) or all(t < T for r, t in S) or (len(S) == 1 and S[0][1] != T):
         return 'Case #{:d}: {}'.format(tc, 'IMPOSSIBLE')
     if len(S) == 1:
         res = V / S[0][0]
     elif len(S) == 2:
         if S[0][1] == S[1][1]:
             res = res = V / (S[0][0] + S[1][0])
         else:
             V0 = (V * T - V * S[1][1]) / (S[0][1] - S[1][1])
             V1 = (V * T - V * S[0][1]) / (S[1][1] - S[0][1])
             res = max(V0 / S[0][0], V1 / S[1][0])
     else:
         raise 'impossible'
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2015/8234486/alexamici/5750872826970112/0/extracted/B.py,1829,64,250,Python,8234486,0,5750872826970112,alexamici,2015
662,C.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     N = int(next(infile))
     #P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for _ in range(P[0])]
     #T = next(infile).split()
     S = [next(infile).strip().split() for _ in range(N)]
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     #import heapq as hq
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
 
     S[0] += ['0']
     S[1] += ['1']
     S = map(frozenset, S)
 
     G = nx.Graph()
     for i, s1 in enumerate(sorted(S)):
         for s2 in sorted(S)[i+1:]:
             if s1 == s2:
                 continue
             cw = s1 & s2
             for w in cw:
                 G.add_edge(s1, w, capacity=1)
                 G.add_edge(w, s2, capacity=1)
 
     return 'Case #{:d}: {}'.format(tc, nx.minimum_cut(G, S[0], S[1])[0])
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2015/8234486/alexamici/5759940174020608/1/extracted/C.py,1622,64,191,Python,8234486,1,5759940174020608,alexamici,2015
663,C.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     N = int(next(infile))
     #P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for _ in range(P[0])]
     #T = next(infile).split()
     S = [next(infile).strip().split() for _ in range(N)]
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     #import heapq as hq
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
 
     pid = os.getpid()
 
     S[0] += ['0']
     S[1] += ['1']
     S = map(frozenset, S)
 
     G = nx.Graph()
     for i, s1 in enumerate(sorted(S)):
         for s2 in sorted(S)[i+1:]:
             if s1 == s2:
                 continue
             cw = s1 & s2
             for w in cw:
                 G.add_edge(s1, w, capacity=1)
                 G.add_edge(w, s2, capacity=1)
 
     return 'Case #{:d}: {}'.format(tc, nx.minimum_cut(G, S[0], S[1])[0])
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2015/8234486/alexamici/5759940174020608/0/extracted/C.py,1647,66,194,Python,8234486,0,5759940174020608,alexamici,2015
664,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     #N = int(next(infile))
     P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for _ in range(P[0])]
     #T = next(infile).split()
     S = [next(infile).strip() for _ in range(P[0])]
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     #import heapq as hq
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
 
     R, C = P
     S = list(S)
     res = 0
 
     def walk(j, i, d):
         if d == '^':
             for jj in reversed(range(j)):
                 if S[jj][i] != '.':
                     return S[jj][i]
             else:
                 return 'X'
         elif d == 'v':
             for jj in range(j + 1, R):
                 if S[jj][i] != '.':
                     return S[jj][i]
             else:
                 return 'X'
         elif d == '<':
             for ii in reversed(range(i)):
                 if S[j][ii] != '.':
                     return S[j][ii]
             else:
                 return 'X'
         else:
             for ii in range(i + 1, C):
                 if S[j][ii] != '.':
                     return S[j][ii]
             else:
                 return 'X'
 
     for j in range(R):
         for i in range(C):
             if S[j][i] == '.':
                 continue
             if walk(j, i, S[j][i]) == 'X':
                 for d in ['^', '>', 'v', '<']:
                     if walk(j, i, d) != 'X':
                         res += 1
                         break
                 else:
                     res = 'IMPOSSIBLE'
                     return 'Case #{:d}: {}'.format(tc, res)
                         
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2015/8234486/alexamici/5708208098246656/1/extracted/A.py,2495,93,277,Python,8234486,1,5708208098246656,alexamici,2015
665,B.py,"import itertools as it
 for tc in range(input()):
 	R,C,N=map(int,raw_input().split())
 	res=float('inf')
 	for t in it.combinations(range(R*C),N):
 		u=0
 		for n1 in t:
 			x1,y1=n1%C,n1//C
 			for n2 in t:
 				x2,y2=n2%C,n2//C
 				if x1==x2 and (y1==y2+1 or y1==y2-1) or \
 					y1==y2 and (x1==x2+1 or x1==x2-1):
 						u+=1
 		res=min(res,u//2)
 	print'Case #{}: {}'.format(tc+1,res)",gcj/2015/8224486/alexamici/5769900270288896/0/extracted/B.py,390,15,43,Python,8224486,0,5769900270288896,alexamici,2015
666,C.py,"import math
 def p(h,t):
 	d,m=h
 	return abs(int(math.floor((t-m*(360-d))/(360.*m))))
 for tc in range(input()):
 	N=input()
 	HG=[map(int,raw_input().split())for n in range(N)]
 	H=[(D,M+h)for D,H,M in HG for h in range(H)]
 	T=[(360-d)*m+n*m for d,m in H for n in range(-1,100)]
 	res=float('inf')
 	for t in sorted(T)[:1000]:
 		u=0
 		for h in H:
 			u+=p(h,t)
 		res=min(res,u)
 	print'Case #{}: {}'.format(tc+1,res)",gcj/2015/8224486/alexamici/5662291475300352/1/extracted/C.py,422,16,48,Python,8224486,1,5662291475300352,alexamici,2015
667,C.py,"for tc in range(input()):
 	N=input()
 	HG=[map(int,raw_input().split())for n in range(N)]
 	H=[(D,M+h)for D,H,M in HG for h in range(H)]
 	res=0
 	if len(H)>1:
 		try:
 			F,S=H
 		except:
 			continue
 		if F[1]>S[1]:
 			F,S=S,F
 		t2=360*F[1]+F[1]*(360-F[0])
 		s1=S[1]*(360-S[0])
 		if s1>=t2:
 			res=1
 	print'Case #{}: {}'.format(tc+1,res)",gcj/2015/8224486/alexamici/5662291475300352/0/extracted/C.py,347,17,35,Python,8224486,0,5662291475300352,alexamici,2015
668,A.py,"import networkx as nx
 G=nx.DiGraph()
 for n in range(2,1000001):
     N=str(n)
     G.add_edge(str(n-1),N)
     if N[-1]!='0':
         G.add_edge(N[::-1],N)
 for tc in range(input()):
     N=raw_input()
     print'Case #{}: {}'.format(tc+1,nx.shortest_path_length(G,'1',N)+1)",gcj/2015/8224486/alexamici/5688567749672960/0/extracted/A.py,277,10,22,Python,8224486,0,5688567749672960,alexamici,2015
669,D.py,"m={
 (2,1,2):0,
 (2,1,4):0,
 (2,2,2):0,
 (2,2,3):0,
 (2,2,4):0,
 (2,3,4):0,
 (2,4,4):0,
 (3,1,3):1,
 (3,2,3):0,
 (3,3,3):0,
 (3,3,4):0,
 (4,1,4):1,
 (4,2,2):1,
 (4,2,4):1,
 (4,3,4):0,
 (4,4,4):0,
 }
 for t in range(input()):
 	X,R,C=map(int,raw_input().split())
 	R,C=min(R,C),max(R,C)
 	if X==1:
 		r=0
 	elif R*C%X!=0:
 		r=1
 	else:
 		r=m[X,R,C]
 	print'Case #%d: %s'%(t+1,['GABRIEL','RICHARD'][r])",gcj/2015/6224486/alexamici/5658571765186560/0/extracted/D.py,402,28,35,Python,6224486,0,5658571765186560,alexamici,2015
670,B3.py,"C={}
 def m(P):
     if P[0]<=3:
         return P[0]
     if P not in C:
         C[P] = 1 + m(tuple(p-1 for p in P if p>1))
         for q in range(1, P[0]):
             C[P] = min(C[P], 1 + m(tuple(sorted(P[1:]+(P[0] - q, q), reverse=True))))
     return C[P]
 for t in range(input()):
     _=input()
     P=tuple(sorted(map(int,raw_input().split()), reverse=True))
     print 'Case #%d: %r'%(t+1,m(P))",gcj/2015/6224486/alexamici/5686275109552128/0/extracted/B3.py,406,13,51,Python,6224486,0,5686275109552128,alexamici,2015
671,C.py,"m={
 ('i','j'):(1,'k'),
 ('j','k'):(1,'i'),
 ('k','i'):(1,'j'),
 ('j','i'):(-1,'k'),
 ('k','j'):(-1,'i'),
 ('i','k'):(-1,'j'),
 }
 C={}
 def r(S):
 	if len(S)<=1:
 		return (1,S)
 	if S not in C:
 		s1,q1=r(S[:len(S)//2])
 		s2,q2=r(S[len(S)//2:])
 		if q1==q2=='':
 			s,q=1,''
 		elif q1==''or q2=='':
 			s,q=1,q1+q2
 		else:
 			s,q=m.get((q1,q2),(-1,''))
 		C[S]=(s*s1*s2,q)
 	return C[S]
 def sol():
 	_,X=map(int,raw_input().split())
 	S=raw_input()
 	S=S*X
 	if r(S)==(-1,''):
 		for i in range(1,len(S)):
 			if r(S[:i])==(1,'i'):
 				for j in range(i+1,len(S)+1):
 					if r(S[i:j])!=(1,'j'):
 						continue
 					if r(S[j:])==(1,'k'):
 						return'Case #%d: YES'%(t+1)
 	return'Case #%d: NO'%(t+1)
 for t in range(input()):
 	print sol()",gcj/2015/6224486/alexamici/5670465267826688/0/extracted/C.py,751,38,68,Python,6224486,0,5670465267826688,alexamici,2015
672,A.py,"for t in range(input()):
 	S=map(int,raw_input().split()[1])
 	c=r=0
 	for n,s in enumerate(S,1):
 		c+=s
 		r+=max(n-c,0)
 		c=max(c,n)
 	print 'Case #%d: %d'%(t+1,r)",gcj/2015/6224486/alexamici/5639104758808576/1/extracted/A.py,167,8,17,Python,6224486,1,5639104758808576,alexamici,2015
673,A.py,"
 for _t in range(input()):
     _=input()
     M=map(int,raw_input().split())
     D=[max(0,M[i-1]-M[i]) for i in range(1,len(M))]
     r1=sum(D)
     d=max(D)
     r2=sum(min(m,d) for m in M[:-1])
     print 'Case #{}: {} {}'.format(_t+1,r1,r2)
",gcj/2015/4224486/alexamici/6404600001200128/1/extracted/A.py,247,10,23,Python,4224486,1,6404600001200128,alexamici,2015
674,B.py,"
 def gcd(a, b):
     while b:
         a, b = b, a % b
     return a
 
 def lcm(a, b):
     return a * b / gcd(a, b)
 
 def solve(N,B):
     M=reduce(lcm,B)
     m=sum(M//b for b in B)
     N%=m
     if N==0:
         N=m
     R=[0]*len(B)
     while True:
         dt=min(R)
         R=[r-dt for r in R]
         for i,b in enumerate(B):
             if R[i]==0:
                 N-=1
                 if N==0:
                     return i+1
                 R[i]=b
 
 for tc in range(input()):
     _,N=map(int,raw_input().split())
     B=map(int,raw_input().split())
     print 'Case #{}: {}'.format(tc+1,solve(N,B))
",gcj/2015/4224486/alexamici/5765824346324992/0/extracted/B.py,622,31,67,Python,4224486,0,5765824346324992,alexamici,2015
675,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     T = next(infile).strip()
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     end = len(T)
     res = ['', '']
     while end > 0:
         fl = sorted(T[:end])[-1]
         i = T[:end].rindex(fl)
         res[0] += fl
         res[1] = T[i + 1:end] + res[1]
         end = i
     return 'Case #{:d}: {}'.format(tc, res[0] + res[1])
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2016/4304486/alexamici/5631989306621952/1/extracted/A.py,865,39,109,Python,4304486,1,5631989306621952,alexamici,2016
676,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     N = int(next(infile))
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import itertools as it
 
     seen = set()
     res = 'INSOMNIA'
     try:
         for i in it.count(1):
             r = i * N
             seen.update(str(r))
             if len(seen) == 10:
                 res = r
                 break
     except KeyboardInterrupt:
         pass
 
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5652388522229760/1/extracted/A.py,873,43,100,Python,6254486,1,5652388522229760,alexamici,2016
677,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     N = int(next(infile))
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
 
     seen = set()
     res = 'INSOMNIA'
     for i in range(1, 100):
         r = i * N
         seen.update(str(r))
         if len(seen) == 10:
             res = r
             break
 
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5652388522229760/0/extracted/A.py,768,39,93,Python,6254486,0,5652388522229760,alexamici,2016
678,D.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import sys
 
 
 def common_setup():
 
     pass
 
 
 def case_reader(tc, infile):
     P = map(int, next(infile).split())
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     K, C, S = P
 
     values = []
     for i in range(0, K, C):
         pp = range(i, min(K, i + C))
         ppp = [p * K ** (C - j - 1) for j, p in enumerate(pp)]
         p = sum(ppp)
         values.append(p + 1)
     if len(values) <= S:
         res = ' '.join('%d' % r for r in values)
     else:
         res = 'IMPOSSIBLE'
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5636311922769920/1/extracted/D.py,917,41,128,Python,6254486,1,5636311922769920,alexamici,2016
679,D.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import sys
 
 
 def common_setup():
 
     pass
 
 
 def case_reader(tc, infile):
     P = map(int, next(infile).split())
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     K, C, S = P
     values = [sum(i * K ** c for c in range(C)) + 1 for i in range(K)]
     res = ' '.join('%d' % r for r in values)
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5636311922769920/0/extracted/D.py,717,32,99,Python,6254486,0,5636311922769920,alexamici,2016
680,C.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     P = map(int, next(infile).split())
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import itertools as it
     import numpy as np
 
     def primes_upto(n, dtype='uint32'):
         P = np.arange(n + 1, dtype=dtype)
         P[1] = 0
         for p in xrange(2, int(n ** 0.5) + 1):
             if P[p]:
                 P[p*p::p] = 0
         # return [p for p in P if p] # lower memory variant
         return P[P>0]
 
     # use only small primes for performance (solved large in 1 sec)
     primes = primes_upto(1000)
 
     def from_base(n, b):
         assert 1 < b < 11, 'Unsupported %r' % locals()
         r = 0
         for i, d in enumerate(reversed(n)):
            r += int(d) * b ** i
         return r
 
     N, J = P
 
     res = []
     # large neumbers first (less primes)
     for items in it.product(['1', '0'], repeat= N - 2):
         tjc = '1' + ''.join(items) + '1'
         factors = []
         for b in range(2, 11):
             tjcb = from_base(tjc, b)
             for p in primes:
                 if p >= tjcb ** 0.5:
                     break
                 if tjcb % p == 0:
                     factors.append(p)
                     break
             else:
                 break
         if len(factors) == 9:
             res.append((tjc, factors))
             print len(res), tjc
         if len(res) == J:
             break
 
     return 'Case #{:d}:\n{}'.format(tc, '\n'.join(r[0] + ' ' + ' '.join(str(p) for p in r[1]) for r in res))
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5738606668808192/1/extracted/C.py,1939,73,250,Python,6254486,1,5738606668808192,alexamici,2016
681,C.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     P = map(int, next(infile).split())
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import itertools as it
     import numpy as np
 
     def primes_upto(n, dtype='uint32'):
         P = np.arange(n + 1, dtype=dtype)
         P[1] = 0
         for p in xrange(2, int(n ** 0.5) + 1):
             if P[p]:
                 P[p*p::p] = 0
         # return [p for p in P if p] # lower memory variant
         return P[P>0]
 
     primes = primes_upto(1000000)
 
     def from_base(n, b):
         assert 1 < b < 11, 'Unsupported %r' % locals()
         r = 0
         for i, d in enumerate(reversed(n)):
            r += int(d) * b ** i
         return r
 
     N, J = P
 
     res = []
     for items in it.product(['0', '1'], repeat= N - 2):
         tjc = '1' + ''.join(items) + '1'
         factors = []
         for b in range(2, 11):
             tjcb = from_base(tjc, b)
             for p in primes:
                 if p >= tjcb ** 0.5:
                     break
                 if tjcb % p == 0:
                     factors.append(p)
                     break
             else:
                 break
         if len(factors) == 9:
             res.append((tjc, factors))
         if len(res) == J:
             break
 
     return 'Case #{:d}:\n{}'.format(tc, '\n'.join(r[0] + ' ' + ' '.join(str(p) for p in r[1]) for r in res))
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5738606668808192/0/extracted/C.py,1809,71,231,Python,6254486,0,5738606668808192,alexamici,2016
682,B.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes
     python -u X.py < X-test.in > X-test.out
 """"""
 
 import os
 import sys
 sys.setrecursionlimit(20000)
 
 
 def common_setup():
     pass
 
 S = {'': 0}
 
 def case_reader(tc, infile):
     T = next(infile).strip()
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, **kwargs):
     #import collections as co
     #import functools32 as ft
     import itertools as it
     #import math as ma
     #import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     #import heapq as hq
 
     def flip(T, slice_stop):
         return ''.join('+' if t == '-' else '-' for t in reversed(T[:slice_stop])) + T[slice_stop:]
 
     def reduced(T):
         tail_index = len(T) - T[::-1].find('-')
         if tail_index > len(T):
             return ''
         else:
             return T[:tail_index]
 
     def best(T):
         T = reduced(T)
         if T not in S:
             if T[0] == '-':
                 S[T] = best(flip(T, len(T))) + 1
             else:
                 S[T] = best(flip(T, T.index('-'))) + 1
         return S[T]
 
     return 'Case #{:d}: {}'.format(tc, best(T))
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print case_solver(**case)
",gcj/2016/6254486/alexamici/5634697451274240/1/extracted/B.py,1463,62,176,Python,6254486,1,5634697451274240,alexamici,2016
683,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     T = next(infile)
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import collections as co
     C = dict(co.Counter(T))
     Z = C.get('Z', 0)
     if Z:
         C['E'] -= Z
         C['R'] -= Z
         C['O'] -= Z
     X = C.get('X', 0)
     if X:
         C['S'] -= X
         C['I'] -= X
     W = C.get('W', 0)
     if W:
         C['T'] -= W
         C['O'] -= W
     U = C.get('U', 0)
     if U:
         C['F'] -= U
         C['O'] -= U
         C['R'] -= U
     O = C.get('O', 0)
     if O:
         C['N'] -= O
         C['E'] -= O
     S = C.get('S', 0)
     if S:
         C['E'] -= S
         C['V'] -= S
         C['E'] -= S
         C['N'] -= S
     V = C.get('V', 0)
     if V:
         C['F'] -= V
         C['I'] -= V
         C['E'] -= V
     G = C.get('G', 0)
     if G:
         C['E'] -= G
         C['I'] -= G
         C['H'] -= G
         C['T'] -= G
     N = C.get('N', 0)
     if N:
         C['E'] -= N / 2
         C['I'] -= N / 2
     R = C.get('R', 0)
     res = '0' * Z + '1' * O + '2' * W + '3' * R + '4' * U + '5' * V + '6' * X + '7' * S + '8' * G + '9' * (N // 2)
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2016/11254486/alexamici/5648941810974720/1/extracted/A.py,1721,80,267,Python,11254486,1,5648941810974720,alexamici,2016
684,B.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     T = next(infile).split()
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import itertools as it
 
     def partial(res_c, res_j, T0, T1):
         if len(T0) == 0:
             return res_c, res_j
 
         c = T0[0]
         j = T1[0]
         T0 = T0[1:]
         T1 = T1[1:]
 
         if c != '?':
             nc = [c]
         else:
             nc = list('0123456789')
 
         if j != '?':
             nj = [j]
         else:
             nj = list('0123456789')
 
         mm = [9999, '9999', '9999']
         for nnc, nnj in it.product(nc, nj):
             rc, rj = partial(res_c + nnc, res_j + nnj, T0, T1)
             if abs(int(rc) - int(rj)) < mm[0] or \
                 (abs(int(rc) - int(rj)) == mm[0] and rc < mm[1]) or \
                 (abs(int(rc) - int(rj)) == mm[0] and rc == mm[1] and rj < mm[2]):
                 mm = [abs(int(rc) - int(rj)), rc, rj]
         return mm[1], mm[2]
     res_c, res_j = partial('0', '0', T[0], T[1])
     return 'Case #{:d}: {} {}'.format(tc, res_c[1:], res_j[1:])
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2016/11254486/alexamici/5695413893988352/0/extracted/B.py,1607,63,203,Python,11254486,0,5695413893988352,alexamici,2016
685,B.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     P = map(int, next(infile).split())
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import itertools as it
     import networkx as nx
     import time
 
     B, M = P
     start = time.time()
     for SB in it.product([0, 1], repeat=B * (B - 1)):
         if time.time() > start + 200.:
             res = 'IMPOSSIBLE'
             break
         skip = False
         G = nx.DiGraph()
         for i, s in enumerate(SB):
             x, y = i // B, i % B
             if x >= y and s:
                 skip = True
                 break
             if s:
                 G.add_edge(x, y)
         if not skip and 0 in G and B - 1 in G and nx.is_directed_acyclic_graph(G):
             mm = len(list(nx.all_simple_paths(G, 0, B-1)))
             if mm == M:
                 res = 'POSSIBLE\n' + '\n'.join(''.join(str(v)for v in SB[i*B:(i+1)*B]) for i in range(B - 1)) + '\n' + '0' * B
                 break
     else:
         res = 'IMPOSSIBLE'
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2016/4314486/alexamici/5744014401732608/0/extracted/B.py,1642,61,208,Python,4314486,0,5744014401732608,alexamici,2016
686,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import os
 import sys
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     N = int(next(infile))
     P = map(int, next(infile).split())
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
 
     P = dict(zip('ABCDEFGHIJKLMNOPQRSTUVWXYZ', P))
     res = ''
     while P:
         S = sorted(P.items(), key=lambda i: i[1], reverse=True)
         if S[0][1] == S[1][1] and len(P) == 2:
             res += S[0][0] + S[1][0] + ' '
             P[S[0][0]] -= 1
             P[S[1][0]] -= 1
             if P[S[0][0]] == 0:
                 P.pop(S[0][0])
                 P.pop(S[1][0])
         else:
             res += S[0][0] + ' '
             P[S[0][0]] -= 1
             if P[S[0][0]] == 0:
                 P.pop(S[0][0])
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2016/4314486/alexamici/5753053697277952/1/extracted/A.py,1304,52,149,Python,4314486,1,5753053697277952,alexamici,2016
687,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     P = list(map(int, next(infile).split()))
     S = [next(infile).strip() for _ in range(P[0])]
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import numpy as np
 
     res = np.asarray([list(s) for s in S])
     def expand(res):
         for i in range(res.shape[0]):
             if sum(l=='?' for l in res[i]) == res.shape[1] and i > 0:
                 res[i] = res[i - 1]
             else:
                 cc = -1
                 for j in range(res.shape[1]):
                     if res[i, j] == '?':
                         if cc < 0:
                             continue
                         else:
                             res[i, j] = res[i, cc]
                     else:
                         cc = j
         return res
     res = expand(res[::-1, ::-1])
     res = expand(res[::-1, ::-1])
     return 'Case #{:d}:\n{}'.format(tc, '\n'.join(''.join(l) for l in res.tolist()))
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/5304486/alexamici/5760761888505856/1/extracted/A.py,1438,52,160,Python,5304486,1,5760761888505856,alexamici,2017
688,B.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     N = int(next(infile))
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
 
     res = str(N)
     n = 2
     while True:
         if n > len(res):
             break
         if int(res[-n]) <= int(res[1-n]):
             n += 1
         else:
             res = str(int(str(int(res[:-n+1]) - 1) + '9' * (n - 1)))
             n += 1
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/3264486/alexamici/5633382285312000/1/extracted/B.py,908,42,112,Python,3264486,1,5633382285312000,alexamici,2017
689,A.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import os
 import sys
 #sys.setrecursionlimit(20000)
 
 
 def common_setup():
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
     pass
 
 
 def case_reader(tc, infile):
     #N = int(next(infile))
     #P = map(int, next(infile).split())
     #I = [map(int, next(infile).split()) for _ in range(P[0])]
     T = next(infile).split()
     #S = [next(infile).strip() for _ in range(N)]
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     #import collections as co
     #import functools32 as ft
     #import itertools as it
     #import math as ma
     #import networkx as nx
     #import numpy as np
     #import operator as op
     #import random as rn
     #import re
     #import scipy as sp
     #import heapq as hq
     #import memcache as mc
     #C = mc.Client(['127.0.0.1:11211'])
 
     S, K = T[0], int(T[1])
 
     res = 0
     s = S
     for i in range(len(S) - K + 1):
         if s[0] == '-':
             s = ''.join('+' if c=='-' else '-' for c in s[1:K]) + s[K:]
             res += 1
         else:
             s = s[1:]
 
     if set(s) != set(['+']):
         res = 'IMPOSSIBLE'
 
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/3264486/alexamici/5736519012712448/1/extracted/A.py,1615,67,208,Python,3264486,1,5736519012712448,alexamici,2017
690,C.py,"""""""Usage:
     pypy -u X.py < X-test.in > X-test.out
 or sometimes:
     python -u X.py < X-test.in > X-test.out
 may be python 2 or 3.
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     P = map(int, next(infile).split())
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     N, K = P
     S = {N: 1}
     while True:
         n = max(S)
         k = S.pop(n)
         if K <= k:
             break
         m = (n - 1) // 2
         S[m] = S.get(m, 0) + k
         S[n - m - 1] = S.get(n - m - 1, 0) + k
         K -= k
     m = (n - 1) // 2
     return 'Case #{:d}: {} {}'.format(tc, n - m - 1, m)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/3264486/alexamici/5654742835396608/2/extracted/C.py,944,43,142,Python,3264486,2,5654742835396608,alexamici,2017
691,A.py,"""""""Usage:
     pypy3 -u X.py < X-test.in > X-test.out
 or sometimes:
     python3 -u X.py < X-test.in > X-test.out
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     P = list(map(int, next(infile).split()))
     I = [list(map(int, next(infile).split()) )for _ in range(P[1])]
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     D, N = P
     t = 0
     for k, s in I:
         t = max(t, (D - k) / s)
     return 'Case #{:d}: {}'.format(tc, D / t)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/8294486/alexamici/5630967708385280/1/extracted/A.py,794,35,102,Python,8294486,1,5630967708385280,alexamici,2017
692,B.py,"""""""Usage:
     pypy3 -u X.py < X-test.in > X-test.out
 or sometimes:
     python3 -u X.py < X-test.in > X-test.out
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     P = list(map(int, next(infile).split()))
     del infile
     return locals()
 
 # def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
 #     N, R, O, Y, G, B, V = P
 #     S = sorted([(R, 'R'), (Y, 'Y'), (B, 'B')])
 #     if S[2][0] <= S[1][0] + 1:
 #         res = ''.join(a+b+c for a,b,c in zip(S[0][1] * S[0][0], S[1][1] * S[1][0], S[2][1] * S[2][0]))
 #         res = ''.join(a+b for a,b in zip(S[1][1] * (S[1][0] - S[0][0]), S[2][1] * S[2][0])) + res
 #     else:
 #         res = 'IMPOSSIBLE'
 #     return 'Case #{:d}: {}'.format(tc, res)
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import collections as co
 
     N, R, O, Y, G, B, V = P
     Q = co.deque()
     Q.append(('', R, Y, B))
     while Q:
         s, r, y, b = Q.popleft()
         mm = min(r, y, b)
         if r > mm and s[-1:] != 'R':
             Q.appendleft((s + 'R', r - 1, y, b))
         if y > mm and s[-1:] != 'Y':
             Q.appendleft((s + 'Y', r, y - 1, b))
         if b > mm and s[-1:] != 'B':
             Q.appendleft((s + 'B', r, y, b - 1))
         if r > 0 and r == b == y:
             if s[-1:] != 'R' and s[:1] != 'B':
                 res = s + 'RYB' * mm
             elif s[-1:] != 'Y' and s[:1] != 'B':
                 res = s + 'YRB' * mm
             elif s[-1:] != 'R' and s[:1] != 'Y':
                 res = s + 'RBY' * mm
             elif s[-1:] != 'B' and s[:1] != 'Y':
                 res = s + 'BRY' * mm
             elif s[-1:] != 'B' and s[:1] != 'R':
                 res = s + 'BYR' * mm
             elif s[-1:] != 'Y' and s[:1] != 'R':
                 res = s + 'YBR' * mm
             break
     else:
         res = 'IMPOSSIBLE'
 
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/8294486/alexamici/5654117850546176/0/extracted/B.py,2201,70,338,Python,8294486,0,5654117850546176,alexamici,2017
693,C.py,"""""""Usage:
     pypy3 -u X.py < X-test.in > X-test.out
 or sometimes:
     python3 -u X.py < X-test.in > X-test.out
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 import heapq as hq
 class priorityDictionary(dict):
     def __init__(self):
         self.__heap = []
         dict.__init__(self)
     def smallest(self):
         heap = self.__heap
         while heap[0][1] not in self or self[heap[0][1]] != heap[0][0]:
             hq.heappop(heap)
         return heap[0][1]
     def __iter__(self):
         def iterfn():
             while len(self) > 0:
                 x = self.smallest()
                 yield x
                 del self[x]
         return iterfn()
     def __setitem__(self,key,val):
         dict.__setitem__(self,key,val)
         heap = self.__heap
         if len(heap) > 2 * len(self):
             self.__heap = [(v,k) for k,v in self.iteritems()]
             hq.heapify(self.__heap)
         else:
             hq.heappush(heap, (val,key))
 
 
 
 def case_reader(tc, infile):
     P = list(map(int, next(infile).split()))
     I = [list(map(int, next(infile).split())) for _ in range(P[0])]
     T = [list(map(int, next(infile).split())) for _ in range(P[0])]
     S = [list(map(int, next(infile).split())) for _ in range(P[1])]
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
 
     N, Q = P
     G = {}
     for u, i in enumerate(T):
         G[u + 1] = {}
         for v, d in enumerate(i):
             if d >= 0:
                 G[u + 1][v + 1] = d
     res = []
     for start, end in S:
         D = {}  # dictionary of final distances
         Q = priorityDictionary()   # est.dist. of non-final vert.
         Q[(start, I[start - 1][0], I[start - 1][1])] = 0
 
         for state in Q:
             D[state] = Q[state]
             v, e, s = state
             if v == end:
                 res.append(D[state])
                 break
 
             for w in G[v]:
                 ee = e - G[v][w]
                 if ee >= 0:
                     wLength = D[state] + G[v][w] / s
                     if (w, ee, s) not in Q or wLength < Q[(w, ee, s)]:
                         Q[w, ee, s] = wLength
                 el, sl = I[v - 1]
                 ee = el - G[v][w]
                 if ee >= 0:
                     wLength = D[state] + G[v][w] / sl
                     if (w, ee, sl) not in Q or wLength < Q[(w, ee, sl)]:
                         Q[w, ee, sl] = wLength
     return 'Case #{:d}: {}'.format(tc, ' '.join(f'{d}' for d in res))
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/8294486/alexamici/5681755159789568/1/extracted/C.py,2806,93,332,Python,8294486,1,5681755159789568,alexamici,2017
694,B.py,"""""""Usage:
     pypy3 -u X.py < X-test.in > X-test.out
 or sometimes:
     python3 -u X.py < X-test.in > X-test.out
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     #N = int(next(infile))
     P = list(map(int, next(infile).split()))
     I = [list(map(int, next(infile).split())) for _ in range(P[0] + P[1])]
     #T = next(infile).split()
     #S = [next(infile).strip() for _ in range(P[0] + P[1])]
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     AC, AJ = P
     I = [(b, e, i < AC) for i, (b, e) in enumerate(I)]
     I.sort()
     res = 4
     for cb in range(720):
         ce = cb + 720
         for p in [True, False]:
             if all(p!=bp or (b>=cb and e<=ce) for b, e, bp in I)\
                 and all(p==bp or (e<=cb or b>=ce) for b, e, bp in I):
                 res = 2
 
     return 'Case #{:d}: {}'.format(tc, res)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/3274486/alexamici/5706636844859392/0/extracted/B.py,1188,45,159,Python,3274486,0,5706636844859392,alexamici,2017
695,A.py,"""""""Usage:
     pypy3 -u X.py < X-test.in > X-test.out
 or sometimes:
     python3 -u X.py < X-test.in > X-test.out
 """"""
 from __future__ import print_function
 
 import sys
 
 
 def common_setup():
     pass
 
 
 def case_reader(tc, infile):
     #N = int(next(infile))
     P = list(map(int, next(infile).split()))
     I = [list(map(int, next(infile).split())) for _ in range(P[0])]
     #T = next(infile).split()
     #S = [next(infile).strip() for _ in range(N)]
     del infile
     return locals()
 
 
 def case_solver(tc, N=None, P=None, I=None, T=None, S=None, **kwargs):
     import math
     N, K = P
     res = 0.
     for i, (r, h) in enumerate(I):
         rres = r ** 2 + r * 2 * h
         II = [(rr, hh) for ii, (rr, hh) in enumerate(I) if rr <= r and ii != i]
         if len(II) < K - 1:
             continue
         for rr, hh in sorted(II, key=lambda x: x[0] * x[1], reverse=True)[:K - 1]:
             rres += rr * 2 * hh
         res = max(res, rres)
     return 'Case #{:d}: {}'.format(tc, res * math.pi)
 
 
 if __name__ == '__main__':
     common_setup()
     cases = [case_reader(tc, sys.stdin) for tc in range(1, int(next(sys.stdin)) + 1)]
     for case in cases:
         print(case_solver(**case))
",gcj/2017/3274486/alexamici/5768968631484416/1/extracted/A.py,1229,45,170,Python,3274486,1,5768968631484416,alexamici,2017
696,000000000004991b.PYTHON3,"import random
import copy

def s(D, N, n):
    DD = []
    m = 0
    for i in range(N):
        DD.append([])
        for j in range(N):
            if D[i][j] is None:
                DD[-1].append(0)
                continue
            DD[-1].append(sum(D[i][j] == D[i][jj] for jj in range(N)) + sum(D[i][j] == D[ii][j] for ii in range(N)) - 2)
            m = max(m, DD[-1][-1])
    if m:
        prob = 1. / sum(d.count(m) for d in DD)
        for i in range(N):
            for j in range(N):
                if DD[i][j] == m and (random.random() <= prob or  n == 0):
                    D[i][j] = None
                    return True
    return m != 0


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    D = []
    for i in range(N):
        D.append(list(map(int, input().split())))
    DD = copy.deepcopy(D)
    res = float('inf')
    for n in range(100):
        R = 0
        D = copy.deepcopy(DD)
        while s(D, N, n):
            R += 1
        res = min(res, R)
    print('Case #{tc}: {res}'.format(**locals()))

",,1050,41,142,Python,7706,000000000004991b,0000000000045875,alexamici,2018
697,0000000000049818.PYTHON3,"import random
import copy

def s(D, N, n):
    DD = []
    m = 0
    for i in range(N):
        DD.append([])
        for j in range(N):
            if D[i][j] is None:
                DD[-1].append(0)
                continue
            DD[-1].append(sum(D[i][j] == D[i][jj] for jj in range(N)) + sum(D[i][j] == D[ii][j] for ii in range(N)) - 2)
            m = max(m, DD[-1][-1])
    if m:
        prob = 1. / sum(d.count(m) for d in DD)
        for i in range(N):
            for j in range(N):
                if DD[i][j] == m and (random.random() <= prob or  n == 0):
                    D[i][j] = None
                    return True
    return m != 0


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    D = []
    for i in range(N):
        D.append(list(map(int, input().split())))
    DD = copy.deepcopy(D)
    res = float('inf')
    for n in range(100):
        R = 0
        D = copy.deepcopy(DD)
        while s(D, N, n):
            R += 1
        res = min(res, R)
    print('Case #{tc}: {res}'.format(**locals()))
",,1049,40,142,Python,7706,0000000000049818,0000000000045875,alexamici,2018
698,000000000004951e.PYTHON3,"import random
import copy

def s(D, N, n):
    DD = []
    m = 0
    for i in range(N):
        DD.append([])
        for j in range(N):
            if D[i][j] is None:
                DD[-1].append(0)
                continue
            DD[-1].append(sum(D[i][j] == D[i][jj] for jj in range(N)) + sum(D[i][j] == D[ii][j] for ii in range(N)) - 2)
            m = max(m, DD[-1][-1])
    if m:
        prob = 1. / sum(d.count(m) for d in DD)
        for i in range(N):
            for j in range(N):
                if DD[i][j] == m and (random.random() <= prob or  n == 0):
                    D[i][j] = None
                    return True
    return m != 0


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    D = []
    for i in range(N):
        D.append(list(map(int, input().split())))
    DD = copy.deepcopy(D)
    res = float('inf')
    for n in range(100):
        R = 0
        D = copy.deepcopy(DD)
        while s(D, N, n):
            R += 1
        res = min(res, R)
    print(D)
    print('Case #{tc}: {res}'.format(**locals()))
",,1062,41,143,Python,7706,000000000004951e,0000000000045875,alexamici,2018
699,0000000000048e5b.PYTHON3,"def s(D, N):
    DD = []
    m = 0
    for i in range(N):
        DD.append([])
        for j in range(N):
            if D[i][j] is None:
                DD[-1].append(0)
                continue
            DD[-1].append(sum(D[i][j] == D[i][jj] for jj in range(N)) + sum(D[i][j] == D[ii][j] for ii in range(N)) - 2)
            m = max(m, DD[-1][-1])
    if m:
        for i in range(N):
            for j in range(N):
                if DD[i][j] == m:
                    D[i][j] = None
                    return True
    return False


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    D = []
    for i in range(N):
        D.append(list(map(int, input().split())))
    res = 0
    while s(D, N):
        res += 1
    print('Case #{tc}: {res}'.format(**locals()))
",,788,31,100,Python,7706,0000000000048e5b,0000000000045875,alexamici,2018
700,0000000000047e66.PYTHON3,"def s(B, C):
    c = 0
    res = 1
    sol = ''
    M = {}
    if B[0] == 0 or B[-1] == 0:
        return 'IMPOSSIBLE', sol
    for i, b in enumerate(B):
        if b == 0:
            continue
        res = max(abs(c - i - 1), res)
        M.update({cc: i for cc in range(c, c + b)})
        c += b
        res = max(abs(c - i), res)
    sol = [list('.'* C) for _ in range(res)]
    for s, f in M.items():
        for i in range(s - f):
            sol[i][s - i] = '/'
        for i in range(f - s):
            sol[i][s + i] = '\\'
    return res, '\n'.join(''.join(s) for s in sol)


T = int(input())
for tc in range(1, T + 1):
    C = int(input())
    B = list(map(int, input().split()))
    res, sol = s(B, C)
    if sol:
        print('Case #{tc}: {res}\n{sol}'.format(**locals()))
    else:
        print('Case #{tc}: {res}'.format(**locals()))
",,852,33,135,Python,7706,0000000000047e66,00000000000459f2,alexamici,2018
701,0000000000047dd2.PYTHON3,"def s(B, C):
    c = 0
    res = 1
    sol = ''
    M = {}
    if B[0] == 0 or B[-1] == 0:
        return 'IMPOSSIBLE', sol
    for i, b in enumerate(B):
        if b == 0:
            continue
        res = max(abs(c - i), res)
        M.update({cc: i for cc in range(c, c + b)})
        c += b
        res = max(abs(c - i), res)
    sol = [list('.'* C) for _ in range(res)]
    for s, f in M.items():
        for i in range(s - f):
            sol[i][s - i] = '/'
        for i in range(f - s):
            sol[i][s + i] = '\\'
    return res, '\n'.join(''.join(s) for s in sol)


T = int(input())
for tc in range(1, T + 1):
    C = int(input())
    B = list(map(int, input().split()))
    res, sol = s(B, C)
    if sol:
        print('Case #{tc}: {res}\n{sol}'.format(**locals()))
    else:
        print('Case #{tc}: {res}'.format(**locals()))
",,848,33,133,Python,7706,0000000000047dd2,00000000000459f2,alexamici,2018
702,000000000004746c.PYTHON3,"def s(B, C):
    c = 0
    res = 1
    if B[0] == 0 or B[-1] == 0:
        return 'IMPOSSIBLE'
    for i, b in enumerate(B):
        if b == 0:
            continue
        res = max(abs(c - i), res)
        c += b
        res = max(abs(c - i), res)
    return res

T = int(input())
for tc in range(1, T + 1):
    C = int(input())
    B = list(map(int, input().split()))
    res = s(B, C)
    print('Case #{tc}: {res}'.format(**locals()))
",,439,20,70,Python,7706,000000000004746c,00000000000459f2,alexamici,2018
703,0000000000034a54.PYTHON3,"import itertools as it


def is_valid(BB, CC, R):
    if sum(b > 0 for b in BB) > R:
        return False
    return all(b <= m for (m, _, _), b in zip(CC, BB))

def time_valid(BB, CC):
    return max([s * b + p for (_, s, p), b in zip(CC, BB) if b])


T = int(input())
for tc in range(1, T + 1):
    R, B, C = map(int, input().split())
    CC = [tuple(map(int, input().split())) for _ in range(C)]

    res = float('inf')

    for items in it.product(range(B + 1), repeat=len(CC) - 1):
        if sum(items) > B:
            continue
        items += (B - sum(items),)
        if is_valid(items, CC, R):
            res = min(res, time_valid(items, CC))

    print('Case #{tc}: {res}'.format(**locals()))
",,706,28,109,Python,0000000000007883,0000000000034a54,000000000002fff6,alexamici,2018
704,0000000000034933.PYTHON3,"import itertools as it


def is_valid(BB, CC, R):
    if sum(b > 0 for b in BB) > R:
        return False
    return all(b <= m for (m, _, _), b in zip(CC, BB))

def time_valid(BB, CC):
    return max([s * b + p for (_, s, p), b in zip(CC, BB)])


T = int(input())
for tc in range(1, T + 1):
    R, B, C = map(int, input().split())
    CC = [tuple(map(int, input().split())) for _ in range(C)]

    res = float('inf')

    for items in it.product(range(B + 1), repeat=len(CC) - 1):
        if sum(items) > B:
            continue
        items += (B - sum(items),)
        if is_valid(items, CC, R):
            res = min(res, time_valid(items, CC))

    print('Case #{tc}: {res}'.format(**locals()))
",,701,28,107,Python,0000000000007883,0000000000034933,000000000002fff6,alexamici,2018
705,000000000003444b.PYTHON3,"import itertools as it


def is_valid(BB, CC, R):
    if sum(b > 0 for b in BB) > R:
        return False
    return all(b <= m for (m, _, _), b in zip(CC, BB))

def time_valid(BB, CC):
    return max([s * b + p for (_, s, p), b in zip(CC, BB)])


T = int(input())
for tc in range(1, T + 1):
    R, B, C = map(int, input().split())
    CC = [tuple(map(int, input().split())) for _ in range(C)]

    res = float('inf')

    for items in it.product(range(B + 1), repeat=len(CC) - 1):
        if sum(items) >= B:
            continue
        items += (B - sum(items),)
        if is_valid(items, CC, R):
            res = min(res, time_valid(items, CC))

    print('Case #{tc}: {res}'.format(**locals()))
",,702,28,107,Python,0000000000007883,000000000003444b,000000000002fff6,alexamici,2018
706,0000000000034308.PYTHON3,"import itertools as it

def is_valid(BB, CC, B, R):
    if sum(BB) != B:
        return False
    if sum(b > 0 for b in BB) > R:
        return False
    return all(b <= m for (m, _, _), b in zip(CC, BB))

def time_valid(BB, CC):
    return max([s * b + p for (_, s, p), b in zip(CC, BB)])


T = int(input())
for tc in range(1, T + 1):
    R, B, C = map(int, input().split())
    CC = [tuple(map(int, input().split())) for _ in range(C)]

    res = float('inf')

    for items in it.product(range(B + 1), repeat=len(CC)):
        if is_valid(items, CC, B, R):
            res = min(res, time_valid(items, CC))

    print('Case #{tc}: {res}'.format(**locals()))
",,661,26,103,Python,0000000000007883,0000000000034308,000000000002fff6,alexamici,2018
707,00000000000339ae.PYTHON3,"T = int(input())
for tc in range(1, T + 1):
    N, P = map(int, input().split())
    C = [tuple(map(int, input().split())) for _ in range(N)]
    min_q = 2 * min(C[0])
    max_q = 2 * (C[0][0] ** 2 + C[0][1] ** 2) ** 0.5
    p = 2 * N * (C[0][0] + C[0][1])
    for n in range(N + 1):
        if p + n * min_q <= P:
            res = min(P, p + n * max_q)
    print('Case #{tc}: {res}'.format(**locals()))
",,405,12,75,Python,0000000000007883,00000000000339ae,000000000002fff7,alexamici,2018
708,0000000000033670.PYTHON3,"T = int(input())
for tc in range(1, T + 1):
    N, P = map(int, input().split())
    C = [tuple(map(int, input().split())) for _ in range(N)]
    min_q = 2 * min(C[0])
    max_q = 2 * (C[0][0] ** 2 + C[0][1] ** 2) ** 0.5
    p = 2 * N * (C[0][0] + C[0][1])
    if p + N * max_q <= P:
        res = p + N * max_q
    elif p + min_q <= P:
        res = P
    else:
        res = P
    print('Case #{tc}: {res}'.format(**locals()))
",,429,15,81,Python,0000000000007883,0000000000033670,000000000002fff7,alexamici,2018
709,00000000000334cd.PYTHON3,"T = int(input())
for tc in range(1, T + 1):
    N, P = map(int, input().split())
    C = [tuple(map(int, input().split())) for _ in range(N)]
    min_q = 2 * min(C[0])
    max_q = 2 * (C[0][0] ** 2 + C[0][1] ** 2) ** 0.5
    p = 2 * N * (C[0][0] + C[0][1])
    if p + N * max_q <= P:
        res = p + N * max_q
    elif p + min_q <= P:
        res = P
    else:
        assert False
    print('Case #{tc}: {res}'.format(**locals()))
",,434,15,80,Python,0000000000007883,00000000000334cd,000000000002fff7,alexamici,2018
710,0000000000033599.PYTHON3,"T = int(input())
for tc in range(1, T + 1):
    N, P = map(int, input().split())
    C = [tuple(map(int, input().split())) for _ in range(N)]
    min_q = 2 * min(C[0])
    max_q = 2 * (C[0][0] ** 2 + C[0][1] ** 2) ** 0.5
    p = 2 * N * (C[0][0] + C[0][1])
    if p + N * max_q <= P:
        res = p + N * max_q
    elif p + N * min_q <= P:
        res = P
    else:
        assert False
    print('Case #{tc}: {res}'.format(**locals()))
",,438,15,82,Python,0000000000007883,0000000000033599,000000000002fff7,alexamici,2018
711,0000000000031bf5.PYTHON3,"def solve(R, C, H, V, W):
    T = sum(r.count('@') for r in W)
    NV = T / (V + 1)
    VV = [0]
    for v in range(V + 1):
        for x in range(VV[v] + 1, C + 1):
            if sum(r[VV[v]:x].count('@') for r in W) == NV:
                VV.append(x)
                break
        else:
            return 'IMPOSSIBLE'
    N = NV / (H + 1)
    hh = 0
    for h in range(H + 1):
        for y in range(hh + 1, R + 1):
            if all(sum(r[VV[v]:VV[v + 1]].count('@') for r in W[hh:y]) == N for v in range(len(VV) - 1)):
                hh = y
                break
        else:
            return 'IMPOSSIBLE'
    return 'POSSIBLE'


T = int(input())
for tc in range(1, T + 1):
    R, C, H, V = map(int, input().split())
    W = [input() for i in range(R)]
    res = solve(R, C, H, V, W)
    print('Case #{tc}: {res}'.format(**locals()))
",,846,30,135,Python,0000000000007883,0000000000031bf5,000000000003005a,alexamici,2018
712,000000000001760d.PYTHON3,"import math


def bisect_root(f, l, r, dx):
    assert f(l) <= 0 <= f(r)
    while r - l > dx:
        m = (r + l) / 2
        if f(m) >= 0:
            r = m
        else:
            l = m
    return (r + l) / 2


T = int(input())
for tc in range(T):
    A = float(input())
    if A <= math.sqrt(2.):
        def f(theta):
            return math.cos(theta) + math.sin(theta) - A
        th = bisect_root(f, 0., math.pi / 4, 1.e-15)
        res = [(0, 0.5 * math.cos(th), 0.5 * math.sin(th)), (0, -0.5 * math.sin(th), 0.5 * math.cos(th)), (0.5, 0, 0)]
        fres = '\n'.join('{} {} {}'.format(*r) for r in res)
    else:
        pass
    print('Case #{}:\n{}'.format(tc + 1, fres))
",,686,27,108,Python,00000000000000cb,000000000001760d,00000000000079cc,alexamici,2018
713,0000000000016f56.PYTHON3,"import math


def bisect_root(f, l, r, dx):
    assert f(l) <= 0 <= f(r)
    while r - l > dx:
        m = (r + l) / 2
        if f(m) >= 0:
            r = m
        else:
            l = m
    return r


T = int(input())
for tc in range(T):
    A = float(input())
    def f(theta):
        return math.cos(theta) + math.sin(theta) - A
    th = bisect_root(f, 0., math.pi / 4, 1.e-14)
    res = [(0.5, 0, 0), (0, 0.5 * math.cos(th), 0.5 * math.sin(th)), (0, 0.5 * math.sin(th), 0.5 * math.cos(th))]
    fres = '\n'.join('{} {} {}'.format(*r) for r in res)
    print('Case #{}:\n{}'.format(tc + 1, fres))
",,605,24,98,Python,00000000000000cb,0000000000016f56,00000000000079cc,alexamici,2018
714,0000000000016e90.PYTHON3,"import math


def bisect_root(f, l, r, dx):
    assert f(l) <= 0 <= f(r)
    while r - l > dx:
        m = (r + l) / 2
        if f(m) >= 0:
            r = m
        else:
            l = m
    return r


T = int(input())
for tc in range(T):
    A = float(input())
    def f(theta):
        return math.cos(theta) + math.sin(theta) - A
    th = bisect_root(f, 0., math.pi / 4, 1.e-9)
    res = [(0.5, 0, 0), (0, 0.5 * math.cos(th), 0.5 * math.sin(th)), (0, 0.5 * math.sin(th), 0.5 * math.cos(th))]
    fres = '\n'.join('{} {} {}'.format(*r) for r in res)
    print('Case #{}:\n{}'.format(tc + 1, fres))
",,604,24,98,Python,00000000000000cb,0000000000016e90,00000000000079cc,alexamici,2018
715,00000000000150b7.PYTHON3,"T = int(input())
for tc in range(T):
    A = int(input())
    dep = 2
    done = set()
    count = 0
    for i in range(1000):
        if len(done) == (dep + 1) * 3:
            dep += 2
        print(500, dep)
        depd = tuple(map(int, input().split()))
        if depd == (0, 0):
            break
        done.add(depd)
",,327,15,47,Python,00000000000000cb,00000000000150b7,0000000000007a30,alexamici,2018
716,00000000000147bb.PYTHON3,"T = int(input())
for tc in range(T):
    A = int(input())
    dep = 2
    done = set()
    count = 0
    for i in range(1000):
        if len(done) == (dep + 1) * 3:
            dep += 3
        print(500, dep)
        depd = tuple(map(int, input().split()))
        if depd == (0, 0):
            break
        done.add((depd))
",,329,15,47,Python,00000000000000cb,00000000000147bb,0000000000007a30,alexamici,2018
717,000000000001487c.PYTHON3,"T = int(input())
for tc in range(T):
    A = int(input())
    dep = 2
    done = set()
    count = 0
    for i in range(1000):
        if len(done) == 9 + (dep - 2) * 3:
            dep += 2
        print(500, dep)
        depd = tuple(map(int, input().split()))
        if depd == (0, 0):
            break
        done.add((depd))
",,333,15,49,Python,00000000000000cb,000000000001487c,0000000000007a30,alexamici,2018
718,00000000000112d0.PYTHON3,"T = int(input())
for tc in range(T):
    input()
    V = list(map(int, input().split()))
    last_change = len(V) - 2
    while last_change > 0:
        P = V[:]
        new_last_change = 0
        for i in range(last_change):
            if V[i] > V[i + 2]:
                V[i:i + 3] = V[i:i + 3][::-1]
                new_last_change = i
        last_change = new_last_change
    for res in range(len(V) - 1):
        if V[res] > V[res + 1]:
            break
    else:
        res = 'OK'
    print('Case #%d: %s' % (tc + 1, res))
",,534,20,75,Python,00000000000000cb,00000000000112d0,00000000000079cb,alexamici,2018
719,0000000000011ce2.PYTHON3,"T = int(input())
for tc in range(T):
    input()
    V = list(map(int, input().split()))
    P = []
    while V != P:
        P = V[:]
        for i in range(len(V) - 2):
            if V[i] > V[i + 2]:
                V[i:i + 3] = V[i:i + 3][::-1]
    for res in range(len(V) - 1):
        if V[res] > V[res + 1]:
            break
    else:
        res = 'OK'
    print('Case #%d: %s' % (tc + 1, res))
",,404,17,66,Python,00000000000000cb,0000000000011ce2,00000000000079cb,alexamici,2018
720,0000000000008a21.PYTHON3,"T = int(input())
for tc in range(T):
    input()
    V = list(map(int, input().split()))
    P = []
    while V != P:
        P = V[:]
        for i in range(len(V) - 2):
            if V[i] > V[i + 2]:
                V[i:i + 3] = V[i:i + 3][::-1]
    S = sorted(V)
    if S == V:
        res = 'OK'
    else:
        res = min(i for i, (v, s) in enumerate(zip(V, S)) if s != v)
    print('Case #%d: %s' % (tc + 1, res))
",,422,17,74,Python,00000000000000cb,0000000000008a21,00000000000079cb,alexamici,2018
721,000000000000856d.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    res = 0
    if P.count('S') > D:
        res = 'IMPOSSIBLE'
    else:
        while True:
            P = P.rstrip('C')
            d = 0
            s = 1
            for i in P:
                if i == 'S':
                    d += s
                elif i == 'C':
                    s *= 2
                else:
                    raise RuntimeError
            if d <= D:
                break
            try:
                c = P.rindex('C')
                P = P[:c] + P[c + 1] + P[c] + P[c + 2:]
                res += 1
            except ValueError:
                res = 'IMPOSSIBLE'
                break
    print('Case #%d: %s' % (tc +1, res))
",,744,30,95,Python,00000000000000cb,000000000000856d,0000000000007966,alexamici,2018
722,0000000000008435.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    res = 0
    while True:
        P = P.rstrip('C')
        d = 0
        s = 1
        for i in P:
            if i == 'S':
                d += s
            elif i == 'C':
                s *= 2
            else:
                raise RuntimeError
        if d <= D:
            break
        try:
            c = P.rindex('C')
            P = P[:c] + P[c + 1] + P[c] + P[c + 2:]
            res += 1
        except ValueError:
            res = 'IMPOSSIBLE'
            break
    print('Case #%d: %s' % (tc +1, res))
",,602,27,87,Python,00000000000000cb,0000000000008435,0000000000007966,alexamici,2018
723,0000000000007f9f.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    if 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
    else:
        one = len(P)
        two = 0
    d = one + 2 * two
    res = max(0, d - D)
    if res > two:
        res = 'IMPOSSIBLE'
    print('Case #%d: %s' % (tc +1, res))
",,342,16,62,Python,00000000000000cb,0000000000007f9f,0000000000007966,alexamici,2018
724,000000000000809e.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    if P.count('C') > 1:
        raise RuntimeError
    if 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
    else:
        one = len(P)
        two = 0
    d = one + 2 * two
    res = max(0, d - D)
    if res > two:
        res = 'IMPOSSIBLE'
    print('Case #%d: %s' % (tc +1, res))
",,394,18,68,Python,00000000000000cb,000000000000809e,0000000000007966,alexamici,2018
725,0000000000007e3e.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    if 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
    else:
        one = len(P)
        two = 0
    d = one + 2 * two
    res = d - D
    if res > two:
        res = 'IMPOSSIBLE'
    print('Case #%d: %s' % (tc +1, res))
",,334,16,61,Python,00000000000000cb,0000000000007e3e,0000000000007966,alexamici,2018
726,0000000000007eb6.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    min_d = P.count('S')
    if 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
    else:
        one = len(P)
        two = 0
    res = one + 2 * two - D
    if res > two:
        res = 'IMPOSSIBLE'
    print('Case #%d: %s' % (tc +1, res))
",,349,16,61,Python,00000000000000cb,0000000000007eb6,0000000000007966,alexamici,2018
727,0000000000007ba7.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    min_d = P.count('S')
    if min_d > D:
        res = 'IMPOSSIBLE'
    elif 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
        res = one + 2 * two - D
    else:
        res = 0
    print('Case #%d: %s' % (tc +1, res))
",,334,15,58,Python,00000000000000cb,0000000000007ba7,0000000000007966,alexamici,2018
728,0000000000007d35.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    min_d = P.count('S')
    if min_d > D:
        res = 'IMPOSSIBLE'
    elif 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
        res = one + 2 * two - D
    else:
        res = 0
    print('Case #%d: %d' % (tc +1, res))
",,334,15,58,Python,00000000000000cb,0000000000007d35,0000000000007966,alexamici,2018
729,0000000000007d88.PYTHON3,"T = int(input())
for tc in range(T):
    D, P = input().split()
    D = int(D)
    min_d = P.count('S')
    if min_d > D:
        res = 'IMPOSSIBLE'
    elif 'C' in P:
        one = P.index('C')
        two = len(P) - P.index('C') - 1
        res = one + 2 * two - D
    else:
        res = 0
    print(f'Case #{tc + 1}: {res}')
",,329,15,56,Python,00000000000000cb,0000000000007d88,0000000000007966,alexamici,2018
730,000000000014cccd.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    res = 'IMPOSSIBLE'
    for c, j in itertools.product(list(range(1, 301)), repeat=2):
        lM = [cc * c + jj * j for cc, jj in M]
        if all(lM[i] < lM[i+1] for i in range(len(lM) - 1)):
            res = '%d %d' % (c, j)
            break

    print('Case #{}: {}'.format(case + 1, res))
",,437,14,68,Python,0000000000051679,000000000014cccd,0000000000146184,alexamici,2019
731,000000000014caf7.PYTHON3,"
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]

    CJ = set(range(100))
    for ci, ji in M:
        for cj, jj in M:
            g = gcd(ci - cj, ji - jj)
            if g == 0:
                continue
            cc, jj = (ci - cj) / g , (ji - jj) / g
            CJ.add(abs(cc))
            CJ.add(abs(jj))
            CJ.add(abs(cc + 1))
            CJ.add(abs(jj + 1))
            CJ.add(abs(cc - 1))
            CJ.add(abs(jj - 1))

    if 0 in CJ:
        CJ.discard(0)

    sol = set()
    for c, j in itertools.product(sorted(CJ), repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        lM = [w(m) for m in MM]
        if MM not in sol and all(lM[i] < lM[i + 1] for i in range(len(MM) - 1)):
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,995,39,147,Python,0000000000051679,000000000014caf7,0000000000146183,alexamici,2019
732,000000000014ca6e.PYTHON3,"
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]

    CJ = set(range(100))
    for ci, ji in M:
        for cj, jj in M:
            g = gcd(ci - cj, ji - jj)
            if g == 0:
                continue
            cc, jj = (ci - cj) / g , (ji - jj) / g
            CJ.add(abs(cc))
            CJ.add(abs(jj))
            CJ.add(abs(cc + 1))
            CJ.add(abs(jj + 1))
            CJ.add(abs(cc - 1))
            CJ.add(abs(jj - 1))

    if 0 in CJ:
        CJ.discard(0)

    sol = set()

    res = 'IMPOSSIBLE'
    for c, j in itertools.product(sorted(CJ), repeat=2):
        lM = [cc * c + jj * j for cc, jj in M]
        if all(lM[i] < lM[i+1] for i in range(len(lM) - 1)):
            res = '%d %d' % (c, j)
            break

    print('Case #{}: {}'.format(case + 1, res))
",,945,40,143,Python,0000000000051679,000000000014ca6e,0000000000146184,alexamici,2019
733,000000000014c12f.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]

    CJ = set()
    for ci, ji in M:
        for cj, jj in M:
            CJ.add(abs(ci - cj))
            CJ.add(abs(ji - jj))
            CJ.add(abs(ci - cj + 1))
            CJ.add(abs(ji - jj + 1))
            CJ.add(abs(ci - cj - 1))
            CJ.add(abs(ji - jj - 1))

    if 0 in CJ:
        CJ.discard(0)

    sol = set()
    for c, j in itertools.product(sorted(CJ), repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        lM = [w(m) for m in MM]
        if MM not in sol and all(lM[i] < lM[i + 1] for i in range(len(MM) - 1)):
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,811,29,118,Python,0000000000051679,000000000014c12f,0000000000146183,alexamici,2019
734,00000000001494dc.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    res = 'IMPOSSIBLE'
    for c, j in itertools.product(list(range(1, 101)), repeat=2):
        lM = [cc * c + jj * j for cc, jj in M]
        if all(lM[i] < lM[i+1] for i in range(len(lM) - 1)):
            res = '%d %d' % (c, j)
            break

    print('Case #{}: {}'.format(case + 1, res))
",,437,14,68,Python,0000000000051679,00000000001494dc,0000000000146184,alexamici,2019
735,0000000000148f97.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    res = 'IMPOSSIBLE'
    for c, j in itertools.product(list(range(1, 101)), repeat=2):
        cur = 0
        for cc, jj in M:
            nex = cc * c + jj * j
            if nex <= cur:
                break
            cur = nex
        else:
            res = '%d %d' % (c, j)
            break

    print('Case #{}: {}'.format(case + 1, res))
",,489,19,70,Python,0000000000051679,0000000000148f97,0000000000146184,alexamici,2019
736,0000000000148d74.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    for c, j in itertools.product(list(range(1, 101)), repeat=2):
        cur = 0
        for cc, jj in M:
            nex = cc * c + jj * j
            if nex <= cur:
                break
            cur = nex
        else:
            res = '%d %d' % (c, j)
            break
    else:
        res = 'IMPOSSIBLE'

    print('Case #{}: {}'.format(case + 1, res))
",,503,20,71,Python,0000000000051679,0000000000148d74,0000000000146184,alexamici,2019
737,0000000000148922.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    for j, c in itertools.product(list(range(1, 101)), repeat=2):
        cur = 0
        for cc, jj in M:
            nex = cc * c + jj * j
            if nex <= cur:
                break
            cur = nex
        else:
            res = '%d %d' % (c, j)
            break
    else:
        res = 'IMPOSSIBLE'

    print('Case #{}: {}'.format(case + 1, res))
",,503,20,71,Python,0000000000051679,0000000000148922,0000000000146184,alexamici,2019
738,0000000000148573.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    VV = set([1, 100000])
    VV.update(v + d for m in M for v in m for d in range(2))
    sol = set()
    for c, j in itertools.product(sorted(VV), repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        if MM not in sol and all(w(MM[i]) < w(MM[i + 1]) for i in range(len(MM) - 1)):
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,556,16,86,Python,0000000000051679,0000000000148573,0000000000146183,alexamici,2019
739,0000000000148357.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    V = sorted(set(v + d for m in M for v in m for d in range(2)))
    sol = set()
    for c, j in itertools.product(V, repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        if MM not in sol and all(w(MM[i]) < w(MM[i + 1]) for i in range(len(MM) - 1)):
            print(c, j, MM)
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,555,16,87,Python,0000000000051679,0000000000148357,0000000000146183,alexamici,2019
740,0000000000148118.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    sol = set()
    for c, j in itertools.product(list(range(1, 201)), repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        if MM not in sol and all(w(MM[i]) < w(MM[i + 1]) for i in range(len(MM) - 1)):
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,478,14,68,Python,0000000000051679,0000000000148118,0000000000146183,alexamici,2019
741,0000000000147fec.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    sol = set()
    for c, j in itertools.product(list(range(1, 301)), repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        if MM not in sol and all(w(MM[i]) < w(MM[i + 1]) for i in range(len(MM) - 1)):
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,478,14,68,Python,0000000000051679,0000000000147fec,0000000000146183,alexamici,2019
742,0000000000147f3e.PYTHON3,"import itertools
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    sol = set()
    for c, j in itertools.product(list(range(1, 301)), repeat=2):
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        if MM not in sol and all(w(MM[i]) < w(MM[i + 1]) for i in range(len(MM) - 1)):
            print(c, j, MM)
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,506,15,71,Python,0000000000051679,0000000000147f3e,0000000000146183,alexamici,2019
743,00000000001478f9.PYTHON3,"import random
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    sol = set()
    for _ in range(1000000):
        if _ == 0:
            c = j = 1
        else:
            c, j = random.randint(1, 10000), random.randint(1, 10000)
        def w(x):
            return x[0] * c + x[1] * j
        MM = tuple(sorted(M, key=w))
        if MM not in sol and all(w(MM[i]) < w(MM[i + 1]) for i in range(len(MM) - 1)):
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,563,18,82,Python,0000000000051679,00000000001478f9,0000000000146183,alexamici,2019
744,000000000014740b.PYTHON3,"import random
T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    sol = set()
    for _ in range(10000):
        c, j = random.randint(1, 1000), random.randint(1, 1000)
        MM = tuple(sorted(M, key=lambda x: x[0] * c + x[1] * j))
        if MM not in sol:
            sol.add(MM)
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,410,13,58,Python,0000000000051679,000000000014740b,0000000000146183,alexamici,2019
745,000000000014678e.PYTHON3,"T = int(input())
for case in range(T):
    N = int(input())
    M = [tuple(map(int, input().split())) for _ in range(N)]
    sol = set()
    sol.add(tuple(sorted(M)))
    sol.add(tuple(sorted(M, key=lambda x: (x[1], x[0]))))
    print('Case #{}: {}'.format(case + 1, len(sol)))
",,278,9,33,Python,0000000000051679,000000000014678e,0000000000146183,alexamici,2019
746,000000000010eb63.PYTHON3,"T, N, M = map(int, input().split())
for case in range(T):
    res =[]
    for i in range(7):
        q = (str(18 - i) + ' ') * 18
        print(q, flush=True)
        ans = input()
        sol = sum(map(int, ans.split()))
        res.append(sol)
    all = list(range(res[0], M + 1, 18))
    for i, r in enumerate(res[1:]):
        all = [n for n in all if (n - r) % (17 - i) == 0]
    res = all
    print(res[0])
    resp = input()
    if resp.strip() == '-1':
        break
",,475,18,77,Python,51635,000000000010eb63,0000000000104f1a,alexamici,2019
747,000000000010ba36.PYTHON3,"T, N, M = map(int, input().split())
for case in range(T):
    res = 0
    for _ in range(7):
        print('18 ' * 18, flush=True)
        ans = input()
        sol = sum(map(int, ans.split()))
        res = max(res, sol)
    print(res)
    input()
",,249,11,35,Python,51635,000000000010ba36,0000000000104f1a,alexamici,2019
748,000000000010b942.PYTHON3,"T, N, M = map(int, input().split())
print(T, N, M, file=file, flush=True)
for case in range(T):
    res = 0
    for _ in range(7):
        print('18 ' * 18, flush=True)
        ans = input()
        sol = sum(map(int, ans.split()))
        res = max(res, sol)
    print(res)
    input()
",,287,12,40,Python,51635,000000000010b942,0000000000104f1a,alexamici,2019
749,0000000000108d10.PYTHON3,"import random
T = int(input())
for case in range(T):
    R, C = map(int, input().split())
    if (R, C) in [(2, 2), (2, 3), (3, 3), (2, 4), (3, 2), (4, 2)]:
        print('Case #{}: IMPOSSIBLE'.format(case + 1))
        continue
    rr, cc = 10 * R, 10 * C
    for _ in range(100):
        res = []
        for _ in range(10000):
            r, c = random.randint(1, R), random.randint(1, C)
            if (r, c) in res or r == rr or c == cc or r - c == rr - cc or r + c == rr + cc:
                continue
            res.append((r, c))
            rr, cc = r, c
            if len(res) == R * C:
                break
        if len(res) == R * C:
            res = 'POSSIBLE\n' + '\n'.join('%d %d' % (r, c) for r, c in res)
            break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{}: {}'.format(case + 1, res))
",,832,25,138,Python,51635,0000000000108d10,0000000000104e03,alexamici,2019
750,0000000000108933.PYTHON3,"import random
T = int(input())
for case in range(T):
    R, C = map(int, input().split())
    if (R, C) in [(2, 2), (2, 3), (3, 3), (2, 4), (3, 2), (4, 2)]:
        print('Case #{}: IMPOSSIBLE'.format(case + 1))
        continue
    rr, cc = 10 * R, 10 * C
    for _ in range(100):
        res = []
        for _ in range(10000):
            r, c = random.randint(1, R), random.randint(1, C)
            if (r, c) in res or r == rr or c == cc or r - c == rr - cc or r + c == rr + cc:
                continue
            res.append((r, c))
            rr, cc = r, c
            if len(res) == R * C:
                break
        if len(res) == R * C:
            res = 'POSSIBLE\n' + '\n'.join('%d %d' % (r, c) for r, c in res)
            break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{}: {}{} {}'.format(case + 1, R, C, res[:3]))
",,848,25,142,Python,51635,0000000000108933,0000000000104e03,alexamici,2019
751,0000000000107ac4.PYTHON3,"import random
T = int(input())
for case in range(T):
    R, C = map(int, input().split())
    rr, cc = 10 * R, 10 * C
    for _ in range(100):
        res = []
        for _ in range(100):
            r, c = random.randint(1, R), random.randint(1, C)
            if (r, c) in res or r == rr or c == cc or r - c == rr - cc or r + c == rr + cc:
                continue
            res.append((r, c))
            rr, cc = r, c
            if len(res) == R * C:
                break
        if len(res) == R * C:
            res = 'POSSIBLE\n' + '\n'.join('%d %d' % (r, c) for r, c in res)
            break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{}: {}'.format(case + 1, res))
",,691,22,116,Python,51635,0000000000107ac4,0000000000104e03,alexamici,2019
752,00000000001059bc.PYTHON3,"T = int(input())
for case in range(T):
    N, = map(int, input().split())
    W = [input() for _ in range(N)]
    res = 0
    M = max(len(w) for w in W)
    C = {}
    for w in W:
        for i in range(1, M):
            if len(w) >= i:
                C.setdefault(w[-i:], []).append(w)
    seen = set()
    res = 0
    for _, WW in sorted(C.items(), key=lambda x: -len(x[0])):
        WWW = set(WW) - seen
        if len(WWW) >= 2:
            res += 2
            seen.update(list(WWW)[:2])
    print('Case #{}: {}'.format(case + 1, res))
",,543,20,79,Python,51635,00000000001059bc,0000000000104e05,alexamici,2019
753,00000000000e5474.PYTHON3,"
# log = open('log', 'w')


def test(N, S, bad):
    t = ''
    ostop = 0
    for start, stop, bad_count in S:
        assert stop <= N
        # assert bad_count < stop - start
        t += '0' * (start - ostop)
        u = '0' * bad_count + '1'
        tot = u * ((stop - start) // len(u) + 1)
        j = 0
        for i in range(start, stop):
            if i in bad:
                t += '0'
            else:
                t += tot[j]
                j += 1
        ostop = stop
    return (t + '0' * N)[:N]


def solve_one(req, res, start, stop, bad_count, NS, bad):
    i = start
    j = i - sum(1 for b in bad if b < i)
    while i < stop:
        assert i == start or req[i - 1] == '1'
        next_one = req.find('1', i)
        if next_one == -1:
            bad.update(range(i, stop))
            break
        assert next_one >= 0, [req, res, i, stop, bad_count, NS, bad]
        n = res.find('1', j)

        if n == -1 or n - j > next_one - i:
            bad.add(next_one)
            NS.append((i, stop, bad_count - 1))
            break
        elif n - j == 0:
            bad.update(range(i, next_one))
            break
        elif n - j == next_one - i:
            i = next_one + 1
            j = n + 1
        elif n - j < next_one - i:
            inside_bad_count = (next_one - i) - (n - j)
            NS.append((i, next_one, inside_bad_count))
            bad_count -= inside_bad_count
            i = next_one + 1
            j = n + 1
        else:
            assert False, [n, j, next_one, i]
    return NS


def solve(req, res, S, bad):
    NS = []
    for start, stop, bad_count in S:
        solve_one(req, res, start, stop, bad_count, NS, bad)
    return NS


def main():
    TC = int(input())
    for tc in range(TC):
        N, B, F = map(int, input().split())
        S = [(0, N, B)]
        bad = set()
        for f in range(F):
            req = test(N, S, bad)
            print(req, flush=True)
            res = input().strip()
            if res == '-1':
                raise ValueError
            S = solve(req, res, S, bad)
            # print(req, '-', res, S, bad, file=log, flush=True)
            if len(S) == 0 or len(bad) == B:
                break
        res = ' '.join(str(b) for b in sorted(bad))
        print(res, flush=True)
        ans = input().strip()
        # print(res, '-', ans, file=log, flush=True)
        if ans == '-1':
            break


if __name__ == '__main__':
    main()
",,2459,91,358,Python,51705,00000000000e5474,00000000000881de,alexamici,2019
754,00000000000e4307.PYTHON3,"
# log = open('log', 'w')


def test(N, S, bad):
    t = ''
    ostop = 0
    for start, stop, bad_count in S:
        assert stop <= N
        # assert bad_count < stop - start
        t += '0' * (start - ostop)
        u = '0' * bad_count + '1'
        tot = u * ((stop - start) // len(u) + 1)
        j = 0
        for i in range(start, stop):
            if i in bad:
                t += '0'
            else:
                t += tot[j]
                j += 1
        ostop = stop
    return (t + '0' * N)[:N]


def solve_one(req, res, start, stop, bad_count, NS, bad):
    i = start
    j = i - sum(1 for b in bad if b < i)
    while i < stop:
        assert i == start or req[i - 1] == '1'
        next_one = req.find('1', i)
        #if len(req[i:stop]) == bad_count:
        #    bad.extend(range(i, i + bad_count))
        #    break
        assert next_one >= 0, [req, res, i, stop, bad_count, NS, bad]
        ## print(i, j, repr(req[i:stop]), repr(res[j:]), bad, bad_count, NS, file=log, flush=True)
        n = res.find('1', j)

        if n == -1:
            bad.add(next_one)
            NS.append((i, stop, bad_count - 1))
            break
        elif n - j == 0:
            bad.update(range(i, next_one))
            break
        elif n - j == next_one - i:
            i = next_one + 1
            j = n + 1
        elif n - j < next_one - i:
            inside_bad_count = (next_one - i) - (n - j)
            NS.append((i, next_one, inside_bad_count))
            bad_count -= inside_bad_count
            i = next_one + 1
            j = n + 1
        else:
            assert False, [n, j, next_one, i]
    return NS


def solve(req, res, S, bad):
    NS = []
    for start, stop, bad_count in S:
        solve_one(req, res, start, stop, bad_count, NS, bad)
    return NS


def main():
    TC = int(input())
    for tc in range(TC):
        N, B, F = map(int, input().split())
        S = [(0, N, B)]
        bad = set()
        for f in range(5):
            req = test(N, S, bad)
            print(req, flush=True)
            res = input().strip()
            if res == '-1':
                raise ValueError
            S = solve(req, res, S, bad)
            #print(req, '-', res, S, bad, file=log, flush=True)
            if len(S) == 0 or len(bad) == B:
                break
        res = ' '.join(str(b) for b in sorted(bad))
        print(res, flush=True)
        ans = input().strip()
        #print(res, '-', ans, file=log, flush=True)
        if ans == '-1':
            break


if __name__ == '__main__':
    main()
",,2559,92,362,Python,51705,00000000000e4307,00000000000881de,alexamici,2019
755,00000000000bcf59.PYTHON3,"
# log = open('log', 'w')


def test(N, S, known_bad):
    t = ''
    ostop = 0
    ounkown_bad_count = 0
    for start, stop, unkown_bad_count in S:
        t += '0' * (start - ostop - ounkown_bad_count)
        u = '1' + '0' * unkown_bad_count
        t += (u * (N // len(u) + 1))
    return t[:N]


def solve(req, res, S, bad):
    NS = []
    for start, stop, unkown_bad_count in S:
        i = start
        j = start - sum(1 for b in bad if b < start)
        while i < stop:
            # print(i, j, repr(req[i:]), repr(res[j:]), bad, unkown_bad_count, NS, file=log, flush=True)
            if req[i] == '1':
                if res[j] == '0':
                    bad.append(i)
                    unkown_bad_count -= 1
                else:
                    j += 1
                i += 1
            else:
                if res[j:j + unkown_bad_count + 1] == '0' * unkown_bad_count + '1':
                    i += unkown_bad_count
                    j += unkown_bad_count
                elif len(req[i:]) == unkown_bad_count:
                    bad.extend(list(range(i, i + unkown_bad_count)))
                    # print(bad, unkown_bad_count, NS, file=log, flush=True)
                    break
                else:
                    NS.append((i, stop, unkown_bad_count))
                    break
    return NS


TC = int(input())
for tc in range(TC):
    N, B, F = map(int, input().split())
    S = [(0, N, B)]
    bad = []
    for f in range(5):
        req = test(N, S, bad)
        print(req, flush=True)
        res = input().strip()
        if res == '-1':
            raise ValueError
        S = solve(req, res, S, bad)
        # print(req, '-', res, S, bad, file=log, flush=True)
        if len(S) == 0:
            break
    res = ' '.join(str(b) for b in bad)
    print(res, flush=True)
    ans = input().strip()
    # print(res, '-', ans, file=log, flush=True)
    if ans == '-1':
        break
",,1929,65,239,Python,51705,00000000000bcf59,00000000000881de,alexamici,2019
756,0000000000091ed7.PYTHON3,"TC = int(input())
for tc in range(TC):
    N, B, F = map(int, input().split())
    s = '0' * (N - 1)
    good = []
    for f in range(min(N, F)):
        t = s[:f] + '1' + s[f:]
        print(t, flush=True)
        ans = input().strip()
        # print(t, '-', ans, file=sys.stderr, flush=True)
        if '1' in ans:
            good.append(f)
        if len(good) == N - B:
            break
    res = ' '.join(str(i) if i not in good else '' for i in range(N))
    print(res)
    ans = input().strip()
    # print(res, '-', ans, file=sys.stderr, flush=True)
    if ans == '-1':
        break
",,595,21,88,Python,51705,0000000000091ed7,00000000000881de,alexamici,2019
757,0000000000091dd4.PYTHON3,"import sys


TC = int(input())
for tc in range(TC):
    N, B, F = map(int, input().split())
    s = '0' * (N - 1)
    good = []
    for f in range(min(N, F)):
        t = s[:f] + '1' + s[f:]
        print(t, flush=True)
        ans = input().strip()
        print(t, '-', ans, file=sys.stderr, flush=True)
        if '1' in ans:
            good.append(f)
        if len(good) == N - B:
            break
    res = ' '.join(str(i) if i not in good else '' for i in range(N))
    print(res)
    ans = input().strip()
    print(res, '-', ans, file=sys.stderr, flush=True)
",,570,22,83,Python,51705,0000000000091dd4,00000000000881de,alexamici,2019
758,000000000008fb6a.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().strip().split())
    C = list(map(int, input().strip().split()))
    for i in range(1, len(C)):
        if C[i - 1] != C[i]:
            break
    p = gcd(C[i - 1], C[i])
    res = [C[i - 1] // p, p]
    for c in C[i:]:
        res.append(c // res[-1])
    ires = [C[i - 1] // p]
    for c in reversed(C[:i - 1]):
        ires.append(c // ires[-1])
    res = ires[1:][::-1] + res
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(set(res)))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,686,25,109,Python,51705,000000000008fb6a,000000000008830b,alexamici,2019
759,000000000008f1cb.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().strip().split())
    C = list(map(int, input().strip().split()))
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,506,20,76,Python,51705,000000000008f1cb,000000000008830b,alexamici,2019
760,000000000008eb12.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# linguo solution optimized (handles n=800m on a 4Gb machine)
def primes_upto(n, dtype='uint32'):
    import numpy as np

    P = np.arange(n + 1, dtype=dtype)
    P[1] = 0
    for p in range(2, int(n ** 0.5) + 1):
        if P[p]:
            P[p*p::p] = 0
    return [int(p) for p in P if p] # lower memory variant

TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    for p in primes_upto(N + 1):
        if C[0] % p == 0 and C[1] % p == 0:
            break
    # p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    for c in C[1:]:
        res.append(c // res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(set(res)))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,871,31,144,Python,51705,000000000008eb12,000000000008830b,alexamici,2019
761,000000000008e689.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    for c in C[1:]:
        res.append(c // res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(set(res)))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,457,18,72,Python,51705,000000000008e689,000000000008830b,alexamici,2019
762,000000000008e3c4.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    print('Case #{:d}: {}'.format(tc + 1, 'PIPPO'))
    continue
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,555,22,83,Python,51705,000000000008e3c4,000000000008830b,alexamici,2019
763,000000000008e4d5.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    if len(P) != 26:
        print('Case #{:d}: {}'.format(tc + 1, 'PIPPO'))
        continue
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,584,23,87,Python,51705,000000000008e4d5,000000000008830b,alexamici,2019
764,000000000008df1a.PYTHON,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(raw_input())
for tc in range(TC):
    N, _ = map(int, raw_input().split())
    C = list(map(int, raw_input().split()))
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    if len(P) != 26:
        import time
        time.sleep(200)
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,567,23,83,Python,51705,000000000008df1a,000000000008830b,alexamici,2019
765,000000000008ddf4.PYTHON,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(raw_input())
for tc in range(TC):
    N, _ = map(int, raw_input().split())
    C = list(map(int, raw_input().split()))
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,502,20,76,Python,51705,000000000008ddf4,000000000008830b,alexamici,2019
766,000000000008db06.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    p = gcd(C[0], C[1])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,490,20,76,Python,51705,000000000008db06,000000000008830b,alexamici,2019
767,000000000008cdc0.PYTHON3,"# python fractions implementation
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    if C[0] > C[1]:
        p = gcd(C[0], C[1])
    else:
        p = gcd(C[1], C[0])
    res = [C[0] // p, p]
    P = set(res)
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,552,23,85,Python,51705,000000000008cdc0,000000000008830b,alexamici,2019
768,000000000008c00b.PYTHON3,"# linguo solution optimized (handles n=800m on a 4Gb machine)
def primes_upto(n, dtype='uint32'):
    import numpy as np
    P = np.arange(n + 1, dtype=dtype)
    P[1] = 0
    for p in range(2, int(n ** 0.5) + 1):
        if P[p]:
            P[p*p::p] = 0
    return [p for p in P if p] # lower memory variant


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in primes_upto(N):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    else:
        assert False
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,1001,36,136,Python,51705,000000000008c00b,000000000008830b,alexamici,2019
769,000000000008bf78.PYTHON3,"# linguo solution optimized (handles n=800m on a 4Gb machine)
def primes_upto(n, dtype='uint32'):
    import numpy as np
    P = np.arange(n + 1, dtype=dtype)
    P[1] = 0
    for p in range(2, int(n ** 0.5) + 1):
        if P[p]:
            P[p*p::p] = 0
    return [p for p in P if p] # lower memory variant


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in primes_upto(N):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    else:
        False
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,994,36,135,Python,51705,000000000008bf78,000000000008830b,alexamici,2019
770,000000000008befb.PYTHON3,"# linguo solution optimized (handles n=800m on a 4Gb machine)
def primes_upto(n, dtype='uint32'):
    import numpy as np
    P = np.arange(n + 1, dtype=dtype)
    P[1] = 0
    for p in range(2, int(n ** 0.5) + 1):
        if P[p]:
            P[p*p::p] = 0
    return [p for p in P if p] # lower memory variant


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in primes_upto(N):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,970,34,133,Python,51705,000000000008befb,000000000008830b,alexamici,2019
771,000000000008bda2.PYTHON3,"# linguo solution optimized (handles n=800m on a 4Gb machine)
def primes_upto(n, dtype='uint32'):
    import numpy as np
    P = np.arange(n + 1, dtype=dtype)
    P[1] = 0
    for p in range(2, int(n ** 0.5) + 1):
        if P[p]:
            P[p*p::p] = 0
    # return [p for p in P if p] # lower memory variant
    return P[P>0]


TC = int(input())
for tc in range(TC):
    N, _ = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in primes_upto(N):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,990,35,136,Python,51705,000000000008bda2,000000000008830b,alexamici,2019
772,000000000008b7f1.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, L = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in range(3, N + 20, 2):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,663,24,85,Python,51705,000000000008b7f1,000000000008830b,alexamici,2019
773,000000000008ae9c.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, = map(int, input().split())
    res = ''.join('E' if m == 'S' else 'S' for m in input())
    print('Case #{:d}: {}'.format(tc + 1, res))
",,184,7,30,Python,51705,000000000008ae9c,00000000000881da,alexamici,2019
774,000000000008ac96.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, = map(int, input().split())
    res = ''.join('E' if m == 'S' else 'S' for m in input())
    print('Case #{:d}: {}'.format(tc, res))
",,180,7,28,Python,51705,000000000008ac96,00000000000881da,alexamici,2019
775,000000000008a731.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, = map(int, input().split())
    P = input()
    if P[0] == 'E':
        res = 'S' + P[1:-1] + 'E'
    else:
        res = 'E' + P[1:-1] + 'S'
    print('Case #{:d}: {}'.format(tc, res))
",,233,11,37,Python,51705,000000000008a731,00000000000881da,alexamici,2019
776,0000000000089dd7.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, = map(int, input().split())
    c1 = ''
    c2 = ''
    for d in str(N):
        if d == '4':
            c1 += '3'
            c2 += '1'
        else:
            c1 += d
            c2 += '0'
    print('Case #{:d}: {}'.format(tc + 1, str(int(c1)) + ' ' + str(int(c2))))
",,319,15,49,Python,51705,0000000000089dd7,0000000000088231,alexamici,2019
777,000000000008972d.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, L = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in range(3, N + 2, 2):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,662,24,85,Python,51705,000000000008972d,000000000008830b,alexamici,2019
778,0000000000089156.PYTHON3,"
TC = int(input())
for tc in range(TC):
    N, L = map(int, input().split())
    C = list(map(int, input().split()))
    P = set()
    res = []
    for n in range(3, N + 1, 2):
        if C[0] % n == 0:
            P.add(n)
            P.add(C[0] // n)
            if C[1] % n == 0:
                res.append(C[0] // n)
                res.append(n)
            else:
                res.append(n)
                res.append(C[0] // n)
            break
    for c in C[1:]:
        res.append(c // res[-1])
        P.add(res[-1])
    CR = {p: chr(i + 65) for i, p in enumerate(sorted(P))}
    print('Case #{:d}: {}'.format(tc + 1, ''.join(CR[r] for r in res)))
",,662,24,85,Python,51705,0000000000089156,000000000008830b,alexamici,2019
779,0000000000293c30,"import collections as co
import itertools as it
import numpy as np

LS = {
    2: [
        np.array([[1, 2], [2, 1]])
    ],
    3: [
        np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])
    ],
    4: [
        np.array([[1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1]]),
        np.array([[1, 2, 3, 4], [2, 4, 1, 3], [3, 1, 4, 2], [4, 3, 2, 1]])
    ],
    5: [
        np.array([[1, 2, 3, 4, 5], [2, 3, 5, 1, 4], [3, 5, 4, 2, 1], [4, 1, 2, 5, 3], [5, 4, 1, 3, 2]]),
        np.array([[1, 2, 3, 4, 5], [2, 4, 1, 5, 3], [3, 5, 4, 2, 1], [4, 1, 5, 3, 2], [5, 3, 2, 1, 4]]),
    ]
}

def is_latin_rectangle(rows):
    valid = True
    for row in rows:
        if len(set(row)) < len(row):
            valid = False
    if valid and rows:
        for i, val in enumerate(rows[0]):
            col = [row[i] for row in rows]
            if len(set(col)) < len(col):
                valid = False
                break
    return valid

def is_latin_square(rows):
    return is_latin_rectangle(rows) and len(rows) == len(rows[0])

for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    res = None
    for items in it.combinations_with_replacement(range(1, N + 1), N):
        s = sum(items)
        if s != K:
            continue
        for ls in LS[N]:
            M = ls.copy()
            for i, item in enumerate(items):
                c = (M[i] == item).argmax()
                if c == i:
                    continue
                if c < i:
                    r = (M[:, i] == item).argmax()
                    if r < i:
                        break
                    tmp = M[i].copy()
                    M[i] = M[r]
                    M[r] = tmp
                else:
                    tmp = M[:, i].copy()
                    M[:, i] = M[:, c]
                    M[:, c] = tmp
                assert is_latin_square(M.tolist()), M
            else:
                res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in m) for m in M)
                break
    if res is None:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000293c30.PYTHON3,2104,69,293,Python,000000000019fd27,0000000000293c30,0000000000209aa0,alexamici,2020
780,000000000029227d,"import collections as co
import itertools as it
import numpy as np

LS = {
    2: [
        np.array([[1, 2], [2, 1]])
    ],
    3: [
        np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])
    ],
    4: [
        np.array([[1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1]]),
        np.array([[1, 2, 3, 4], [2, 4, 1, 3], [3, 1, 4, 2], [4, 3, 2, 1]])
    ],
    5: [
        np.array([[1, 2, 3, 4, 5], [2, 3, 5, 1, 4], [3, 5, 4, 2, 1], [4, 1, 2, 5, 3], [5, 4, 1, 3, 2]]),
        np.array([[1, 2, 3, 4, 5], [2, 4, 1, 5, 3], [3, 5, 4, 2, 1], [4, 1, 5, 3, 2], [5, 3, 2, 1, 4]]),
    ]
}



for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    res = None
    for items in it.combinations_with_replacement(range(1, N + 1), N):
        s = sum(items)
        if s != K:
            continue
        for ls in LS[N]:
            M = ls.copy()
            for i, item in enumerate(items):
                c = (M[i] == item).argmax()
                if c < i:
                    break
                if c == i:
                    continue
                tmp = M[:, i].copy()
                M[:, i] = M[:, c]
                M[:, c] = tmp
            else:
                res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in m) for m in M)
                break
    if res == None:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",000000000029227d.PYTHON3,1388,48,220,Python,000000000019fd27,000000000029227d,0000000000209aa0,alexamici,2020
781,0000000000291e45,"import collections as co
import itertools as it
import numpy as np

LS = {
    2: [
        np.array([[1, 2], [2, 1]])
    ],
    3: [
        np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])
    ],
    4: [
        np.array([[1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1]]),
        np.array([[1, 2, 3, 4], [2, 4, 1, 3], [3, 1, 4, 2], [4, 3, 2, 1]])
    ],
    5: [
        np.array([[1, 2, 3, 4, 5], [2, 3, 5, 1, 4], [3, 5, 4, 2, 1], [4, 1, 2, 5, 3], [5, 4, 1, 3, 2]]),
        np.array([[1, 2, 3, 4, 5], [2, 4, 1, 5, 3], [3, 5, 4, 2, 1], [4, 1, 5, 3, 2], [5, 3, 2, 1, 4]]),
    ]
}


for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    res = None
    for items in it.combinations_with_replacement(range(1, N + 1), N):
        s = sum(items)
        if s < K:
            continue
        elif s > K:
            continue
        if N - 1 in co.Counter(items).values():
            continue
        for ls in LS[N]:
            M = ls.copy()
            for i, item in enumerate(items):
                c = (M[i] == item).argmax()
                if c < i:
                    break
                if c == i:
                    continue
                tmp = M[:, i].copy()
                M[:, i] = M[:, c]
                M[:, c] = tmp
            else:
                res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in m) for m in M)
                break
    if res == None:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000291e45.PYTHON3,1496,51,232,Python,000000000019fd27,0000000000291e45,0000000000209aa0,alexamici,2020
782,0000000000291b0a,"import collections as co
import itertools as it
import numpy as np

LS = {
    2: [
        np.array([[1, 2], [2, 1]])
    ],
    3: [
        np.array([[1, 2, 3], [2, 3, 1], [3, 1, 2]])
    ],
    4: [
        np.array([[1, 2, 3, 4], [2, 1, 4, 3], [3, 4, 1, 2], [4, 3, 2, 1]]),
        np.array([[1, 2, 3, 4], [2, 4, 1, 3], [3, 1, 4, 2], [4, 3, 2, 1]])
    ],
    5: [
        np.array([[1, 2, 3, 4, 5], [2, 3, 5, 1, 4], [3, 5, 4, 2, 1], [4, 1, 2, 5, 3], [5, 3, 1, 3, 2]]),
        np.array([[1, 2, 3, 4, 5], [2, 4, 1, 5, 3], [3, 5, 4, 2, 1], [4, 1, 5, 3, 2], [5, 3, 2, 1, 4]]),
    ]
}


for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    res = None
    for items in it.combinations_with_replacement(range(1, N + 1), N):
        s = sum(items)
        if s < K:
            continue
        elif s > K:
            continue
        if N - 1 in co.Counter(items).values():
            continue
        for ls in LS[N]:
            M = ls.copy()
            for i, item in enumerate(items):
                c = (M[i] == item).argmax()
                if c < i:
                    break
                if c == i:
                    continue
                tmp = M[:, i].copy()
                M[:, i] = M[:, c]
                M[:, c] = tmp
            else:
                res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in m) for m in M)
                break
    if res == None:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000291b0a.PYTHON3,1496,51,232,Python,000000000019fd27,0000000000291b0a,0000000000209aa0,alexamici,2020
783,000000000028b9bd,"import random

# latin square code from: https://stackoverflow.com/a/49616910

def is_latin_rectangle(rows):
    valid = True
    for row in rows:
        if len(set(row)) < len(row):
            valid = False
    if valid and rows:
        for i, val in enumerate(rows[0]):
            col = [row[i] for row in rows]
            if len(set(col)) < len(col):
                valid = False
                break
    return valid


def is_latin_square(rows):
    return is_latin_rectangle(rows) and len(rows) == len(rows[0])


def latin_square3(items):
    result = [list(items)]
    while len(result) < len(items):
        new_row = list(items)
        random.shuffle(new_row)
        result.append(new_row)
        if not is_latin_rectangle(result):
            result = result[:-1]
    return result


for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    for _ in range(5000):
        S = latin_square3(list(range(1, N + 1)))
        if sum(S[i][i] for i in range(N)) == K:
            res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in s) for s in S)
            break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",000000000028b9bd.PYTHON3,1189,44,132,Python,000000000019fd27,000000000028b9bd,0000000000209aa0,alexamici,2020
784,000000000028b4f1,"import random

# latin square code from: https://stackoverflow.com/a/49616910

def is_latin_rectangle(rows):
    valid = True
    for row in rows:
        if len(set(row)) < len(row):
            valid = False
    if valid and rows:
        for i, val in enumerate(rows[0]):
            col = [row[i] for row in rows]
            if len(set(col)) < len(col):
                valid = False
                break
    return valid


def is_latin_square(rows):
    return is_latin_rectangle(rows) and len(rows) == len(rows[0])


def latin_square3(items):
    result = [list(items)]
    while len(result) < len(items):
        new_row = list(items)
        random.shuffle(new_row)
        result.append(new_row)
        if not is_latin_rectangle(result):
            result = result[:-1]
    return result


for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    for _ in range(10000):
        S = latin_square3(list(range(1, N + 1)))
        if sum(S[i][i] for i in range(N)) == K:
            res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in s) for s in S)
            break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",000000000028b4f1.PYTHON3,1190,44,132,Python,000000000019fd27,000000000028b4f1,0000000000209aa0,alexamici,2020
785,000000000028b2e4,"import random

# latin square code from: https://stackoverflow.com/a/49616910

def is_latin_rectangle(rows):
    valid = True
    for row in rows:
        if len(set(row)) < len(row):
            valid = False
    if valid and rows:
        for i, val in enumerate(rows[0]):
            col = [row[i] for row in rows]
            if len(set(col)) < len(col):
                valid = False
                break
    return valid


def is_latin_square(rows):
    return is_latin_rectangle(rows) and len(rows) == len(rows[0])


def latin_square3(items):
    result = [list(items)]
    while len(result) < len(items):
        new_row = list(items)
        random.shuffle(new_row)
        result.append(new_row)
        if not is_latin_rectangle(result):
            result = result[:-1]
    return result


for tc in range(1, int(input()) + 1):
    N, K = map(int, input().split())
    for _ in range(1000):
        S = latin_square3(list(range(1, N + 1)))
        if sum(S[i][i] for i in range(N)) == K:
            res = 'POSSIBLE\n' + '\n'.join(' '.join(str(d) for d in s) for s in S)
            break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",000000000028b2e4.PYTHON3,1189,44,132,Python,000000000019fd27,000000000028b2e4,0000000000209aa0,alexamici,2020
786,000000000027e393,"T, B = map(int, input().split())
for tc in range(1, T + 1):
    L = []
    R = []
    M = []
    for i in range(B // 2):
        print(i + 1)
        l = input()
        L.append(l)
        print(B - i)
        r = input()
        R.append(r)
        M.append(l == r)

    L = []
    for i in range(B // 2):
        print(i + 1)
        l = input()
        L.append(l)

    print(''.join(L + [l if M[i] else ['1', '0'][int(l)] for i, l in enumerate(L)][::-1]))
    if input() == 'N':
        break
",000000000027e393.PYTHON3,498,24,78,Python,000000000019fd27,000000000027e393,0000000000209a9e,alexamici,2020
787,000000000027e2e9,"T, B = map(int, input().split())
for tc in range(1, T + 1):
    L = []
    R = []
    M = []
    for i in range(B // 2):
        print(i + 1)
        l = input()
        L.append(l)
        print(B - i)
        r = input()
        R.append(r)
        M.append(l == r)

    L = []
    for i in range(10):
        print(i + 1)
        l = input()
        L.append(l)

    print(''.join(L + [l if M[i] else ['1', '0'][int(l)] for i, l in enumerate(L)][::-1]))
    if input() == 'N':
        break
",000000000027e2e9.PYTHON3,494,24,76,Python,000000000019fd27,000000000027e2e9,0000000000209a9e,alexamici,2020
788,000000000027e0d2,"T, B = map(int, input().split())
for tc in range(1, T + 1):
    L = []
    R = []
    M = []
    for i in range(10):
        print(i + 1)
        l = input()
        L.append(l)
        print(B - i)
        r = input()
        R.append(r)
        M.append(l == r)

    L = []
    for i in range(10):
        print(i + 1)
        l = input()
        L.append(l)

    print(''.join(L + [l if M[i] else ['1', '0'][int(l)] for i, l in enumerate(L)][::-1]))
    if input() == 'N':
        break
",000000000027e0d2.PYTHON3,490,24,74,Python,000000000019fd27,000000000027e0d2,0000000000209a9e,alexamici,2020
789,000000000027ac51,"T, B = map(int, input().split())
for tc in range(1, T + 1):
    res = []
    for i in range(1, 11):
        if i % 10 == 1:
            pass
        print(i)
        res += [input()]
    print(''.join(res))
    if input() == 'N':
        raise ValueError
",000000000027ac51.PYTHON3,255,12,38,Python,000000000019fd27,000000000027ac51,0000000000209a9e,alexamici,2020
790,0000000000279a27,"T, B = map(int, input())
for tc in range(1, T + 1):
    res = []
    for i in range(1, 11):
        if i % 10 == 1:
            pass
        print(i)
        res += [input()]
    print(''.join(res))
    if input() == 'N':
        raise ValueError
",0000000000279a27.PYTHON3,247,12,38,Python,000000000019fd27,0000000000279a27,0000000000209a9e,alexamici,2020
791,00000000002799a3,"T, B = map(int, input())
for tc in range(1, T + 1):
    res = []
    for i in rante(1, 11):
        if i % 10 == 1:
            pass
        print(i)
        res += [input()]
    print(''.join(res))
    if input() == 'N':
        raise ValueError
        ",00000000002799a3.PYTHON3,255,12,38,Python,000000000019fd27,00000000002799a3,0000000000209a9e,alexamici,2020
792,0000000000277d81,"T, B = map(int, input())
for tc in range(1, T + 1):
    res = []
    for i in rante(1, 11):
        if i % 10 == 1:
            pass
        print(i)
        res += [input()]
    print(''.join(res))
    if input() != 'Y':
        raise ValueError
        ",0000000000277d81.PYTHON3,255,12,38,Python,000000000019fd27,0000000000277d81,0000000000209a9e,alexamici,2020
793,0000000000276a54,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = [(0, stop, [], [i], 1)]
    seen = {(0, stop, 1)}
    while len(Q):
        Cb, Jb, Cs, Js, t = Q.pop()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        if start >= Cb and (stop, Jb, t+1) not in seen:
            Q.append((stop, Jb, Cs + [i], Js, t+1))
            seen.add((stop, Jb, t+1))
        if start >= Jb and (Cb, stop, t+1) not in seen:
            Q.append((Cb, stop, Cs, Js + [i], t+1))
            seen.add((Cb, stop, t+1))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",0000000000276a54.PYTHON3,933,29,131,Python,000000000019fd27,0000000000276a54,000000000020bdf9,alexamici,2020
794,00000000002769a1,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = [(0, stop, [], [i], 1)]
    seen = {(0, stop, 1)}
    while len(Q):
        Cb, Jb, Cs, Js, t = Q.pop()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        if start >= Cb and (stop, Jb, t+1) not in seen:
            Q.append((stop, Jb, Cs + [i], Js, t+1))
            seen.add((stop, Jb, t+1))
        if start >= Jb and (Cb, stop, t+1):
            Q.append((Cb, stop, Cs, Js + [i], t+1))
            seen.add((Cb, stop, t+1))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",00000000002769a1.PYTHON3,921,29,128,Python,000000000019fd27,00000000002769a1,000000000020bdf9,alexamici,2020
795,00000000002764fc,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, raw_input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = [(0, stop, [], [i], 1)]
    seen = {(0, stop, 1)}
    while len(Q):
        Cb, Jb, Cs, Js, t = Q.pop()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        if start >= Cb and (stop, Jb, t+1) not in seen:
            Q.append((stop, Jb, Cs + [i], Js, t+1))
            seen.add((stop, Jb, t+1))
        if start >= Jb and (Cb, stop, t+1):
            Q.append((Cb, stop, Cs, Js + [i], t+1))
            seen.add((Cb, stop, t+1))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",00000000002764fc.PYPY2,925,29,128,Python,000000000019fd27,00000000002764fc,000000000020bdf9,alexamici,2020
796,0000000000275bd4,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, raw_input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = {(0, stop, 1): ([], [i])}
    while len(Q):
        (Cb, Jb, t), (Cs, Js) = Q.popitem()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        kC = (stop, Jb, t+1)
        if start >= Cb and kC not in Q:
            Q[kC] = (Cs + [i], Js)
        kJ = (Cb, stop, t+1)
        if start >= Jb and kJ not in Q:
            Q[kJ] = (Cs, Js + [i])
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",0000000000275bd4.PYPY2,837,28,124,Python,000000000019fd27,0000000000275bd4,000000000020bdf9,alexamici,2020
797,0000000000275757,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = {(0, stop, 1): ([], [i])}
    while len(Q):
        (Cb, Jb, t), (Cs, Js) = Q.popitem()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        kC = (stop, Jb, t+1)
        if start >= Cb and kC not in Q:
            Q[kC] = (Cs + [i], Js)
        kJ = (Cb, stop, t+1)
        if start >= Jb and kJ not in Q:
            Q[kJ] = (Cs, Js + [i])
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",0000000000275757.PYTHON3,833,28,124,Python,000000000019fd27,0000000000275757,000000000020bdf9,alexamici,2020
798,0000000000273e2d,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, raw_input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = [(0, stop, [], [i], 1)]
    while len(Q):
        Cb, Jb, Cs, Js, t = Q.pop()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        if start >= Cb:
            Q.append((stop, Jb, Cs + [i], Js, t+1))
        if start >= Jb:
            Q.append((Cb, stop, Cs, Js + [i], t+1))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",0000000000273e2d.PYPY2,771,26,106,Python,000000000019fd27,0000000000273e2d,000000000020bdf9,alexamici,2020
799,0000000000273d49,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    i, (start, stop) = T[0]
    Q = [(0, stop, [], [i], 1)]
    while len(Q):
        Cb, Jb, Cs, Js, t = Q.pop()
        if t == len(T):
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[t]
        if start >= Cb:
            Q.append((stop, Jb, Cs + [i], Js, t+1))
        if start >= Jb:
            Q.append((Cb, stop, Cs, Js + [i], t+1))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",0000000000273d49.PYTHON3,767,26,106,Python,000000000019fd27,0000000000273d49,000000000020bdf9,alexamici,2020
800,00000000002731ca,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: -x[1][1])
    i, (start, stop) = T.pop()
    Q = [(0, stop, [], [i], T)]
    while len(Q):
        Cb, Jb, Cs, Js, T = Q.pop()
        if len(T) == 0:
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T[-1]
        if start >= Cb:
            Q.append((stop, Jb, Cs + [i], Js, T[:-1]))
        if start >= Jb:
            Q.append((Cb, stop, Cs, Js + [i], T[:-1]))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",00000000002731ca.PYTHON3,778,26,106,Python,000000000019fd27,00000000002731ca,000000000020bdf9,alexamici,2020
801,00000000002729f3,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: -x[1][1])
    Q = [(0, 0, [], [], T)]
    while len(Q):
        Cb, Jb, Cs, Js, T = Q.pop()
        if len(T) == 0:
            SC = [None] * N
            for i in Cs:
                SC[i] = 'C'
            for i in Js:
                SC[i] = 'J'
            res = ''.join(SC)
            break
        i, (start, stop) = T.pop()
        if start >= Cb:
            Q.append((stop, Jb, Cs + [i], Js, T.copy()))
        if start >= Jb:
            Q.append((Cb, stop, Cs, Js + [i], T.copy()))
    else:
        res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",00000000002729f3.PYTHON3,749,25,101,Python,000000000019fd27,00000000002729f3,000000000020bdf9,alexamici,2020
802,000000000026f4eb,"import itertools as it


def compatible(C):
    for i, (_, stop) in enumerate(C):
        for start, _ in C[i+1:]:
            if start < stop:
                return False
    return True


for tc in range(1, int(input()) + 1):
    N = int(input())
    T = [list(map(int, input().split())) for _ in range(N)]
    for S in it.product(['J', 'C'], repeat=len(T)):
        C = sorted([t for t, s in zip(T, S) if s == 'C'], key=lambda x: x[1])
        if not compatible(C):
            continue
        J = sorted([t for t, s in zip(T, S) if s == 'J'], key=lambda x: x[1])
        if not compatible(J):
            continue
        res = ''.join(S)
        break
    else:
        res = 'IMPOSSIBLE'
    print('Case #{tc}: {res}'.format(**locals()))
",000000000026f4eb.PYTHON3,746,27,100,Python,000000000019fd27,000000000026f4eb,000000000020bdf9,alexamici,2020
803,000000000026c30f,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: (x[1][1], -x[1][0]))
    S = [None] * len(T)
    C = 0
    J = 0
    res = None
    for i, (start, stop) in T:
        if start >= J:
            J = stop
            S[i] = 'J'
        elif start >= C:
            C = stop
            S[i] = 'C'
        else:
            res = 'IMPOSSIBLE'
            break
    if res is None:
        res = ''.join(S)
    print('Case #{tc}: {res}'.format(**locals()))
",000000000026c30f.PYTHON3,571,22,80,Python,000000000019fd27,000000000026c30f,000000000020bdf9,alexamici,2020
804,000000000026b538,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: (x[1][1], x[1][0]))
    S = [None] * len(T)
    C = 0
    J = 0
    res = None
    for i, (start, stop) in T:
        if start >= J:
            J = stop
            S[i] = 'J'
        elif start >= C:
            C = stop
            S[i] = 'C'
        else:
            res = 'IMPOSSIBLE'
            break
    if res is None:
        res = ''.join(S)
    print('Case #{tc}: {res}'.format(**locals()))
",000000000026b538.PYTHON3,570,22,80,Python,000000000019fd27,000000000026b538,000000000020bdf9,alexamici,2020
805,0000000000269acf,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = list(enumerate(list(map(int, input().split())) for _ in range(N)))
    T = sorted(T, key=lambda x: x[1][1])
    S = [None] * len(T)
    C = 0
    J = 0
    res = None
    for i, (start, stop) in T:
        if start >= J:
            J = stop
            S[i] = 'J'
        elif start >= C:
            C = stop
            S[i] = 'C'
        else:
            res = 'IMPOSSIBLE'
            break
    if res is None:
        res = ''.join(S)
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000269acf.PYTHON3,559,22,79,Python,000000000019fd27,0000000000269acf,000000000020bdf9,alexamici,2020
806,00000000002683a7,"for tc in range(1, int(input()) + 1):
    N = int(input())
    T = [list(map(int, input().split())) for _ in range(N)]
    res = ''
    C = 0
    J = 0
    for start, stop in sorted(T, key=lambda x: x[1]):
        if start >= J:
            J = stop
            res += 'J'
        elif start >= C:
            C = stop
            res += 'C'
        else:
            res = 'IMPOSSIBLE'
            break
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002683a7.PYTHON3,455,18,63,Python,000000000019fd27,00000000002683a7,000000000020bdf9,alexamici,2020
807,000000000026679d,"for tc in range(1, int(input()) + 1):
    S = list(map(int, input()))
    Sp = ''
    for i, s in enumerate(S):
        pre = '(' * (s - max(S[i-1:i] + [0]))
        post = ')' * (s - max(S[i+1:i+2] + [0]))
        Sp += pre + str(s) + post
    print('Case #{tc}: {Sp}'.format(**locals()))
",000000000026679d.PYTHON3,290,9,47,Python,000000000019fd27,000000000026679d,0000000000209a9f,alexamici,2020
808,0000000000265471,"for tc in range(1, int(input()) + 1):
    S = input()
    Sp = ''
    for i, s in enumerate(S):
        if s == '1' and (i == 0 or S[i-1] == '0'):
            Sp += '('
        Sp += s
        if s == '1' and (i >= (len(S) - 1) or S[i+1] == '0'):
            Sp += ')'
    print('Case #{tc}: {Sp}'.format(**locals()))
",0000000000265471.PYTHON3,318,11,56,Python,000000000019fd27,0000000000265471,0000000000209a9f,alexamici,2020
809,0000000000263d09,"import numpy as np
for tc in range(1, int(input()) + 1):
    N = int(input())
    M = np.array([list(map(int, input().split())) for _ in range(N)])
    k = M.trace()
    r = sum(np.unique(r).size != N for r in M)
    c = sum(np.unique(r).size != N for r in M.T)
    print('Case #{tc}: {k} {r} {c}'.format(**locals()))
",0000000000263d09.PYTHON3,318,9,48,Python,000000000019fd27,0000000000263d09,000000000020993c,alexamici,2020
810,00000000002c3822,"import numpy as np
for tc in range(1, int(input()) + 1):
    R, C = map(int, input().split())
    M = np.array([list(map(int, input().split())) for _ in range(R)], 'int64')
    res = 0
    change = True
    while change:
        change = False
        res += int(M.sum())
        N = M.copy()
        for i in range(R):
            r = M[i, :]
            ra = r[r > 0].sum()
            rc = (r > 0).sum()
            if np.any((r * rc < ra) & (r > 0)):
                change = True
                N[i, r * rc < ra] = 0
        for j in range(C):
            c = M[:, j]
            ca = c[c > 0].sum()
            cc = (c > 0).sum()
            if np.any((c * cc < ca) & (c > 0)):
                change = True
                N[c * cc < ca, j] = 0
        M = N
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002c3822.PYTHON3,817,27,126,Python,000000000019fd74,00000000002c3822,00000000002b1355,alexamici,2020
811,00000000002c346e,"import numpy as np
for tc in range(1, int(input()) + 1):
    R, C = map(int, input().split())
    M = np.array([list(map(int, input().split())) for _ in range(R)])
    res = 0
    change = True
    while change:
        change = False
        res += M.sum()
        N = M.copy()
        for i in range(R):
            r = M[i, :]
            ra = r[r > 0].sum()
            rc = (r > 0).sum()
            if np.any((r * rc < ra) & (r > 0)):
                change = True
                N[i, r * rc < ra] = 0
        for j in range(C):
            c = M[:, j]
            ca = c[c > 0].sum()
            cc = (c > 0).sum()
            if np.any((c * cc < ca) & (c > 0)):
                change = True
                N[c * cc < ca, j] = 0
        M = N
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002c346e.PYTHON3,803,27,125,Python,000000000019fd74,00000000002c346e,00000000002b1355,alexamici,2020
812,00000000002c2eb9,"import numpy as np
for tc in range(1, int(input()) + 1):
    R, C = map(int, input().split())
    M = np.array([list(map(int, input().split())) for _ in range(R)])
    res = 0
    while True:
        change = False
        res += M.sum()
        N = M.copy()
        for i, r in enumerate(M):
            ra = r[r > 0].sum()
            rc = (r > 0).sum()
            if np.any((r * rc < ra) & (r > 0)):
                change = True
                N[i, r * rc < ra] = 0
        for j, c in enumerate(M.T):
            ca = c[c > 0].sum()
            cc = (c > 0).sum()
            if np.any((c * cc < ca) & (c > 0)):
                change = True
                N[c * cc < ca, j] = 0
        M = N
        if not change:
            break
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002c2eb9.PYTHON3,792,26,120,Python,000000000019fd74,00000000002c2eb9,00000000002b1355,alexamici,2020
813,00000000002c1bec,"import numpy as np
for tc in range(1, int(input()) + 1):
    R, C = map(int, input().split())
    M = np.array([list(map(int, input().split())) for _ in range(R)])
    res = M.sum()
    while True:
        change = False
        N = M.copy()
        for i, r in enumerate(M):
            ra = r[r > 0].sum()
            rc = (r > 0).sum()
            if np.any((r * rc < ra) & (r > 0)):
                change = True
                N[i, r * rc < ra] = 0
        for j, c in enumerate(M.T):
            ca = c[c > 0].sum()
            cc = (c > 0).sum()
            if np.any((c * cc < ca) & (c > 0)):
                change = True
                N[c * cc < ca, j] = 0
        M = N
        if not change:
            break
        res += M.sum()
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002c1bec.PYTHON3,798,26,120,Python,000000000019fd74,00000000002c1bec,00000000002b1355,alexamici,2020
814,00000000002be353,"def binom(n, r):
    if r < 0 or r > n:
        return 0
    if r > n - r:
        return binom(n, n-r)
    p = 1
    for i in range(r):
        p = p * (n - i) // (i + 1)
    return p


for tc in range(1, int(input()) + 1):
    N = int(input())
    queue = [(1, 1, [(1, 1)])]
    while len(queue):
        su, le, W = queue.pop()
        if su == N:
            break
        r, k = W[-1]
        for dr, dk in [(1, 1), (1, 0), (0, 1)]:
            nr, nk = r + dr, k + dk
            b = binom(nr - 1 , nk - 1)
            if le <= 500 and su + b <= N and b > 0:
                queue.append((su + b, le + 1, W + [(nr, nk)]))
    print('Case #{tc}:'.format(**locals()))
    for r, k in W:
        print(r, k)
",00000000002be353.PYTHON3,711,28,135,Python,000000000019fd74,00000000002be353,00000000002b1353,alexamici,2020
815,00000000002bdb8d,"def binom(n, r):
    if r < 0 or r > n:
        return 0
    if r > n - r:
        return binom(n, n-r)
    p = 1
    for i in range(r):
        p = p * (n - i) // (i + 1)
    return p


for tc in range(1, int(input()) + 1):
    N = int(input())
    queue = [(1, 1, [(1, 1)])]
    while len(queue):
        su, le, W = queue.pop()
        if su == N:
            break
        r, k = W[-1]
        for dr, dk in [(1, 1), (1, 0), (0, 1)]:
            nr, nk = r + dr, k + dk
            b = binom(nr - 1 , nk - 1)
            if le <= 500 and su + b <= N and b > 0:
                queue.append((su + b, le + 1, W + [(nr, nk)]))
    print('Case #{tc}'.format(**locals()))
    for r, k in W:
        print(r, k)
",00000000002bdb8d.PYTHON3,710,28,135,Python,000000000019fd74,00000000002bdb8d,00000000002b1353,alexamici,2020
816,00000000002bd2ae,"def binom(n, r):
    if r < 0 or r > n:
        return 0
    if r > n - r:
        return binom(n, n-r)
    p = 1
    for i in range(r):
        p = p * (n - i) // (i + 1)
    return p


for tc in range(1, int(input()) + 1):
    N = int(input())
    queue = [(1, 1, [(1, 1)])]
    while len(queue):
        su, le, W = queue.pop()
        if su == N:
            break
        r, k = W[-1]
        for dr, dk in [(0, 1), (1, 1), (1, 0)]:
            nr, nk = r + dr, k + dk
            b = binom(nr - 1 , nk - 1)
            if le <= 500 and su + b <= N:
                queue.append((su + b, le + 1, W + [(nr, nk)]))
    print('Case #{tc}'.format(**locals()))
    for r, k in W:
        print(r, k)
",00000000002bd2ae.PYTHON3,700,28,131,Python,000000000019fd74,00000000002bd2ae,00000000002b1353,alexamici,2020
817,00000000002bcebd,"def binom(n, r):
    if r < 0 or r > n:
        return 0
    if r > n - r:
        return binom(n, n-r)
    p = 1
    for i in range(r):
        p = p * (n - i) // (i + 1)
    return p


for tc in range(1, int(input()) + 1):
    N = int(input())
    found = False
    W = []
    queue = [(1, 1, [(1, 1)])]
    while len(queue):
        su, le, W = queue.pop()
        r, k = W[-1]
        for dr, dk in [(0, 1), (1, 1), (1, 0)]:
            nr, nk = r + dr, k + dk
            b = binom(nr - 1 , nk - 1)
            if su + b == N:
                W.append((nr, nk))
                found = True
                break
            elif le <= 500 and su + b < N:
                queue.append((su + b, le + 1, W + [(nr, nk)]))
        if found:
            break
    print('Case #{tc}'.format(**locals()))
    for r, k in W:
        print(r, k)
",00000000002bcebd.PYTHON3,842,34,147,Python,000000000019fd74,00000000002bcebd,00000000002b1353,alexamici,2020
818,00000000002bac9a,"for tc in range(1, int(input()) + 1):
    N = int(input())
    print('Case #{tc}'.format(**locals()))
    for i in range(N):
        print(i + 1, 1)
",00000000002bac9a.PYTHON3,149,6,20,Python,000000000019fd74,00000000002bac9a,00000000002b1353,alexamici,2020
819,00000000002ba53e,"for tc in range(1, int(input()) + 1):
    N = int(input())
    print('Case #{tc}'.format(**locals()))
    for i in range(N):
        print(1, i + 1)
",00000000002ba53e.PYTHON3,149,6,20,Python,000000000019fd74,00000000002ba53e,00000000002b1353,alexamici,2020
820,00000000002ba39c,"for tc in range(1, int(input()) + 1):
    N = int(input())
    print('Case #{tc}'.format(**locals()))
    for i in range(N + 1):
        print(1, i + 1)
",00000000002ba39c.PYTHON3,153,6,22,Python,000000000019fd74,00000000002ba39c,00000000002b1353,alexamici,2020
821,00000000002ba0d6,"for tc in range(1, int(input()) + 1):
    N = int(input())
    print('Case #{tc}')
    for i in range(N + 1):
        print(1, i + 1)
",00000000002ba0d6.PYTHON3,134,6,22,Python,000000000019fd74,00000000002ba0d6,00000000002b1353,alexamici,2020
822,00000000002b6f81,"import re
for tc in range(1, int(input()) + 1):
    N = int(input())
    P = [input() for _ in range(N)]
    T = [p.split('*') for p in P]
    tb = sorted((t[0] for t in T), key=len, reverse=True)[0]
    te = sorted((t[-1] for t in T), key=len, reverse=True)[0]
    res = ''.join([tb] + [s for t in T for s in t[1:-1]] + [te])
    for p in P:
        if not re.fullmatch(p.replace('*', '.*'), res):
            res = '*'
            break
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002b6f81.PYTHON3,489,14,75,Python,000000000019fd74,00000000002b6f81,00000000002b3034,alexamici,2020
823,00000000002b3903,"import re
for tc in range(1, int(input()) + 1):
    N = int(input())
    P = [input() for _ in range(N)]
    res = sorted((p.replace('*', '') for p in P), key=len, reverse=True)[0]
    for s in P:
        if not re.match(s.replace('*', '.*') + '$', res):
            res = '*'
            break
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002b3903.PYTHON3,345,11,47,Python,000000000019fd74,00000000002b3903,00000000002b3034,alexamici,2020
824,00000000002b370f,"import re
for tc in range(1, int(input()) + 1):
    N = int(input())
    P = [input() for _ in range(N)]
    res = sorted((p.replace('*', '') for p in P), key=len, reverse=True)[0]
    for s in P:
        if not re.match(s.replace('*', '.*'), res):
            res = '*'
            break
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002b370f.PYTHON3,339,11,45,Python,000000000019fd74,00000000002b370f,00000000002b3034,alexamici,2020
825,0000000000307507,"import sys
import numpy as np

T, A, B = map(int, input().split())
for tc in range(1, T + 1):
    hit = set()
    miss = set()
    C = np.array([0, 0])
    seen = {}
    for i in range(300):
        d = int((A ** 2 / 2) ** 0.5)
        S = np.array([(1, 1), (-1, -1), (-1, 1), (1, -1), (0, 0)][i % 5])
        p = C + S * d
        CC = tuple(C)
        if seen.get(CC, 0) > 2:
            p = CC
        seen[CC] = seen.get(CC, 0) + 1
        print(*p)
        l = input()
        if l == 'CENTER':
            break
        elif l == 'HIT':
            C = np.maximum(np.minimum(C + S, [51, 51]), [-51, -51])
        elif l == 'MISS':
            C = np.maximum(np.minimum(C - S, [51, 51]), [-51, -51])
",0000000000307507.PYTHON3,705,26,118,Python,000000000019fef2,0000000000307507,00000000002d5b63,alexamici,2020
826,0000000000306503,"import sys
import numpy as np

T, A, B = map(int, input().split())
for tc in range(1, T + 1):
    hit = set()
    miss = set()
    C = np.array([0, 0])
    seen = {}
    for i in range(300):
        d = int((A ** 2 / 2) ** 0.5)
        S = np.array([(1, 1), (-1, -1), (-1, 1), (1, -1), (0, 0)][i % 5])
        p = C + S * d
        print('try', p, file=sys.stderr)
        CC = tuple(C)
        if seen.get(CC, 0) > 2:
            p = CC
        seen[CC] = seen.get(CC, 0) + 1
        print(*p)
        l = input()
        if l == 'CENTER':
            break
        elif l == 'HIT':
            C = np.maximum(np.minimum(C + S, [51, 51]), [-51, -51])
            print('HIT', C, file=sys.stderr)
        elif l == 'MISS':
            C = np.maximum(np.minimum(C - S, [51, 51]), [-51, -51])
            print('MISS', C, file=sys.stderr)
",0000000000306503.PYTHON3,837,29,127,Python,000000000019fef2,0000000000306503,00000000002d5b63,alexamici,2020
827,000000000030618c,"import sys
import numpy as np

T, A, B = map(int, input().split())
for tc in range(1, T + 1):
    hit = set()
    miss = set()
    C = np.array([0, 0])
    seen = {}
    for i in range(300):
        d = 707106746
        S = np.array([(1, 1), (-1, -1), (-1, 1), (1, -1), (0, 0)][i % 5])
        p = C + S * d
        print('try', p, file=sys.stderr)
        CC = tuple(C)
        if seen.get(CC, 0) > 2:
            p = CC
        seen[CC] = seen.get(CC, 0) + 1
        print(*p)
        l = input()
        if l == 'CENTER':
            break
        elif l == 'HIT':
            C = np.maximum(np.minimum(C + S, [51, 51]), [-51, -51])
            print('HIT', C, file=sys.stderr)
        elif l == 'MISS':
            C = np.maximum(np.minimum(C - S, [51, 51]), [-51, -51])
            print('MISS', C, file=sys.stderr)
",000000000030618c.PYTHON3,822,29,121,Python,000000000019fef2,000000000030618c,00000000002d5b63,alexamici,2020
828,0000000000305afa,"import sys
import numpy as np

T, A, B = map(int, input().split())
for tc in range(1, T + 1):
    hit = set()
    miss = set()
    C = np.array([0, 0])
    seen = {}
    for i in range(300):
        d = 707106746
        S = np.array([(1, 1), (-1, -1), (-1, 1), (1, -1), (0, 0)][i % 4])
        p = C + S * d
        print('try', p, file=sys.stderr)
        CC = tuple(C)
        if seen.get(CC, 0) > 3:
            p = CC
        seen[CC] = seen.get(CC, 0) + 1
        print(*p)
        l = input()
        if l == 'CENTER':
            break
        elif l == 'HIT':
            C = np.maximum(np.minimum(C + S, [50, 50]), [-50, -50])
            print('HIT', C, file=sys.stderr)
        elif l == 'MISS':
            C = np.maximum(np.minimum(C - S, [50, 50]), [-50, -50])
            print('MISS', C, file=sys.stderr)
",0000000000305afa.PYTHON3,822,29,121,Python,000000000019fef2,0000000000305afa,00000000002d5b63,alexamici,2020
829,000000000030215a,"import sys

T, A, B = map(int, input().split())
# print(T, A, B, file=sys.stderr)
for tc in range(1, T + 1):
    hit = set()
    miss = set()
    for i in range(300):
        p = i // 15 - 5, i % 15 - 5
        print(*p)
        l = input()
        if l == 'CENTER':
            break
        elif l == 'HIT':
            hit.add(p)
        elif l == 'MISS':
            miss.add(p)

",000000000030215a.PYTHON3,384,19,61,Python,000000000019fef2,000000000030215a,00000000002d5b63,alexamici,2020
830,00000000002ff3bc,"def solve(X, Y):
    Q = [((0, 0), '')]
    ju = 1
    for t in range(11):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002ff3bc.PYTHON3,745,26,111,Python,000000000019fef2,00000000002ff3bc,00000000002d5b62,alexamici,2020
831,00000000002fc0b7,"def solve(X, Y):
    sol = {(0, 0)}
    Q = [((0, 0), '')]
    ju = 1
    for t in range(11):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    elif nex not in sol:
                        sol.add(nex)
                        NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002fc0b7.PYTHON3,846,29,121,Python,000000000019fef2,00000000002fc0b7,00000000002d5b62,alexamici,2020
832,00000000002fbf7b,"def solve(X, Y):
    sol = {(0, 0)}
    Q = [((0, 0), '')]
    ju = 1
    for t in range(12):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    elif nex not in sol:
                        sol.add(nex)
                        NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002fbf7b.PYTHON3,846,29,121,Python,000000000019fef2,00000000002fbf7b,00000000002d5b62,alexamici,2020
833,00000000002fbd67,"def solve(X, Y):
    sol = {(0, 0)}
    Q = [((0, 0), '')]
    ju = 1
    for t in range(10):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    elif nex not in sol:
                        sol.add(nex)
                        NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002fbd67.PYTHON3,846,29,121,Python,000000000019fef2,00000000002fbd67,00000000002d5b62,alexamici,2020
834,00000000002fb9f4,"def solve(X, Y):
    sol = {(0, 0)}
    Q = [((0, 0), '')]
    ju = 1
    for t in range(100):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    elif nex not in sol:
                        sol.add(nex)
                        NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002fb9f4.PYTHON3,847,29,121,Python,000000000019fef2,00000000002fb9f4,00000000002d5b62,alexamici,2020
835,00000000002fb7b2,"def solve(X, Y):
    sol = {(0, 0)}
    Q = [((0, 0), '')]
    ju = 1
    for t in range(10000):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    elif nex not in sol:
                        sol.add(nex)
                        NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002fb7b2.PYTHON3,849,29,121,Python,000000000019fef2,00000000002fb7b2,00000000002d5b62,alexamici,2020
836,00000000002faf84,"def solve(X, Y):
    sol = {(0, 0)}
    Q = [((0, 0), '')]
    ju = 1
    for t in range(10000000):
        NQ = []
        for pos, S in Q:
            for i, DD in [(0, 'WE'), (1, 'SN')]:
                for j, s in zip([-1, +1], DD):
                    if i == 0:
                        nex = pos[0] + j * ju, pos[1]
                    else:
                        nex = pos[0], pos[1] + j * ju
                    if nex == (X, Y):
                        return S + s
                    elif nex not in sol:
                        sol.add(nex)
                        NQ.append((nex, S + s))
        Q = NQ
        ju = ju * 2

for tc in range(1, int(input()) + 1):
    X, Y = map(int, input().split())
    if (X + Y) % 2 == 0:
        res = 'IMPOSSIBLE'
    else:
        res = solve(X, Y)
    print('Case #{tc}: {res}'.format(**locals()))
",00000000002faf84.PYTHON3,852,29,121,Python,000000000019fef2,00000000002faf84,00000000002d5b62,alexamici,2020
837,0000000000325ca7,"import collections
for tc in range(1, int(input()) + 1):
    N, D = map(int, input().split())
    A = list(map(int, input().split()))
    C = collections.Counter(A)
    M = max(C.values())
    if M >= D:
        res = 0
    elif D == 2:
        res = 1
    else:
        res = 2
        if M == 2:
            m = min(c for c, n in C.items() if n == M)
            for s in C:
                if s > m:
                    res = 1
        for s in C:
            if s % 2 == 0 and s // 2 in C:
                res = 1
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000325ca7.PYTHON3,568,22,91,Python,000000000019fef4,0000000000325ca7,00000000003172d1,alexamici,2020
838,0000000000325628,"import collections
for tc in range(1, int(input()) + 1):
    N, D = map(int, input().split())
    A = list(map(int, input().split()))
    C = collections.Counter(A)
    M = max(C.values())
    if M >= D:
        res = 0
    elif D == 2:
        res = 1
    else:
        res = 2
        if M == 2:
            m = min(c for c, n in C.items() if n == M)
            for s in C:
                if s > m:
                    res = 1
        else:
            for s in C:
                if s % 2 == 0 and s // 2 in C:
                    res = 1
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000325628.PYTHON3,594,23,92,Python,000000000019fef4,0000000000325628,00000000003172d1,alexamici,2020
839,0000000000324b32,"import collections
for tc in range(1, int(input()) + 1):
    N, D = map(int, input().split())
    A = list(map(int, input().split()))
    C = collections.Counter(A)
    M = max(C.values())
    if M >= D:
        res = 0
    elif D == 2:
        res = 1
    else:
        res = 2
        m = min(c for c, n in C.items() if n == M)
        if M == 2:
            for s in C:
                if s > m:
                    res = 1
        else:
            for s in C:
                if s % 2 == 0 and s // 2 in C:
                    res = 1
    print('Case #{tc}: {res}'.format(**locals()))
",0000000000324b32.PYTHON3,590,23,92,Python,000000000019fef4,0000000000324b32,00000000003172d1,alexamici,2020
840,00000000003236ec,"import collections
for tc in range(1, int(input()) + 1):
    N, D = map(int, input().split())
    A = list(map(int, input().split()))
    C = collections.Counter(A)
    M = max(C.values())
    if M >= D:
        res = 0
    elif D == 2:
        res = 1
    else:
        res = 2
        if M == 2:
            for s in C:
                if s > M:
                    res = 1
        else:
            for s in C:
                if s % 2 == 0 and s // 2 in C:
                    res = 1
    print('Case #{tc}: {res}'.format(**locals()))
",00000000003236ec.PYTHON3,539,22,80,Python,000000000019fef4,00000000003236ec,00000000003172d1,alexamici,2020
841,00000000003231c6,"import collections
for tc in range(1, int(input()) + 1):
    N, D = map(int, input().split())
    A = list(map(int, input().split()))
    C = collections.Counter(A)
    if max(C.values()) >= D:
        res = 0
    elif D == 2:
        res = 1
    else:
        res = 2
        M = max(C.values())
        if M == 2:
            for s, n in C.items():
                if s > M:
                    res = 1
        else:
            for s in C:
                if s % 2 == 0 and s // 2 in C:
                    res = 1
    print('Case #{tc}: {res}'.format(**locals()))
",00000000003231c6.PYTHON3,568,22,81,Python,000000000019fef4,00000000003231c6,00000000003172d1,alexamici,2020
842,000000000031fe5c,"import collections

for tc in range(1, int(input()) + 1):
    U = int(input())
    R = [input().split() for _ in range(10000)]
    R = sorted([(int(req), res) for req, res in R])
    RRR = set(''.join([r for _, r in R]))
    RR = ''.join([r[0] for _, r in R])
    C = sorted(collections.Counter(RR).items(), key=lambda x: -x[1])
    res = RRR.difference(set(RR)).pop() + ''.join(c for c, _ in C)
    print('Case #{tc}: {res}'.format(**locals()))
",000000000031fe5c.PYTHON3,446,12,63,Python,000000000019fef4,000000000031fe5c,00000000003179a1,alexamici,2020
843,000000000031f592,"import collections

for tc in range(1, int(input()) + 1):
    U = int(input())
    R = [input().split() for _ in range(10000)]
    R = sorted([(int(req), res) for req, res in R])
    RR = ''.join([r for _, r in R])
    C = sorted(collections.Counter(RR).items(), key=lambda x: -x[1])
    res = C[-1][0] + ''.join(c for c, _ in C[:-1])
    print('Case #{tc}: {res}'.format(**locals()))
",000000000031f592.PYTHON3,385,11,55,Python,000000000019fef4,000000000031f592,00000000003179a1,alexamici,2020
844,000000000031ce6d,"import numpy as np

SHIFT = {
    ""N"": np.array([0, 1]),
    ""S"": np.array([0, -1]),
    ""E"": np.array([1, 0]),
    ""W"": np.array([-1, 0]),
}
for tc in range(1, int(input()) + 1):
    X, Y, P = input().split()
    curr = np.array([int(X), int(Y)])
    if curr.sum() == 0:
        res = 0
    else:
        for t, s in enumerate(P, 1):
            curr += SHIFT[s]
            d = abs(curr).sum()
            if d <= t:
                res = t
                break
        else:
            res = 'IMPOSSIBLE'

    print('Case #{tc}: {res}'.format(**locals()))
",000000000031ce6d.PYTHON3,561,25,71,Python,000000000019fef4,000000000031ce6d,0000000000317409,alexamici,2020
845,000000000033dd85,"
def bisect_root(f, l, r, dx):
    assert f(l) <= 0 <= f(r)
    while r - l > dx:
        m = (r + l) // 2
        if f(m) > 0:
            r = m
        else:
            l = m
    return l


for tc in range(1, int(input()) + 1):
    L, R = map(int, input().split())
    reverse = False
    if L < R:
        L, R = R, L
        reverse = True

    i = bisect_root(lambda x: x * (x + 1) // 2 - L + R, 0, max(L, R), 1)
    L -= i * (i + 1) // 2

    if L < R or (L == R and reverse):
        L, R = R, L
        reverse = not reverse

    if i % 2 == 1:
        ne = i // 2
        L += ne * (ne + 1)
        nn = bisect_root(lambda x: x * (x + 1) - L, 0, L, 1)
        L -= nn * (nn + 1)
        no = ne + 1
        R += no * no
        nnn = int(R ** 0.5)
        R = R - nnn * nnn
        i = max(2 * nn, 2 * nnn - 1)
    else:
        no = i // 2
        L += no * no
        nn = int(L ** 0.5)
        L -= nn * nn
        ne = no
        R += ne * (ne + 1)
        nnn = bisect_root(lambda x: x * (x + 1) - R, 0, R, 1)
        R -= nnn * (nnn + 1)
        i = max(2 * nn - 1, 2 * nnn)

    res = '%d %d %d' % (i, R if reverse else L, L if reverse else R)
    print('Case #{tc}: {res}'.format(**locals()))
",000000000033dd85.PYTHON3,1211,50,264,Python,000000000019ffb9,000000000033dd85,00000000003384ea,alexamici,2020
846,0000000000024c4a.PYTHON3,"import math

















for t in range(1,int(input())+1):
    area=float(input())* 1000000
    for i in range(0,91):
        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
        #print(math.sin(math.radians(i)))
        if int(a*1000000) == area :
            angle=i
            break
    else :
        for i in range(0,91):
            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))    
            if int(a*100000) == area//10 :
                angle=i
                break
        else :
            for i in range(0,91):
                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                if int(a*10000) == area//100 :
                    angle=i
                    break
            else :
                for i in range(0,91):
                    a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                    if int(a*1000) == area//1000 :
                        angle=i
                        break
                else:
                    for i in range(0,91) :
                        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                        if int(a*100) == area//10000 :
                            angle=i
                            break

                    else:
                        for i in range(0,91) :
                            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                            if int(a*10) == area//100000 :
                                angle=i
                                break
                        else:
                            for i in range(0,91) :
                                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                                if int(a) == area//1000000 :
                                    angle=i
                                    break
    


    x1=0.5 * math.cos(math.radians(angle))
    y1=0.5 * math.sin(math.radians(angle))
    z1=0

    x2=0.5 * math.cos(math.radians(angle+90))
    y2=0.5 * math.sin(math.radians(angle+90))
    z2=0

    x3=0
    y3=0
    z3=0.5
    if i==0 :
        x2=0
    if i==90 :
        y2=0

    print('case #{}:'.format(t))
    print(x1,y1,z1)
    if x2<0 :
        x2*=(-1)
        print('-{} {} {}'.format(y1,y2,z2))
    
    else :
        print(x2,y2,z2)
    print(x3,y3,z3)
",,2485,92,151,Python,00000000000000cb,0000000000024c4a,00000000000079cc,vulcrine,2018
847,000000000002415c.PYTHON3,"import math

















for t in range(1,int(input())+1):
    area=float(input())* 1000000
    for i in range(0,91):
        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
        #print(math.sin(math.radians(i)))
        if int(a*1000000) == area :
            angle=i
            break
    else :
        for i in range(0,91):
            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))    
            if int(a*100000) == area//10 :
                angle=i
                break
        else :
            for i in range(0,91):
                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                if int(a*10000) == area//100 :
                    angle=i
                    break
            else :
                for i in range(0,91):
                    a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                    if int(a*1000) == area//1000 :
                        angle=i
                        break
                else:
                    for i in range(0,91) :
                        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                        if int(a*100) == area//10000 :
                            angle=i
                            break

                    else:
                        for i in range(0,91) :
                            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                            if int(a*10) == area//100000 :
                                angle=i
                                break
                        else:
                            for i in range(0,91) :
                                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                                if int(a) == area//1000000 :
                                    angle=i
                                    break
    


    x1=0.5 * math.cos(math.radians(angle))
    y1=0.5 * math.sin(math.radians(angle))
    z1=0

    x2=0.5 * math.cos(math.radians(angle+90))
    y2=0.5 * math.sin(math.radians(angle+90))
    z2=0

    x3=0
    y3=0
    z3=0.5
    if i==0 :
        x2=0
    if i==90 :
        y2=0
    print('Case #{}:'.format(t))
    print(x1,y1,z1)
    print(x2,y2,z2)
    print(x3,y3,z3)
",,2383,86,142,Python,00000000000000cb,000000000002415c,00000000000079cc,vulcrine,2018
848,0000000000023db7.PYTHON3,"import math

















for t in range(1,int(input())+1):
    area=float(input())* 1000000
    for i in range(0,91):
        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
        #print(math.sin(math.radians(i)))
        if int(a*1000000) == area :
            angle=i
            break
    else :
        for i in range(0,91):
            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))    
            if int(a*100000) == area//10 :
                angle=i
                break
        else :
            for i in range(0,91):
                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                if int(a*10000) == area//100 :
                    angle=i
                    break
            else :
                for i in range(0,91):
                    a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                    if int(a*1000) == area//1000 :
                        angle=i
                        break
                else:
                    for i in range(0,91) :
                        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                        if int(a*100) == area//10000 :
                            angle=i
                            break

                    else:
                        for i in range(0,91) :
                            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                            if int(a*10) == area//100000 :
                                angle=i
                                break
                        else:
                            for i in range(0,91) :
                                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                                if int(a) == area//1000000 :
                                    angle=i
                                    break
    


    x1=0.5 * math.cos(math.radians(angle))
    y1=0.5 * math.sin(math.radians(angle))
    z1=0

    x2=0.5 * math.cos(math.radians(angle+90))
    y2=0.5 * math.sin(math.radians(angle+90))
    z2=0

    x3=0
    y3=0
    z3=0.5
    if i==0 :
        x2=0
    if i==90 :
        y2=0
    print('case #{}:'.format(t))
    print(x1,y1,z1)
    print(x2,y2,z2)
    print(x3,y3,z3)
",,2383,86,142,Python,00000000000000cb,0000000000023db7,00000000000079cc,vulcrine,2018
849,0000000000023c6b.PYTHON3,"import math

















for t in range(1,int(input())+1):
    area=float(input())* 1000000
    for i in range(0,91):
        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
        #print(math.sin(math.radians(i)))
        if int(a*1000000) == area :
            angle=i
            break
    else :
        for i in range(0,91):
            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))    
            if int(a*100000) == area//10 :
                angle=i
                break
        else :
            for i in range(0,91):
                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                if int(a*10000) == area//100 :
                    angle=i
                    break
            else :
                for i in range(0,91):
                    a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                    if int(a*1000) == area//1000 :
                        angle=i
                        break
                else:
                    for i in range(0,91) :
                        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                        if int(a*100) == area//10000 :
                            angle=i
                            break

                    else:
                        for i in range(0,91) :
                            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                            if int(a*10) == area//100000 :
                                angle=i
                                break
                        else:
                            for i in range(0,91) :
                                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                                if int(a) == area//1000000 :
                                    angle=i
                                    break
    


    x1=0.5 * math.cos(math.radians(angle))
    y1=0.5 * math.sin(math.radians(angle))
    z1=0

    x2=0.5 * math.cos(math.radians(angle+90))
    y2=0.5 * math.sin(math.radians(angle+90))
    z2=0

    x3=0
    y3=0
    z3=0.5
    if i==0 :
        x2=0
    print('case #{}:'.format(t))
    print(x1,y1,z1)
    print(x2,y2,z2)
    print(x3,y3,z3)
",,2353,84,138,Python,00000000000000cb,0000000000023c6b,00000000000079cc,vulcrine,2018
850,0000000000023538.PYTHON3,"import math

















for t in range(1,int(input())+1):
    area=float(input())* 1000000
    for i in range(0,91):
        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
        #print(math.sin(math.radians(i)))
        if int(a*1000000) == area :
            angle=i
            break
    else :
        for i in range(0,91):
            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))    
            if int(a*100000) == area//10 :
                angle=i
                break
        else :
            for i in range(0,91):
                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                if int(a*10000) == area//100 :
                    angle=i
                    break
            else :
                for i in range(0,91):
                    a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                    if int(a*1000) == area//1000 :
                        angle=i
                        break
                else:
                    for i in range(0,91) :
                        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                        if int(a*100) == area//10000 :
                            angle=i
                            break

                    else:
                        for i in range(0,91) :
                            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                            if int(a*10) == area//100000 :
                                angle=i
                                break
                        else:
                            for i in range(0,91) :
                                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                                if int(a) == area//1000000 :
                                    angle=i
                                    break
    


    x1=0.5 * math.cos(math.radians(angle))
    y1=0.5 * math.sin(math.radians(angle))
    z1=0

    x2=0.5 * math.cos(math.radians(angle))
    y2=0.5 * math.sin(math.radians(angle))
    z2=0

    x3=0
    y3=0
    z3=0.5

    print('case #{}:'.format(t))
    print(x1,y1,z1)
    print(x2*(-1),y2,z2)
    print(x3,y3,z3)
",,2325,83,134,Python,00000000000000cb,0000000000023538,00000000000079cc,vulcrine,2018
851,0000000000023458.PYTHON3,"import math

















for t in range(1,int(input())+1):
    area=float(input())* 1000000
    for i in range(0,91):
        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
        #print(math.sin(math.radians(i)))
        if int(a*1000000) == area :
            angle=i
            break
    else :
        for i in range(0,91):
            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))    
            if int(a*100000) == area//10 :
                angle=i
                break
        else :
            for i in range(0,91):
                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                if int(a*10000) == area//100 :
                    angle=i
                    break
            else :
                for i in range(0,91):
                    a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                    if int(a*1000) == area//1000 :
                        angle=i
                        break
                else:
                    for i in range(0,91) :
                        a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                        if int(a*100) == area//10000 :
                            angle=i
                            break

                    else:
                        for i in range(0,91) :
                            a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                            if int(a*10) == area//100000 :
                                angle=i
                                break
                        else:
                            for i in range(0,91) :
                                a=float(math.cos(math.radians(i))+ math.cos(math.radians(90-i)))
                                if int(a) == area//1000000 :
                                    angle=i
                                    break
    


    x1=0.5 * math.cos(math.radians(angle))
    y1=0.5 * math.sin(math.radians(angle))
    z1=0

    x2=0.5 * math.cos(math.radians(angle))
    y2=0.5 * math.sin(math.radians(angle))
    z2=0

    x3=0
    y3=0
    z3=0.5

    print('case #{}:'.format(t))
    print(x1,y1,z1)
    print(x2,y2,z2)
    print(x3,y3,z3)
",,2320,83,134,Python,00000000000000cb,0000000000023458,00000000000079cc,vulcrine,2018
852,000000000001ef1e.PYTHON3,"t=int(input())
for i in range(1,t+1):
    n=int(input())   
    arr=list(input().split(' '))
    ar=arr.copy()
    ars=arr.copy()
    done=True
    while done:
        done=False
        for x in range(0,n-2):
            if int(ars[x]) > int(ars[x+2]):
                temp=ars[x]
                ars[x]=ars[x+2]
                ars[x+2]=temp
                done=True
                #if i==3 and x<5:
                   # print(ars)

        
    
    for y in range(0,n-1):
        for x in range(0,n-1-y):
            if int(ar[x])>int(ar[x+1]):
                temp=ar[x+1]
                ar[x+1]=ar[x]
                ar[x]=temp

    
   
    for y in range(0,n):
        if not int(ar[y])==int(ars[y]):
            print('case #{}: {}'.format(i,y))
            break
    else :
        print('case #{}: OK'.format(i))
",,862,36,61,Python,00000000000000cb,000000000001ef1e,00000000000079cb,vulcrine,2018
853,000000000001e57c.PYTHON3,"t=int(input())
for i in range(1,t+1):
    s=input()
    s=list(s.split(' '))
    p=int(s[0])
    pa=s[1]
    pat=list(pa)
    powerate=1
    count=0
    l=0
    damage=0
    for j in range(0,len(pa)):
        if pat[j]== 'S' :
            damage +=powerate
        elif pat[j]=='C' :
            powerate *= 2

    if p >= damage:
        if l==0:
            print('case #{}: {}'.format(i,count))
        l=1
        
    
    for k in range(len(pa)-1,0,-1):
        k=k-1
            
        if pat[k]=='C' and pat[k+1]=='S' :
            for kn in range(k,len(pa)-1,1) :
                
                if pat[kn]=='C' and pat[kn+1]=='S' :

                    temp=pat[kn+1]
                    pat[kn+1]=pat[kn]
                    pat[kn]=temp

                    #pat[kn],pat[kn+1]=pat[kn+1],pat[kn]
                    count +=1
                    damage=0
                    powerate=1
                    for j in range(0,len(pa)):
                        if pat[j]== 'S' :
                            damage +=powerate
                        if pat[j]=='C' :
                            powerate *= 2
                    if p >= damage:
                        if l==0:
                            print('case #{}: {}'.format(i,count))
                        l=1
                        break
                        
                    
                    


                        
        k=k+1        
    powerate=1    
    damage=0
    for j in range(0,len(pa)):
        if pat[j]== 'S' :
            damage +=powerate
        elif pat[j]=='C' :
            powerate *= 2

    

    if p >= damage:
        if l==0:
            print('case #{}: {}'.format(i,count))
        l=1

    if l==0 :
        print('case #{}: IMPOSSIBLE'.format(i))
        

    
    
   
",,1870,79,131,Python,00000000000000cb,000000000001e57c,0000000000007966,vulcrine,2018
854,000000000001dd38.PYTHON3,"t=int(input())
for i in range(1,t+1):
    n=int(input())   
    arr=list(input().split(' '))
    ar=arr.copy()
    done=True
    while done:
        done=False
        for x in range(0,n-2):
            if arr[x]>arr[x+2]:
                temp=arr[x]
                arr[x]=arr[x+2]
                arr[x+2]=temp
                done=True

    
    for y in range(0,n-1):
        for x in range(0,n-1-y):
            if ar[x]>ar[x+1]:
                temp=ar[x+1]
                ar[x+1]=ar[x]
                ar[x]=temp

    
   
    for y in range(0,n):
        if not ar[y]==arr[y]:
            print('case #{}: {}'.format(i,y))
            break
    else :
        print('case #{}: OK'.format(i))
",,732,32,52,Python,00000000000000cb,000000000001dd38,00000000000079cb,vulcrine,2018
855,000000000001aa80.PYTHON3,"t=int(input())
for i in range(1,t+1):
    n=int(input())   
    arr=list(input().split(' '))
    ar=arr.copy()
    done=True
    while done:
        done=False
        for x in range(0,n-2):
            if arr[x]>arr[x+2]:
                temp=arr[x]
                arr[x]=arr[x+2]
                arr[x+2]=temp
                done=True

    
    for y in range(0,n-1):
        for x in range(0,n-1-y):
            if ar[x]>ar[x+1]:
                temp=ar[x]
                ar[x+1]=ar[x]
                ar[x]=temp

    
   
    for y in range(0,n):
        if not ar[y]==arr[y]:
            print('case #{}: {}'.format(i,y))
            break
    else :
        print('case #{}: OK'.format(i))
",,730,32,52,Python,00000000000000cb,000000000001aa80,00000000000079cb,vulcrine,2018
856,00000000000f9588.PYTHON3,"import sys
def quilt(qi):
    bill=[]
    if qi[0]>8:
        while(qi[0]>8):
            bill.append(8)
            qi[0]-=8
        else:
            if qi[0]>0:
                bill.append(qi[0])
    else:
        for q in qi:
            if q==1:
                bill.append(1)
            else:
                bill.append(int(q/2))
                if q%2==0:
                    bill.append(int(q/2))
                else:
                    bill.append(int(q/2)+1)
    st=''
    chip='0'
    for b in bill:
        st+=chip*b
        if chip=='0':
            chip='1'
        else:
            chip='0'
    print(st)
    sys.stdout.flush()
    return bill



def cipher():
    global g,x
    res=input()
    t=[]
    gi=0
    for i in range(len(g)):
        if g[i]:
            c0=0
            c1=0
            #create a cycle, note the index
            if not len(g)-i==1:
                for k in range(gi,len(res)):
                    if res[k]=='0':
                        c0+=1
                    else:
                        gi=k
                        break
                if c0>0:
                    t.append(1)
                else:
                    t.append(0)
                for k in range(gi,len(res)):
                    if res[k]=='1':
                        c1+=1
                    else:
                        gi=k
                        break
                if c1>0:
                    t.append(1)
                else:
                    t.append(0)

            else:
                if len(x)%2==0:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)
                    for k in range(gi,len(res)):
                        if res[k]=='1':
                            c1+=1
                        else:
                            gi=k
                            break
                    if c1>0:
                        t.append(1)
                    else:
                        t.append(0)

                else:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)

        else:
            if len(g)-i==1:
                if len(x)%2==0:
                    t.append(0)
                    t.append(0)
                else:
                    t.append(0)
    return t






tc=int(input())
for i in range(tc):
    global n,parent
    n,b,f=map(int,input().split())
    x=[n]
    g=[1]
    for i in range(5):
        x=quilt(x)
        g=cipher()
    pto=''
    for ink  in  range(len(g)):
        if g[ink] ==0:
            if len(pto) >0:
                pto+=' '
            pto+=str(ink)
    print(pto)
    sys.stdout.flush()
    input()
",,3194,134,192,Python,51705,00000000000f9588,00000000000881de,vulcrine,2019
857,00000000000f926a.PYTHON3,"import sys
def quilt(qi):
    bill=[]
    if qi[0]>8:
        while(qi[0]>8):
            bill.append(8)
            qi[0]-=8
        else:
            if qi[0]>0:
                bill.append(qi[0])
    else:
        for q in qi:
            if q==1:
                bill.append(1)
            else:
                bill.append(int(q/2))
                if q%2==0:
                    bill.append(int(q/2))
                else:
                    bill.append(int(q/2)+1)
    st=''
    chip='0'
    for b in bill:
        st+=chip*b
        if chip=='0':
            chip='1'
        else:
            chip='0'
    print(st)
    sys.stdout.flush()
    return bill



def cipher():
    global g,x
    res=input()
    t=[]
    gi=0
    for i in range(len(g)):
        if g[i]:
            c0=0
            c1=0
            #create a cycle, note the index
            if not len(g)-i==1:
                for k in range(gi,len(res)):
                    if res[k]=='0':
                        c0+=1
                    else:
                        gi=k
                        break
                if c0>0:
                    t.append(1)
                else:
                    t.append(0)
                for k in range(gi,len(res)):
                    if res[k]=='1':
                        c1+=1
                    else:
                        gi=k
                        break
                if c1>0:
                    t.append(1)
                else:
                    t.append(0)

            else:
                if len(x)%2==0:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)
                    for k in range(gi,len(res)):
                        if res[k]=='1':
                            c1+=1
                        else:
                            gi=k
                            break
                    if c1>0:
                        t.append(1)
                    else:
                        t.append(0)

                else:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)

        else:
            if len(g)-i==1:
                if len(x)%2==0:
                    t.append(0)
                    t.append(0)
                else:
                    t.append(0)
    return t






tc=int(input())
for i in range(tc):
    global n,parent
    n,b,f=map(int,input().split())
    x=[n]
    g=[1]
    for i in range(5):
        x=quilt(x)
        g=cipher()
    pto=''
    for ink  in  range(len(g)):
        if g[ink] ==0:
            if len(pto) >0:
                pto+=' '
            pto+=str(ink)
    print(pto)
    sys.stdout.flush()
",,3182,133,191,Python,51705,00000000000f926a,00000000000881de,vulcrine,2019
858,00000000000f8e78.PYTHON3,"import sys
def quilt(qi):
    bill=[]
    if qi[0]>8:
        while(qi[0]>8):
            bill.append(8)
            qi[0]-=8
        else:
            if qi[0]>0:
                bill.append(qi[0])
    else:
        for q in qi:
            if q==1:
                bill.append(1)
            else:
                bill.append(int(q/2))
                if q%2==0:
                    bill.append(int(q/2))
                else:
                    bill.append(int(q/2)+1)
    st=''
    chip='0'
    for b in bill:
        st+=chip*b
        if chip=='0':
            chip='1'
        else:
            chip='0'
    print(st)
    sys.stdout.flush()
    return bill



def cipher():
    global g,x
    res=input()
    t=[]
    gi=0
    for i in range(len(g)):
        if g[i]:
            c0=0
            c1=0
            #create a cycle, note the index
            if not len(g)-i==1:
                for k in range(gi,len(res)):
                    if res[k]=='0':
                        c0+=1
                    else:
                        gi=k
                        break
                if c0>0:
                    t.append(1)
                else:
                    t.append(0)
                for k in range(gi,len(res)):
                    if res[k]=='1':
                        c1+=1
                    else:
                        gi=k
                        break
                if c1>0:
                    t.append(1)
                else:
                    t.append(0)

            else:
                if len(x)%2==0:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)
                    for k in range(gi,len(res)):
                        if res[k]=='1':
                            c1+=1
                        else:
                            gi=k
                            break
                    if c1>0:
                        t.append(1)
                    else:
                        t.append(0)

                else:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)

        else:
            if len(g)-i==1:
                if len(x)%2==0:
                    t.append(0)
                    t.append(0)
                else:
                    t.append(0)
    return t






tc=int(input())
for i in range(tc):
    global n,parent
    n,b,f=map(int,input().split())
    x=[n]
    g=[1]
    while(5):
        x=quilt(x)
        g=cipher()
    pto=''
    for ink  in  range(len(g)):
        if g[ink] ==0:
            if len(pto) >0:
                pto+=' '
            pto+=str(ink)
    print(pto)
    sys.stdout.flush()
",,3173,133,188,Python,51705,00000000000f8e78,00000000000881de,vulcrine,2019
859,00000000000f8a60.PYTHON3,"import sys
def quilt(qi):
    bill=[]
    if qi[0]>8:
        while(qi[0]>8):
            bill.append(8)
            qi[0]-=8
        else:
            if qi[0]>0:
                bill.append(qi[0])
    else:
        for q in qi:
            if q==1:
                bill.append(1)
            else:
                bill.append(int(q/2))
                if q%2==0:
                    bill.append(int(q/2))
                else:
                    bill.append(int(q/2)+1)
    st=''
    chip='0'
    for b in bill:
        st+=chip*b
        if chip=='0':
            chip='1'
        else:
            chip='0'
    print(st)
    sys.stdout.flush()
    return bill



def cipher():
    global g,x
    res=input()
    t=[]
    gi=0
    for i in range(len(g)):
        if g[i]:
            c0=0
            c1=0
            #create a cycle, note the index
            if not len(g)-i==1:
                for k in range(gi,len(res)):
                    if res[k]=='0':
                        c0+=1
                    else:
                        gi=k
                        break
                if c0>0:
                    t.append(1)
                else:
                    t.append(0)
                for k in range(gi,len(res)):
                    if res[k]=='1':
                        c1+=1
                    else:
                        gi=k
                        break
                if c1>0:
                    t.append(1)
                else:
                    t.append(0)

            else:
                if len(x)%2==0:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)
                    for k in range(gi,len(res)):
                        if res[k]=='1':
                            c1+=1
                        else:
                            gi=k
                            break
                    if c1>0:
                        t.append(1)
                    else:
                        t.append(0)

                else:
                    for k in range(gi,len(res)):
                        if res[k]=='0':
                            c0+=1
                        else:
                            gi=k
                            break
                    if c0>0:
                        t.append(1)
                    else:
                        t.append(0)

        else:
            if len(g)-i==1:
                if len(x)%2==0:
                    t.append(0)
                    t.append(0)
                else:
                    t.append(0)
    return t






tc=int(input())
for i in range(tc):
    global n,parent
    n,b,f=map(int,input().split())
    x=[n]
    g=[1]
    while(1):
        for po in x:
            if not x == 1:
                break
        else:
            break
        x=quilt(x)
        g=cipher()
    pto=''
    for ink  in  range(len(g)):
        if g[ink] ==0:
            if len(pto) >0:
                pto+=' '
            pto+=str(ink)
    print(pto)
    sys.stdout.flush()
",,3275,138,200,Python,51705,00000000000f8a60,00000000000881de,vulcrine,2019
860,00000000000e0177.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
alpha=[]
beta=[]
multi=[]
for i in range(tc):
    temp=input().split(' ')
    alpha.append(int(temp[0]))
    beta.append(int(temp[1]))
    multi.append(input().split(' '))
primos(max(alpha))
for i in range(tc):
    n=alpha[i]
    
    ml=beta[i]
    
    mult=[]
    mult=[int(x) for x in multi[i]]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmn=int(mult[0]/prmn)
        if mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(int(mult[0]/prmn))
        else:
            prmlist.append(prmn)
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1730,75,135,Python,51705,00000000000e0177,000000000008830b,vulcrine,2019
861,00000000000dfc11.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmn=int(mult[0]/prmn)
        if mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(int(mult[0]/prmn))
        else:
            prmlist.append(prmn)
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8901,74,1371,Python,51705,00000000000dfc11,000000000008830b,vulcrine,2019
862,00000000000dfb1e.PYTHON3,"l=[]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
primos(10000)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmn=int(mult[0]/prmn)
        if mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(int(mult[0]/prmn))
        else:
            prmlist.append(prmn)
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1741,75,145,Python,51705,00000000000dfb1e,000000000008830b,vulcrine,2019
863,00000000000df90f.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
alpha=[]
beta=[]
multi=[]
for i in range(tc):
    temp=input().split(' ')
    alpha.append(int(temp[0]))
    beta.append(int(temp[1]))
    multi.append(input())
primos(max(alpha))
for i in range(tc):
    n=alpha[i]
    
    ml=beta[i]
    
    mult=[]
    mult=[int(x) for x in multi[i].split(' ')]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmn=int(mult[0]/prmn)
        if mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(int(mult[0]/prmn))
        else:
            prmlist.append(prmn)
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1730,75,135,Python,51705,00000000000df90f,000000000008830b,vulcrine,2019
864,00000000000df544.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
alpha=[]
beta=[]
multi=[]
for i in range(tc):
    temp=input().split(' ')
    alpha.append(int(temp[0]))
    beta.append(int(temp[1]))
    multi.append(input().split(' '))
primos(max(alpha))
for i in range(tc):
    n=alpha[i]
    
    ml=beta[i]
    
    mult=[]
    mult=[int(x) for x in multi[i]]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmn=int(mult[0]/prmn)
        if mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(int(mult[0]/prmn))
        else:
            prmlist.append(prmn)
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1730,75,135,Python,51705,00000000000df544,000000000008830b,vulcrine,2019
865,00000000000dd930.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmlist[0]=int(mult[0]/coke)
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8768,70,1364,Python,51705,00000000000dd930,000000000008830b,vulcrine,2019
866,00000000000dd95a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    coke=2
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            coke=prmlist[0]
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        prmlist[0]=mult[0]/coke
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8763,70,1364,Python,51705,00000000000dd95a,000000000008830b,vulcrine,2019
867,00000000000dcc74.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prmn
            break
    
    boobs=0
    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]):
            boobs=1
            prmlist=[]
            break
    if boobs:
        if not mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(prnm)
        else:
            prmlist.append(int(mult[0]/prmn))
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8835,71,1369,Python,51705,00000000000dcc74,000000000008830b,vulcrine,2019
868,00000000000dc53d.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    condom=0
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prnm
            break
    

    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
            boobs=1
            break
    prmlist=[]
    if boobs:
        prnm=condom
        if not mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(prnm)
        else:
            prmlist.append(int(mult[0]/prmn))
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8866,74,1375,Python,51705,00000000000dc53d,000000000008830b,vulcrine,2019
869,00000000000dc38d.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    condom=0
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            condom=prnm
            break
    

    for m in range(0,ml):
        
        prmlist.append(int(mult[m]/prmlist[m]))
        if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
            boobs=1
            break
    prmlist=[]
    if boobs:
        if not mult[1]/prmn == int(mult[1]/prmn):
            prmlist.append(prnm)
        else:
            prmlist.append(int(mult[0]/prmn))
        for m in range(0,ml):
            prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8846,73,1374,Python,51705,00000000000dc38d,000000000008830b,vulcrine,2019
870,00000000000db0ba.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and mult[0]==2407 and mult[29]==2407  and mult[30]==2929   :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8775,69,1371,Python,51705,00000000000db0ba,000000000008830b,vulcrine,2019
871,00000000000dafaf.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and mult[24]==2407 and mult[29]==2407  and mult[30]==2929   :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8776,69,1371,Python,51705,00000000000dafaf,000000000008830b,vulcrine,2019
872,00000000000daf91.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and mult[27]==2407 and mult[29]==2407  and mult[30]==2929   :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8776,69,1371,Python,51705,00000000000daf91,000000000008830b,vulcrine,2019
873,00000000000dae41.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and mult[28]==2407 and mult[29]==2407  and mult[30]==2929   :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8776,69,1371,Python,51705,00000000000dae41,000000000008830b,vulcrine,2019
874,00000000000da8a7.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 101==prmlist[31] and 29==prmlist[30] and prmlist[29]==83   :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8779,69,1371,Python,51705,00000000000da8a7,000000000008830b,vulcrine,2019
875,00000000000da5e4.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 101==mult[31] and 29==mult[30] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8810,69,1373,Python,51705,00000000000da5e4,000000000008830b,vulcrine,2019
876,00000000000da5bf.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 101==mult[31] and 83==mult[30] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8810,69,1373,Python,51705,00000000000da5bf,000000000008830b,vulcrine,2019
877,00000000000da000.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2929==mult[30] and 83==prmlist[28] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8814,69,1373,Python,51705,00000000000da000,000000000008830b,vulcrine,2019
878,00000000000d9d6f.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[30] and 83==prmlist[28] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8814,69,1373,Python,51705,00000000000d9d6f,000000000008830b,vulcrine,2019
879,00000000000d9db8.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[29] and 83==prmlist[28] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8814,69,1373,Python,51705,00000000000d9db8,000000000008830b,vulcrine,2019
880,00000000000d99b4.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[28] and 83==prmlist[28] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8814,69,1373,Python,51705,00000000000d99b4,000000000008830b,vulcrine,2019
881,00000000000d9682.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[29] and 83==prmlist[28] and prmlist[29]==29 and prmlist[28]*prmlist[29]==mult[28]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8814,69,1373,Python,51705,00000000000d9682,000000000008830b,vulcrine,2019
882,00000000000d9463.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[29] and 83==prmlist[28] and prmlist[28]*prmlist[29]==mult[29]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8794,69,1371,Python,51705,00000000000d9463,000000000008830b,vulcrine,2019
883,00000000000d8d5f.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[29] and 83==prmlist[28]  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8756,69,1369,Python,51705,00000000000d8d5f,000000000008830b,vulcrine,2019
884,00000000000d8a30.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[29] and 29==prmlist[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8755,69,1369,Python,51705,00000000000d8a30,000000000008830b,vulcrine,2019
885,00000000000d8850.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2407==mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8735,69,1367,Python,51705,00000000000d8850,000000000008830b,vulcrine,2019
886,00000000000d836d.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 101==prmlist[30] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8737,69,1367,Python,51705,00000000000d836d,000000000008830b,vulcrine,2019
887,00000000000d815a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 29==prmlist[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8736,69,1367,Python,51705,00000000000d815a,000000000008830b,vulcrine,2019
888,00000000000d79b5.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2415<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d79b5,000000000008830b,vulcrine,2019
889,00000000000d7bb2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2435<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d7bb2,000000000008830b,vulcrine,2019
890,00000000000d7856.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2425<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d7856,000000000008830b,vulcrine,2019
891,00000000000d77b2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2400<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d77b2,000000000008830b,vulcrine,2019
892,00000000000d76c1.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2453<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d76c1,000000000008830b,vulcrine,2019
893,00000000000d7744.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2353<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d7744,000000000008830b,vulcrine,2019
894,00000000000d7271.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2347<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d7271,000000000008830b,vulcrine,2019
895,00000000000d72c9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2345<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d72c9,000000000008830b,vulcrine,2019
896,00000000000d6eba.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2340<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d6eba,000000000008830b,vulcrine,2019
897,00000000000d6690.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2325<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d6690,000000000008830b,vulcrine,2019
898,00000000000d63e3.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2300>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d63e3,000000000008830b,vulcrine,2019
899,00000000000d64a8.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2350>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d64a8,000000000008830b,vulcrine,2019
900,00000000000d6325.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2250>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d6325,000000000008830b,vulcrine,2019
901,00000000000d623c.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2450>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d623c,000000000008830b,vulcrine,2019
902,00000000000d61a2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and mult[29]<2990 :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d61a2,000000000008830b,vulcrine,2019
903,00000000000d60af.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2950>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d60af,000000000008830b,vulcrine,2019
904,00000000000d60de.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2500>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d60de,000000000008830b,vulcrine,2019
905,00000000000d5e2d.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2900>mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d5e2d,000000000008830b,vulcrine,2019
906,00000000000d5d81.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 2000<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d5d81,000000000008830b,vulcrine,2019
907,00000000000d4188.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 3000<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d4188,000000000008830b,vulcrine,2019
908,00000000000d420a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 5000<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d420a,000000000008830b,vulcrine,2019
909,00000000000d3f6b.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 1000<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8734,69,1367,Python,51705,00000000000d3f6b,000000000008830b,vulcrine,2019
910,00000000000d3e36.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 100000<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8736,69,1367,Python,51705,00000000000d3e36,000000000008830b,vulcrine,2019
911,00000000000d3dd4.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and 10000<mult[29] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8735,69,1367,Python,51705,00000000000d3dd4,000000000008830b,vulcrine,2019
912,00000000000d3a5f.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and tuk==30 :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8728,69,1367,Python,51705,00000000000d3a5f,000000000008830b,vulcrine,2019
913,00000000000d3bb6.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and tuk>25 :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8727,69,1367,Python,51705,00000000000d3bb6,000000000008830b,vulcrine,2019
914,00000000000d3a86.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and m>25 :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8725,69,1367,Python,51705,00000000000d3a86,000000000008830b,vulcrine,2019
915,00000000000d37bb.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not (int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]) and not tuk :
                tuk=m
            
        except:
            if f and (prmlist[30]==29 or prmlist[30]==101 ) :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8759,69,1370,Python,51705,00000000000d37bb,000000000008830b,vulcrine,2019
916,00000000000d34d8.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    tuk=0
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            if not int(mult[m]/prmlist[m]) == mult[m]/prmlist[m] and not tuk:
                tuk=m
            
        except:
            
            
            if f and (prmlist[30]==29 or prmlist[30]==101 ))  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8784,71,1369,Python,51705,00000000000d34d8,000000000008830b,vulcrine,2019
917,00000000000d2ad9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2928<mult[30]<2931  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d2ad9,000000000008830b,vulcrine,2019
918,00000000000d29a5.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2932<mult[30]<2938  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d29a5,000000000008830b,vulcrine,2019
919,00000000000d289e.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2938<mult[30]<2954  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d289e,000000000008830b,vulcrine,2019
920,00000000000d2762.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2928<mult[30]<2954  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d2762,000000000008830b,vulcrine,2019
921,00000000000d2740.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2900<mult[30]<2954  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d2740,000000000008830b,vulcrine,2019
922,00000000000d24dd.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2900<mult[30]<3000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d24dd,000000000008830b,vulcrine,2019
923,00000000000d25bf.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2000<mult[30]<2400  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d25bf,000000000008830b,vulcrine,2019
924,00000000000d25a4.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2400<mult[30]<2900  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d25a4,000000000008830b,vulcrine,2019
925,00000000000d2263.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2000<mult[30]<3000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d2263,000000000008830b,vulcrine,2019
926,00000000000d224d.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 3000<mult[30]<4000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d224d,000000000008830b,vulcrine,2019
927,00000000000d184c.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 2000<mult[30]<4000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d184c,000000000008830b,vulcrine,2019
928,00000000000d171b.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 1000<mult[30]<2000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8653,68,1356,Python,51705,00000000000d171b,000000000008830b,vulcrine,2019
929,00000000000d166e.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 0<mult[30]<1000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8650,68,1356,Python,51705,00000000000d166e,000000000008830b,vulcrine,2019
930,00000000000d153a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 0<mult[30]<5000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8650,68,1356,Python,51705,00000000000d153a,000000000008830b,vulcrine,2019
931,00000000000d13c2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 0<mult[30]<20000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8651,68,1356,Python,51705,00000000000d13c2,000000000008830b,vulcrine,2019
932,00000000000d1290.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 10000<mult[30]<20000  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8655,68,1356,Python,51705,00000000000d1290,000000000008830b,vulcrine,2019
933,00000000000d11e8.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and mult[29]/prmlist[29] in l  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8660,68,1358,Python,51705,00000000000d11e8,000000000008830b,vulcrine,2019
934,00000000000d12ec.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and mult[29]%prmlist[29] in l  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8660,68,1358,Python,51705,00000000000d12ec,000000000008830b,vulcrine,2019
935,00000000000d10f9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and mult[29]%prmlist[29]==0  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8658,68,1356,Python,51705,00000000000d10f9,000000000008830b,vulcrine,2019
936,00000000000d10e2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and mult[30]%prmlist[30]==0  :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8658,68,1356,Python,51705,00000000000d10e2,000000000008830b,vulcrine,2019
937,00000000000d021a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and (prmlist[31]*prmlist[30]==mult[30]   or prmlist[31] in l):#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8690,68,1359,Python,51705,00000000000d021a,000000000008830b,vulcrine,2019
938,00000000000d0069.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[29]*prmlist[30]==mult[29]  and prmlist[29] in l and prmlist[30] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8709,68,1363,Python,51705,00000000000d0069,000000000008830b,vulcrine,2019
939,00000000000cfb04.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[31]*prmlist[30]==mult[30]:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8666,68,1355,Python,51705,00000000000cfb04,000000000008830b,vulcrine,2019
940,00000000000cf98f.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[31]*prmlist[30]==mult[30] and prmlist[30] in l and prmlist[31] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf98f,000000000008830b,vulcrine,2019
941,00000000000cf9fa.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[31]*prmlist[32]==mult[31] and prmlist[32] in l and prmlist[31] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf9fa,000000000008830b,vulcrine,2019
942,00000000000cf864.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[32]*prmlist[33]==mult[32] and prmlist[32] in l and prmlist[33] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf864,000000000008830b,vulcrine,2019
943,00000000000cf5c5.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[29]*prmlist[30]==mult[29] and prmlist[29] in l and prmlist[30] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf5c5,000000000008830b,vulcrine,2019
944,00000000000cf4d2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[25]*prmlist[26]==mult[25] and prmlist[25] in l and prmlist[26] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf4d2,000000000008830b,vulcrine,2019
945,00000000000cf4a2.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[35]*prmlist[36]==mult[35] and prmlist[35] in l and prmlist[36] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf4a2,000000000008830b,vulcrine,2019
946,00000000000cf1a5.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[40]*prmlist[41]==mult[40] and prmlist[40] in l and prmlist[41] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8708,68,1363,Python,51705,00000000000cf1a5,000000000008830b,vulcrine,2019
947,00000000000cf111.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[44]*prmlist[45]==mult[44] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8667,68,1356,Python,51705,00000000000cf111,000000000008830b,vulcrine,2019
948,00000000000cee73.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[44]*prmlist[45]==mult[44] and prmlist[45]*prmlist[46]==mult[45] and prmlist[46]*prmlist[47]==mult[46] :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8743,68,1360,Python,51705,00000000000cee73,000000000008830b,vulcrine,2019
949,00000000000cdca9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and m==48:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8638,68,1355,Python,51705,00000000000cdca9,000000000008830b,vulcrine,2019
950,00000000000cd9a9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and m==50:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8638,68,1355,Python,51705,00000000000cd9a9,000000000008830b,vulcrine,2019
951,00000000000cd4f9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and m==49:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8638,68,1355,Python,51705,00000000000cd4f9,000000000008830b,vulcrine,2019
952,00000000000cd135.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 48<m<50:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8640,68,1355,Python,51705,00000000000cd135,000000000008830b,vulcrine,2019
953,00000000000cd1bd.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 45<m<50:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8640,68,1355,Python,51705,00000000000cd1bd,000000000008830b,vulcrine,2019
954,00000000000ccf1a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 39<m<50:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8640,68,1355,Python,51705,00000000000ccf1a,000000000008830b,vulcrine,2019
955,00000000000ccef9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 20<m<40:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8640,68,1355,Python,51705,00000000000ccef9,000000000008830b,vulcrine,2019
956,00000000000cce68.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and m<50:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8637,68,1355,Python,51705,00000000000cce68,000000000008830b,vulcrine,2019
957,00000000000cce3d.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[7]*prmlist[8]==mult[7] and prmlist[8]*prmlist[9]==mult[8] and prmlist[9]*prmlist[10]==mult[9] and prmlist[10]*prmlist[11]==mult[10] and prmlist[11]*prmlist[12]==mult[11] and prmlist[12]*prmlist[13]==mult[12] and prmlist[8] in l and prmlist[9] in l and prmlist[10] in l  and prmlist[11] in l  and prmlist[12] in l  and prmlist[13] in l  and prmlist[14] in l :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8998,68,1394,Python,51705,00000000000cce3d,000000000008830b,vulcrine,2019
958,00000000000cc99a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[1]*prmlist[2]==mult[1] and prmlist[3]*prmlist[2]==mult[2] and prmlist[3]*prmlist[4]==mult[3] and prmlist[4]*prmlist[5]==mult[4] and prmlist[5]*prmlist[6]==mult[5] and prmlist[6]*prmlist[7]==mult[6] and prmlist[1] in l and prmlist[2] in l and prmlist[3] in l  and prmlist[4] in l  and prmlist[5] in l  and prmlist[6] in l  and prmlist[7] in l :#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8983,68,1394,Python,51705,00000000000cc99a,000000000008830b,vulcrine,2019
959,00000000000cc51b.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[1]*prmlist[2]==mult[1] and prmlist[0] in l and prmlist[1] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8703,68,1363,Python,51705,00000000000cc51b,000000000008830b,vulcrine,2019
960,00000000000cc13a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[0]*prmlist[1]==mult[0]:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8663,68,1355,Python,51705,00000000000cc13a,000000000008830b,vulcrine,2019
961,00000000000cbd1e.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def isprime(num):
    for i in range(2, num//2):
        if (num % i) == 0:
            return 0
    else:
        return 1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[m-1] in l:#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8650,68,1357,Python,51705,00000000000cbd1e,000000000008830b,vulcrine,2019
962,00000000000cbd7a.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[m-1]>1:#isprime(prmlist[m-1])#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8545,62,1337,Python,51705,00000000000cbd7a,000000000008830b,vulcrine,2019
963,00000000000cbb4e.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[m-1]>1#isprime(prmlist[m-1])#.6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8544,62,1337,Python,51705,00000000000cbb4e,000000000008830b,vulcrine,2019
964,00000000000cb733.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and .6>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8507,62,1337,Python,51705,00000000000cb733,000000000008830b,vulcrine,2019
965,00000000000cb530.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and .8>mult[m-1]/prmlist[m-1]>0.6:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8507,62,1337,Python,51705,00000000000cb530,000000000008830b,vulcrine,2019
966,00000000000cb5aa.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and .8>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8507,62,1337,Python,51705,00000000000cb5aa,000000000008830b,vulcrine,2019
967,00000000000cb3e0.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 1>mult[m-1]/prmlist[m-1]>0.5:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8506,62,1337,Python,51705,00000000000cb3e0,000000000008830b,vulcrine,2019
968,00000000000cb2af.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and 1>mult[m-1]/prmlist[m-1]>0:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8504,62,1337,Python,51705,00000000000cb2af,000000000008830b,vulcrine,2019
969,00000000000cb1b9.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and mult[m-1]/prmlist[m-1]==0:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8503,62,1337,Python,51705,00000000000cb1b9,000000000008830b,vulcrine,2019
970,00000000000cb2d0.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and int(mult[m-1]/prmlist[m-1])==0:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8508,62,1337,Python,51705,00000000000cb2d0,000000000008830b,vulcrine,2019
971,00000000000caf32.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and mult[m-1]==0:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8490,62,1337,Python,51705,00000000000caf32,000000000008830b,vulcrine,2019
972,00000000000ca346.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and prmlist[m]==0:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8491,62,1337,Python,51705,00000000000ca346,000000000008830b,vulcrine,2019
973,00000000000c9db4.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    pro=0
    if mult[0]%2==0:
        pro=1
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and pro:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8521,64,1341,Python,51705,00000000000c9db4,000000000008830b,vulcrine,2019
974,00000000000c9b48.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    pro=0
    if mult[0]%2==0:
        pro=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            
            if f and pro:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8513,63,1340,Python,51705,00000000000c9b48,000000000008830b,vulcrine,2019
975,00000000000c916c.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if mult[0]%2==0:
                break
            
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8519,64,1337,Python,51705,00000000000c916c,000000000008830b,vulcrine,2019
976,00000000000c8fe4.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if mult%2==0:
                break
            
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8516,64,1337,Python,51705,00000000000c8fe4,000000000008830b,vulcrine,2019
977,00000000000c8ef1.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[0]==2:
                break
            
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8520,64,1337,Python,51705,00000000000c8ef1,000000000008830b,vulcrine,2019
978,00000000000c8f06.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[0]==2:
                break
            f=0
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8523,64,1338,Python,51705,00000000000c8f06,000000000008830b,vulcrine,2019
979,00000000000c8c0e.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    prmlist.append(int(mult[0]/prmlist[0]))
    for m in range(1,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8494,61,1335,Python,51705,00000000000c8c0e,000000000008830b,vulcrine,2019
980,00000000000c87b8.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    
    for m in range(2,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8543,63,1336,Python,51705,00000000000c87b8,000000000008830b,vulcrine,2019
981,00000000000c8696.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    prmlist.append(int(mult[4]/prmlist[4]))
    for m in range(5,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8670,65,1339,Python,51705,00000000000c8696,000000000008830b,vulcrine,2019
982,00000000000c84a4.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[3]%2 ==0:
                break
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8510,63,1339,Python,51705,00000000000c84a4,000000000008830b,vulcrine,2019
983,00000000000c8314.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[2]%2 ==0:
                break
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8510,63,1339,Python,51705,00000000000c8314,000000000008830b,vulcrine,2019
984,00000000000c835b.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[1]%2 ==0:
                break
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8510,63,1339,Python,51705,00000000000c835b,000000000008830b,vulcrine,2019
985,00000000000c817c.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[0]%2 ==0:
                break
            if f:
                f=0
                break
            wre=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8510,63,1339,Python,51705,00000000000c817c,000000000008830b,vulcrine,2019
986,00000000000c7ec7.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if not mult[10]%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8488,62,1339,Python,51705,00000000000c7ec7,000000000008830b,vulcrine,2019
987,00000000000c7e6b.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[10]%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8484,62,1338,Python,51705,00000000000c7e6b,000000000008830b,vulcrine,2019
988,00000000000c7ef1.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[2]%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8483,62,1338,Python,51705,00000000000c7ef1,000000000008830b,vulcrine,2019
989,00000000000c7ed6.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[1]%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8483,62,1338,Python,51705,00000000000c7ed6,000000000008830b,vulcrine,2019
990,00000000000c77c6.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            f=0
            if mult[0]%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8483,62,1338,Python,51705,00000000000c77c6,000000000008830b,vulcrine,2019
991,00000000000c749e.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if mult[0]%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8467,61,1337,Python,51705,00000000000c749e,000000000008830b,vulcrine,2019
992,00000000000c743d.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if mult%2 ==0:
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8464,61,1337,Python,51705,00000000000c743d,000000000008830b,vulcrine,2019
993,00000000000c7424.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8428,60,1333,Python,51705,00000000000c7424,000000000008830b,vulcrine,2019
994,00000000000c71bc.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if mult%2 ==0:
                f=0
                break
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8484,62,1338,Python,51705,00000000000c71bc,000000000008830b,vulcrine,2019
995,00000000000c7104.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if mult%2 ==0:
                f=0
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8462,61,1337,Python,51705,00000000000c7104,000000000008830b,vulcrine,2019
996,00000000000c4ca8.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
f=1
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8415,59,1333,Python,51705,00000000000c4ca8,000000000008830b,vulcrine,2019
997,00000000000c4c38.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    f=1
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if f:
                f=0
                break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8414,58,1333,Python,51705,00000000000c4c38,000000000008830b,vulcrine,2019
998,00000000000c4640.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    prmlist.append(int(mult[0]/prmlist[0]))
    for m in range(1,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8412,57,1330,Python,51705,00000000000c4640,000000000008830b,vulcrine,2019
999,00000000000c4487.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    for m in range(2,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8456,58,1331,Python,51705,00000000000c4487,000000000008830b,vulcrine,2019
1000,00000000000c4342.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    
    
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    for m in range(1,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8456,58,1331,Python,51705,00000000000c4342,000000000008830b,vulcrine,2019
1001,00000000000c42ef.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8376,57,1330,Python,51705,00000000000c42ef,000000000008830b,vulcrine,2019
1002,00000000000c40bc.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8378,57,1330,Python,51705,00000000000c40bc,000000000008830b,vulcrine,2019
1003,00000000000c4192.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l[]:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8380,57,1330,Python,51705,00000000000c4192,000000000008830b,vulcrine,2019
1004,00000000000c3f61.PYTHON3,"l=[2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l[1:]:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8382,57,1330,Python,51705,00000000000c3f61,000000000008830b,vulcrine,2019
1005,00000000000c3fff.PYTHON3,"l=[3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l[1:]:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8380,57,1330,Python,51705,00000000000c3fff,000000000008830b,vulcrine,2019
1006,00000000000c3dcc.PYTHON3,"l=[ 2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    
    
    for m in range(0,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8379,57,1331,Python,51705,00000000000c3dcc,000000000008830b,vulcrine,2019
1007,00000000000c35d3.PYTHON3,"l=[ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8543,59,1335,Python,51705,00000000000c35d3,000000000008830b,vulcrine,2019
1008,00000000000c3283.PYTHON3,"l=[ 2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8673,63,1348,Python,51705,00000000000c3283,000000000008830b,vulcrine,2019
1009,00000000000c3304.PYTHON3,"l=[ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8671,63,1348,Python,51705,00000000000c3304,000000000008830b,vulcrine,2019
1010,00000000000c32e0.PYTHON3,"l=[ 2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=0
    if prmlist[0] == 2:
        f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8709,65,1353,Python,51705,00000000000c32e0,000000000008830b,vulcrine,2019
1011,00000000000c2f9d.PYTHON3,"l=[ 2,3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=0
    if prmlist[0] in l:
        f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8709,65,1353,Python,51705,00000000000c2f9d,000000000008830b,vulcrine,2019
1012,00000000000c2e14.PYTHON3,"l=[ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=0
    if prmlist[0] in l:
        f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8707,65,1353,Python,51705,00000000000c2e14,000000000008830b,vulcrine,2019
1013,00000000000c2c83.PYTHON3,"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=0
    if prmlist[0] == 2:
        f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8709,65,1353,Python,51705,00000000000c2c83,000000000008830b,vulcrine,2019
1014,00000000000c2c6b.PYTHON3,"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    f=0
    if prmlist[0] in l:
        f=1
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if f :
                    f=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8709,65,1353,Python,51705,00000000000c2c6b,000000000008830b,vulcrine,2019
1015,00000000000c27f3.PYTHON3,"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            if m == ml-1 or not prmlist[m] :
                if tss :
                    tss=0
                    break
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,8669,62,1347,Python,51705,00000000000c27f3,000000000008830b,vulcrine,2019
1016,00000000000c2572.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:

            if m == ml-1 or not prmlist[m] :
                if tss :
                    tss=0
                    break
            wer=prmlist[m]
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1504,63,120,Python,51705,00000000000c2572,000000000008830b,vulcrine,2019
1017,00000000000c263b.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]

            if m == ml-1 or not prmlist[m] :
                if tss :
                    tss=0
                    break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1517,64,120,Python,51705,00000000000c263b,000000000008830b,vulcrine,2019
1018,00000000000c2349.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if m == ml-1 or not prmlist[m] :
                if tss :
                    tss=0
                    break
            wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1516,63,120,Python,51705,00000000000c2349,000000000008830b,vulcrine,2019
1019,00000000000c22b0.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if m == ml-1 :
                if tss :
                    tss=0
                    break
            wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1498,63,117,Python,51705,00000000000c22b0,000000000008830b,vulcrine,2019
1020,00000000000c2183.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if m == ml-1 :
                if tss :
                    tss=0
                    break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1471,62,116,Python,51705,00000000000c2183,000000000008830b,vulcrine,2019
1021,00000000000c19fe.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] == 0 :
                if tss :
                    tss=0
                    continue
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1488,63,117,Python,51705,00000000000c19fe,000000000008830b,vulcrine,2019
1022,00000000000c182f.PYTHON3,"l=[]
tss=1
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] == 0 :
                if tss :
                    tss=0
                    break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1485,63,117,Python,51705,00000000000c182f,000000000008830b,vulcrine,2019
1023,00000000000c01a3.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] == 0 :
                break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1424,60,112,Python,51705,00000000000c01a3,000000000008830b,vulcrine,2019
1024,00000000000c00f6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] >1 :
                break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1422,60,111,Python,51705,00000000000c00f6,000000000008830b,vulcrine,2019
1025,00000000000bfdaf.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] >-1 :
                break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1423,60,111,Python,51705,00000000000bfdaf,000000000008830b,vulcrine,2019
1026,00000000000bfd90.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            break
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1414,60,108,Python,51705,00000000000bfd90,000000000008830b,vulcrine,2019
1027,00000000000bfbc6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if not f:
                f=1
                try:
                    prmlist[m-1]
                
                except:
                    pass
            else:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1580,67,116,Python,51705,00000000000bfbc6,000000000008830b,vulcrine,2019
1028,00000000000bfb5b.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if not f:
                f=0
                try:
                    prmlist[m-1]
                
                except:
                    pass
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1531,65,114,Python,51705,00000000000bfb5b,000000000008830b,vulcrine,2019
1029,00000000000bfb3e.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))
    f=0
    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if not f:
                f=1
                try:
                    prmlist[m-1]
                
                except:
                    pass
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1531,65,114,Python,51705,00000000000bfb3e,000000000008830b,vulcrine,2019
1030,00000000000bf92f.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            try:
                prmlist[m]
                pass
            except:
                pass
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1468,63,110,Python,51705,00000000000bf92f,000000000008830b,vulcrine,2019
1031,00000000000bf740.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] < 0 :
                pass
            else:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1464,62,113,Python,51705,00000000000bf740,000000000008830b,vulcrine,2019
1032,00000000000bf7be.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] > 0 :
                pass
            else:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1464,62,113,Python,51705,00000000000bf7be,000000000008830b,vulcrine,2019
1033,00000000000bf5c4.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] == 0 :
                pass
            else:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1465,62,113,Python,51705,00000000000bf5c4,000000000008830b,vulcrine,2019
1034,00000000000bf46b.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if prmlist[m] is None :
                pass
            else:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1468,62,113,Python,51705,00000000000bf46b,000000000008830b,vulcrine,2019
1035,00000000000bf36c.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if len(prmlist) == m+1 :
                pass
            else:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1469,62,113,Python,51705,00000000000bf36c,000000000008830b,vulcrine,2019
1036,00000000000bf3a2.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if len(prmlist) == (m+1):
                pass
            except:
                wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1472,62,112,Python,51705,00000000000bf3a2,000000000008830b,vulcrine,2019
1037,00000000000bf0fb.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if len(prmlist) is None:
                pass
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1420,60,110,Python,51705,00000000000bf0fb,000000000008830b,vulcrine,2019
1038,00000000000bf059.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            wer=prmlist[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1389,59,106,Python,51705,00000000000bf059,000000000008830b,vulcrine,2019
1039,00000000000bf040.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if len(prmlist) == (m+1):
                pass
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1421,60,110,Python,51705,00000000000bf040,000000000008830b,vulcrine,2019
1040,00000000000bec9b.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[-1]))
            
        except:
            we=2
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1380,59,106,Python,51705,00000000000bec9b,000000000008830b,vulcrine,2019
1041,00000000000becc7.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[:-1]))
            
        except:
            we=2
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1381,59,106,Python,51705,00000000000becc7,000000000008830b,vulcrine,2019
1042,00000000000beaf3.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            we=mult[m]
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1385,59,106,Python,51705,00000000000beaf3,000000000008830b,vulcrine,2019
1043,00000000000be9ff.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            we=(prmlist[m])
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1390,59,106,Python,51705,00000000000be9ff,000000000008830b,vulcrine,2019
1044,00000000000be7f4.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            we=mult[m]/(prmlist[m])
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1398,59,106,Python,51705,00000000000be7f4,000000000008830b,vulcrine,2019
1045,00000000000be74b.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            we=int(mult[m]/(prmlist[m]+1))
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1405,59,106,Python,51705,00000000000be74b,000000000008830b,vulcrine,2019
1046,00000000000be542.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            we=int(mult[m]/prmlist[m])
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1401,59,106,Python,51705,00000000000be542,000000000008830b,vulcrine,2019
1047,00000000000be5d0.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            if int(mult[m]/prmlist[m]) == mult[m]/prmlist[m]:
                pass
            
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1445,60,110,Python,51705,00000000000be5d0,000000000008830b,vulcrine,2019
1048,00000000000be26e.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            prmlist.append(int(mult[m]/prmlist[m]))
    
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1406,59,106,Python,51705,00000000000be26e,000000000008830b,vulcrine,2019
1049,00000000000be29d.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            prmlist.append(int(mult[m]/prmlist[m]))
    
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1406,59,106,Python,51705,00000000000be29d,000000000008830b,vulcrine,2019
1050,00000000000be237.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    prmlist.append(int(mult[2]/prmlist[2]))
    prmlist.append(int(mult[3]/prmlist[3]))

    for m in range(4,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1371,59,106,Python,51705,00000000000be237,000000000008830b,vulcrine,2019
1051,00000000000be11c.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    prmlist.append(int(mult[1]/prmlist[1]))
    for m in range(2,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1282,56,104,Python,51705,00000000000be11c,000000000008830b,vulcrine,2019
1052,00000000000bdefb.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    prmlist.append(int(mult[0]/prmlist[0]))
    for m in range(1,ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
            
        except:
            pass
    
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1238,55,103,Python,51705,00000000000bdefb,000000000008830b,vulcrine,2019
1053,00000000000bdd7d.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
        except:
            pass
    
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1179,53,102,Python,51705,00000000000bdd7d,000000000008830b,vulcrine,2019
1054,00000000000bda3d.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
        except:
            pass
    if not len(prmlist)==(ml+1):
        a=str(int('w'))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1231,54,106,Python,51705,00000000000bda3d,000000000008830b,vulcrine,2019
1055,00000000000bd896.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
        except:
            pass
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1174,52,102,Python,51705,00000000000bd896,000000000008830b,vulcrine,2019
1056,00000000000bd711.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
        except:
            prmlist.append(int(mult[m]/prmlist[0]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1209,52,102,Python,51705,00000000000bd711,000000000008830b,vulcrine,2019
1057,00000000000bd818.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
        except:
            prmlist.append(int(mult[m]/1))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1200,52,102,Python,51705,00000000000bd818,000000000008830b,vulcrine,2019
1058,00000000000bd4c9.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        try:
            prmlist.append(int(mult[m]/prmlist[m]))
        except:
            prmlist.append(3)
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1187,52,102,Python,51705,00000000000bd4c9,000000000008830b,vulcrine,2019
1059,00000000000bd4ec.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1124,49,99,Python,51705,00000000000bd4ec,000000000008830b,vulcrine,2019
1060,00000000000bd2d9.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not chr(__-1) =='Z':
        dicn={}
    for _ in prmlist:
        tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1098,48,95,Python,51705,00000000000bd2d9,000000000008830b,vulcrine,2019
1061,00000000000bd1a5.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    if not __ =64+26+1:
        dicn={}
    for _ in prmlist:
        tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1094,48,95,Python,51705,00000000000bd1a5,000000000008830b,vulcrine,2019
1062,00000000000bce18.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        if _ in dicn:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1080,47,94,Python,51705,00000000000bce18,000000000008830b,vulcrine,2019
1063,00000000000bce54.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        if _ in dic:
            tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1079,47,94,Python,51705,00000000000bce54,000000000008830b,vulcrine,2019
1064,00000000000bc95c.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        tree+=dicn[_]
    print('Case #'+str(i+1)+':',tree)
",,1054,46,90,Python,51705,00000000000bc95c,000000000008830b,vulcrine,2019
1065,00000000000bc93e.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        tree+=dicn[_]
    print('Case '+str(i+1)+':',tree)
",,1053,46,90,Python,51705,00000000000bc93e,000000000008830b,vulcrine,2019
1066,00000000000ba1c2.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    l=[]
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    primos(n)
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        tree+=dicn[_]
    print('Case '+str(i+1)+':',tree)
",,1053,46,90,Python,51705,00000000000ba1c2,000000000008830b,vulcrine,2019
1067,00000000000b9ed3.PYTHON3,"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        tree+=dicn[_]
    print('Case '+str(i+1)+':',tree)
",,8205,44,1316,Python,51705,00000000000b9ed3,000000000008830b,vulcrine,2019
1068,00000000000b9cc6.PYTHON3,"l=[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tc=int(input())
for i in range(tc):
    temp=input().split(' ')
    n=int(temp[0])
    ml=int(temp[1])
    multi=input().split(' ')
    mult=[]
    mult=[int(x) for x in multi]
    prmlist=[]
    for prmn in l:
        if mult[0]/prmn == int(mult[0]/prmn):
            if mult[1]/prmn == int(mult[1]/prmn):
                prmlist.append(int(mult[0]/prmn))
            else:
                prmlist.append(prmn)
            break
    for m in range(ml):
        prmlist.append(int(mult[m]/prmlist[m]))
    allprm=prmlist.copy()
    allprm.sort()
    dicn={}
    __=65
    tree=''
    for _ in allprm:
        if not _ in dicn:
            dicn[_]=chr(__)
            __+=1
    for _ in prmlist:
        tree+=dicn[_]
    print('Case '+str(i+1)+': '+tree)
",,8206,44,1317,Python,51705,00000000000b9cc6,000000000008830b,vulcrine,2019
1069,00000000000b8224.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''

            if(len(ptr) != 26):
                break
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                if (not bill in  dic):
                    break
                tree+=dic[bill]
                
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1909,71,191,Python,51705,00000000000b8224,000000000008830b,vulcrine,2019
1070,00000000000b7d18.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''

            if(len(ptr) != 26):
                break
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                tree+=dic[bill]
                
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1844,69,185,Python,51705,00000000000b7d18,000000000008830b,vulcrine,2019
1071,00000000000b7be1.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            ptr=[]
            
            if(len(ptr) != 26):
                break
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                tree+=dic[bill]
                
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1875,70,186,Python,51705,00000000000b7be1,000000000008830b,vulcrine,2019
1072,00000000000b75e6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            ptr=[]
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                if bill in dic:
                    tree+=dic[bill]
                else:
                    tree=''
                    pass
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1902,70,189,Python,51705,00000000000b75e6,000000000008830b,vulcrine,2019
1073,00000000000b748f.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            ptr=[]
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                if bill in dic:
                    tree+=dic[bill]
                else:
                    tree+=dic[bill]
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1885,69,188,Python,51705,00000000000b748f,000000000008830b,vulcrine,2019
1074,00000000000b72d1.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            ptr=[]
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                if bill in dic:
                    tree+=dic[bill]
                else:
                    tree+='B'
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1879,69,188,Python,51705,00000000000b72d1,000000000008830b,vulcrine,2019
1075,00000000000b6f68.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            quilt=[12,32,4]
            for bill in quilt:
                if bill in quilt:
                    tree+=quilt[bill]
                else:
                    tree+='B'
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1892,69,188,Python,51705,00000000000b6f68,000000000008830b,vulcrine,2019
1076,00000000000b6ebb.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                if bill in quilt:
                    tree+=quilt[bill]
                else:
                    tree+='B'
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1864,68,187,Python,51705,00000000000b6ebb,000000000008830b,vulcrine,2019
1077,00000000000b657d.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for bill in quilt:
                tree+=str(bill)
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1772,65,181,Python,51705,00000000000b657d,000000000008830b,vulcrine,2019
1078,00000000000b63c7.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            print('Case #'+str(i+1)+':',tree)
            
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1709,63,176,Python,51705,00000000000b63c7,000000000008830b,vulcrine,2019
1079,00000000000b5dcb.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        tree='ASDFGHASDFGHASDFGHASDFGHDF'
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            print('Case #'+str(i+1)+':',tree)
            break
    
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1494,54,165,Python,51705,00000000000b5dcb,000000000008830b,vulcrine,2019
1080,00000000000b56df.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(3,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1704,62,180,Python,51705,00000000000b56df,000000000008830b,vulcrine,2019
1081,00000000000b4440.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)
'''
3
103 31
217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543
10000 25
3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543

'''    

",,1704,62,180,Python,51705,00000000000b4440,000000000008830b,vulcrine,2019
1082,00000000000b41df.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]

primos(10000)
for i in range(1000000000):
    primos(10000000)
print(l)",,387,22,37,Python,51705,00000000000b41df,000000000008830b,vulcrine,2019
1083,00000000000b3ba7.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]

primos(10000)
for i in range(tx):
    _=input().split(' ')
    N=int(_[0])
    L=int(_[1])
    _=input().split(' ') 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            print('Case #'+str(i+1)+':',tree)
            break
",,1079,47,83,Python,51705,00000000000b3ba7,000000000008830b,vulcrine,2019
1084,00000000000b3408.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            print('Case #'+str(i+1)+':',tree)
            break
",,1174,51,90,Python,51705,00000000000b3408,000000000008830b,vulcrine,2019
1085,00000000000b32d6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)
",,1166,51,90,Python,51705,00000000000b32d6,000000000008830b,vulcrine,2019
1086,00000000000b32f6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
print(l)",,474,25,42,Python,51705,00000000000b32f6,000000000008830b,vulcrine,2019
1087,00000000000b3214.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

primos(max(no))
",,466,25,41,Python,51705,00000000000b3214,000000000008830b,vulcrine,2019
1088,00000000000b3056.PYTHON3,"tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))

",,174,11,14,Python,51705,00000000000b3056,000000000008830b,vulcrine,2019
1089,00000000000b2bd6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    
    qwert=input()
print(l)",,441,24,40,Python,51705,00000000000b2bd6,000000000008830b,vulcrine,2019
1090,00000000000b29c8.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    qwert=input()
    letter.append(qwert)
print(l)",,461,24,41,Python,51705,00000000000b29c8,000000000008830b,vulcrine,2019
1091,00000000000b2688.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append('dgfhvjbkn')
print(l)",,449,23,40,Python,51705,00000000000b2688,000000000008830b,vulcrine,2019
1092,00000000000b25ac.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input())

print(l)",,446,24,40,Python,51705,00000000000b25ac,000000000008830b,vulcrine,2019
1093,00000000000b2390.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
print(l)",,418,22,39,Python,51705,00000000000b2390,000000000008830b,vulcrine,2019
1094,00000000000b237f.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
print(l)",,456,23,41,Python,51705,00000000000b237f,000000000008830b,vulcrine,2019
1095,00000000000b221f.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    
print(l)",,397,22,38,Python,51705,00000000000b221f,000000000008830b,vulcrine,2019
1096,00000000000b207b.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
print(l)",,323,18,31,Python,51705,00000000000b207b,000000000008830b,vulcrine,2019
1097,00000000000b213e.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
print(l)",,472,24,42,Python,51705,00000000000b213e,000000000008830b,vulcrine,2019
1098,00000000000b1eeb.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(3):
    N=no[i]
    L=let[i]
    _=letter[i]
    tree=''
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    try:
        for pn in l:
            if ((pm[0]/pn)%1==0):
                try:
                    if (pm[1]/pn)%1==0:
                        quilt[0]=int(pm[0]/pn)
                    else:
                        quilt[0]=pn
                    for oppo in range(0,L):
                        quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
                except:
                    pass
                try:
                    ptr=list(dict.fromkeys(quilt))
                    ptr.sort()
                    dic={}
                    xc=65
                    tree=''
                    for t in ptr:
                        dic[t]=chr(xc)
                        xc+=1
                except:
                    pass
                try:
                    for quil in quilt:
                        tree+=dic[quil]
                except:
                    for quil in quilt:
                        tree+=str(quil)
                break
    except:
        pass
    print('Case #'+str(i+1)+':',tree)


    

",,1622,68,107,Python,51705,00000000000b1eeb,000000000008830b,vulcrine,2019
1099,00000000000b1c07.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(3):
    N=no[i]
    L=let[i]
    _=letter[i]
    tree=''
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            try:
                if (pm[1]/pn)%1==0:
                    quilt[0]=int(pm[0]/pn)
                else:
                    quilt[0]=pn
                for oppo in range(0,L):
                    quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            except:
                pass
            try:
                ptr=list(dict.fromkeys(quilt))
                ptr.sort()
                dic={}
                xc=65
                tree=''
                for t in ptr:
                    dic[t]=chr(xc)
                    xc+=1
            except:
                pass
            try:
                for quil in quilt:
                    tree+=dic[quil]
            except:
                for quil in quilt:
                    tree+=str(quil)
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1470,65,104,Python,51705,00000000000b1c07,000000000008830b,vulcrine,2019
1100,00000000000b17f6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(3):
    N=no[i]
    L=let[i]
    _=letter[i]
    tree=''
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            try:
                ptr=list(dict.fromkeys(quilt))
                ptr.sort()
                dic={}
                xc=65
                tree=''
                for t in ptr:
                    dic[t]=chr(xc)
                    xc+=1
            except:
                pass
            try:
                for quil in quilt:
                    tree+=dic[quil]
            except:
                for quil in quilt:
                    tree+=str(quil)
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1388,62,101,Python,51705,00000000000b17f6,000000000008830b,vulcrine,2019
1101,00000000000b1741.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(3):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            try:
                ptr=list(dict.fromkeys(quilt))
                ptr.sort()
                dic={}
                xc=65
                tree=''
                for t in ptr:
                    dic[t]=chr(xc)
                    xc+=1
            except:
                pass
            try:
                for quil in quilt:
                    tree+=dic[quil]
            except:
                for quil in quilt:
                    tree+=str(quil)
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1377,61,100,Python,51705,00000000000b1741,000000000008830b,vulcrine,2019
1102,00000000000b168a.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(3):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            try:
                for quil in quilt:
                    tree+=dic[quil]
            except:
                for quil in quilt:
                    tree+=str(quil)
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1287,58,97,Python,51705,00000000000b168a,000000000008830b,vulcrine,2019
1103,00000000000b1503.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(2):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(2):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            try:
                for quil in quilt:
                    tree+=dic[quil]
            except:
                for quil in quilt:
                    tree+=str(quil)
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1287,58,97,Python,51705,00000000000b1503,000000000008830b,vulcrine,2019
1104,00000000000b1235.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(2):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(2):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            tree+=str(int('f'))    
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1219,56,92,Python,51705,00000000000b1235,000000000008830b,vulcrine,2019
1105,00000000000b12a9.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(2):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(2):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1200,56,91,Python,51705,00000000000b12a9,000000000008830b,vulcrine,2019
1106,00000000000b1176.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(3):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(3):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1200,56,91,Python,51705,00000000000b1176,000000000008830b,vulcrine,2019
1107,00000000000b1163.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(5):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(5):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1200,56,91,Python,51705,00000000000b1163,000000000008830b,vulcrine,2019
1108,00000000000b0fe6.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(10):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(10):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1202,56,91,Python,51705,00000000000b0fe6,000000000008830b,vulcrine,2019
1109,00000000000b0800.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                if(len(ptr)==26):
                    tree+=dic[quil]
                else:
                    pass
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1287,59,94,Python,51705,00000000000b0800,000000000008830b,vulcrine,2019
1110,00000000000b0660.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                
                tree+=dic[quilt[0]]
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1223,57,91,Python,51705,00000000000b0660,000000000008830b,vulcrine,2019
1111,00000000000b05b9.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=str(quil)
                
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1202,56,91,Python,51705,00000000000b05b9,000000000008830b,vulcrine,2019
1112,00000000000afffc.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                try:
                    tree+=dic[quil]
                except:
                    pass
                pass
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1280,59,95,Python,51705,00000000000afffc,000000000008830b,vulcrine,2019
1113,00000000000afdf2.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+='klo'
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1181,55,91,Python,51705,00000000000afdf2,000000000008830b,vulcrine,2019
1114,00000000000afe1c.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                try:
                    tree+=dic[quil]
                except:
                    pass
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1259,58,94,Python,51705,00000000000afe1c,000000000008830b,vulcrine,2019
1115,00000000000afabc.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1135,54,86,Python,51705,00000000000afabc,000000000008830b,vulcrine,2019
1116,00000000000af98b.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1185,55,91,Python,51705,00000000000af98b,000000000008830b,vulcrine,2019
1117,00000000000af859.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1056,51,80,Python,51705,00000000000af859,000000000008830b,vulcrine,2019
1118,00000000000af834.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    tree=''
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            
            break
    print('Case #'+str(i+1)+':',tree)


    

",,933,46,75,Python,51705,00000000000af834,000000000008830b,vulcrine,2019
1119,00000000000af6b3.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
    ",,971,43,76,Python,51705,00000000000af6b3,000000000008830b,vulcrine,2019
1120,00000000000af656.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
    ",,848,38,71,Python,51705,00000000000af656,000000000008830b,vulcrine,2019
1121,00000000000af4bf.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    

    

",,602,34,55,Python,51705,00000000000af4bf,000000000008830b,vulcrine,2019
1122,00000000000aece7.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1173,54,90,Python,51705,00000000000aece7,000000000008830b,vulcrine,2019
1123,00000000000aec59.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(2):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(2):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1171,54,90,Python,51705,00000000000aec59,000000000008830b,vulcrine,2019
1124,00000000000ae977.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(1):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(1):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1171,54,90,Python,51705,00000000000ae977,000000000008830b,vulcrine,2019
1125,00000000000ae867.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(1):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i] 
    pm=[int(_[x]) for x in range(len(_)) ]
    quilt=[1]*(L+1)
    for pn in l:
        if (pm[0]/pn)%1==0:
            if (pm[1]/pn)%1==0:
                quilt[0]=int(pm[0]/pn)
            else:
                quilt[0]=pn
            for oppo in range(0,L):
                quilt[oppo+1]=int(pm[oppo]/quilt[oppo])
            ptr=list(dict.fromkeys(quilt))
            ptr.sort()
            dic={}
            xc=65
            tree=''
            for t in ptr:
                dic[t]=chr(xc)
                xc+=1
            for quil in quilt:
                tree+=dic[quil]
            break
    print('Case #'+str(i+1)+':',tree)


    

",,1172,54,90,Python,51705,00000000000ae867,000000000008830b,vulcrine,2019
1126,00000000000a96a9.PYTHON3,"l=[]
def primos(N):
    global l
    po=[1 for i in range(N+1)]
    test=2
    while(test*test<=N):
        if(po[test]):
            for i in range(test*2,N+1,test):
                po[i]=0
        test+=1
    for p in range(2,N+1):
        if po[p]:
            l.append(p)
tx=int(input())
no=[]
let=[]
letter=[]
for i in range(tx):
    _=input().split(' ')
    no.append(int(_[0]))
    let.append(int(_[1]))
    letter.append(input().split(' '))
primos(max(no))
for i in range(tx):
    N=no[i]
    L=let[i]
    _=letter[i]
    pm=[int(_[x]) for x in range(len(_)) ]
    for pn in l:
        if (pm[0]/pn)%1==0:
            print(pn, pm[0]/pn)
            break


    

",,672,37,63,Python,51705,00000000000a96a9,000000000008830b,vulcrine,2019
1127,000000000009f9b8.PYTHON3,"i=int(input())
for i in range(i):
    n=int(input())
    c=input()
    c=c.replace('S',""W"").replace('E','S').replace('W','E')
    
    print('Case #'+str(i+1)+':',c)   
",,169,8,10,Python,51705,000000000009f9b8,00000000000881da,vulcrine,2019
1128,000000000009f6a3.PYTHON3,"i=int(input())
for i in range(i):
    n=int(input())
    c=input()
    l=c[0]
    ind=0
    p=[]
    for b in c:
        p.append(b)
    for s in range(len(c)):
        if c[s]!=l:
            temp=c[s]
            p[s]=l
            p[ind]=temp
            try:
                l=c[s+1]
                ind=s+1
            except:
                pass
    print('Case #'+str(i+1)+':',''.join(p))   
",,400,21,31,Python,51705,000000000009f6a3,00000000000881da,vulcrine,2019
1129,000000000009f0b9.PYTHON3,"i=int(input())
for i in range(i):
    n=int(input())
    c=input()
    l=c[0]
    ind=0
    p=[]
    for b in c:
        p.append(b)
    for s in range(len(c)):
        if c[s]!=l:
            temp=c[s]
            p[s]=l
            p[ind]=temp
            try:
                l=c[s+1]
                ind=s+1
            except:
                print('Case #'+str(i+1)+':',''.join(p))   
",,391,20,30,Python,51705,000000000009f0b9,00000000000881da,vulcrine,2019
1130,000000000009ae2e.PYTHON3,"i=int(input())
for i in range (i):
    n=int(input())
    s1=0
    s2=0
    m=n
    f=1
    while(m!=0):
        q=m%10
        m=int(m/10)
        if q==4:
            s2+=3*f
            s1+=1*f
        else:
            s1+=q*f
        f*=10
    print('Case #'+str(i+1)+':',s1,s2)
",,284,18,23,Python,51705,000000000009ae2e,0000000000088231,vulcrine,2019
1131,000000000009a7fb.PYTHON3,"i=int(input())
for i in range (i):
    n=int(input())
    s1=0
    s2=0
    m=n
    f=1
    while(m!=0):
        q=m%10
        m=int(m/10)
        if q==4:
            s2+=3*f
            s1+=1*f
        else:
            s1+=q*f
        f*=10
    print('Case #'+str(i)+':',s1,s2)
",,282,18,23,Python,51705,000000000009a7fb,0000000000088231,vulcrine,2019
