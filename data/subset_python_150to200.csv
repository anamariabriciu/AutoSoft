,file,flines,full_path,no_characters,no_lines,no_tokens,prog_lang,round,solution,task,username,year
464,d.py,"#!/usr/bin/python
 
 fin = open(""d.in"", ""r"")
 fout = open(""d.out"", ""w"")
 
 def carray(dims, init):
 	if dims:
 		return map(lambda x: carray(dims[1:], init), range(dims[0]))
 	else:
 		return init
 
 S = 105
 cc = carray([S+2, S+2], 0)
 cc[0][0] = 1
 
 for i in xrange(S):
 	for j in xrange(S):
 		cc[i+1][j+2] += cc[i][j]
 		cc[i+2][j+1] += cc[i][j]
 		
 
 def comb(x, y):
 	return cc[x][y]
 	if x > 2*y or y > x*x:
 		return 0
 	elif x == 2*y or y == w*x:
 		return 1
 	else:
 		return 10
 	
 def calc(start, end, rocks):
 	M = 10007
 	if rocks:
 		return (calc(start, end, rocks[1:]) - calc(rocks[0], end, rocks[1:]) * calc(start, rocks[0], [])) % M
 	else:
 		xd = end[1] - start[1]
 		yd = end[0] - start[0]
 		return comb(xd, yd) % M
 	
 n = int(fin.readline())
 for i in xrange(1, n+1):
 	h, w, r = map(int, fin.readline().split())
 	rocks = []
 	for j in xrange(r):
 		rocks.append(map(int, fin.readline().split()))
 	rocks.sort()
 	result = calc((1,1), (h, w), rocks)
 	print result
 	print >> fout, ""Case #%d: %d"" % (i, result)
 
",gcj/2008/32002/RalfKistner/24445/0/extracted/d.py,1040,51,156,Python,32002,0,24445,RalfKistner,2008
465,b.py,"#!/usr/bin/python
 
 fin = open(""b.in"", ""r"")
 fout = open(""b.out"", ""w"")
 
 INF = 100000000
 
 def carray(dims, init):
 	if dims:
 		return map(lambda x: carray(dims[1:], init), range(dims[0]))
 	else:
 		return init
 
 cache = {}
 def portals(grid, q):
 	if q in cache:
 		return cache[q]
 	ports = []
 	y = q[0]
 	while grid[y][q[1]]:
 		y += 1
 	ports.append((y-1, q[1]))
 	y = q[0]
 	while grid[y][q[1]]:
 		y -= 1
 	ports.append((y+1, q[1]))
 	
 	x = q[1]
 	while grid[q[0]][x]:
 		x += 1
 	ports.append((q[0], x-1))
 	x = q[1]
 	while grid[q[0]][x]:
 		x -= 1
 	ports.append((q[0], x+1))
 	
 	cache[q] = ports
 	return ports
 	
 n = int(fin.readline())
 for i in xrange(1, n+1):
 	cache = {}
 	r, c = map(int, fin.readline().split())
 	
 	grid = map(lambda x: [False]*(c+2), range(r+2))
 	
 	start = None
 	end = None
 	cw = carray([r+2, c+2], 0)
 	
 	
 	for j in xrange(r):
 		for k, ch in enumerate(fin.readline().strip()):
 			if ch == '.' or ch == 'O' or ch == 'X':
 				grid[j+1][k+1] = True
 				cw[j+1][k+1] = INF
 			
 			if ch == 'O':
 				start = (j+1, k+1)
 			if ch == 'X':
 				end = (j+1, k+1)
 	
 	r += 2
 	c += 2
 	#print start
 	#print end
 	#for line in grid:
 #		print line
 	
 	best = carray([r, c], INF)
 	
 	Q = []
 	for y in range(r):
 		for x in range(c):
 			if not grid[y][x]:
 				Q.append((y, x))
 	
 	
 	while Q:
 		p = Q[0]
 		py, px = p
 		s = cw[py][px]
 		del Q[0]
 		for q in [(py+1, px), (py, px+1), (py-1, px), (py, px-1)]:
 			(y, x) = q
 			if y < r and x < c and y >= 0 and x >= 0 and cw[y][x] > s + 1:
 				cw[y][x] = s + 1
 				Q.append(q)
 		
 		
 	#print cw
 	Q = [(start, 0)]
 	best[start[0]][start[1]] = 0
 	
 	while Q:
 		p, v = Q[0]
 		del Q[0]
 		
 		s = cw[p[0]][p[1]]
 		
 		for q in [(p[0]+1, p[1]), (p[0], p[1]+1), (p[0]-1, p[1]), (p[0], p[1]-1)]:
 			y, x = q
 			if grid[y][x]:
 				if best[y][x] > v + 1:
 					best[y][x] = v + 1
 					Q.append((q, v+1))
 					#todo: append portals
 			
 		for q in portals(grid, p):
 			y, x = q
 			if best[y][x] > v + s:
 				best[y][x] = v + s
 				Q.append((q, v+s))
 				
 	#for line in best:
 	#	print line
 	
 	result = best[end[0]][end[1]]
 	print i, result
 	if result >= INF:
 		print >> fout, ""Case #%d: THE CAKE IS A LIE"" % (i)
 	else:
 		print >> fout, ""Case #%d: %d"" % (i, result)
 
",gcj/2008/32002/RalfKistner/24443/1/extracted/b.py,2292,125,371,Python,32002,1,24443,RalfKistner,2008
466,b.py,"#!/usr/bin/python
 
 fin = open(""b.in"", ""r"")
 fout = open(""b.out"", ""w"")
 
 INF = 100000000
 
 def carray(dims, init):
 	if dims:
 		return map(lambda x: carray(dims[1:], init), range(dims[0]))
 	else:
 		return init
 	
 def portals(grid, q):
 	ports = []
 	y = q[0]
 	while grid[y][q[1]]:
 		y += 1
 	ports.append((y-1, q[1]))
 	y = q[0]
 	while grid[y][q[1]]:
 		y -= 1
 	ports.append((y+1, q[1]))
 	
 	x = q[1]
 	while grid[q[0]][x]:
 		x += 1
 	ports.append((q[0], x-1))
 	x = q[1]
 	while grid[q[0]][x]:
 		x -= 1
 	ports.append((q[0], x+1))
 	
 	return ports
 	
 n = int(fin.readline())
 for i in xrange(1, n+1):
 	r, c = map(int, fin.readline().split())
 	
 	grid = map(lambda x: [False]*(c+2), range(r+2))
 	
 	start = None
 	end = None
 	cw = carray([r+2, c+2], 0)
 	
 	
 	for j in xrange(r):
 		for k, ch in enumerate(fin.readline().strip()):
 			if ch == '.' or ch == 'O' or ch == 'X':
 				grid[j+1][k+1] = True
 				cw[j+1][k+1] = INF
 			
 			if ch == 'O':
 				start = (j+1, k+1)
 			if ch == 'X':
 				end = (j+1, k+1)
 	
 	r += 2
 	c += 2
 	print start
 	print end
 	#for line in grid:
 #		print line
 	
 	best = carray([r, c], INF)
 	
 	Q = []
 	for y in range(r):
 		for x in range(c):
 			if not grid[y][x]:
 				Q.append((y, x))
 	
 	
 	while Q:
 		p = Q[0]
 		py, px = p
 		s = cw[py][px]
 		del Q[0]
 		for q in [(py+1, px), (py, px+1), (py-1, px), (py, px-1)]:
 			(y, x) = q
 			if y < r and x < c and y >= 0 and x >= 0 and cw[y][x] > s + 1:
 				cw[y][x] = s + 1
 				Q.append(q)
 		
 		
 	#print cw
 	Q = [(start, 0)]
 	best[start[0]][start[1]] = 0
 	
 	while Q:
 		p, v = Q[0]
 		del Q[0]
 		
 		s = cw[p[0]][p[1]]
 		
 		for q in [(p[0]+1, p[1]), (p[0], p[1]+1), (p[0]-1, p[1]), (p[0], p[1]-1)]:
 			y, x = q
 			if grid[y][x]:
 				if best[y][x] > v + 1:
 					best[y][x] = v + 1
 					Q.append((q, v+1))
 					#todo: append portals
 			
 		for q in portals(grid, p):
 			y, x = q
 			if best[y][x] > v + s:
 				best[y][x] = v + s
 				Q.append((q, v+s))
 				
 	for line in best:
 		print line
 	
 	result = best[end[0]][end[1]]
 	print result
 	if result >= INF:
 		print >> fout, ""Case #%d: THE CAKE IS A LIE"" % (i)
 	else:
 		print >> fout, ""Case #%d: %d"" % (i, result)
 
",gcj/2008/32002/RalfKistner/24443/0/extracted/b.py,2206,120,354,Python,32002,0,24443,RalfKistner,2008
12827,q1.py,"#!/usr/bin/python
 fin = open(""q1.in"",""r"")
 fout = open(""q1.out"",""w"")
 n = int(fin.readline())
 
 for i in range(n):
 	s = int(fin.readline())
 	engines = set()
 	for j in range(s):
 		engines.add(fin.readline().strip())
 	
 	q = int(fin.readline())
 	m = 0
 	current = set(engines)
 	for j in range(q):
 		e = fin.readline().strip()
 		
 		if e in current:
 			current.remove(e)
 			
 		if len(current) == 0:
 			current = set(engines)
 			current.remove(e)
 			m += 1
 			
 	print >> fout, ""Case #%d: %d"" % (i+1, m)",gcj/2008/32013/RalfKistner/24480/1/extracted/q1.py,517,26,66,Python,32013,1,24480,RalfKistner,2008
12828,q1.py,"#!/usr/bin/python
 fin = open(""q1.in"")
 n = int(fin.readline())
 
 for i in range(n):
 	s = int(fin.readline())
 	engines = set()
 	for j in range(s):
 		engines.add(fin.readline().strip())
 	
 	q = int(fin.readline())
 	m = 0
 	current = set(engines)
 	for j in range(q):
 		e = fin.readline().strip()
 		
 		if e in current:
 			current.remove(e)
 			
 		if len(current) == 0:
 			current = set(engines)
 			current.remove(e)
 			m += 1
 			
 	print ""Case #%d: %d"" % (i+1, m)",gcj/2008/32013/RalfKistner/24480/0/extracted/q1.py,477,25,61,Python,32013,0,24480,RalfKistner,2008
12829,c.py,"#!/usr/bin/python
 import math
 
 def pyth(k, r):
 	return   math.sqrt(r*r-k*k)
 	
 def corner(x1, y1, x2, y2, r):	#x1 < x2, y1 > y2
 	tr = (x1 * (y1 - y2) + y2 * (x2 - x1))/2
 	angle = math.atan(y1/x1) - math.atan(y2/x2)
 	sl = r * r * angle / 2
 	return sl - tr
 	
 	
 def inside(x, y, r):
 	return x*x + y*y <= r*r
 	
 def square(x, y, w, r):
 	if not inside(x, y, r):
 		return 0
 	
 	if inside(x+w, y+w, r):
 		return w*w
 	
 	if inside(x+w, y, r) and inside(x, y+w, r):
 		x2 = pyth(y+w,r)
 		y2 = pyth(x+w,r)
 		return w*w - (x+w-x2)*(y+w-y2) + corner(x2, y+w, x+w, y2, r)
 	
 	if inside(x+w, y, r):
 		y2 = pyth(x+w, r)
 		y3 = pyth(x, r)
 		return w*(y2-y) + corner(x, y3, x+w, y2, r)
 		
 	if inside(x, y+w, r):
 		x2 = pyth(y+w, r)
 		x3 = pyth(y, r)
 		return w*(x2-x) + corner(x2, y+w, x3, y, r)
 	
 	else:
 		y2 = pyth(x, r)
 		x2 = pyth(y, r)
 		return corner(x, y2, x2, y, r)
 
 def solve(f, R, t, w, g):
 	OPEN = 'open'
 	CLOSED = 'closed'
 	
 	t += f
 	w += f
 	g -= f*2
 	if g <= 0:
 		return 1.0
 	r = R - t
 	
 	
 	squarea = 0
 	y = w
 	while y <= r:
 		x = w
 		while x <= r:
 			squarea += square(x, y, g, r)
 			x += 2*w+g
 		y += 2*w+g
 		
 	
 	cut = squarea
 	circle = math.pi*R*R/4
 	return 1.0 - cut/circle
 
 fin = open(""c.in"",""r"")
 fout = open(""c.out"",""w"")
 
 n = int(fin.readline())
 for i in range(n):
 	f, R, t, w, g = map(float, fin.readline().split())
 	s = solve(f, R, t, w, g)
 	print >> fout, ""Case #%d: %.6f"" % (i+1, s)
 	print ""Case #%d: %.6f"" % (i+1, s)
 
 fout.close()",gcj/2008/32013/RalfKistner/24479/1/extracted/c.py,1510,80,274,Python,32013,1,24479,RalfKistner,2008
12831,b.py,"#!/usr/bin/python
 def timeToMin(s):
 	a = map(int,s.split("":""))
 	return a[0]*60+a[1]
 	
 	
 fin = open(""b.in"",""r"")
 fout = open(""b.out"",""w"")
 
 n = int(fin.readline())
 
 LEN = 1440
 
 for i in range(n):
 	
 	t = int(fin.readline())
 	na, nb = map(int, fin.readline().split())
 	
 	
 	a = [0]*(LEN+t)
 	b = [0]*(LEN+t)
 	
 	for j in range(na):
 		t1, t2 = map(timeToMin, fin.readline().split())
 		t2 += t
 		a[t1] -= 1
 		b[t2] += 1
 	
 	for j in range(nb):
 		t1, t2 = map(timeToMin, fin.readline().split())
 		t2 += t
 		b[t1] -= 1
 		a[t2] += 1
 		
 	at = 0
 	s = 0
 	for k in a:
 		s += k
 		if s < 0:
 			at -= s
 			s = 0
 		
 	bt = 0
 	s = 0
 	for k in b:
 		s += k
 		if s < 0:
 			bt -= s
 			s = 0
 	
 	print >> fout, ""Case #%d: %d %d"" % (i+1, at, bt)
 	print ""Case #%d: %d %d"" % (i+1, at, bt)
 		",gcj/2008/32013/RalfKistner/24481/1/extracted/b.py,810,53,140,Python,32013,1,24481,RalfKistner,2008
12832,b.py,"#!/usr/bin/python
 def timeToMin(s):
 	a = map(int,s.split("":""))
 	return a[0]*60+a[1]
 	
 	
 fin = open(""b.in"",""r"")
 fout = open(""b.out"",""w"")
 
 n = int(fin.readline())
 
 LEN = 1440
 
 for i in range(n):
 	a = [0]*LEN
 	b = [0]*LEN
 	
 	t = int(fin.readline())
 	na, nb = map(int, fin.readline().split())
 	
 	
 	for j in range(na):
 		t1, t2 = map(timeToMin, fin.readline().split())
 		t2 += t
 		a[t1] -= 1
 		b[t2] += 1
 	
 	for j in range(nb):
 		t1, t2 = map(timeToMin, fin.readline().split())
 		t2 += t
 		b[t1] -= 1
 		a[t2] += 1
 		
 	at = 0
 	s = 0
 	for k in a:
 		s += k
 		if s < 0:
 			at -= s
 			s = 0
 		
 	bt = 0
 	s = 0
 	for k in b:
 		s += k
 		if s < 0:
 			bt -= s
 			s = 0
 	
 	print >> fout, ""Case #%d: %d %d"" % (i+1, at, bt)
 	print ""Case #%d: %d %d"" % (i+1, at, bt)
 		",gcj/2008/32013/RalfKistner/24481/0/extracted/b.py,799,52,140,Python,32013,0,24481,RalfKistner,2008
34443,a.py,"#!/usr/bin/python
 
 IM = 10000000
 
 fin = open(""a.in"", ""r"")
 fout = open(""a.out"", ""w"")
 
 n = int(fin.readline())
 for i in xrange(1, n+1):
 	m, v = map(int, fin.readline().split())
 	tree = []
 	for j in xrange(m):
 		tree.append(map(int, fin.readline().split()))
 	
 	changes = [(None, None)] * ((m-1)/2)
 	for val in tree[(m-1)/2:]:
 		if val[0]:
 			changes.append((IM, 0))
 		else:
 			changes.append((0, IM))
 			
 	for j in xrange((m-1)/2-1, -1, -1):
 		c = tree[j][1]
 		o = tree[j][0]
 		no = (o+1)%2
 		
 		zero = [0, 0]
 		one = [0, 0]
 		zero[1] = min(changes[j*2+1][0] + min(changes[j*2+2]), changes[j*2+2][0] + min(changes[j*2+1]))
 		one[1] = changes[j*2+1][1] + changes[j*2+2][1]
 		
 		zero[0] = changes[j*2+1][0] + changes[j*2+2][0]
 		one[0] = min(changes[j*2+1][1] + min(changes[j*2+2]), changes[j*2+2][1] + min(changes[j*2+1]))
 		
 		
 		if c:
 			changes[j] = (min(zero[o], zero[no]+1), min(one[o], one[no]+1))
 		else:
 			changes[j] = (zero[o], one[o])
 		
 	#print changes
 	output = changes[0][v]
 	if output >= IM:
 		output = ""IMPOSSIBLE""
 	print ""Case #%d: %s"" % (i, str(output))
 	print >> fout, ""Case #%d: %s"" % (i, str(output))
 	
 fout.close()
",gcj/2008/32001/RalfKistner/24439/1/extracted/a.py,1180,49,142,Python,32001,1,24439,RalfKistner,2008
34445,d.py,"#!/usr/bin/python
 
 fin = open(""d.in"", ""r"")
 fout = open(""d.out"", ""w"")
 
 def all_perms(str):
     if len(str) <=1:
         yield str
     else:
         for perm in all_perms(str[1:]):
             for i in range(len(perm)+1):
                 yield perm[:i] + str[0:1] + perm[i:]
 
 
 n = int(fin.readline())
 for i in xrange(1, n+1):
 	k = int(fin.readline())
 	s = fin.readline().strip()
 	print k, s
 	
 	best = 10000000
 	for perm in all_perms(range(k)):
 		last = None
 		count = 0
 		ns = s
 		while len(ns):
 			for p in perm:
 				if ns[p] != last:
 					count += 1
 					last = ns[p]
 			ns = ns[k:]
 			
 		best = min(best, count)
 	print best
 	print >> fout, ""Case #%d: %d"" % (i, best)",gcj/2008/32001/RalfKistner/24442/0/extracted/d.py,701,35,98,Python,32001,0,24442,RalfKistner,2008
34446,b.py,"#!/usr/bin/python
 
 IM = 10000000
 
 fin = open(""b.in"", ""r"")
 fout = open(""b.out"", ""w"")
 
 
 c = int(fin.readline())
 for i in xrange(1, c+1):
 	n, m, a = map(int, fin.readline().split())
 	# n => x
 	if n < m:
 		x1 = n
 		x2 = 1
 		y2 = (a+n-1) / n
 		y1 = y2*x1 - a
 	else:
 		y1 = m
 		x2 = (a+m-1) / m
 		y2 = 1
 		x1 = x2*y1 - a
 			
 	
 	output = ""0 0 %d %d %d %d"" % (x1, y1, x2, y2)
 	if y2 > m or x2 > n:
 		output = ""IMPOSSIBLE""
 	print ""Case #%d: %s"" % (i, str(output))
 	print >> fout, ""Case #%d: %s"" % (i, str(output))
 	",gcj/2008/32001/RalfKistner/24440/1/extracted/b.py,535,30,107,Python,32001,1,24440,RalfKistner,2008
45169,d.py,"#!/usr/bin/python
 fin = open(""d.in"",""r"")
 N = int(fin.readline())
 fout = open(""d.out"", ""w"")
 
 for i in xrange(1, N+1):
 	n, m, X, Y, Z = map(long, fin.readline().split())
 	A = []
 	for j in xrange(m):
 		A.append(long(fin.readline()))
 	s = []
 	for j in xrange(n):
 		s.append(A[j % m])
 		A[j % m] = (X * A[j % m] + Y * (j + 1)) % Z
 	
 	count = [1] * n
 	for j in xrange(n):
 		p = s[j]
 		for k in xrange(j):
 			if p > s[k]:
 				count[j] += count[k]
 				
 	total = sum(count) % 1000000007
 	print total
 	print >> fout, ""Case #%d: %d"" % (i, total)
 	
 fout.close()",gcj/2008/32015/RalfKistner/24488/0/extracted/d.py,575,27,99,Python,32015,0,24488,RalfKistner,2008
45170,c.py,"#!/usr/bin/python
 fin = open(""c.in"",""r"")
 n = int(fin.readline())
 fout = open(""c.out"", ""w"")
 
 def ugly(n):
 	if n % 2 == 0 or n % 3 == 0 or n % 5 == 0 or n % 7 == 0:
 		return 1
 	return 0
 
 def count(n, k, s, pos):
 	if len(n) == 0:
 		return ugly(k+s)
 	
 	a = 0
 	if pos:
 		a += count(n[1:], k, s * 10 + int(n[0]), True)
 	else:
 		a += count(n[1:], k, s * 10 - int(n[0]), False)
 	a += count(n[1:], k + s, int(n[0]), True)
 	a += count(n[1:], k + s, -int(n[0]), False)
 	return a
 
 for i in xrange(1, n+1):
 	d = fin.readline().strip()
 	c = count(d[1:], 0, int(d[0]), True)
 	print c
 	print >> fout, ""Case #%d: %d"" % (i, c)",gcj/2008/32015/RalfKistner/24487/0/extracted/c.py,635,28,121,Python,32015,0,24487,RalfKistner,2008
45171,b.py,"#!/usr/bin/python
 fin = open(""b.in"",""r"")
 n = int(fin.readline())
 fout = open(""b.out"", ""w"")
 for i in xrange(1, n+1):
 	p, k, l = map(int, fin.readline().split())
 	freqs = map(int, fin.readline().split())
 	
 	if p * k < l:
 		print >> fout, ""Case #%d: Impossible"" % i
 	else:
 		freqs.sort(lambda a, b: b - a)
 		total = 0
 		for j in xrange(1, p+1):
 			total += sum(freqs[:k]) * j
 			freqs = freqs[k:]
 			if len(freqs) == 0:
 				break
 		print >> fout, ""Case #%d: %d"" % (i, total)
 		
 		
 fout.close()",gcj/2008/32015/RalfKistner/24486/1/extracted/b.py,511,22,78,Python,32015,1,24486,RalfKistner,2008
5345,b.py,"# -*- coding: utf-8 -*-
 
 fin = open(""b.in"",""r"")
 T = int(fin.readline())
 
 def overlap(a, b):
     greater = b[0] > a[0]
     for p, q in zip(a,b):
         if p == q:
             return True
         if (q > p) != greater:
             return True
     return False
             
 for i in range(1,T+1):
     n, s = map(int, fin.readline().split())
     prices = []
     for j in range(n):
         p = map(int, fin.readline().split())
         prices.append(p)
     prices.sort()
     #print prices
     count = 0
     used = {}
     for j in range(n):
         if j in used:
             continue
         used[j] = True
         count += 1
         top = prices[j]
         
         for k in range(j+1,n):
             if k in used:
                 continue
             bad = False
             if overlap(top, prices[k]):
                 continue
             
             used[k] = True
             top = [max(y) for y in zip(top, prices[k])]
             
     print ""Case #%d: %d"" % (i, count)",gcj/2009/204113/RalfKistner/244101/0/extracted/b.py,1011,42,122,Python,204113,0,244101,RalfKistner,2009
5346,a.py,"# -*- coding: utf-8 -*-
 
 fin = open(""a.in"",""r"")
 T = int(fin.readline())
 
 for i in range(1,T+1):
     N = int(fin.readline())
     lengths = []
     for j in range(N):
         line = fin.readline()
         l = 0
         for s, c in enumerate(line):
             if c == '1':
                 l = s+1
         lengths.append(l)
     swaps = 0
     for j in range(N):
         for k in range(N-j):
             if lengths[k] <= j+1:
                 break
         del lengths[k]
         swaps += k
     print ""Case #%d: %d"" % (i, swaps)",gcj/2009/204113/RalfKistner/241102/1/extracted/a.py,543,23,72,Python,204113,1,241102,RalfKistner,2009
5348,d.py,"# -*- coding: utf-8 -*-
 import math
 
 fin = open(""d.in"",""r"")
 T = int(fin.readline())
 
 def d(a, b):
     dist = math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2)
     if abs(a[2]-b[2]) > dist:
         return max(a[2], b[2])
     return (a[2] + b[2] + dist) / 2.0
     
     
 for i in range(1,T+1):
     n = int(fin.readline())
     
     p = []
     for j in range(n):
         x, y, r = map(int, fin.readline().split())
         p.append((x,y,r))
     
     R = 0;
     if n == 1:
         R = p[0][2]
     elif n == 2:
         R = max(p[0][2], p[1][2])
     elif n == 3:
         R1 = max(d(p[0], p[1]), p[2][2])
         R2 = max(d(p[1], p[2]), p[0][2])
         R3 = max(d(p[2], p[0]), p[1][2])
         R = min(R1, R2, R3)
     else:
         exit(1)
     
     print ""Case #%d: %.6f"" % (i, R)
         ",gcj/2009/204113/RalfKistner/250101/0/extracted/d.py,806,36,106,Python,204113,0,250101,RalfKistner,2009
17338,b.py,"# -*- coding: utf-8 -*-
 
 fin = open(""b.in"",""r"")
 T = int(fin.readline())
 
 alt = []
 H = 0
 W = 0
 
 def valid(p):
     row, col = p
     return row >= 0 and row < H and col >= 0 and col < W
     
 def galt(p):
     row, col = p
     if valid(p):
         return alt[row][col]
     else:
         return 1000000
         
 # 0 - sink, 1 - up, 2 - right, 3 - down, 4 - left
 def child(p):
     if not valid(p):
         return None
     row, col = p
     a = galt(p)
     u = galt((row-1,col))
     d = galt((row+1,col))
     l = galt((row,col-1))
     r = galt((row,col+1))
     m = min([u,d,l,r,a])
     if a == m:
         return p
     if u == m:
         return (row-1,col)
     if l == m:
         return (row,col-1)
     if r == m:
         return (row,col+1)
     if d == m:
         return (row+1,col)
     
 def parents(p):
     par = []
     for n in nbs(p):
         if child(n) == p:
             par.append(n)
     return par
     
 def nbs(p):
     r,c = p
     return filter(valid, [(r-1,c),(r+1,c),(r,c-1),(r,c+1)])
     
 for i in range(T):
     print ""Case #%d:"" % (i+1)
     H, W = map(int, fin.readline().split())
     alt = []
     for r in range(H):
         alt.append(map(int, fin.readline().split()))
         
     positions = zip([x/W for x in range(W*H)], range(W)*H)
     
     sinks = filter(lambda p: child(p) == p, positions)
     
     names = {}
     
     
     
     basins = {}
     
     for s in sinks:
         todo = set([s])
         while todo:
             k = todo.pop()
             basins[k] = s
             for p in parents(k):
                 if p not in basins:
                     todo.add(p)
     
     o = ord('a')
     for r in range(H):
         for c in range(W):
             b = basins[(r,c)]
             if b not in names:
                 names[b] = chr(o)
                 o += 1
             print names[b],
         print
     
         
         
     
     ",gcj/2009/90101/RalfKistner/111101/1/extracted/b.py,1929,93,252,Python,90101,1,111101,RalfKistner,2009
17340,c.py,"# -*- coding: utf-8 -*-
 
 fin = open(""c.in"",""r"")
 T = int(fin.readline())
 
 S = ""welcome to code jam""
 N = len(S)
 
 for t in range(T):
     string = fin.readline().strip()
     
     M = len(string)
     Nk = [1]*(M+1)
     
     for c in S:
         k = Nk
         Nk = [0]*(M+1)
         
         for i, d in zip(range(1, M+1), string):
             Nk[i] = Nk[i-1]
             if c == d:
                 Nk[i] += k[i-1]
                 while Nk[i] > 10000:
                     Nk[i] -= 10000
         
     s = str(Nk[-1])
     while len(s) < 4:
         s = ""0"" + s
     print ""Case #%d: %s"" % (t+1, s)",gcj/2009/90101/RalfKistner/122101/1/extracted/c.py,615,29,86,Python,90101,1,122101,RalfKistner,2009
17342,a.py,"# -*- coding: utf-8 -*-
 import re
 
 fin = open(""a.in"",""r"")
 L, D, N = map(int, fin.readline().split())
 
 words = []
 for i in range(D):
     words.append(fin.readline().strip())
 
 for i in range(N):
     pattern = fin.readline().strip()
     pattern = pattern.replace('(', '[').replace(')',']')
     
     p = re.compile(pattern)
     
     count = 0
     for w in words:
         if p.match(w):
             count += 1
     
     print ""Case #%d: %d"" % (i+1, count)
     
",gcj/2009/90101/RalfKistner/116101/1/extracted/a.py,477,24,57,Python,90101,1,116101,RalfKistner,2009
48432,b.py,"# -*- coding: utf-8 -*-
 import math
 
 fin = open(""b.in"",""r"")
 T = int(fin.readline())
 
 def size(v):
     return math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
     
 for i in range(T):
     N = int(fin.readline())
     
     px = 0.0
     py = 0.0
     pz = 0.0
     
     vx = 0.0
     vy = 0.0
     vz = 0.0
     
     for j in range(N):
         x, y, z, xx, yy, zz = map(int, fin.readline().split())
         px += x
         py += y
         pz += z
         vx += xx
         vy += yy
         vz += zz
         
     px /= N
     py /= N
     pz /= N
     vx /= N
     vy /= N
     vz /= N
     
     #print px, py, pz, vx, vy, vz
     dotp = - (px*vx + py*vy + pz*vz)
     bs = size((vx,vy,vz))
     if bs == 0:
         time = -1
     else:
         dist = dotp/bs
         cross = (vx/bs*dist + px, vy/bs*dist + py, vz/bs*dist + pz)
         time = dist/bs
     if time < 0:
         time = 0
         cross = (px, py, pz)
     
     print ""Case #%d: %.8f %.8f"" % (i+1,  size(cross), time)
     
     
     ",gcj/2009/189252/RalfKistner/156117/1/extracted/b.py,1019,53,159,Python,189252,1,156117,RalfKistner,2009
48434,c.py,"# -*- coding: utf-8 -*-
 fin = open(""c.in"",""r"")
 T = int(fin.readline())
 
 global p, q, prisoners, cc
 
 def cost(a, b):
     if (a,b) in cc:
         return cc[(a,b)]
     
     if b - a <= 1:
         return 0
     
     minc = None
     for p in range(a+1,b):
         c = cost(a,p) + cost(p,b) + prisoners[b] - prisoners[a] - 2
         if minc is None or c < minc:
             minc = c
     
     cc[(a,b)] = minc
     return minc
     
 for i in range(T):
     cc = {}
     p, q = map(int, fin.readline().split())
     prisoners = [0] + map(int, fin.readline().split()) + [p+1]
     p += 2
     q += 2
     print ""Case #%d: %d"" % (i+1, cost(0, q-1))",gcj/2009/189252/RalfKistner/192120/1/extracted/c.py,657,29,101,Python,189252,1,192120,RalfKistner,2009
48436,a.py,"# -*- coding: utf-8 -*-
 
 fin = open(""a.in"",""r"")
 T = int(fin.readline())
 
 for i in range(T):
     line = fin.readline().strip()
     
     present = {}
     for c in line:
         present[c] = True
     
     base = len(present)
     if base < 2:
         base = 2
         
     digit = {}
     cn = 1
     for c in line:
         if c not in digit:
             digit[c] = cn
             if cn == 1:
                 cn = 0
             elif cn == 0:
                 cn = 2
             else:
                 cn += 1
     
     rev = line[::-1]
     f = 1
     total = 0
     for c in rev:
         total += f * digit[c]
         f *= base
     print ""Case #%d: %d"" % (i+1, total)",gcj/2009/189252/RalfKistner/171121/1/extracted/a.py,690,35,102,Python,189252,1,171121,RalfKistner,2009
8525,c.py,"# -*- coding: utf-8 -*-
 import sys
 import math
 
 cmem = {}
 def C(total, choose):
     if total < choose:
         return 0
     if (total, choose) in cmem:
         return cmem[(total, choose)]
     c = (math.factorial(total) / math.factorial(choose) / math.factorial(total - choose)) % 100003
     cmem[(total, choose)] = c
     return c
     
 mem = {}
 COUNTER = 0
 def g(n, rank):
     global COUNTER
     if rank == 1:
         return 1
     
     if (n, rank) in mem:
         return mem[(n, rank)]
         
     total = 0
     for i in range(1, rank):
         COUNTER += 1
         total += C(n - rank - 1, rank - i - 1) * g(rank, i)
     mem[(n, rank)] = total
     return total % 100003
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     
     total = 0
     for i in range(1, N):
         total += g(N, i)
     print ""Case #%d: %s"" % (case, total % 100003)
 #print COUNTER",gcj/2010/635101/RalfKistner/598111/1/extracted/c.py,942,41,141,Python,635101,1,598111,RalfKistner,2010
8526,c.py,"# -*- coding: utf-8 -*-
 import sys
 import math
 
 def C(total, choose):
     if total < choose:
         return 0
     return math.factorial(total) / math.factorial(choose) / math.factorial(total - choose)
     
     #if total < choose:
         #return 0
     #if choose == 0 or choose == total:
         #return 1
     #return C(total-1,choose-1)+C(total-1,choose);
 
 mem = {}
 COUNTER = 0
 def g(n, rank):
     global COUNTER
     if rank == 1:
         return 1
     
     if (n, rank) in mem:
         return mem[(n, rank)]
         
     total = 0
     for i in range(1, rank):
         COUNTER += 1
         total += C(n - rank - 1, rank - i - 1) * g(rank, i)
     mem[(n, rank)] = total
     return total % 100003
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     
     result = sum([g(N, i) for i in range(1, N)]) % 100003
     print ""Case #%d: %s"" % (case, result)
 #print COUNTER",gcj/2010/635101/RalfKistner/598111/0/extracted/c.py,948,40,136,Python,635101,0,598111,RalfKistner,2010
8527,a.py,"# -*- coding: utf-8 -*-
 import sys
 
 
 def parent(path):
     return path[:path.rindex(""/"")]
     
     
 fin = sys.stdin
 T = int(fin.readline())
     
 for case in range(1,T+1):
     N, M = map(int, fin.readline().split())
     
     current = set()
     current.add("""")
     
     for i in range(N):
         path = fin.readline().strip()
         while not path in current:
             current.add(path)
             path = parent(path)
         
     count = 0
     for i in range(M):
         path = fin.readline().strip()
         
         while not path in current:
             current.add(path)
             path = parent(path)
             count += 1
         
     print ""Case #%d: %s"" % (case, count)
",gcj/2010/635101/RalfKistner/563117/1/extracted/a.py,718,34,75,Python,635101,1,563117,RalfKistner,2010
8529,b.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N, K, B, T = map(int, fin.readline().split())
     x = map(int, fin.readline().split())
     v = map(int, fin.readline().split())
     chicks = zip(x, v)
     chicks.sort(reverse=True)
     
     slow_counter = 0
     
     swap_counter = 0
     
     safe_counter = 0
     for c in chicks:
         if c[0] + c[1]*T >= B:
             swap_counter += slow_counter
             safe_counter += 1
         else:
             slow_counter += 1
         if safe_counter >= K:
             break
     
     if safe_counter >= K:
         result = swap_counter
     else:
         result = ""IMPOSSIBLE""
     print ""Case #%d: %s"" % (case, result)
",gcj/2010/635101/RalfKistner/542118/1/extracted/b.py,751,31,89,Python,635101,1,542118,RalfKistner,2010
24442,c.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     r, k, n = map(int, fin.readline().split())
     g = map(int, fin.readline().split())
     next_group = 0
     total = 0
     total_at = {}
     current_ride = 0
     while current_ride < r:
         current = 0
         group_count = 0
         while current + g[next_group] <= k and group_count < n:
             group_count += 1
             current += g[next_group]
             next_group = (next_group + 1) % n
         total += current
         if next_group in total_at:
             tdiff = total - total_at[next_group][0]
             rdiff = current_ride - total_at[next_group][1]
             repetitions = (r - current_ride - 1) / rdiff
             total += repetitions * tdiff
             current_ride += repetitions * rdiff
             
         else:
             total_at[next_group] = (total, current_ride)
             
         current_ride += 1
     
     
     print ""Case #%d: %s"" % (case, total)
",gcj/2010/433101/RalfKistner/509101/1/extracted/c.py,1032,34,123,Python,433101,1,509101,RalfKistner,2010
24444,b.py,"# -*- coding: utf-8 -*-
 import sys
 
 def gcd(a, b):
     if a > b:
         return gcd(b, a)
     if a == 0:
         return b
     return gcd(b % a, a)
         
 
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     t = map(int, fin.readline().split())[1:]
     m = t[0]
     last = 0
     for k in t:
         last = gcd(last, abs(k-m))
     print ""Case #%d: %s"" % (case,  (- m) % last)
",gcj/2010/433101/RalfKistner/506101/1/extracted/b.py,413,21,66,Python,433101,1,506101,RalfKistner,2010
24446,a.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     n, k = map(int, fin.readline().split())
     
     if k & ((1 << n) - 1) == ((1 << n) - 1):
         result = ""ON""
     else:
         result = ""OFF""
     print ""Case #%d: %s"" % (case, result)
",gcj/2010/433101/RalfKistner/502103/1/extracted/a.py,303,13,50,Python,433101,1,502103,RalfKistner,2010
65437,b.py,"# -*- coding: utf-8 -*-
 #INF = 10000000000000
 INF = float(""infinity"")
 import sys
 fin = open(sys.argv[1], 'r')
 N = int(fin.readline())
 for case in range(1,N+1):
     P = int(fin.readline())
     M = map(int, fin.readline().split())
     prices = []
     for i in range(P):
         prices.append(map(int, fin.readline().split()))
 
     last = []
     for i in range(2**P):
         m = M[i]
         s = []
         for j in range(P+2):
             if j <= m:
                 s.append(0)
             else:
                 s.append(INF)
         last.append(s)
 
         #for j in range(P-M[i]):
         #    playing[P-j-1][i/(2**(P-j))] = True
     n = len(last)
     #print last
     for k in range(P):
         n /= 2
         next = []
         for i in range(n):
             s = []
             cost = prices[k][i]
             for j in range(P+1):
                 p = min(last[2*i][j] + last[2*i+1][j] + cost, last[2*i][j+1] + last[2*i+1][j+1])
                 s.append(p)
             s.append(INF)
             next.append(s)
         last = next
         #print last
 
     #print last
     print ""Case #%d: %s"" % (case, last[0][0])
 fin.close()",gcj/2010/635102/RalfKistner/698485/1/extracted/b.py,1168,45,130,Python,635102,1,698485,RalfKistner,2010
65438,b.py,"# -*- coding: utf-8 -*-
 import sys
 fin = open(sys.argv[1], 'r')
 N = int(fin.readline())
 for case in range(1,N+1):
     P = int(fin.readline())
     M = map(int, fin.readline().split())
     prices = []
     playing = []
     for i in range(P):
         prices.append(map(int, fin.readline().split()))
         playing.append([False]*(2**(P-i-1)))
     result = prices
     for i in range(2**P):
         for j in range(P-M[i]):
             playing[P-j-1][i/(2**(P-j))] = True
 
     t = 0
     for row in playing:
         t += sum(row)
     print ""Case #%d: %s"" % (case, t)
 fin.close()",gcj/2010/635102/RalfKistner/698485/0/extracted/b.py,592,22,70,Python,635102,0,698485,RalfKistner,2010
65439,a.py,"# -*- coding: utf-8 -*-
 import sys
 fin = open(sys.argv[1], 'r')
 
 def best(k, rows):
     m = []
     for p in range(len(rows)):
         working = True
         #print p
         for r in rows:
             #print r
             for i, a in enumerate(r):
                 q = i*2 + k - len(r)
                 o = p*2 - q
                 j = (o + len(r) - k)/2
 
                 if j < 0 or j >= len(r):
                     continue
                 #print i, j
                 if a != r[j]:
                     working = False
                     break
         if working:
             shift = abs((k-1)-p)
             #print p, shift, k
             m.append(shift)
     # print "".""
     return min(m)
 
 def size(k):
     t = 0
     for i in range(2*k-1):
         t += k-abs(k-i-1)
     return t
 
 N = int(fin.readline())
 for case in range(1,N+1):
     k = int(fin.readline())
     rows = []
     S = 2*k-1
     for i in range(S):
         rows.append(map(int, fin.readline().split()))
     cols = [[] for i in range(S)]
     for i, row in enumerate(rows):
         for p, a in enumerate(row):
             c = 2*p + k - len(row)
             cols[c].append(a)
     #print rows
     #print cols
     a = best(k, rows)
     b = best(k, cols)
     #print a, b
     shift = a + b
     result = size(k+shift) - size(k)
 
     print ""Case #%d: %s"" % (case, result)
 
 fin.close()",gcj/2010/635102/RalfKistner/694485/1/extracted/a.py,1392,58,185,Python,635102,1,694485,RalfKistner,2010
11034,C.py,"# -*- coding: utf-8 -*-
 def xor(a,b):
     return a^b
     
 import sys
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     n = int(fin.readline())
     pile = map(int, fin.readline().split())
     if reduce(xor, pile) == 0:
         result = sum(pile) - min(pile)
     else:
         result = ""NO""
     print ""Case #%d: %s"" % (case, result)
",gcj/2011/975485/RalfKistner/1059486/1/extracted/C.py,365,16,49,Python,975485,1,1059486,RalfKistner,2011
11036,A.py,"# -*- coding: utf-8 -*-
 from itertools import *
    
 import sys
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     line = fin.readline().split()
     data = zip(line[1::2], map(int, line[2::2]))
     
     op = 1
     ot = 0
     bp = 1
     bt = 0
     for user, position in data:
         if user == 'O':
             ot = max(ot+abs(position-op), bt)+1
             op = position
         else:
             bt = max(bt+abs(position-bp), ot)+1
             bp = position
     
     print ""Case #%d: %s"" % (case, max(ot, bt))
",gcj/2011/975485/RalfKistner/1080487/1/extracted/A.py,553,24,73,Python,975485,1,1080487,RalfKistner,2011
11038,D.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     n = int(fin.readline())
     seq = map(int, fin.readline().split())
     wrong = 0
     for i, k in enumerate(seq):
         if i+1 != k:
             wrong += 1
     
     print ""Case #%d: %.6f"" % (case, wrong)
",gcj/2011/975485/RalfKistner/992486/1/extracted/D.py,322,14,46,Python,975485,1,992486,RalfKistner,2011
11040,B.py,"# -*- coding: utf-8 -*-
 def popn(line):
     n = int(line[0])
     return (line[1:n+1], line[n+1:])
 import sys
 fin = sys.stdin
 N = int(fin.readline())
 for case in range(1,N+1):
     line = fin.readline().split()
     pairs, line = popn(line)
     opposed, line = popn(line)
     seq = line[1]
     replace = {}
     for pair in pairs:
         a,b,c = list(pair)
         replace[(a,b)] = c
         replace[(b,a)] = c
     destroy = set()
     for o in opposed:
         a,b = list(o)
         destroy.add((a,b))
         destroy.add((b,a))
     #print replace, destroy, seq
     l = []
     for c in seq:
         if not l:
             l.append(c)
         else:
             k = (l[-1], c)
             if k in replace:
                 l[-1] = replace[k]
             else:
                 d = False
                 for cc in l:
                     if (cc,c) in destroy:
                         d = True
                         break
                 if d:
                     l = []
                 else:
                     l.append(c)
                         
     print ""Case #%d: %s"" % (case, str(l).replace(""'"",""""))
",gcj/2011/975485/RalfKistner/1026487/1/extracted/B.py,1141,44,124,Python,975485,1,1026487,RalfKistner,2011
80949,C.py,"# -*- coding: utf-8 -*-
 def primefactors(x): 
     factors={}
     for i in range(2, x+1):
         count = 0
         while x % i == 0:
             count += 1
             x /= i
         if count > 0:
             factors[i] = count
     return factors
 
 def allfactors(x):
     af = {}
     for i in range(1, x+1):
         factors = primefactors(i)
         for k, v in factors.items():
             if k in af:
                 af[k] = max(af[k], v)
             else:
                 af[k] = v
     return af
     
 def m(x):
     if x == 1:
         return 1
     af = allfactors(x)
     count = 0
     p = map(lambda i: primefactors(i), range(x, 0, -1))
     p.sort(key=lambda f: sum(f.values()), reverse=True)
     for f in p:
         use = False
         for k, v in f.items():
             rem = af[k]
             if rem > 0:
                 use = True
                 break
         if use:
             for k, v in f.items():
                 af[k] = af[k] - v
             count += 1
     
     return count
 
 def span(x):
     af = allfactors(x)
     s = sum(af.values())+1
     l = m(x)
     return (l, s, s-l)
 
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     X = int(fin.readline())
     low, high, result = span(X)
     print ""Case #%d: %s"" % (case, result)
 
 
",gcj/2011/1150486/RalfKistner/1100485/0/extracted/C.py,1330,61,177,Python,1150486,0,1100485,RalfKistner,2011
80950,A.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     X, S, R, t, N = map(int, fin.readline().split())
     walkways = []
     for i in range(N):
         b, e, w = map(float, fin.readline().split())
         walkways.append((e-b,w))
         X -= e-b
     walkways.append((X,0.0))
     print >> sys.stderr, walkways
     walkways.sort(key=lambda w: w[1])
     print >> sys.stderr, walkways
     time = 0.0
     for l, s in walkways:
         speed = s + R
         runtime = min(t, l/speed)
         t -= runtime
         time += runtime
         remaining = l - runtime*speed
         walktime = remaining / (s+S)
         time += walktime
         
     print ""Case #%d: %.7f"" % (case, time)
 
",gcj/2011/1150486/RalfKistner/1163489/1/extracted/A.py,753,28,97,Python,1150486,1,1163489,RalfKistner,2011
80952,B.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 
 def moment(grid):
     rows = []
     for row in grid:
         rr = map(lambda (i, v): (i)*v, enumerate(row))
         rrr = [0]
         last = 0
         for col in rr:
             last += col
             rrr.append(last)
         rows.append(rrr)
     
     blocks = []
     last = [0]*len(rows[0])
     blocks.append(last)
     for row in rows:
         last = map(lambda (a,b): a+b, zip(last, row))
         blocks.append(last)
     return blocks
     
 def weight(grid):
     rows = []
     for row in grid:
         rrr = [0]
         last = 0
         for col in row:
             last += col
             rrr.append(last)
         rows.append(rrr)
     blocks = []
     last = [0]*len(rows[0])
     blocks.append(last)
     for row in rows:
         last = map(lambda (a,b): a+b, zip(last, row))
         blocks.append(last)
     return blocks
 
 def total(blocks, r, c, d):
     return blocks[r][c] + blocks[r+d][c+d] - blocks[r][c+d] - blocks[r+d][c]
 
 def tblade(blocks, r, c, d):
     return total(blocks, r, c, d) - total(blocks, r, c, 1) - total(blocks, r+d-1, c+d-1, 1) \
         - total(blocks, r+d-1, c, 1) - total(blocks, r, c+d-1, 1)
 
 def cog(blocks, weights, r, c, d):
     m = tblade(blocks, r, c, d)
     w = tblade(weights, r, c, d)
     
     return 2*m == w*(2*c+(d-1))
     
 def invert(grid):
     R = len(grid)
     C = len(grid[0])
     inverted = []
     for r in range(C):
         row = [c[r] for c in grid]
         inverted.append(row)
     return inverted
 
 for case in range(1,T+1):
     R, C, D = map(int, fin.readline().split())
     grid = []
     for i in range(R):
         row = map(int, fin.readline().strip())
         row = map(lambda x: x + D, row)
         grid.append(row)
     
     inv = invert(grid)
     mxblocks = moment(grid)
     wxblocks = weight(grid)
     myblocks = moment(inv)
     wyblocks = weight(inv)
     
     result = ""IMPOSSIBLE""
     for s in range(min(R, C), 2, -1):
         if D == 682969:
             break
         print >> sys.stderr, s
         for r in range(R-s+1):
             if result == s:
                 break
             for c in range(C-s+1):
                 cx = cog(mxblocks, wxblocks, r, c, s)
                 cy = cog(myblocks, wyblocks, c, r, s)
                 #if cx == c+(s-1)/2.0 and cy == r+(s-1)/2.0:
                 if cx and cy:
                     result = s 
                     break
         if result == s:
                 break
                     
     #print >> sys.stderr, ""Grid"", grid
     #print >> sys.stderr, ""Inve"", invert(grid)
     #print >> sys.stderr, ""Moment"", mxblocks
     #print >> sys.stderr, ""Weight"", wxblocks
     #print >> sys.stderr, cog(mxblocks, wxblocks, 0, 0, 3)
     #print >> sys.stderr, cog(myblocks, wyblocks, 0, 0, 3)
     #print >> sys.stderr, cog(mxblocks, wxblocks, 1, 1, 5)
     #print >> sys.stderr, cog(myblocks, wyblocks, 1, 1, 5)
     
     #print >> sys.stderr
     
     print ""Case #%d: %s"" % (case, result)
 
",gcj/2011/1150486/RalfKistner/1160486/1/extracted/B.py,3059,109,375,Python,1150486,1,1160486,RalfKistner,2011
80953,B.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 
 def moment(grid):
     rows = []
     for row in grid:
         rr = map(lambda (i, v): (i)*v, enumerate(row))
         rrr = [0]
         last = 0
         for col in rr:
             last += col
             rrr.append(last)
         rows.append(rrr)
     
     blocks = []
     last = [0]*len(rows[0])
     blocks.append(last)
     for row in rows:
         last = map(lambda (a,b): a+b, zip(last, row))
         blocks.append(last)
     return blocks
     
 def weight(grid):
     rows = []
     for row in grid:
         rrr = [0]
         last = 0
         for col in row:
             last += col
             rrr.append(last)
         rows.append(rrr)
     blocks = []
     last = [0]*len(rows[0])
     blocks.append(last)
     for row in rows:
         last = map(lambda (a,b): a+b, zip(last, row))
         blocks.append(last)
     return blocks
 
 def total(blocks, r, c, d):
     return blocks[r][c] + blocks[r+d][c+d] - blocks[r][c+d] - blocks[r+d][c]
 
 def tblade(blocks, r, c, d):
     return total(blocks, r, c, d) - total(blocks, r, c, 1) - total(blocks, r+d-1, c+d-1, 1) \
         - total(blocks, r+d-1, c, 1) - total(blocks, r, c+d-1, 1)
 
 def cog(blocks, weights, r, c, d):
     m = tblade(blocks, r, c, d)
     w = tblade(weights, r, c, d)
     #print >> sys.stderr, m, w
     center = float(m)/w
     return center
     
 def invert(grid):
     R = len(grid)
     C = len(grid[0])
     inverted = []
     for r in range(C):
         row = [c[r] for c in grid]
         inverted.append(row)
     return inverted
 
 for case in range(1,T+1):
     R, C, D = map(int, fin.readline().split())
     grid = []
     for i in range(R):
         row = map(int, fin.readline().strip())
         row = map(lambda x: x + D, row)
         grid.append(row)
     
     inv = invert(grid)
     mxblocks = moment(grid)
     wxblocks = weight(grid)
     myblocks = moment(inv)
     wyblocks = weight(inv)
     
     result = ""IMPOSSIBLE""
     for s in range(3, min(R, C)+1):
         for r in range(R-s+1):
             for c in range(C-s+1):
                 cx = cog(mxblocks, wxblocks, r, c, s)
                 cy = cog(myblocks, wyblocks, c, r, s)
                 if cx == c+(s-1)/2.0 and cy == r+(s-1)/2.0:
                     result = s
                     
     #print >> sys.stderr, ""Grid"", grid
     #print >> sys.stderr, ""Inve"", invert(grid)
     #print >> sys.stderr, ""Moment"", mxblocks
     #print >> sys.stderr, ""Weight"", wxblocks
     #print >> sys.stderr, cog(mxblocks, wxblocks, 0, 0, 3)
     #print >> sys.stderr, cog(myblocks, wyblocks, 0, 0, 3)
     #print >> sys.stderr, cog(mxblocks, wxblocks, 1, 1, 5)
     #print >> sys.stderr, cog(myblocks, wyblocks, 1, 1, 5)
     
     #print >> sys.stderr
     
     print ""Case #%d: %s"" % (case, result)
 
",gcj/2011/1150486/RalfKistner/1160486/0/extracted/B.py,2858,101,356,Python,1150486,0,1160486,RalfKistner,2011
98263,B.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     C, D = map(int, fin.readline().split())
     endP = -100000
     most = 0
     total = 0
     for i in range(C):
         P, V = map(int, fin.readline().split())
         if endP + D < P:
             # Start over
             endP = P-D
         
         endP += D*V
         most = max(most, endP-P)
         
     result = most / 2.0
     
     print ""Case #%d: %.2f"" % (case, result)
",gcj/2011/1150485/RalfKistner/1058489/1/extracted/B.py,499,22,71,Python,1150485,1,1058489,RalfKistner,2011
98265,A.py,"#!/usr/bin/python
 # -*- coding: utf-8 -*-
 class Team:
         
     def wp(self, j=-1):
         if j in self.won:
             return 1.0 * (len(self.won)-1) / (len(self.opponents)-1)
         elif j == -1:
             return 1.0 * (len(self.won)) / (len(self.opponents))
         else:
             return 1.0 * (len(self.won)) / (len(self.opponents)-1)
     
     def score(self):
         return 0.25 * self.wp() + 0.50 * self.owp + 0.25 * self.oowp
         
     def __str__(self):
         return ""%s: %.2f %.2f %.2f %.6f"" % (self.n, self.wp(), self.owp, self.oowp, self.score())
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     played = []
     teams = []
     for i in range(N):
         row = fin.readline().strip()
         t = Team()
         t.n = i
         t.won = set()
         t.opponents = []
         for j, c in enumerate(row):
             if c == '1':
                 t.won.add(j)
             if c != '.':
                 t.opponents.append(j)
         teams.append(t)
     
     for t in teams:
         total = 0.0
         for i in t.opponents:
             o = teams[i]
             total += o.wp(t.n)
         t.owp = total / len(t.opponents)
     for t in teams:
         total = 0.0
         for i in t.opponents:
             o = teams[i]
             total += o.owp
         t.oowp = total / len(t.opponents)
     
     print ""Case #%d:"" % (case)
     
     for t in teams:
         print ""%.8f"" % t.score()
     
",gcj/2011/1150485/RalfKistner/1048486/1/extracted/A.py,1521,57,179,Python,1150485,1,1048486,RalfKistner,2011
1159,c.py,"# -*- coding: utf-8 -*-
 
 import sys
 import math
 
 class ImpossibleException(Exception):
     pass
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     peaks = list(map(int, fin.readline().split()))
     rev = [[] for i in range(N)]
     for i, p in enumerate(peaks):
         rev[p-1].append(i)
 
     height = {}
     height[N-1] = 0
 
     def visit(i, slope, limit):
         h = height[i]
         prev = -1
         for j in rev[i]:
             for k in range(max(limit+1, prev+1), j):
                 if peaks[k] > i:
                     raise ImpossibleException(""At %d"" % j)
             if j <= limit or j >= i:
                 raise ImpossibleException(""At %d"" % j)
             maximum = math.floor(h - slope * (i-j))
             height[j] = maximum-1
 
             newslope = (h - height[j])/(i-j)
 
             visit(j, newslope, prev)
             prev = j
             slope = newslope
 
     try:
         visit(N-1, 0, -1)
 
         result = []
         for i in range(N):
             result.append(height[i])
         # Make output positive
         m = min(result)
         result = [x - m + 1 for x in result]
 
 
         print(""Case #%d: %s"" % (case, "" "".join(map(str, result))))
 
         for i, h in enumerate(result):
             if i == N-1:
                 break
             maxslope = 0
             bestj = -1
             for j in range(i+1, N):
                 jh = result[j]
                 slope = (jh-h)/(j-i)
                 if slope > maxslope:
                     bestj = j
                     maxslope = slope
             if bestj != peaks[i]-1:
                 print(""Failed case %d at %d-> %d != %d"" % (case, i+1, peaks[i], bestj+1), file=sys.stderr)
 
 
     except ImpossibleException:
         print(""Case #%d: Impossible"" % (case))
 
 
     
 
 
",gcj/2012/1842485/RalfKistner/1486492/0/extracted/c.py,1866,74,214,Python,1842485,0,1486492,RalfKistner,2012
1160,a.py,"# -*- coding: utf-8 -*-
 from collections import deque
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     vines = []
     for i in range(N):
         di, li = map(int, fin.readline().split())
         vines.append((di, li))
 
     D = int(fin.readline())
 
     vines.append((D, 0))
 
     queue = deque([(vines[0][0], vines[0][0]*2)])
 
     for d, l in vines[1:]:
         while queue and queue[0][1] < d:
             queue.popleft()
         if not queue:
             break
         distance = min(l, d - queue[0][0])
         p = d + distance
         if p > queue[-1][1]:
             queue.append((d, p))
 
     success = bool(queue)
     print(""Case #%d: %s"" % (case, success and ""YES"" or ""NO""))
 
",gcj/2012/1842485/RalfKistner/1481486/1/extracted/a.py,773,33,93,Python,1842485,1,1481486,RalfKistner,2012
1162,b.py,"# -*- coding: utf-8 -*-
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N, W, L = map(int, fin.readline().split())
     Rl = list(map(int, fin.readline().split()))
     R = []
     for i, r in enumerate(Rl):
         R.append((r, i))
     R.sort(reverse=True)
 
     x = W   # Right edge of column
     rs = 0  # Top of row
     re = -1000000  # Bottom of row
     y = 0   # Top edge of remaining space in column
     p = []
     for r, i in R:
         if re - y >= r*2 and L - y >= r:
             # Stack on column
             p.append((i, x-r, y+r))
             y += r*2
         elif W - x >= r*2:
             # New column
             x += r*2
             pos = max(0, rs+r)
             p.append((i, x-r, pos))
             y = pos+r
         elif L - re >= r:
             # New row
             rs = max(re, -r)    # minimum y pos
             re = rs + 2*r
             p.append((i, 0, rs+r))
             x = r
             y = re
             # Will start a new column directly after this
         else:
             print(""IMPOSSIBLE"")
             break
 
 
     p.sort()
     print(p, file=sys.stderr)
     result = """"
     for i, x, y in p:
         if x > W or y > L:
             print(""ERROR"")
 
         result += ""%d %d "" % (x, y)
 
 
     print(""Case #%d: %s"" % (case, result.strip()))
 
",gcj/2012/1842485/RalfKistner/1484495/1/extracted/b.py,1354,55,201,Python,1842485,1,1484495,RalfKistner,2012
8777,a.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 
 DELTA = 0.000000001
 
 for case in range(1,T+1):
     line = map(int, fin.readline().split())
     N = line[0]
     points = line[1:]
     total = sum(points)
     pointfs = []
     for p in points:
         pointfs.append(p * 1.0 / total)
 
     #sorted = points[:]
     #sorted.sort()
     result = []
     for i, p in enumerate(pointfs):
         a = 0.0
         b = 1.0
         guess = 0.5
         while b - a > DELTA:
             guess = (b+a)/2
             target = p + guess
             remainder = 1.0 - guess
             for j, q in enumerate(pointfs):
                 if i == j:
                     continue
                 required = target - q
                 if required > 0:
                     remainder -= required
             if remainder > 0:
                 # can be eliminated
                 a = guess
             else:
                 b = guess
         result.append(guess)
 
 
     print ""Case #%d: %s"" % (case, ' '.join([""%.6f"" % (s*100) for s in result]))
 
 
",gcj/2012/1836486/RalfKistner/1480487/1/extracted/a.py,1084,45,137,Python,1836486,1,1480487,RalfKistner,2012
8779,b.py,"# -*- coding: utf-8 -*-
 import heapq
 import sys
 
 
 C = []
 F = []
 H = 0
 INF = float('inf')
 
 def time_taken(water_level, floor_level, t):
     if t == 0:
         return 0
     if water_level - floor_level >= 20:
         return 1
     else:
         return 10
 
 def length(a, b, t):
     """"""
     Time required to move from a to b, starting at time t.
     """"""
     ca = C[a[0]][a[1]]
     cb = C[b[0]][b[1]]
     fa = F[a[0]][a[1]]
     fb = F[b[0]][b[1]]
 
     water_level = H - t*10
     # We assume we are on a valid block already
 
     if fb + 50 > ca:
         # We cannot move there, ever
         return INF
 
     if max(fa, fb, water_level) + 50 <= cb:
         # We can move immediately
         return time_taken(water_level, fa, t)
 
     if max(fa, fb) + 50 <= cb:
         # We have to wait for the water level to drop
         drop = water_level - (cb - 50)
         drop_time = drop / 10.0
         return drop_time + time_taken((cb-50), fa, t+drop_time)
 
     # We cannot move there, ever
     return INF
 
 
 
 
 
 
 def Dijkstra(G,start,end=None):
     """"""
     Find shortest paths from the start vertex to all
     vertices nearer than or equal to the end.
 
     The input graph G is assumed to have the following
     representation: A vertex can be any object that can
     be used as an index into a dictionary.  G is a
     dictionary, indexed by vertices.  For any vertex v,
     G[v] is itself a dictionary, indexed by the neighbors
     of v.  For any edge v->w, G[v][w] is the length of
     the edge.
 
     The output is a pair (D,P) where D[v] is the distance
     from start to v and P[v] is the predecessor of v along
     the shortest path from s to v.
     """"""
 
     D = {}  # dictionary of final distances
     P = {}  # dictionary of predecessors (previous node)
     Q = []  # queue
     heapq.heappush(Q, (0, start))
 
     while len(Q) > 0:
         d, v = heapq.heappop(Q)
         if v in D and d > D[v]:
             continue
         if v == end: break
 
         # Loop through neighbours
         for w in G[v]:
             vwLength = d + length(v, w, d)
             if w in D:
                 if vwLength >= D[w]:
                     continue
             D[w] = vwLength
             P[w] = v
             heapq.heappush(Q, (vwLength, w))
 
     return (D,P)
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     H, N, M = map(int, fin.readline().split())
     C = []
     F = []
     for i in range(N):
         C.append(map(int, fin.readline().split()))
     for i in range(N):
         F.append(map(int, fin.readline().split()))
 
     G = {}
     for r in range(N):
         for c in range(M):
             neighbours = []
             a = (r, c)
             if r+1 < N:
                 neighbours.append((r+1, c))
             if r-1 >= 0:
                 neighbours.append((r-1, c))
             if c+1 < M:
                 neighbours.append((r, c+1))
             if c-1 >= 0:
                 neighbours.append((r, c-1))
             G[a] = neighbours
 
     end = (N-1, M-1)
     D, P = Dijkstra(G, (0,0), end)
     print ""Case #%d: %s"" % (case, D[end])
 
",gcj/2012/1836486/RalfKistner/1485488/1/extracted/b.py,3160,125,451,Python,1836486,1,1485488,RalfKistner,2012
8781,c.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     line = map(int, fin.readline().split())
     N = line[0]
     points = line[1:]
     points.sort()
 
     numbers = {0: []}
 
     result = None
     for n in points:
         for a, prefix in numbers.items():
             b = a + n
             seq = prefix + [n]
             if b in numbers:
                 line2 = numbers[b]
                 result = (seq, line2)
                 break
             else:
                 numbers[b] = seq
         if result:
             break
     #print numbers
 
 
     print ""Case #%d:"" % (case)
     if result:
         print "" "".join(map(str, result[1]))
         print "" "".join(map(str, result[0]))
     else:
         print ""Impossible""
 
 
",gcj/2012/1836486/RalfKistner/1484496/0/extracted/c.py,800,37,93,Python,1836486,0,1484496,RalfKistner,2012
28245,b.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     numbers = map(int, fin.readline().split())
     N, S, p = numbers[:3]
     T = numbers[3:]
     normal_limit = p + 2*max(0, (p-1))
     surpising_limit = p + 2*max(0, (p-2))
 
     normal_count = 0
     surprising_count = 0
 
     for t in T:
         if t >= normal_limit:
             normal_count += 1
         elif t >= surpising_limit:
             surprising_count += 1
 
     result = normal_count + min(surprising_count, S)
 
     print ""Case #%d: %s"" % (case, result)
 
",gcj/2012/1460488/RalfKistner/1595491/0/extracted/b.py,589,25,78,Python,1460488,0,1595491,RalfKistner,2012
28246,c.py,"# -*- coding: utf-8 -*-
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     A, B = map(int, fin.readline().split())
 
     total = 0
 
     for i in range(A, B+1):
         n = str(i)
         pairs = set()
         for shift in range(1, len(n)):
             m = n[shift:] + n[:shift]
             j = int(m)
             if j > i and j <= B:
                 pairs.add(m)
         total += len(pairs)
 
 
     print ""Case #%d: %s"" % (case, total)
 
",gcj/2012/1460488/RalfKistner/1483488/1/extracted/c.py,485,23,68,Python,1460488,1,1483488,RalfKistner,2012
28248,a.py,"# -*- coding: utf-8 -*-
 import sys
 
 input = """"""ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
 
 output = """"""our language is impossible to understand
 there are twenty six factorial possibilities
 so it is okay if you want to just give up""""""
 
 mapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}
 
 for i, c in enumerate(input):
     mapping[c] = output[i]
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     line = fin.readline().strip()
 
     result = """"
     for c in line:
         result += mapping[c]
 #    N, M = map(int, fin.readline().split())
 
     print ""Case #%d: %s"" % (case, result)
 
",gcj/2012/1460488/RalfKistner/1483485/0/extracted/a.py,716,30,111,Python,1460488,0,1483485,RalfKistner,2012
93724,c.py,"# -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     M, F, N = map(int, fin.readline().split())
     types_a = []
     for i in range(N):
         p, s = map(int, fin.readline().split())
         types_a.append((p, -s))
     types_a.sort()
     types = []
     last = -1
     for p, s in types_a:
         s = -s
         if s > last:
             types.append((p, s))
             last = s
 
     cheapest = []
     cost = F
     type = 0
     i = 0
     while cost < M:
         p, s = types[type]
         if s < i:
             type += 1
             if type >= len(types):
                 break
             p, s = types[type]
 
         cost += p
         cheapest.append(cost)
         i += 1
 
     #print(list(enumerate(cheapest)), file=sys.stderr)
 
     result = 0
     for i in range(len(cheapest)):
         # i: number of days per delivery - 1
         res = 0
         if i < len(cheapest)-1:
             cost = cheapest[i]
             costp = cheapest[i+1]
             a = M // cost
             rem = M % cost
             diff = costp - cost
             b = min(rem // diff, a)
             a -= b
             res = a*(i+1) + b*(i+2)
             #print(i, a, b, res, file=sys.stderr)
         else:
             cost = cheapest[i]
             a = M // cost
             res = a*(i+1)
             #print(i, a, 0, res, file=sys.stderr)
         result = max(result, res)
 
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2012/1835486/RalfKistner/1481492/0/extracted/c.py,1558,63,199,Python,1835486,0,1481492,RalfKistner,2012
93725,a.py,"# -*- coding: utf-8 -*-
 
 def mycmp(a, b):
     v1 = a.l + a.p*b.l
     v2 = b.l + b.p*a.l
 
     if v1 == v2:
         return a.i - b.i
     else:
         return v1-v2
 
 class K(object):
     def __init__(self, l, p, i):
         self.l = l
         self.p = p
         self.i = i
 
     def __lt__(self, other):
         return mycmp(self, other) < 0
     def __gt__(self, other):
         return mycmp(self, other) > 0
     def __eq__(self, other):
         return mycmp(self, other) == 0
     def __le__(self, other):
         return mycmp(self, other) <= 0
     def __ge__(self, other):
         return mycmp(self, other) >= 0
     def __ne__(self, other):
         return mycmp(self, other) != 0
 
 
 
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     L = list(map(int, fin.readline().split()))
     P = list(map(int, fin.readline().split()))
     k = []
     for i, l_p in enumerate(zip(L, P)):
         k.append(K(l_p[0], 1- l_p[1]/100, i))
     k.sort()
 
     result = [str(v.i) for v in k]
 
     print(""Case #%d: %s"" % (case, "" "".join(result)))
 
",gcj/2012/1835486/RalfKistner/1475486/1/extracted/a.py,1129,50,144,Python,1835486,1,1475486,RalfKistner,2012
93726,a.py,"# -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 
 def mycmp(a, b):
     #v1 = a.l*a.p + b.l*(1 - (1-a.p)*(1-b.p))
     #v2 = b.l*b.p + a.l*(1 - (1-a.p)*(1-b.p))
     v1 = a.l + a.p * (a.l + b.l)
     v2 = b.l + b.p * (a.l + b.l)
 #    if v1 == v2:
 #        return a.i - b.i
 #    else:
 #        return v1-v2
     return v1-v2
 
 class K(object):
     def __init__(self, l, p, i):
         self.l = l
         self.p = p
         self.i = i
 
     def __lt__(self, other):
         return mycmp(self, other) < 0
     def __gt__(self, other):
         return mycmp(self, other) > 0
     def __eq__(self, other):
         return mycmp(self, other) == 0
     def __le__(self, other):
         return mycmp(self, other) <= 0
     def __ge__(self, other):
         return mycmp(self, other) >= 0
     def __ne__(self, other):
         return mycmp(self, other) != 0
 
 
 
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N = int(fin.readline())
     L = list(map(int, fin.readline().split()))
     P = list(map(int, fin.readline().split()))
     #print(L, file=sys.stderr)
 #    k = []
 #    for i, l_p in enumerate(zip(L, P)):
 #        k.append(K(l_p[0], 1- l_p[1]/100, i))
 #    k.sort()
     q = [(100-p, i) for i, p in enumerate(P)]
     q.sort()
     #combined = list(enumerate(zip(L, P)))
     #combined.sort(key=cmp_to_key(cmp))
     #q = [(-l_p[0]*(l_p[1]), i) for i, l_p in enumerate(zip(L, P))]
     #q.sort()
     result = [str(i) for v, i in q]
 
     print(q, file=sys.stderr)
     print(""Case #%d: %s"" % (case, "" "".join(result)))
 
",gcj/2012/1835486/RalfKistner/1475486/0/extracted/a.py,1616,61,210,Python,1835486,0,1475486,RalfKistner,2012
12583,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys, math
 
 
 def ncr(n, r):
     """""" n choose r """"""
     return math.factorial(n) // math.factorial(r) // math.factorial(n - r)
 
 def probability(height, diamonds):
     ways = 0
     for i in range(height, diamonds+1):
         ways += ncr(diamonds, i)
     return ways / (2**diamonds)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     N, X, Y = map(int, fin.readline().split())
 
     seq = (abs(X) + Y) // 2
 
     remaining = N
     for i in range(seq):
         diamonds = i * 4 + 1
         remaining -= diamonds
     sidelen = seq * 2 + 1
     diamonds = seq * 4 + 1
     prob = 0.0
     if remaining >= diamonds:
         prob = 1.0
     elif remaining <= 0:
         prob = 0.0
     else:
         if X == 0:
             # Top diamond
             prob = 0.0
         else:
             if remaining - (sidelen - 1) > Y:
                 prob = 1.0
             else:
                 prob = probability(Y+1, remaining)
 
     print(""Case #%d: %.10f"" % (case, prob))
 
",gcj/2013/2434486/RalfKistner/2700486/1/extracted/b.py,1121,48,153,Python,2434486,1,2700486,RalfKistner,2013
12585,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 words = set([w.strip() for w in open('garbled_email_dictionary.txt', 'r').readlines()])
 
 
 alphabet = 'abcdefghijklmnopqrstuvwxyz'
 
 def setletter(word, index, letter):
     return word[:index] + letter + word[index+1:]
 
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     S = fin.readline().strip()
 
     dp = []
     dp.append([0]*5)
 
     for i in range(len(S)):
         dp.append([10**10]*5)
 
     for i, c in enumerate(S):
         # j = 0 means the letter at i-1 changed
         # j = 4 means the letter at i-5 changed
         # the letter at i-j-1 was the last letter that changed
         for j in range(5):
             for l in range(1, 11):
                 if i + l > len(S):
                     break
 
                 best = None
                 word = S[i:i + l]
                 if word in words:
                     newj = min(4, j + l)
                     best = 0
                     dp[i + l][newj] = min(dp[i + l][newj], dp[i][j])
                 else:
                     # i + p1 - 5 must be >= i-j-1
                     # =>  p1 >= 4 - j
                     for p1 in range(4 - j, l):
                         if best is not None:
                             break
                         for letter in alphabet:
                             word1 = setletter(word, p1, letter)
 
                             if word1 in words:
                                 # last letter => j=0
                                 newj = min(4, l - (p1 + 1))
                                 best = 1
                                 dp[i + l][newj] = min(dp[i + l][newj], dp[i][j] + 1)
                                 break
                             else:
                                 for p2 in range(p1 + 5, l):
                                     if best is not None:
                                         break
                                     newj = min(4, l - (p2 + 1))
 
                                     for letter in alphabet:
                                         word2 = setletter(word1, p2, letter)
 
                                         if word2 in words:
                                             best = 2
                                             dp[i + l][newj] = min(dp[i + l][newj], dp[i][j] + 2)
                                             break
 
 
 
 
 
     #print(dp, file=sys.stderr)
     result = min(dp[-1])
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2013/2434486/RalfKistner/2705486/1/extracted/c.py,2585,78,267,Python,2434486,1,2705486,RalfKistner,2013
12586,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 words = set([w.strip() for w in open('garbled_email_dictionary.txt', 'r').readlines()])
 
 # print(words[0:10])
 # print(len(words))
 # print(max([len(w) for w in words]))
 
 alphabet = 'abcdefghijklmnopqrstuvwxyz'
 
 def setletter(word, index, letter):
     return word[:index] + letter + word[index+1:]
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     S = fin.readline().strip()
 
     dp = []
     dp.append([0]*5)
 
     for i in range(len(S)):
         dp.append([10**10]*5)
 
     for i, c in enumerate(S):
         # j = 0 means the letter at i-1 changed
         # j = 4 means the letter at i-5 changed
         # the letter at i-j-1 was the last letter that changed
         for j in range(5):
             for l in range(1, 11):
                 if i + l > len(S):
                     break
 
                 word = S[i:i + l]
                 if word in words:
                     newj = min(4, j + l)
                     dp[i + l][newj] = min(dp[i + l][newj], dp[i][j])
                 else:
                     # i + p1 - 5 must be >= i-j-1
                     # =>  p1 >= 4 - j
                     for p1 in range(4 - j, l):
                         for letter in alphabet:
                             word1 = setletter(word, p1, letter)
 
                             if word1 in words:
                                 # last letter => j=0
                                 newj = min(4, l - (p1 + 1))
                                 dp[i+l][newj] = min(dp[i+l][newj], dp[i][j] + 1)
 
                             else:
                                 for p2 in range(p1 + 5, l):
                                     for letter in alphabet:
                                         word2 = setletter(word1, p2, letter)
 
                                         if word2 in words:
                                             newj = min(4, l - (p2 + 1))
                                             dp[i + l][newj] = min(dp[i + l][newj], dp[i][j] + 2)
                                             pass
 
 
 
     #print(dp, file=sys.stderr)
     result = min(dp[-1])
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2013/2434486/RalfKistner/2705486/0/extracted/c.py,2284,69,248,Python,2434486,0,2705486,RalfKistner,2013
12587,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     A, N = map(int, fin.readline().split())
     motes = list(map(int, fin.readline().split()))
     limit = len(motes)
     limit1 = limit + 1
     motes.sort()
 
     last = [0] * limit1
     last[0] = A
     for mote in motes:
         current = [0] * limit1
         for used, size in enumerate(last):
             newsize = size
             for moves in range(used, limit1):
                 if newsize > mote:
                     current[moves] = max(current[moves], newsize + mote)
                 newsize = newsize*2 - 1
             if used < limit:
                 current[used+1] = max(current[used+1], size)
         last = current
 
     best = None
     for used, size in enumerate(last):
         if size > 0:
             best = used
             break
 
     print(""Case #%d: %s"" % (case, best))
 
",gcj/2013/2434486/RalfKistner/2692487/1/extracted/a.py,1009,37,121,Python,2434486,1,2692487,RalfKistner,2013
23590,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from collections import defaultdict
 
 
 def debug(*argv):
     print(*argv, file=sys.stderr)
 
 
 def cost(on, off, c):
     dist = off - on
     return dist * c - (dist * (dist - 1) // 2)
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, M = map(int, fin.readline().split())
     up = defaultdict(int)
     down = defaultdict(int)
     stations = set()
     expected_cost = 0
     for i in range(M):
         o, e, p = map(int, fin.readline().split())
         up[o] += p
         down[e] += p
         stations.add(e)
         stations.add(o)
         expected_cost += cost(o, e, N) * p
 
     stations = sorted(stations)
 
     real_cost = 0
     tickets = []
     prev_station = None
     for s in stations:
         u = up[s]
         d = down[s]
         # Number of tickets at each distance travelled
         tickets.append((s, u))
 
         while d > 0:
             station, number = tickets.pop()
             use = 0
             if number > d:
                 number -= d
                 use = d
                 tickets.append((station, number))
             elif number == d:
                 use = d
             else:
                 use = number
             real_cost += cost(station, s, N) * use
             d -= use
 
     result = (expected_cost - real_cost) % 1000002013
 
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2013/2442487/RalfKistner/2772486/1/extracted/a.py,1502,64,185,Python,2442487,1,2772486,RalfKistner,2013
23592,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*argv):
     print(*argv, file=sys.stderr)
 
 
 def best_position(k, n):
     """"""
     1-based indexing
     """"""
     total = 2 ** n
     above = k - 1
     below = total - k
     wins = 0
     while below > 0:
         wins += 1
         killed_above = above // 2
         killed_below = (above + below + 1) // 2 - killed_above
         above -= killed_above
         below -= killed_below
     losses = n - wins
     position = 2 ** losses
     return position
 
 
 def worst_position(k, n):
     total = 2 ** n
     above = k - 1
     below = total - k
     losses = 0
     while above > 0:
         losses += 1
         killed_below = below // 2
         killed_above = (above + below + 1) // 2 - killed_below
         above -= killed_above
         below -= killed_below
 
     wins = n - losses
     position = total - 2 ** wins + 1
     return position
 
 
 # n = 6
 # for i in range(1, 2**n+1):
 #     best = best_position(i, n)
 #     worst = worst_position(i, n)
 #     debug(i, best, worst)
 
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, P = map(int, fin.readline().split())
 
     g = 0
 
     T = 2 ** N
     p = T
     l = 1
     for i in range(N+1):
         v = T - 2 ** (N - i)
         limit = (2 ** i)
         if P >= limit:
             l = v
 
 
         v = 2 ** (i+1) - 1
         if i == N:
             v = T
         limit = T - 2 ** (N - i)
         #debug(i, v, limit)
         if P > limit:
             g = v-1
 
 
 
 
     #debug('-')
     # g = 0
     # l = 0
     # for i in range(1, 2 ** N + 1):
     #     best = best_position(i, N)
     #     worst = worst_position(i, N)
     #     if best <= P:
     #         l = i
     #     if worst <= P:
     #         g = i
     print(""Case #%d: %d %d"" % (case, g, l))
 
 
 # Case #1: 0 0
 # Case #2: 0 4
 # Case #3: 0 4
 # Case #4: 0 6
 # Case #5: 2 6
 # Case #6: 2 6
 # Case #7: 6 6
 # Case #8: 7 7
 # 1 1 1
 # 2 2 5
 # 3 2 5
 # 4 2 7
 # 5 2 7
 # 6 4 7
 # 7 4 7
 # 8 8 8
 
",gcj/2013/2442487/RalfKistner/2766487/1/extracted/b.py,2124,114,389,Python,2442487,1,2766487,RalfKistner,2013
23593,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*argv):
     print(*argv, file=sys.stderr)
 
 
 def best_position(k, n):
     """"""
     1-based indexing
     """"""
     total = 2 ** n
     above = k - 1
     below = total - k
     wins = 0
     while below > 0:
         wins += 1
         killed_above = above // 2
         killed_below = (above + below + 1) // 2 - killed_above
         above -= killed_above
         below -= killed_below
     losses = n - wins
     position = 2 ** losses
     return position
 
 
 def worst_position(k, n):
     total = 2 ** n
     above = k - 1
     below = total - k
     losses = 0
     while above > 0:
         losses += 1
         killed_below = below // 2
         killed_above = (above + below + 1) // 2 - killed_below
         above -= killed_above
         below -= killed_below
 
     wins = n - losses
     position = total - 2 ** wins + 1
     return position
 
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, P = map(int, fin.readline().split())
 
     g = 0
     l = 0
     for i in range(1, 2 ** N + 1):
         best = best_position(i, N)
         worst = worst_position(i, N)
         if best <= P:
             l = i
         if worst <= P:
             g = i
 
     print(""Case #%d: %d %d"" % (case, g-1, l-1))
 
",gcj/2013/2442487/RalfKistner/2766487/0/extracted/b.py,1387,66,211,Python,2442487,0,2766487,RalfKistner,2013
60577,a.py,"
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     board = []
     for i in range(4):
         row = list(fin.readline().strip())
         board.append(row)
 
     fin.readline()
 
     rows = [[], [], [], []]
     cols = [[], [], [], []]
     diags = [[], []]
 
     for i in range(4):
         for j in range(4):
             v = board[i][j]
             rows[i].append(v)
             cols[j].append(v)
             if i == j:
                 diags[0].append(v)
             if i + j == 3:
                 diags[1].append(v)
 
     buckets = rows + cols + diags
     result = 'Draw'
     filled = True
     for bucket in buckets:
         d = {'T': 0, 'X': 0, 'O': 0, '.': 0}
         for v in bucket:
             d[v] += 1
         if d['T'] + d['X'] == 4:
             result = 'X won'
             break
         if d['T'] + d['O'] == 4:
             result = 'O won'
             break
         if d['.'] > 0:
             result = 'Game has not completed'
 
     print(""Case #%d: %s"" % (case, result))
 
 
 
",gcj/2013/2270488/RalfKistner/2453486/1/extracted/a.py,1055,47,137,Python,2270488,1,2453486,RalfKistner,2013
60579,c.py,"import sys
 import bisect
 import math
 
 
 
 def isp(n):
     s = str(n)
     return s == s[::-1]
 
 
 
 fs = [1, 4, 9, 121, 484]
 
 # No idea why this works mathematically, but it follows a pattern
 
 prev = ['1', '2']
 for d in range(1,30):
     next = []
     for p in prev:
         for c in '012':
             n1 = int(p + c + p[::-1])**2
             n2 = int(p + c + c + p[::-1])**2
             w = False
             if isp(n1):
                 fs.append(n1)
                 w = True
             if isp(n2):
                 fs.append(n2)
                 w = True
             if w:
                 next.append(p + c)
     prev = next
 
 
 fs.sort()
 
 print(fs[:10], file=sys.stderr)
 print(len(str(fs[-1])), file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     board = []
     A, B = map(int, fin.readline().split())
 
     i = bisect.bisect_left(fs, A)
     j = bisect.bisect_right(fs, B)
 
     print(""Case #%d: %s"" % (case, j-i))
 
 
",gcj/2013/2270488/RalfKistner/2463486/2/extracted/c.py,995,53,129,Python,2270488,2,2463486,RalfKistner,2013
60582,b.py,"
 import sys
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1,T+1):
     board = []
     N, M = map(int, fin.readline().split())
     for i in range(N):
         board.append(list(map(int, fin.readline().split())))
     
     row_min = [100]*N
     row_max = [0]*N
     col_min = [100]*M
     col_max = [0]*M
 
     for i in range(N):
         for j in range(M):
             v = board[i][j]
             row_min[i] = min(v, row_min[i])
             row_max[i] = max(v, row_max[i])
             col_min[j] = min(v, col_min[j])
             col_max[j] = max(v, col_max[j])
 
 
     possible = True
     for i in range(N):
         for j in range(M):
             v = board[i][j]
             if v != row_max[i] and v != col_max[j]:
                 possible = False
                 break
 
 
     print(""Case #%d: %s"" % (case, possible and ""YES"" or ""NO""))
 
 
 
",gcj/2013/2270488/RalfKistner/2449486/1/extracted/b.py,876,38,101,Python,2270488,1,2449486,RalfKistner,2013
141754,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 # Best obtainable score by completely filling `level`, and partially filling `level+1`
 def best_level_score(level, numbers, money):
     base_cost = 0
     base_gain = 0
     width = 0
     for n in numbers:
         if n <= level:
             base_cost += level - n
             width += 1
     if base_cost > money:
         return 0
 
     if width == 0:
         return 0
 
     base_gain = base_cost
     base_score = base_gain * (36 / width) - base_cost
 
     scores = [base_score]
     for n in reversed(numbers):
         if n <= level:
             base_cost += 1
             if base_cost > money:
                 break
             width -= 1
             if width == 0:
                 break
             base_gain -= (level - n)
             score = base_gain * (36 / width) - base_cost
             scores.append(score)
     return max(scores)
 
 
 
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     B, N = map(int, fin.readline().split())
     numbers = list(map(int, fin.readline().split())) + [0] * (37 - N)
     numbers.sort()
 
     scores = []
     # This would be brute-force, O(max(numbers))
     # for i in range(max(numbers) + 1):
     #     score = best_level_score(i, numbers, B)
     #     scores.append(score)
 
     # This doesn't seem to be important, but we include them for safety
     for n in numbers:
         scores.append(best_level_score(n, numbers, B))
         if n > 0:
             scores.append(best_level_score(n - 1, numbers, B))
 
     width = 0
     underwater = 0
     for n in numbers:
         if width > 0:
             fill = (B + underwater) // width
             # These two don't seem to have an effect, but we include them for safety
             scores.append(best_level_score(fill, numbers, B))
             scores.append(best_level_score(fill+1, numbers, B))
 
             # This is the important one
             if fill > 0:
                 scores.append(best_level_score(fill-1, numbers, B))
         width += 1
         underwater += n
 
     result = max(scores)
 
     print(""Case #%d: %.10f"" % (case, result))
 
",gcj/2013/2433487/RalfKistner/2850486/1/extracted/a.py,2294,85,277,Python,2433487,1,2850486,RalfKistner,2013
141755,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 # Best obtainable score by completely filling `level`, and partially filling `level+1`
 def best_level_score(level, numbers, money):
     base_cost = 0
     base_gain = 0
     width = 0
     for n in numbers:
         if n <= level:
             base_cost += level - n
             width += 1
     if base_cost > money:
         return 0
 
     if width == 0:
         return 0
     
     base_gain = base_cost
     base_score = base_gain * (36 / width) - base_cost
 
     scores = [base_score]
     for n in reversed(numbers):
         if n <= level:
             base_cost += 1
             if base_cost > money:
                 break
             width -= 1
             if width == 0:
                 break
             base_gain -= (level - n)
             score = base_gain * (36 / width) - base_cost
             scores.append(score)
     return max(scores)
 
 
 
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     B, N = map(int, fin.readline().split())
     numbers = list(map(int, fin.readline().split())) + [0] * (37 - N)
     numbers.sort()
 
     scores = []
     for i in range(max(numbers) + 1):
         score = best_level_score(i, numbers, B)
         scores.append(score)
     debug(scores)
     result = max(scores)
     # counts = {}
     # for n in numbers:
     #     if n not in counts:
     #         counts[n] = 1
     #     else:
     #         counts[n] += 1
     # heights = list(counts.keys())
     # heights.sort()
     #
     # underwater = 0
     #
     # empty = 37 - N
     # for height in heights:
     #     count = counts[height]
     #
     #     # Score 1 - will up below height
     #     fill = min(height - 1, (B + underwater) // empty)
     #     spent = fill * empty - underwater
     #     receive = 36 * fill
 
 
     print(""Case #%d: %.10f"" % (case, result))
 
",gcj/2013/2433487/RalfKistner/2850486/0/extracted/a.py,2018,83,266,Python,2433487,0,2850486,RalfKistner,2013
28125,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Naomi and Ken sometimes play games together. Before they play, each of them gets N identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:
 
 # Each player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.
 # They repeat the following process N times:
 # Naomi chooses one of her own blocks, with mass ChosenNaomi.
 # Naomi tells Ken the mass of the block she chose.
 # Ken chooses one of his own blocks, with mass ChosenKen.
 # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.
 # Both blocks are destroyed in a fire.
 # Naomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!
 
 # Here is how Deceitful War works, with differences between Deceitful War and War in bold:
 
 # Each player weighs each of his or her own blocks. Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks and Ken only knows the weights of his own blocks.
 # They repeat the following process N times:
 # Naomi chooses one of her own blocks, with mass ChosenNaomi.
 # Naomi tells Ken a number, ToldNaomi, between 0.0kg and 1.0kg exclusive. Ken, who thinks they're playing War, thinks the number Naomi just told him is ChosenNaomi.
 # Ken chooses one of his own blocks, with mass ChosenKen.
 # They each put their block on one side of a balance scale, and the person whose block is heavier gets one point.
 # Both blocks are destroyed in a fire.
 # Naomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that ChosenNaomi  ToldNaomi. In other words, she must make decisions so that:
 
 # ChosenNaomi > ChosenKen if, and only if, ToldNaomi > ChosenKen, and
 # ToldNaomi is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.
 # It might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.
 
 # You'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points assuming that both players are playing War. What will Naomi's score be? What would it have been if she had played War optimally instead?
 
 # Examples
 
 # If each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't say her number is  0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.
 
 # If each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing a single integer N, the number of blocks each player has. Next follows a line containing N space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing N space-separated real numbers: the masses of Ken's blocks, in kg.
 
 # Each of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.
 
 # Output
 
 # For each test case, output one line containing ""Case #x: y z"", where x is the test case number (starting from 1), y is the number of points Naomi will score if she plays Deceitful War optimally, and z is the number of points Naomi will score if she plays War optimally.
 
 # Limits
 
 # 1  T  50.
 # All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.
 # Small dataset
 
 # 1  N  10.
 # Large dataset
 
 # 1  N  1000.
 
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     numbers1 = list(map(float, fin.readline().split()))
     numbers2 = list(map(float, fin.readline().split()))
 
     numbers1.sort(reverse=True)
     numbers2.sort()
 
     # Normal
     naomi = 0
     remaining = numbers2[:]
     for n in numbers1:
         lost = False
         for i, r in enumerate(remaining):
             if r > n:
                 del remaining[i]
                 lost = True
                 break
         if not lost:
             naomi += 1
 
     cheat = 0
     remaining = numbers2[:]
     numbers1.sort()
     # debug(numbers1)
     # debug(remaining)
     while numbers1:
         n = numbers1[0]
         if n > remaining[0]:
             cheat += 1
             del remaining[0]
             del numbers1[0]
         else:
             del remaining[-1]
             del numbers1[0]
 
     print(""Case #%d: %d %d"" % (case, cheat, naomi))
 
",gcj/2014/2974486/RalfKistner/5644738749267968/1/extracted/d.py,6662,107,1138,Python,2974486,1,5644738749267968,RalfKistner,2014
28129,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Minesweeper is a computer game that became popular in the 1980s, and is still included in some versions of the Microsoft Windows operating system. This problem has a similar idea, but it does not assume you have played Minesweeper.
 
 # In this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are M mines hidden in M different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.
 
 # For example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):
 
 # *..*...**.
 # ....*.....
 # ..c..*....
 # ........*.
 # ..........
 # There are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:
 # *..*...**.
 # 1112*.....
 # 00012*....
 # 00001111*.
 # 00000001..
 # At this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.
 # You want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (R x C) and the number of hidden mines M, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the Output section. Otherwise, print ""Impossible"".
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T lines follow. Each line contains three space-separated integers: R, C, and M.
 
 # Output
 
 # For each test case, output a line containing ""Case #x:"", where x is the test case number (starting from 1). On the following R lines, output the board configuration with C characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.
 
 # If there is no possible configuration, then instead of the grid, output a line with ""Impossible"" instead. If there are multiple possible configurations, output any one of them.
 
 # Limits
 
 # 0  M < R * C.
 # Small dataset
 
 # 1  T  230.
 # 1  R, C  5.
 # Large dataset
 
 # 1  T  140.
 # 1  R, C  50.
  
 
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     RR, CC, M = map(int, fin.readline().split())
     R, C = None, None
     blocks = RR*CC - M
     inverse = False
     if RR > CC:
         inverse = True
         R, C = CC, RR
     else:
         R, C = RR, CC
     result = None
     # Now R <= C
     if R == 1:
         # Always possible
         result = [('.' * blocks) + ('*' * M)]
     elif R == 2:
         # Possible if blocks == 1 or blocks % 2 == 0
         if blocks == 1:
             result = ['.' + ('*' * (C-1)), '*' * C]
         elif blocks % 2 == 0 and blocks != 2:
             cc = blocks // 2
             result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] 
         else:
             result = None
     else:
         if blocks == 1:
             result = ['*' * C] * R
         elif blocks == 4:
             result = ['..' + (C-2)*'*']*2
             result += ['*'*C] * (R-2)
         elif blocks == 6:
             result = ['...' + (C-3)*'*']*2
             result += ['*'*C] * (R-2)
         for rows in range(3, R+1):
             for columns in range(rows, C+1):
                 size = rows * columns
                 if size - blocks >= 0:
                     if size - blocks <= columns - 2: 
                         result = []
                         for r in range(rows):
                             if r < rows - 1:
                                 result.append(('.' * columns) + ('*' * (C - columns)))
                             else:
                                 cc = columns - (size - blocks)
                                 result.append(('.' * cc) + ('*' * (C - cc)))
                         for r in range(R - rows):
                             result.append('*' * C)
                     elif size - blocks == columns - 1 and rows >= 4:
                         result = []
                         for r in range(rows):
                             if r < rows - 2:
                                 result.append(('.' * columns) + ('*' * (C - columns)))
                             elif r == rows - 2:
                                 cc = columns - 1
                                 result.append(('.' * cc) + ('*' * (C - cc)))
                             else:
                                 cc = 2
                                 result.append(('.' * cc) + ('*' * (C - cc)))
                         for r in range(R - rows):
                             result.append('*' * C)
                     
 
 
 
     print(""Case #%d: "" % (case))
     if result is None:
         debug('impossible', blocks, RR, CC)
         print(""Impossible"")
     else:
         mines = 0
         for r in range(RR):
             row = ''
             for c in range(CC):
                 rr, cc = r, c
                 if inverse:
                     rr, cc = c, r
                 if rr == 0 and cc == 0:
                     row += 'c'
                 else:
                     row += result[rr][cc]
                     if result[rr][cc] == '*':
                         mines += 1
             print(row)
         if mines != M:
             raise Exception(""%d != %d %d x %d"" % (mines, M, RR, CC))
             
 
 
",gcj/2014/2974486/RalfKistner/5690574640250880/1/extracted/c.py,6305,145,961,Python,2974486,1,5690574640250880,RalfKistner,2014
28131,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 # Recently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!
 
 # The magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.
 
 # Finally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?
 
 # You decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.
 
 # Your program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).
 
 # Solving this problem
 
 # Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has only 1 Small input. Once you have solved the Small input, you have finished solving this problem.
 
 # Input
 
 # The first line of the input gives the number of test cases, T. T test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.
 
 # Output
 
 # For each test case, output one line containing ""Case #x: y"", where x is the test case number (starting from 1).
 
 # If there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be ""Bad magician!"", without the quotes. If there are no cards consistent with the volunteer's answers, y should be ""Volunteer cheated!"", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.
 
 # Limits
 
 # 1  T  100.
 # 1  both answers  4.
 # Each number from 1 to 16 will appear exactly once in each arrangement.
 
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     answer1 = int(fin.readline())
     rows1 = []
     for i in range(4):
         rows1.append(set(map(int, fin.readline().split())))
     answer2 = int(fin.readline())
     rows2 = []
     for i in range(4):
         rows2.append(set(map(int, fin.readline().split())))
 
     possibilities1 = rows1[answer1-1]
     possibilities2 = rows2[answer2-1]
 
     numbers = possibilities1.intersection(possibilities2)
     result = None
     if len(numbers) == 1:
         result = list(numbers)[0]
     elif len(numbers) == 0:
         result = 'Volunteer cheated!'
     else:
         result = 'Bad magician!'
 
 
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2014/2974486/RalfKistner/5756407898963968/0/extracted/a.py,3588,69,577,Python,2974486,0,5756407898963968,RalfKistner,2014
134192,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def solve1(N, M, K):
     # Incorrect, but solves small input!
     result = K
     if N == 1:
         result = K
     else:
         for l in range(0, M-1):
             h1_min = max(0, K // (l+2) - 2)
             for h1 in range(h1_min, N-1):
                 upper_limit = (l+2) * (h1+2)
                 if upper_limit < K:
                     continue
                 for h2 in range(0, h1+1):
                     stones = l*2 + h1 + h2
                     diff = h1 - h2
                     if diff >= l:
                         continue
                     rect = l * h1
                     triangle = diff*(diff+1)//2
 
                     covered = rect - triangle + stones
                     if covered > K:
                         continue
                     required = stones + K - covered
                     result = min(result, required)
     return result
 
 def solve2(N, M, K):
     result = K
     if N == 1:
         result = K
     else:
         for l in range(2, M+1):
             stones = 0
             covered = 0
             i = 1
             onside = 0
             while i * 2 <= l + 1:
                 if i == 1:
                     stones += 2
                     covered += 2
                 else:
                     b = min(N, 2*i-1)
                     if i * 2 == l + 1:
                         stones += 2
                         covered += b
                         if b == N:
                             onside += 1
                     else:
                         stones += 4
                         covered += b*2
                         if b == N:
                             onside += 2
                 i += 1
 
             if covered > K:
                 required = stones
             else:
                 required = stones + K - covered
             result = min(result, required)
 
             a = min(N-1, (l-1)//2)
             b = min(l, N) - a - 1
             corners = [a, a, b, b]
             while sum(corners) > 0:
                 corners.sort(reverse=True)
                 stones += 1
                 covered += corners[0]
                 corners[0] -= 1
                 
                 if covered > K:
                     required = stones
                 else:
                     required = stones + K - covered
                 result = min(result, required)
 
 
     return result
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, M, K = map(int, fin.readline().split())
     N, M = min([N, M]), max([N, M])
     debug(""Case #%d"" % case)
     result = solve2(N, M, K)
 
     print(""Case #%d: %s"" % (case, result))",gcj/2014/3004486/RalfKistner/5658068650033152/1/extracted/c.py,2840,99,326,Python,3004486,1,5658068650033152,RalfKistner,2014
134193,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, M, K = map(int, fin.readline().split())
     N, M = min([N, M]), max([N, M])
     result = K
     if N == 1:
         result = K
     else:
         for l in range(0, M-1):
             for h1 in range(0, N-1):
                 for h2 in range(0, h1+1):
                     stones = l*2 + h1 + h2
                     diff = h1 - h2
                     if diff >= l:
                         continue
                     rect = l * h1
                     triangle = diff*(diff+1)//2
 
                     covered = rect - triangle + stones
                     if covered > K:
                         continue
                     required = stones + K - covered
                     result = min(result, required)
 
 
     print(""Case #%d: %s"" % (case, result))",gcj/2014/3004486/RalfKistner/5658068650033152/0/extracted/c.py,1025,37,122,Python,3004486,0,5658068650033152,RalfKistner,2014
134194,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 from itertools import permutations
 
 M = 1000000007
 def modperm(p):
     r = 1
     for i in range(1, p+1):
         r *= i
         r %= M
     return r
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 ALPHABET = 'abcdefghijklmnopqrstuvwxyz'
 
 class SolveError(Exception):
     pass
 
 def solve2(cars):
     result = 0
     for perm in permutations(cars):
         cc = ''
         for car in perm:
             cc += car
         trimmed = trim(cc)
         if len(set(trimmed)) == len(trimmed):
             result += 1
     return result
 
 def trim(car):
     trimmed = ''
     last = None
     for c in car:
         if c != last:
             trimmed += c
             last = c
     return trimmed
 
 def solve(cars):
     start = {}
     end = {}
     singular = {}
     mid = {}
 
     for c in ALPHABET:
         start[c] = 0
         end[c] = 0
         singular[c] = 0
         mid[c] = 0
 
     pairs = []
     for car in cars:
         trimmed = trim(car)
         if len(trimmed) != len(set(trimmed)):
             raise SolveError('Duplicate cars in set')
         elif len(trimmed) == 1:
             singular[trimmed] += 1
         else:
             for i, c in enumerate(trimmed):
                 if i == 0:
                     start[c] += 1
                 elif i == len(trimmed) - 1:
                     end[c] += 1
                 else:
                     mid[c] += 1
             pairs.append(trimmed[0] + trimmed[-1])
 
 
     # Merge cars for cycle check
     for i in range(len(pairs)-1, -1, -1):
         p1 = pairs[i]
         for j in range(0, i):
             p2 = pairs[j]
             if p1[0] == p2[-1]:
                 p3 = p2 + p1
                 pairs[j] = p3
                 del pairs[i]
                 break
             elif p1[-1] == p2[0]:
                 p3 = p1 + p2
                 pairs[j] = p3
                 del pairs[i]
                 break
 
     for car in pairs:
         trimmed = trim(car)
         if len(set(trimmed)) != len(trimmed):
             raise SolveError('Cycle detected')
     
 
     result = 1
     groups = len(cars)
     for c in ALPHABET:
         if mid[c] > 1:
             raise SolveError('%s in middle of more than 1 car' % c)
         elif mid[c] == 1:
             if start[c] > 0 or end[c] > 0 or singular[c] > 0:
                 raise SolveError('%s in middle and other cars' % c)
         elif start[c] > 1 or end[c] > 1:
             raise SolveError('%s in multiple starts or ends' % c)
         else:
             # Valid
             result *= modperm(singular[c])
             if singular[c] + start[c] + end[c] > 1:
                 groups -= singular[c] + start[c] + end[c] - 1
 
         result %= M
 
     result *= modperm(groups)
     result %= M
     return result
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     cars = fin.readline().split()
 
     try:
         # if len(cars) > 8:
         #     result = ""too long""
         # else:
         #     result = solve2(cars)
         result = solve(cars)
     except SolveError as e:
         debug(""Case #%d:"" % case, e)
         result = 0
 
 
     print(""Case #%d: %s"" % (case, result))",gcj/2014/3004486/RalfKistner/5669245564223488/1/extracted/b.py,3344,136,412,Python,3004486,1,5669245564223488,RalfKistner,2014
134196,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from fractions import gcd
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     p, q = map(int, fin.readline().split('/'))
     g = gcd(p, q)
     p //= g
     q //= g
 
     result = None
     if p > q:
         result = ""impossible""
     else:
         is_power = None
         for i in range(0, 41):
             power = 2**i
             if q == power:
                 is_power = power
         if is_power is None:
             result = ""impossible""
         else:
             result = ""broken""
             for i in range(1, 41):
                 qq = 2**i
                 if p * qq >= q:
                     result = str(i)
                     break
 
 
 
     print(""Case #%d: %s"" % (case, result))",gcj/2014/3004486/RalfKistner/5706278382862336/1/extracted/a.py,912,41,112,Python,3004486,1,5706278382862336,RalfKistner,2014
147793,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     #debug(""Case #%d"" % case)
 
     N = int(fin.readline())
     numbers = list(map(int, fin.readline().split()))
 
     ordered = numbers[:]
     ordered.sort()
     index = {}
     for i, n in enumerate(numbers):
         index[n] = i
 
     steps = 0
     for j, n in enumerate(ordered):
         i = numbers.index(n)
         l = i
         r = len(numbers)-i-1
         steps += min(l, r)
         del numbers[i]
 
 
 
 
     print(""Case #%d: %s"" % (case, steps))
 
 # 98 3986 2708 468 4907 5915 657 257 8714
 
 # 98 3986 2708 468 4907 5915 8714 657 257
 # 98 468 2708 3986 4907 5915 8714 657 257
 
 
 # 98 468 2708 3986 4907 5915 8714 2657 57
 
 
 # 98 3986 2708 468 4907 5915 657 257 8714
 # 98 2708 468 3986 4907 5915 657 8714 257
 # 98 468 2708 3986 4907 5915 8714 657 257",gcj/2014/3014486/RalfKistner/5721094409420800/1/extracted/b.py,1032,49,154,Python,3014486,1,5721094409420800,RalfKistner,2014
147795,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def perm(N, i):
     if i == 0:
         return [[]]
     result = []
     for j in range(N):
         for p in perm(N, i-1):
             result.append(p + [j])
     return result
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def count(words):
     trie = {}
     for word in words:
         for i in range(0, len(word)+1):
             prefix = word[:i]
             trie[prefix] = 1
     return len(trie)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     M, N = map(int, fin.readline().split())
     words = []
     for i in range(M):
         words.append(fin.readline().strip())
 
     worst = 0
     counter = {}
 
     for permutation in perm(N, M):
         groups = []
         for i in range(N):
             groups.append([])
         for i, word in enumerate(words):
             groups[permutation[i]].append(word)
         c = 0
         for group in groups:
             c += count(group)
         if c not in counter:
             counter[c] = 0
         counter[c] += 1
         worst = max(worst, c)
 
 
     print(""Case #%d: %d %d"" % (case, worst, counter[worst]))",gcj/2014/3014486/RalfKistner/5649687893770240/0/extracted/d.py,1247,54,148,Python,3014486,0,5649687893770240,RalfKistner,2014
147796,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, X = map(int, fin.readline().split())
     sizes = list(map(int, fin.readline().split()))
     sizes.sort()
     a = 0
     b = N - 1
     discs = 0
     while b > a:
         large = sizes[b]
         small = sizes[a]
         if large + small <= X:
             b -= 1
             a += 1
             discs += 1
         else:
             b -= 1
             discs += 1
     if b == a:
         discs += 1
 
     print(""Case #%d: %s"" % (case, discs))",gcj/2014/3014486/RalfKistner/5737429512224768/1/extracted/a.py,710,33,95,Python,3014486,1,5737429512224768,RalfKistner,2014
1754,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def same(a, b):
     return a == b
     if a == 0 and b == 0:
         return True
     return abs(a-b)/(abs(a)+abs(b)) < 0.0000001
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     head = fin.readline().split()
     N = int(head[0])
     V = float(head[1])
     X = float(head[2])
 
     flows = []
     for i in range(N):
         r, c = map(float, fin.readline().split())
         r /= V
         c /= X
         flows.append((r, c))
 
 
     result = None
     if N == 1:
         if same(flows[0][1], 1):
             result = 1/flows[0][0]
         else:
             debug(case, 'IMPOSSIBLE - n=1 and invalid flow', flows)
             result = None
     elif N == 2:
         x1 = flows[0][1]
         x2 = flows[1][1]
         r1 = flows[0][0]
         r2 = flows[1][0]
 
         if same(x1, x2):
             if same(x1, 1) or same(x2, 1):
                 r = r1 + r2
                 result = 1/r
             else:
                 debug(case, 'IMPOSSIBLE')
                 result = None
         else:
             v1 = (1-x2)/(x1-x2)
             t1 = v1/r1
             v2 = 1-v1
             t2 = v2/r2
             if (v1 < 0 and not same(v1, 0)) or (v2 < 0 and not same(v2, 0)):
                 debug(case, 'IMPOSSIBLE - need negative flow', flows)
                 result = None
             else:
                 result = max(t1, t2)
 
 
         if result is not None:
             if x1 > 1 and x2 > 1:
                 raise Exception(""FOO"")
             if x1 < 1 and x2 < 1:
                 raise Exception(""BAR"")
 
     else:
         debug(case, 'Too large N', flows)
 
 
     if result is None:
         print(""Case #%d: IMPOSSIBLE"" % (case))
     else:
         print(""Case #%d: %.10f"" % (case, result))
 
 """"""
 5 IMPOSSIBLE - n=1 and invalid flow [(0.5065784290553849, 0.9999930078853573)]
 7 IMPOSSIBLE - need negative flow [(7.000007000007e-06, 3.2941648461705153), (2.0000020000020002e-06, 1.0000644250648643)]
 20 IMPOSSIBLE
 45 IMPOSSIBLE - need negative flow [(0.8844685997744044, 0.3729357156665556), (0.4674556594959117, 0.1578028405375057)]
 58 IMPOSSIBLE - need negative flow [(0.09639824257412465, 2.2674094006991425), (1.708984008282862, 4.549410255765411)]
 65 IMPOSSIBLE - need negative flow [(1.0, 1.001), (1.0, 1.002)]
 67 IMPOSSIBLE - n=1 and invalid flow [(0.31994045973707197, 222.829)]
 71 IMPOSSIBLE - need negative flow [(2.0, 0.9999958534441293), (499999.49999999994, 0.15433066295135262)]
 77 IMPOSSIBLE - need negative flow [(1.836245658197279, 1.396698781593187), (1.5251835676387264, 1.4236068137716646)]
 80 IMPOSSIBLE - need negative flow [(6.0, 0.9999989989989989), (4.0, 0.9979979979979979)]
 81 IMPOSSIBLE - need negative flow [(0.345442002741243, 0.9999884315662069), (3.9922528115894673, 0.2476295556130764)]
 83 IMPOSSIBLE - n=1 and invalid flow [(0.6161911348919223, 1.379364032840781)]
 94 IMPOSSIBLE - n=1 and invalid flow [(0.40686398047122074, 0.5395495495495496)]
 96 IMPOSSIBLE - need negative flow [(1.6347387167917022, 1.1186229467704087), (6.7309747252443035, 1.0000135852784984)]
 """"""",gcj/2015/8234486/RalfKistner/5750872826970112/0/extracted/b.py,3273,95,367,Python,8234486,0,5750872826970112,RalfKistner,2015
1755,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 EMPTY = (-1, -1)
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 
 def count(grid, rows, cols):
 
     cc = 0
 
     for i, (m, n) in enumerate(rows):
         if m == -1:
             continue
         elif m == n:
             e = grid[i][m]
             if e == '<' or e == '>':
                 if cols[m][0] == cols[m][1]:
                     raise ""IMPOSSIBLE""
                 else:
                     cc += 1
             else:
                 # Will handle in column pass
                 pass
         else:
             if grid[i][m] == '<':
                 cc += 1
             if grid[i][n] == '>':
                 cc += 1
 
     for j, (m, n) in enumerate(cols):
         if m == -1:
             continue
         elif m == n:
             e = grid[m][j]
             if e == '^' or e == 'v':
                 if rows[m][0] == rows[m][1]:
                     raise Exception(""IMPOSSIBLE"")
                 else:
                     cc += 1
             else:
                 # Will handle in column pass
                 pass
         else:
             if grid[m][j] == '^':
                 cc += 1
             if grid[n][j] == 'v':
                 cc += 1
 
     return cc
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     R,C = map(int, fin.readline().split())
     rows = [EMPTY]*R
     cols = [EMPTY]*C
     grid = []
     for i in range(R):
         row = fin.readline().strip()
         grid.append(row)
         for j, c in enumerate(row):
             if c != '.':
                 if rows[i] == EMPTY:
                     rows[i] = (j, j)
                 else:
                     rows[i] = (min(rows[i][0], j), max(rows[i][1], j))
 
                 if cols[j] == EMPTY:
                     cols[j] = (i, i)
                 else:
                     cols[j] = (min(cols[j][0], i), max(cols[j][1], i))
 
 
     debug(rows)
     debug(cols)
     debug('--')
 
     try:
         cc = count(grid, rows, cols)
     except:
         cc = 'IMPOSSIBLE'
 
 
     print(""Case #%d: %s"" % (case, cc))
 
",gcj/2015/8234486/RalfKistner/5708208098246656/1/extracted/a.py,2196,92,239,Python,8234486,1,5708208098246656,RalfKistner,2015
10757,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def permutations(n, k):
     if k == 0:
         yield [False]*n
         return
     for p in permutations(n-1, k-1):
         yield p + [True]
     if n > k:
         for p in permutations(n-1, k):
             yield p + [False]
 
 def cost(p, r, c):
     result = 0
     for i in range(r):
         for j in range(c-1):
             if p[i*c+j] and p[i*c+j+1]:
                 result += 1
     for i in range(r-1):
         for j in range(c):
             if p[i*c+j] and p[i*c+j+c]:
                 result += 1
     return result
 
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     R, C, N = map(int, fin.readline().split())
 
     best = R*C*10
     for p in permutations(R*C, N):
         best = min(best, cost(p, R, C))
 
     result = best
     print(""Case #%d: %s"" % (case, result))",gcj/2015/8224486/RalfKistner/5769900270288896/0/extracted/b.py,1000,44,129,Python,8224486,0,5769900270288896,RalfKistner,2015
10758,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 import heapq
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
 
     heap = []
     hikers = 0
 
     for i in range(N):
         d, h, m = map(int, fin.readline().split())
         for p in range(m, m+h):
             t = p * (360-d) / 360.0
             heapq.heappush(heap, (t, 1, p))
             hikers += 1
 
     current = hikers
     least = current
     while current <= hikers*2:
         token = heapq.heappop(heap)
         t, d, p = token
         current -= d
         least = min(current, least)
         heapq.heappush(heap, (t + p, -1, p))
 
     result = least
     debug(""Case %d"" % case)
     print(""Case #%d: %s"" % (case, result))
",gcj/2015/8224486/RalfKistner/5662291475300352/2/extracted/c.py,880,38,113,Python,8224486,2,5662291475300352,RalfKistner,2015
10759,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     hikers = []
     for i in range(N):
         d, h, m = map(int, fin.readline().split())
         for p in range(m, m+h):
             rev = p * (360-d) / 360.0
             hikers.append({'start': d, 'p': p, 't': rev})
     hikers.sort(key=lambda hiker: -hiker['t'])
     debug(hikers)
     M = len(hikers)
     best = []
     for i in range(M+1):
         count = 0
         if i < M:
             finish_at = hikers[i]['t']+0.000000000001
         else:
             finish_at = 0
         for h in hikers:
             first_rev = h['t']
             if finish_at < first_rev:
                 # deer pass hiker
                 count += 1
             else:
                 rem = finish_at - first_rev
                 times = int(rem / h['p'])
                 count += times
         best.append(count)
     result = min(best)
     print(""Case #%d: %s"" % (case, result))
",gcj/2015/8224486/RalfKistner/5662291475300352/1/extracted/c.py,1161,43,133,Python,8224486,1,5662291475300352,RalfKistner,2015
10761,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from fractions import gcd
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def reverse(nr):
     return int(str(nr)[::-1])
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     n = int(fin.readline())
     count = 0
     while n > 0:
         digits = str(n)
         halfcount = (len(digits)+1)//2
         rev = reverse(n)
         mod = n % (10 ** halfcount)
 
         if mod == 1 and n != rev:
             n = rev
             count += 1
         elif mod <= 1:
             n -= 1
             count += 1
         else:
             n -= (mod-1)
             count += (mod-1)
 
     print(""Case #%d: %s"" % (case, count))",gcj/2015/8224486/RalfKistner/5688567749672960/1/extracted/a.py,782,36,100,Python,8224486,1,5688567749672960,RalfKistner,2015
10762,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from fractions import gcd
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def reverse(nr):
     return int(str(nr)[::-1])
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     n = int(fin.readline())
     least = {1: 1}
     for i in range(2, n+1):
         if i in least:
             least[i] = min(least[i-1]+1, least[i])
         else:
             least[i] = least[i-1]+1
 
         rev = reverse(i)
         if rev > i:
             least[rev] = least[i] + 1
 
     result = least[n]
     # debug(least)
 
     print(""Case #%d: %s"" % (case, result))",gcj/2015/8224486/RalfKistner/5688567749672960/0/extracted/a.py,711,33,84,Python,8224486,0,5688567749672960,RalfKistner,2015
34071,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 def debug(args):
     print >> sys.stderr, args
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     win = False
     x, r, c = map(int, fin.readline().split())
     if r > c:
        c, r = r, c
     if x >= 4:
         win = (x >= 2*r) or (r >= 3 and (x >= r + c - 3)) 
     elif x == 4:
         win = r <= 2
     else:
         win = False
     if (r * c) % x != 0:
         win = True
     print ""Case #%d: %s"" % (case, win and ""RICHARD"" or ""GABRIEL"")",gcj/2015/6224486/RalfKistner/5658571765186560/0/extracted/d.py,602,25,105,Python,6224486,0,5658571765186560,RalfKistner,2015
34072,b.py,"
 import sys
 
 def debug(args):
     print >> sys.stderr, args
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     D = int(fin.readline())
     diners = map(int, fin.readline().split())
 
     costs = []
     for i in range(1, 1002):
         cost = i
         for d in diners:
             cost += (d-1) / i
         costs.append(cost)
 
     best = min(costs)
 
 
     print ""Case #%d: %s"" % (case, best)",gcj/2015/6224486/RalfKistner/5686275109552128/1/extracted/b.py,434,23,59,Python,6224486,1,5686275109552128,RalfKistner,2015
34073,b.py,"
 import sys
 
 def debug(args):
     print >> sys.stderr, args
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     D = int(fin.readline())
     diners = map(int, fin.readline().split())
 
     costs = []
     for i in range(1, 1001):
         cost = i
         for d in diners:
             cost += (d-1) / i
         costs.append(cost)
 
     best = min(costs)
 
 
     print ""Case #%d: %s"" % (case, best)",gcj/2015/6224486/RalfKistner/5686275109552128/0/extracted/b.py,434,23,59,Python,6224486,0,5686275109552128,RalfKistner,2015
34074,a.py,"
 import sys
 
 def debug(args):
     print >> sys.stderr, args
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     win = False
     a, b = fin.readline().split()
     smax = int(a)
     s = map(int, b)
     count = 0
     add = 0
     for i, n in enumerate(s):
     	if n > 0:
     		if i > count:
     			k = i - count
     			count += k
     			add += k
     		count += n
 
     print ""Case #%d: %s"" % (case, add)",gcj/2015/6224486/RalfKistner/5639104758808576/1/extracted/a.py,443,24,75,Python,6224486,1,5639104758808576,RalfKistner,2015
56974,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 # from Set import Set
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     found = set()
     if N == 0:
         result = 'INSOMNIA'
     else:
         r = 0
         while len(found) < 10:
             r += N
             digits = str(r)
             for d in digits:
                 found.add(d)
         result = str(r)
 
 
 
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2016/6254486/RalfKistner/5652388522229760/1/extracted/a.py,607,31,75,Python,6254486,1,5652388522229760,RalfKistner,2016
56976,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     K, C, S = map(int, fin.readline().split())
     if K > C*S:
         result = 'IMPOSSIBLE'
     else:
         p = 0
         numbers = []
         while p < K:
             nr = 0
             for c in range(C):
                 if p < K:
                     nr += p * (K**c)
                     p += 1
             numbers.append(nr + 1)
         result = ' '.join(map(str, numbers))
 
     print(""Case #%d: %s"" % (case, result))
",gcj/2016/6254486/RalfKistner/5636311922769920/1/extracted/d.py,688,30,86,Python,6254486,1,5636311922769920,RalfKistner,2016
56978,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 
 def calculate_primes(limit):
     """"""
     Calculates all primes <= limit.
 
     >>> calculate_primes(10)
     [2, 3, 5, 7]
     >>> calculate_primes(3)
     [2, 3]
     """"""
     limit += 1
     is_prime = [True]*limit
     is_prime[0] = False
     is_prime[1] = False
     primes = []
     for i in range(2, limit):
         if not is_prime[i]:
             continue
         primes.append(i)
         for j in range(2*i, limit, i):
             is_prime[j] = False
     return primes
 
 def find_factor(number, primes):
     for p in primes:
         if p >= number:
             break
 
         if number % p == 0:
             return p
     return None
 
 primes = calculate_primes(2**10)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, J = map(int, fin.readline().split())
 
     print(""Case #%d:"" % (case))
     count = 0
     number = 2**(N-1) + 1
     while count < J:
         s = bin(number)[2:]
         success = True
         factors = []
         for base in range(2, 11):
             basenum = int(s, base)
             factor = find_factor(basenum, primes)
             if factor is None:
                 success = False
                 break
             else:
                 factors.append(factor)
         if success:
             count += 1
             print(s, ' '.join(map(str, factors)))
         number += 2
 
 
 
 
",gcj/2016/6254486/RalfKistner/5738606668808192/1/extracted/c.py,1562,73,174,Python,6254486,1,5738606668808192,RalfKistner,2016
56980,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     line = fin.readline().strip() + '+'
     last = line[0]
     count = 0
     for c in line:
         if c != last:
             count += 1
         last = c
 
     print(""Case #%d: %s"" % (case, count))
 
",gcj/2016/6254486/RalfKistner/5634697451274240/1/extracted/b.py,457,24,60,Python,6254486,1,5634697451274240,RalfKistner,2016
168941,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 import math
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 class Graph(object):
     def edges(self, node, **kwargs):
         """"""
         All edges from node to its neighbours.
 
         Additional parameters may be passed, for example ""distance"" - the current shortest distance to node.
 
         If the node does not exist, an empty dictionary will be returned.
 
         Result: {neighbour: weight}
         """"""
         return {}
 
     def nodes(self):
         """"""
         Iterator generating all nodes in this graph.
 
         The value of each node is implementation-specific.
         """"""
         return []
 
     def value(self, node):
         """"""
         Returns the value associated with a node. Optional.
         """"""
         return None
 
     def total_edges(self):
         total = 0
         for node in self.nodes():
             total += len(self.edges(node))
         return total
 
 
 class GridGraph(Graph):
     """"""
     Represents a grid as a graph.
 
     `filter` is a function to filter out a block. The default filter accepts any block that evaluates to True.
 
     >>> g = GridGraph([[1, 0], [1, 1]])
     >>> g
     1 0
     1 1
     >>> list(g.all_nodes())
     [(0, 0), (0, 1), (1, 0), (1, 1)]
     >>> list(g.nodes())
     [(0, 0), (1, 0), (1, 1)]
     >>> sorted(g.edges((0, 0)).keys())
     [(1, 0)]
     """"""
 
     def __init__(self, grid, filter=None):
         self.grid = grid
         self.rows = len(grid)
         self.cols = len(grid[0])
 
         if not filter:
             filter = lambda x: bool(x)
 
         self.filter = filter
 
     def distance(self, a, b, **kwargs):
         return 1
 
     def edges(self, node, **kwargs):
         row, col = node
         neighbours = []
         if row > 0:
             neighbours.append((row - 1, col))
         if col > 0:
             neighbours.append((row, col - 1))
         if col < self.cols - 1:
             neighbours.append((row, col + 1))
         if row < self.rows - 1:
             neighbours.append((row + 1, col))
 
         return {n: self.distance(node, n, **kwargs) for n in filter(self.node_filter, neighbours)}
 
     def node_filter(self, node):
         return self.filter(self.value(node))
 
 
     def all_nodes(self):
         for row in range(self.rows):
             for col in range(self.cols):
                 yield (row, col)
 
     def value(self, node):
         return self.grid[node[0]][node[1]]
 
     def nodes(self):
         return filter(self.node_filter, self.all_nodes())
 
     def __str__(self):
         result = """"
         for row in self.grid:
             result += "" "".join(map(str, row)) + ""\n""
         return result.strip()
 
     def __repr__(self):
         return str(self)
 
 
 class DirectedGraph(Graph):
     def __init__(self, G=None):
         """"""
         The input graph G is assumed to have the following
         representation: A vertex can be any object that can
         be used as an index into a dictionary.  G is a
         dictionary, indexed by vertices.  For any vertex v,
         G[v] is itself a dictionary, indexed by the neighbors
         of v.  For any edge v->w, G[v][w] is the length of
         the edge.
 
         >>> g = DirectedGraph({1: {2: 1}, 2: {3: 1}})
         >>> sorted(list(g.nodes()))
         [1, 2, 3]
         >>> sorted(g.edges(1).keys())
         [2]
         >>> sorted(g.edges(2).keys())
         [3]
         """"""
         G = G or {}
         self.G = {}
         for a, edges in G.items():
             for b, weight in edges.items():
                 self.add_edge(a, b, weight)
 
     def edges(self, node, **kwargs):
         return self.G.get(node) or {}
 
     def add_edge(self, a, b, weight=1.0):
         if not a in self.G:
             self.G[a] = {}
         if not b in self.G:
             self.G[b] = {}
         self.G[a][b] = weight
 
     def nodes(self):
         return self.G.keys()
 
     def __str__(self):
         return str(self.G)
 
     def __repr__(self):
         return ""<Directed %s>"" % self
 
 
 class UndirectedGraph(DirectedGraph):
     def __init__(self, G=None):
         """"""
         The input graph G is assumed to have the following
         representation: A vertex can be any object that can
         be used as an index into a dictionary.  G is a
         dictionary, indexed by vertices.  For any vertex v,
         G[v] is itself a dictionary, indexed by the neighbors
         of v.  For any edge v->w, G[v][w] is the length of
         the edge.
 
         For any edge v->w, the reverse edge w->v is automatically created.
 
         >>> g = UndirectedGraph({1: {2: 1}, 2: {3: 1}})
         >>> sorted(list(g.nodes()))
         [1, 2, 3]
         >>> sorted(g.edges(1).keys())
         [2]
         >>> sorted(g.edges(2).keys())
         [1, 3]
         """"""
 
         super(UndirectedGraph, self).__init__(G)
 
     def add_edge(self, a, b, weight=1.0):
         super(UndirectedGraph, self).add_edge(a, b, weight)
         super(UndirectedGraph, self).add_edge(b, a, weight)
 
     def total_edges(self):
         return super().total_edges() // 2
 
     def __repr__(self):
         return ""<Undirected %s>"" % self
 
 
 def floodfill(graph, max_distance):
     """"""
     Given a graph, performs a flood fill. The result is undefined on directed graphs.
 
     Group numbers (i) start at 1.
 
     Result: (n, {node => i})
 
     >>> g = GridGraph([[1, 1], [0, 0], [1, 1]])
     >>> n, d = floodfill(g)
     >>> n
     2
     >>> sorted(d.items())
     [((0, 0), 1), ((0, 1), 1), ((2, 0), 2), ((2, 1), 2)]
     """"""
 
     result = {}
     i = 0
     for node in graph.nodes():
         if node in result:
             continue
         i += 1
         queue = [node]
         result[node] = i
         while queue:
             next = queue.pop()
             for neighbour, distance in graph.edges(next).items():
                 if distance > max_distance:
                     continue
                 if not neighbour in result:
                     queue.append(neighbour)
                     result[neighbour] = i
     return i, result
 
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     debug(""case"", case)
     N, S = map(int, fin.readline().split())
     g = UndirectedGraph()
     positions = []
     for i in range(N):
         x, y, z, vx, vy, vz = map(int, fin.readline().split())
         positions.append((x, y, z))
 
     for i in range(N):
         ip = positions[i]
         for j in range(N):
             if i == j:
                 continue
             jp = positions[j]
             dx = ip[0] - jp[0]
             dy = ip[1] - jp[1]
             dz = ip[2] - jp[2]
 
             distance = math.sqrt(dx*dx + dy*dy + dz*dz)
             g.add_edge(i, j, distance)
 
     # debug(g)
     a = 0.0
     b = 2000.0
     while b - a > 0.00001:
         guess = a + (b - a) / 2
         n, d = floodfill(g, guess)
         if d[0] == d[1]:
             # Win
             b = guess
         else:
             # Fail
             a = guess
 
 
     print(""Case #%d: %.6f"" % (case, a))
 
",gcj/2016/3224486/RalfKistner/5740812302286848/0/extracted/c.py,7230,270,846,Python,3224486,0,5740812302286848,RalfKistner,2016
168942,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 
 def invert(char):
     if char == '1':
         return '0'
     elif char == '0':
         return '1'
     else:
         raise Exception(char)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, L = map(int, fin.readline().split())
     G = fin.readline().split()
     B = fin.readline().strip()
 
     if B in G:
         result = 'IMPOSSIBLE'
     elif L == 1:
         if B == '0':
             result = '1 1?'
         else:
             result = '0 0?'
     else:
         a = ''
         b = ''
         for c in B:
             b += invert(c) + '?'
 
             if c == '1':
                 a += '01'
             else:
                 a += '10'
         a = a[:-2]
 
         if len(a) + len(b) > 4*L:
             raise Exception(""Too large"")
         result = a + ' ' + b
 
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2016/3224486/RalfKistner/5632366324219904/1/extracted/d.py,1045,52,134,Python,3224486,1,5632366324219904,RalfKistner,2016
168943,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, L = map(int, fin.readline().split())
     G = fin.readline().split()
     B = fin.readline().strip()
 
     if B in G:
         result = 'IMPOSSIBLE'
     else:
         debug(L, B, G)
 
         a = '0' + ('1' * (L - 1))
         b = '0?' * L
         result = a + ' ' + b
         debug(len(a) + len(b))
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2016/3224486/RalfKistner/5632366324219904/0/extracted/d.py,609,29,82,Python,3224486,0,5632366324219904,RalfKistner,2016
168944,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     moods = fin.readline().strip()
 
     points = 0
     seq = []
     last = None
     for c in moods:
         if not seq or seq[-1] != c:
             seq.append(c)
         else:
             seq.pop()
             points += 10
     points += len(seq) // 2 * 5
     print(""Case #%d: %s"" % (case, points))
 
",gcj/2016/3224486/RalfKistner/5634618900348928/1/extracted/a.py,562,28,71,Python,3224486,1,5634618900348928,RalfKistner,2016
171893,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 from itertools import combinations
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, K = list(map(int, fin.readline().split()))
     P = list(map(float, fin.readline().split()))
     P.sort()
     M = K // 2 + 1
 
     best = (0, [])
 
     for c in range(K+1):
         combination = P[:c]
         if c < K:
             combination += P[-(K-c):]
 
         s = [0] * M
         s[0] = 1
         for a1 in combination:
             a0 = 1 - a1
             ss = [0] * M
             ss[0] = s[0] * a0
             for k in range(M):
                 ss[k] = s[k-1] * a1 + s[k] * a0
             s = ss
         best = max(best, (s[-1], combination))
     # debug(case, P, best)
 
     print(""Case #%d: %s"" % (case, best[0]))
 
",gcj/2016/10224486/RalfKistner/5677604812095488/1/extracted/b.py,938,41,126,Python,10224486,1,5677604812095488,RalfKistner,2016
171894,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 from itertools import combinations
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, K = list(map(int, fin.readline().split()))
     P = list(map(float, fin.readline().split()))
     debug(P)
 
     M = K // 2 + 1
 
     best = 0
 
     for combination in list(combinations(P, K)):
         s = [0] * M
         s[0] = 1
         for a1 in combination:
             a0 = 1 - a1
             ss = [0] * M
             ss[0] = s[0] * a0
             for k in range(M):
                 ss[k] = s[k-1] * a1 + s[k] * a0
             s = ss
         best = max(best, s[-1])
         # debug(case, s)
 
     print(""Case #%d: %s"" % (case, best))
 
",gcj/2016/10224486/RalfKistner/5677604812095488/0/extracted/b.py,849,38,114,Python,10224486,0,5677604812095488,RalfKistner,2016
171895,d.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 from collections import defaultdict
 from itertools import combinations, permutations
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     worker_machine = {}
     machine_worker = defaultdict(set)
     for i in range(N):
         bitmap = list(fin.readline().strip())
         known = set()
         for j, b in enumerate(bitmap):
             if b == '1':
                 known.add(j)
                 machine_worker[j].add(i)
         worker_machine[i] = known
     debug(case, machine_worker)
 
     worker_groups = {}
     machine_groups = {}
     group = 0
     groups = []
     base_cost = 0
     for i in range(N):
         if i in worker_groups:
             continue
         queue = [i]
         group += 1
         group_workers = []
         group_machines = []
         while queue:
             next = queue.pop()
             if next in worker_groups:
                 continue
             worker_groups[next] = group
             group_workers.append(next)
             machines = worker_machine[next]
             for machine in machines:
                 if machine in machine_groups:
                     continue
                 machine_groups[machine] = group
                 group_machines.append(machine)
                 for worker in machine_worker[machine]:
                     queue.append(worker)
 
         for worker in group_workers:
             base_cost += len(group_machines) - len(worker_machine[worker])
         groups.append((len(group_workers), len(group_machines)))
     for i in range(N):
         if i not in machine_groups:
             groups.append((0, 1))
 
     debug(case, groups)
 
     best = (100000000000, ())
     for perm in permutations(groups):
         cost = 0
         tw, tm = 0, 0
         for nw, nm in perm:
             if nw == nm:
                 continue
             cost += nw * tm + nm * tw
             tw += nw
             tm += nm
             if tw == tm:
                 tw, tm = 0, 0
         best = min(best, (cost, perm))
     debug(case, base_cost, best)
 
     print(""Case #%d: %s"" % (case, base_cost + best[0]))
 
",gcj/2016/10224486/RalfKistner/5718447400943616/0/extracted/d.py,2336,82,234,Python,10224486,0,5718447400943616,RalfKistner,2016
171896,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, R, P, S = list(map(int, fin.readline().split()))
 
     r, p, s = R, P, S
 
     possible = True
     for i in range(N):
         a = (r + s - p) // 2
         b = (p + r - s) // 2
         c = (s + p - r) // 2
         if min(a, b, c) < 0:
             possible = False #'IMPOSSIBLE'
             break
         r = a
         p = b
         s = c
     if possible and r + p + s != 1:
         raise Exception(""Something went wrong: %d %d %d"" % (r, p, s))
 
     if not possible:
         print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
     else:
         m = {'P': 'P', 'R': 'R', 'S': 'S'}
         for i in range(N):
             next = {}
             next['P'] = min(m['P'] + m['R'], m['R'] + m['P'])
             next['S'] = min(m['P'] + m['S'], m['S'] + m['P'])
             next['R'] = min(m['R'] + m['S'], m['S'] + m['R'])
             m = next
             debug(case, next)
 
 
         if r > 0:
             result = m['R']
         elif s > 0:
             result = m['S']
         elif p > 0:
             result = m['P']
         #result = (b * 'PR') + (c * 'PS') + (a * 'RS')
         print(""Case #%d: %s"" % (case, result))
 
 
 
",gcj/2016/10224486/RalfKistner/5718606851604480/1/extracted/a.py,1402,56,212,Python,10224486,1,5718606851604480,RalfKistner,2016
207986,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     B, N = map(int, fin.readline().split())
 
     result = []
     for i in range(B-1):
         row = '0' * (B-i) + '1' * i
         result.append(row)
 
     # 0: 1
     # 1: 1
     # 2: 2
     # 3: 4
     # 2 ** (i-1)
     remaining = N
     lastrow = '0'
     for i in range(1, B):
         val = 1
         if (B-i-1) > 1:
             val = 2 ** (B-i-2)
         debug(i, val)
         if remaining >= val:
             remaining -= val
             lastrow += '1'
         else:
             lastrow += '0'
     result.append(lastrow)
     result.reverse()
 
     if remaining == 0:
         print(""Case #%d: %s"" % (case, ""POSSIBLE""))
         for row in result:
             print(row)
     else:
         print(""Case #%d: %s"" % (case, ""IMPOSSIBLE""))
 
",gcj/2016/4314486/RalfKistner/5744014401732608/1/extracted/b.py,1012,48,130,Python,4314486,1,5744014401732608,RalfKistner,2016
207988,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N = int(fin.readline())
     inparty = list(map(int, fin.readline().split()))
     mylist = []
     for i, num in enumerate(inparty):
         c = chr(65 + i)
         mylist.append((num, c))
 
     result = []
     total = sum(inparty)
     debug(total, inparty)
     while total > 0:
         mylist.sort(reverse=True)
         if mylist[0][0]*2 > total:
             debug(""INVALID!!!"", mylist)
         debug(mylist)
         if mylist[0][0] == mylist[1][0] and (len(mylist) < 3 or mylist[2][0] < mylist[1][0]):
             result.append(mylist[0][1] + mylist[1][1])
             mylist[0] = (mylist[0][0] - 1, mylist[0][1])
             mylist[1] = (mylist[1][0] - 1, mylist[1][1])
             total -= 2
         else:
             result.append(mylist[0][1])
             mylist[0] = (mylist[0][0] - 1, mylist[0][1])
             total -= 1
     debug(mylist)
 
     print(""Case #%d: %s"" % (case, ' '.join(result)))
 
",gcj/2016/4314486/RalfKistner/5753053697277952/1/extracted/a.py,1181,42,120,Python,4314486,1,5753053697277952,RalfKistner,2016
207990,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 from collections import defaultdict
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     J, P, S, K = map(int, fin.readline().split())
 
 
     pairs_jp = defaultdict(int)
     pairs_js = defaultdict(int)
     pairs_ps = defaultdict(int)
     result = []
     s = 0
     MAX = J * P * min(S, K) # Theoretical maximum. We hope to achieve this.
     for j in range(1, J+1):
         s = j
 
         for p in range(1, P+1):
 
             for i in range(S):
 
                 if pairs_jp[(j, p)] >= K:
                     break
                 s = (s % S) + 1
 
                 if pairs_js[(j, s)] >= K:
                     continue
                 if pairs_ps[(p, s)] >= K:
                     continue
                 pairs_jp[(j, p)] += 1
                 pairs_js[(j, s)] += 1
                 pairs_ps[(p, s)] += 1
 
                 result.append(""%d %d %d"" % (j, p, s))
 
 
 
     debug(MAX == len(result), MAX, len(result))
     print(""Case #%d: %s"" % (case, len(result)))
     # for row in result:
     #     print(row)
 
 
",gcj/2016/4314486/RalfKistner/5708921029263360/1/extracted/c.py,1239,52,150,Python,4314486,1,5708921029263360,RalfKistner,2016
207991,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 from collections import defaultdict
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     J, P, S, K = map(int, fin.readline().split())
 
 
     pairs_jp = defaultdict(int)
     pairs_js = defaultdict(int)
     pairs_ps = defaultdict(int)
     result = []
     s = 0
     for j in range(1, J+1):
         s = j
 
         for p in range(1, P+1):
 
             for i in range(S):
 
                 if pairs_jp[(j, p)] >= K:
                     break
                 s = (s % S) + 1
                 debug(j, p, s)
                 if pairs_js[(j, s)] >= K:
                     continue
                 if pairs_ps[(p, s)] >= K:
                     continue
                 pairs_jp[(j, p)] += 1
                 pairs_js[(j, s)] += 1
                 pairs_ps[(p, s)] += 1
 
                 result.append(""%d %d %d"" % (j, p, s))
 
 
 
 
     print(""Case #%d: %s"" % (case, len(result)))
     for row in result:
         print(row)
 
 
",gcj/2016/4314486/RalfKistner/5708921029263360/0/extracted/c.py,1141,51,130,Python,4314486,0,5708921029263360,RalfKistner,2016
2495,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     Hd, Ad, Hk, Ak, B, D = map(int, fin.readline().split())
 
     # 1. debuff knight
     # 2. buff attack
     # 3. attack
     # 4. heal when required
 
     def tryit(buffs, debuffs):
 
         hd = Hd
         hk = Hk
         ad = Ad
         ak = Ak
 
         # actions = []
         count = 0
         for i in range(debuffs):
             if hd <= ak - D:
                 # actions.append('heal')
                 count += 1
                 hd = Hd
                 hd -= ak
 
             # actions.append('debuff')
             count += 1
             ak -= D
             ak = max(0, ak)
             hd -= ak
             if hd <= 0:
                 return None
 
         for i in range(buffs):
             if hd <= ak:
                 # actions.append('heal')
                 count += 1
                 hd = Hd
                 hd -= ak
 
             # actions.append('debuff')
             count += 1
             ad += B
             hd -= ak
             if hd <= 0:
                 return None
 
         while hk > 0:
             if count > 101:
                 return None
             if hd <= ak and hk > ad:
                 # actions.append('heal')
                 count += 1
                 hd = Hd
                 hd -= ak
 
             # actions.append('attack')
             count += 1
             hk -= ad
             hd -= ak
             if hd <= 0 and hk > 0:
                 return None
         return count
 
 
     START = (100000000, 0)
     best = START
     for buffs in range(0, 101):
         drange = 1
         if D > 0:
             drange = Ak // D + 2
         for debuffs in range(0, drange):
             actions = tryit(buffs, debuffs)
             if actions:
                 # nr = len(actions)
                 nr = actions
                 best = min(best, (nr, actions))
 
     # debug(best[1])
     if best == START:
         print(""Case #%d: %s"" % (case, ""IMPOSSIBLE""))
     else:
         print(""Case #%d: %s"" % (case, best[0]))
 
",gcj/2017/5304486/RalfKistner/5719039502450688/0/extracted/c.py,2260,96,274,Python,5304486,0,5719039502450688,RalfKistner,2017
2496,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from collections import deque
 import heapq
 import math
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def minmax(serving_size, packet_size):
 
     # serving_size * k * 0.9 <= packet_size <= serving_size * k * 1.1
     # k * 9 <= packet_size * 10 / serving_size <= k * 11
     # k * 9 <= 15 <= k * 11
     # packet_size * 10 / serving_size / 11 <= k <= packet_size * 10 / serving_size / 9
     # k >= packet_size * 10 / serving_size / 9
 
     # k_min = math.ceil(packet_size * 10 / serving_size / 11)
     k_min = (packet_size * 10 - 1) // serving_size // 11 + 1
     k_max = packet_size * 10 // serving_size // 9
     return k_min, k_max
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, P = map(int, fin.readline().split())
     recipe = list(map(int, fin.readline().split()))
     packet_sizes = []
     for i in range(N):
         sizes = sorted(list(map(int, fin.readline().split())))
         packet_sizes.append(deque(sizes))
 
     count = 0
 
     for i in range(P):
         stack = [] # smallest_max
         largest_min = 0
 
         for j in range(N):
 
             if not packet_sizes[j]:
                 break
             packet_size = packet_sizes[j].popleft()
 
             k_min, k_max = minmax(recipe[j], packet_size)
 
             largest_min = max(largest_min, k_min)
 
             heapq.heappush(stack, (k_max, k_min, j))
 
         if len(stack) != N:
             break
 
         while stack[0][0] < largest_min:
             item = heapq.heappop(stack)
             j = item[2]
 
             if not packet_sizes[j]:
                 break
             packet_size = packet_sizes[j].popleft()
 
             k_min, k_max = minmax(recipe[j], packet_size)
 
             largest_min = max(largest_min, k_min)
 
             heapq.heappush(stack, (k_max, k_min, j))
 
         if len(stack) != N:
             break
 
         count += 1
 
     print(""Case #%d: %s"" % (case, count))
 
",gcj/2017/5304486/RalfKistner/5697460110360576/1/extracted/b.py,2082,79,250,Python,5304486,1,5697460110360576,RalfKistner,2017
2498,a.py,"
 """"""
 AABC
 ??BC
 
 AB?
 ???
 
 AAB
 ?C?
 
 AC?
 ?C?
 
 A??
 ???
 ??B
 
 AC?
 ?C?
 ??B
 
 A??
 ???
 C?B
 
 A
 ?
 """"""
 
 #!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 def intersects(r1, r2):
     if (r1[1] > r2[3]) or (r1[3] < r2[1]):
         return False
     if (r1[0] > r2[2]) or (r1[2] < r2[0]):
         return False
     return True
 
 global grid, r, c, placements, R, C
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     R, C = map(int, fin.readline().split())
     grid = []
     chars = set()
     placements = []
     for i in range(R):
         grid.append(fin.readline().strip())
         placements.append(list(grid[-1]))
         for c in grid[-1]:
             if c != '?':
                 chars.add(c)
 
     chars = sorted(list(chars))
     debug(chars)
     N = len(chars)
 
     corners = {}
     for r in range(R):
         for c in range(C):
             if grid[r][c] == '?':
                 continue
 
             char = grid[r][c]
             if char in corners:
                 existing = corners[char]
                 corners[char] = (min(existing[0], r), min(existing[1], c), max(existing[2], r), max(existing[3], c))
             else:
                 corners[char] = (r, c, r, c)
 
 
     def can_place(r, c, char):
         existing = corners[char]
         ccorners = (min(existing[0], r), min(existing[1], c), max(existing[2], r), max(existing[3], c))
         for oc, ocorners in corners.items():
             if oc == char:
                 continue
             if intersects(ccorners, ocorners):
                 return False
 
         return True
 
 
     def place(r, c, char):
         existing = corners[char]
         ccorners = (min(existing[0], r), min(existing[1], c), max(existing[2], r), max(existing[3], c))
         corners[char] = ccorners
 
     def get_char(r, c):
         for oc, ocorners in corners.items():
             if intersects(ocorners, (r, c, r, c)):
                 return oc
         return '!'
 
 
 
     for r in range(R):
         for c in range(C):
             if grid[r][c] != '?':
                 continue
             placed = False
             for char in chars:
                 if can_place(r, c, char):
                     place(r, c, char)
                     placed = True
                     break
             if not placed:
                 raise ""Could not place!""
 
     result = ''
     for r in range(R):
         for c in range(C):
             result += get_char(r, c)
         if r != R - 1:
             result += '\n'
 
     # debug(result)
 
 
     print(""Case #%d:\n%s"" % (case, result))
 
",gcj/2017/5304486/RalfKistner/5760761888505856/1/extracted/a.py,2757,131,302,Python,5304486,1,5760761888505856,RalfKistner,2017
17565,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, P = map(int, fin.readline().split())
     groups = map(int, fin.readline().split())
     r = [0] * P
     for g in groups:
         r[g % P] += 1
     # debug(r)
 
     result = 0
     if P == 2:
         result = r[0] + (r[1] + 1) // 2
     elif P == 3:
         result = r[0]
         k = min(r[1], r[2])
         result += k
         r[1] -= k
         r[2] -= k
         result += r[1] // 3
         r[1] %= 3
         result += r[2] // 3
         r[2] %= 3
         if r[1] > 0 or r[2] > 0:
             result += 1
     elif P == 4:
         result = r[0]
         k = min(r[1], r[3])
         result += k
         r[1] -= k
         r[3] -= k
         twos = r[2] + r[1]//2 + r[3]//2
         r[1] %= 2
         r[3] %= 2
         result += twos // 2
         twos %= 2
         remaining = twos + r[1] + r[3]
         if remaining > 0:
             result += 1
 
     print(""Case #%d: %s"" % (case, result))
 
",gcj/2017/5314486/RalfKistner/5700919488413696/1/extracted/a.py,1174,53,178,Python,5314486,1,5700919488413696,RalfKistner,2017
17567,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from collections import defaultdict
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, C, M = map(int, fin.readline().split())
     # C: customers
     # N: seats
     # M: tickets
     number_on_seat = [0]*N
     total = [0]*C
     for i in range(M):
         p, b = map(int, fin.readline().split())
         p -= 1
         b -= 1
         number_on_seat[p] += 1
         total[b] += 1
 
     rides = max(total)
     promotions = 0
     while True:
 
         promotions = 0
         promotions_at_last = 0
         for seat in range(N-1, -1, -1):
             on_seat = number_on_seat[seat] + promotions_at_last
             to_promote = max(0, on_seat - rides)
             promotions += max(0, to_promote - promotions_at_last)
             promotions_at_last = to_promote
 
         if promotions_at_last == 0:
             break
 
         rides += 1
 
 
     print(""Case #%d: %d %d"" % (case, rides, promotions))
 
",gcj/2017/5314486/RalfKistner/5687148430753792/1/extracted/b.py,1128,48,131,Python,5314486,1,5687148430753792,RalfKistner,2017
17568,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 import sys
 
 from collections import defaultdict
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     N, C, M = map(int, fin.readline().split())
     # C: customers
     # N: seats
     # M: tickets
     tickets = list(map(lambda x: defaultdict(int), [0]*C))
     total = [0]*C
     for i in range(M):
         p, b = map(int, fin.readline().split())
         p -= 1
         b -= 1
         tickets[b][p] += 1
         total[b] += 1
 
     debug(""Case #%d"" % (case))
     debug(N, C, M)
     if C != 2:
         print(""Case #%d: %s"" % (case, ""unknown""))
         continue
 
     rides = max(total[0], total[1], tickets[0][0] + tickets[1][0])
     promotions = 0
     for seat in range(N):
         for_seat = tickets[0][seat] + tickets[1][seat]
         promotions += max(0, for_seat - rides)
 
 
     print(""Case #%d: %d %d"" % (case, rides, promotions))
 
",gcj/2017/5314486/RalfKistner/5687148430753792/0/extracted/b.py,1047,43,129,Python,5314486,0,5687148430753792,RalfKistner,2017
45697,b.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 from __future__ import print_function
 import sys
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     s = fin.readline().strip()
     si = list(map(int, s))
     n = len(s)
     result = s
     for i, k in enumerate(si):
         ns = str(k) * (n - i)
         if ns > s[i:]:
             result = s[:i] + str(k - 1) + '9' * (n - i - 1)
             break
 
     if result[0] == '0':
         result = result[1:]
     
     print(""Case #%d: %s"" % (case, result))
     ",gcj/2017/3264486/RalfKistner/5633382285312000/1/extracted/b.py,657,28,91,Python,3264486,1,5633382285312000,RalfKistner,2017
45699,a.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 from __future__ import print_function
 import sys
 # from Set import Set
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     s, ks = fin.readline().split()
     k = int(ks)
     debug(k, s)
 
     flipped = False
     flips = 0
     impossible = False
     queue = set()
     for i, c in enumerate(s):
         if i in queue:
             queue.remove(i)
             flipped = not flipped
         if (c == '-') ^ flipped:
             if i + k > len(s):
                 impossible = True
             flipped = not flipped
             queue.add(i + k)
             flips += 1
 
 
 
     if impossible:
         print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
     else:
         print(""Case #%d: %s"" % (case, flips))
 
",gcj/2017/3264486/RalfKistner/5736519012712448/1/extracted/a.py,909,41,113,Python,3264486,1,5736519012712448,RalfKistner,2017
45701,c.py,"#!/usr/bin/env python3
 # -*- coding: utf-8 -*-
 # Uses https://github.com/rkistner/contest-algorithms
 
 from __future__ import print_function
 from heapq import heappush, heappop
 import sys
 
 def debug(*args):
     print(*args, file=sys.stderr)
 
 fin = sys.stdin
 T = int(fin.readline())
 for case in range(1, T + 1):
     n, k = map(int, fin.readline().split())
     debug(n, k)
 
     q = []
     heappush(q, -n)
     lasta = 0
     lastb = 0
     for i in range(k):
         largest = -heappop(q)
         a = (largest - 1) // 2
         b = largest - 1 - a
         heappush(q, -a)
         heappush(q, -b)
         lasta = a
         lastb = b
 
     print(""Case #%d: %d %d"" % (case, lastb, lasta))
     ",gcj/2017/3264486/RalfKistner/5654742835396608/1/extracted/c.py,714,32,95,Python,3264486,1,5654742835396608,RalfKistner,2017
9095,000000000004a545.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from bisect import bisect_right


def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    N = int(fin.readline())
    V = N * 2
    grid = [[0]*N for i in range(N)]

    columns = [[0]* N for i in range(V)]
    rows = [[0] * N for i in range(V)]
    for i in range(N):
        c = list(map(int, fin.readline().split()))

        for j, v in enumerate(c):
            if v > 0:
                v -= 1
            else:
                v = -1 - v + N
            grid[i][j] = v

            rows[v][i] += 1
            columns[v][j] += 1

    changed = 0
    for v in range(V):
        for r in range(N):
            elems = []
            for c in range(N):
                if grid[r][c] == v:
                    count = 0
                    for r2 in range(N):
                        if grid[r2][c] == v:
                            count += 1
                    elems.append((count, c))
            elems.sort(reverse=True)
            for count, c in elems[:-1]:
                changed += 1
                grid[r][c] = None


    for v in range(V):
        for c in range(N):
            elems = []
            for r in range(N):
                if grid[r][c] == v:
                    count = 0
                    for c2 in range(N):
                        if grid[r][c2] == v:
                            count += 1
                    elems.append((count, r))
            elems.sort(reverse=True)
            for count, r in elems[:-1]:
                changed += 1
                grid[r][c] = None

    #
    #
    # changes = 0
    # for v in range(V):
    #     rt = 0
    #     ct = 0
    #     for r in rows[v]:
    #         rt += max(0, r - 1)
    #     for c in columns[v]:
    #         ct += max(0, c - 1)
    #     changes += max(rt, ct)


    print(""Case #%d: %s"" % (case, changed))

",,1939,80,250,Python,7706,000000000004a545,0000000000045875,RalfKistner,2018
9096,00000000000495fa.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from bisect import bisect_right


def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    N = int(fin.readline())
    V = N * 2
    columns = [[0]* N for i in range(V)]
    rows = [[0] * N for i in range(V)]
    for i in range(N):
        c = list(map(int, fin.readline().split()))

        for j, v in enumerate(c):
            if v > 0:
                v -= 1
            else:
                v = -1 - v + N
            rows[v][i] += 1
            columns[v][j] += 1

    changes = 0
    for v in range(V):
        rt = 0
        ct = 0
        for r in rows[v]:
            rt += max(0, r - 1)
        for c in columns[v]:
            ct += max(0, c - 1)
        changes += max(rt, ct)


    print(""Case #%d: %s"" % (case, changes))

",,866,42,132,Python,7706,00000000000495fa,0000000000045875,RalfKistner,2018
9097,00000000000480d4.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import functools


def debug(*args):
    print(*args, file=sys.stderr)


def bisect_left(func, val, low, high):
    """"""
    Like bisect.bisect_left, but works on functions.

    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in a[i:] have e >= x.  So if x already appears
    in the list, a.insert(x) will insert just before the leftmost x already there.  Optional args lo (default 0) and hi
    (default len(a)) bound the slice of a to be searched.

    >>> bisect_left([1,2,3,3,4].__getitem__, 3, 0, 4)
    2
    >>> bisect_left([1,2,3,3,4].__getitem__, 4, 0, 4)
    4
    >>> bisect_left([1,2,3,6,8].__getitem__, 4, 0, 4)
    3
    """"""

    a = low
    b = high
    while b > a:
        guess = (a+b)//2

        if val > func(guess):
            a = guess+1
        else:
            b = guess

    return a


# m(r, b): maximum combinations with r, b
# p(r, b, t): true if t <= m(r, b)
# p2(r, b, ro, bo, t) = p(r - t*ro, b - t*bo, t)
# p(r, 0, t): true if t(t+1)/2 <= r
# p(r, b+1, t): p2(r


def p2(r, b, ro, bo, t):
    return p3(r - t*ro, b - t*bo, t)

cache = {}

def m(r, b):
    if b > r:
        return m(b, r)
    if (r, b) in cache:
        return cache[(r, b)]
    def f(t):
        if p(r, b, t):
            return 0
        else:
            return 1

    result = bisect_left(f, 1, 0, 500) - 1
    cache[(r, b)] = result
    return result

def p3(r, b, t):
    if r < 0 or b < 0:
        return False
    if t <= 0:
        return True
    return m(r, b) >= t

def p(r, b, t):
    if r < 0 or b < 0:
        return False
    if t <= 0:
        return True
    if (r, b) in cache:
        return p3(r, b)
    for rowt in range(1, 500):
        usedred = rowt*(rowt-1) // 2
        if r - usedred < 0:
            break

        if p2(r - usedred, b, 0, 1, t-rowt):
            return True
    return False

#
# for r in range(5):
#     for b in range(5):
#         debug(r, b, '=', m(r, b))

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    R, B = list(map(int, fin.readline().split()))

    result = m(R, B) - 1
    debug(R, B, result)

    print(""Case #%d: %s"" % (case, result))


",,2285,109,384,Python,7706,00000000000480d4,00000000000459f3,RalfKistner,2018
9098,0000000000046262.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    C = int(fin.readline())

    expected = list(map(int, fin.readline().split()))
    result = None
    debug(expected)

    if expected[0] == 0 or expected[-1] == 0:
        result = 'IMPOSSIBLE'
    else:
        current = [1]*C
        rows = []

        while current != expected:
            row = ['.']*C
            next = [0]*C
            debug(current, expected)
            expected_total = 0
            current_total = 0
            for i in range(C):
                expected_right = C - expected_total - expected[i]
                current_right = C - current_total - current[i]
                if expected_total > current_total:
                    row[i] = '/'
                    next[i-1] += current[i]
                elif expected_right > current_right:
                    row[i] = '\\'
                    next[i+1] += current[i]
                else:
                    row[i] = '.'
                    next[i] += current[i]
                expected_total += expected[i]
                current_total += current[i]
            rows.append(row)
            current = next

            if len(rows) > 200 + C:
                debug('?', rows, current, expected)
                result = 'IMPOSSIBLE'
                break


        rows.append(['.']*C)

        result = ""%d\n%s"" % (len(rows), ""\n"".join([''.join(row) for row in rows]))

        # debug(rows)


    print(""Case #%d: %s"" % (case, result))
",,1613,63,161,Python,7706,0000000000046262,00000000000459f2,RalfKistner,2018
9099,0000000000045dcb.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    C = int(fin.readline())

    expected = list(map(int, fin.readline().split()))
    result = 'test'
    debug(expected)

    if expected[0] == 0 or expected[-1] == 0:
        result = 'IMPOSSIBLE'
    else:
        current = [1]*C
        rows = []

        while current != expected:
            row = ['.']*C
            next = [0]*C
            debug(current, expected)
            expected_total = 0
            current_total = 0
            for i in range(C):
                if expected_total > current_total:
                    row[i] = '/'
                    next[i-1] += current[i]
                elif expected_total < current_total:
                    row[i] = '\\'
                    next[i+1] += current[i]
                else:
                    row[i] = '.'
                    next[i] += current[i]
                expected_total += expected[i]
                current_total += current[i]
            rows.append(row)
            current = next

            if len(rows) > 200 + C:
                debug('?', rows, current)
                raise Exception('Failure at %d' % case)

        rows.append(['.']*C)

        result = ""%d\n%s"" % (len(rows), ""\n"".join([''.join(row) for row in rows]))

        # debug(rows)


    print(""Case #%d: %s"" % (case, result))
",,1471,59,148,Python,7706,0000000000045dcb,00000000000459f2,RalfKistner,2018
9100,0000000000045d92.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    C = int(fin.readline())

    expected = list(map(int, fin.readline().split()))
    result = 'test'
    debug(expected)

    if expected[0] == 0 or expected[-1] == 0:
        result = 'IMPOSSIBLE'
    else:
        current = [1]*C
        rows = []

        while current != expected:
            row = ['.']*C
            next = [0]*C
            # debug(current, expected)
            for i in range(C):
                if sum(expected[:i]) > sum(current[:i]):
                    row[i] = '/'
                    next[i-1] += current[i]
                elif sum(expected[:i]) < sum(current[:i]):
                    row[i] = '/'
                    next[i+1] += current[i]
                else:
                    row[i] = '.'
                    next[i] += current[i]
            rows.append(row)
            current = next

            if len(rows) > 20:
                debug('?', rows, current)
                raise Exception('Failure at %d' % case)

        rows.append(['.']*C)

        result = ""%d\n%s"" % (len(rows), ""\n"".join([''.join(row) for row in rows]))

        # debug(rows)


    print(""Case #%d: %s"" % (case, result))
",,1328,55,135,Python,7706,0000000000045d92,00000000000459f2,RalfKistner,2018
22370,000000000003f05b.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys


def debug(*args):
    print(*args, file=sys.stderr)

MAX = sys.maxsize
fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    N = int(fin.readline())
    weights = list(map(int, fin.readline().split()))
    debug(weights)

    # w[i][h]: for ant i, height h (including i), w[i][h] is the minimum weight, potentially including ant i
    # w[i][h] = min(w[i-1][h-1] + weight[i], w[i-1][h])
    wi = [0]

    for w in weights:
        win = [0]
        for h in range(1, len(wi) + 1):
            la = MAX
            lb = MAX
            if wi[h-1] <= 6 * w:
                la = wi[h-1] + w
            if h < len(wi):
                lb = wi[h]
            lr = min(la, lb)
            if lr < MAX:
                win.append(lr)
        wi = win

    print(""Case #%d: %s"" % (case, len(wi) - 1))

",,876,38,123,Python,7765,000000000003f05b,000000000003e0a8,RalfKistner,2018
22371,000000000003e839.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from collections import defaultdict

debugout = open('debug.log', 'w')
def debug(*args):
    print(*args, file=sys.stderr)
    print(*args, file=debugout)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    N = int(fin.readline())
    debug(""Case %d: %d"" % (case, N))
    seen = defaultdict(int)
    used = set()
    for i in range(N):
        [d, *choices] = map(int, fin.readline().split())
        # debug(choices)
        choices = set(choices)
        chosen = None
        for c in choices:
            if c in used:
                continue
            seen[c] += 1
        for c in sorted(seen, key=seen.get):
            if c not in choices:
                continue
            if c in used:
                # Should not happen?
                continue
            chosen = c
            used.add(chosen)
            del seen[c]
            break
        if chosen is None:
            chosen = -1
        print(chosen)
        sys.stdout.flush()
",,1039,42,116,Python,7765,000000000003e839,000000000003e068,RalfKistner,2018
22372,000000000003e1f6.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys


def debug(*args):
    print(*args, file=sys.stderr)

def combinations(letters):
    if len(letters) == 0:
        yield ''
        return
    for l in letters[0]:
        for c in combinations(letters[1:]):
            yield l + c

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    N, L = map(int, fin.readline().split())

    words = set()
    letters = [set() for i in range(L)]
    for i in range(N):
        word = fin.readline().strip()
        words.add(word)
        for j, c in enumerate(word):
            letters[j].add(c)

    result = '-'
    for l in combinations(letters):
        if l in words:
            continue
        else:
            result = l
            break


    print(""Case #%d: %s"" % (case, result))
",,815,41,99,Python,7765,000000000003e1f6,000000000003e064,RalfKistner,2018
108943,0000000000028b37.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from __future__ import print_function
import sys

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    a = float(fin.readline())

    d = a
    r = 2**0.5
    h = (2 - d**2)**0.5
    debug(a, d, r, h)

    p1x = - d / 2
    p1y = h / 2

    p2x = p1y
    p2y = -p1x

    p3x = -p1x
    p3y = -p1y

    c1 = ((p1x + p2x) / 2, (p1y + p2y) / 2)
    c2 = ((p3x + p2x) / 2, (p3y + p2y) / 2)
    debug(c1)
    debug(c2)


    print(""Case #%d:"" % (case))
    print(c2[0], c2[1], 0.0)
    print(c1[0], c1[1], 0.0)
    print(0.0, 0.0, 0.5)

",,653,40,110,Python,00000000000000cb,0000000000028b37,00000000000079cc,RalfKistner,2018
108944,00000000000281ab.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

from __future__ import print_function
import sys

debugout = open('debug.log', 'w')
def debug(*args):
    print(*args, file=sys.stderr)
    print(*args, file=debugout)

fin = sys.stdin

t = int(fin.readline())

def totalsum(grid, sr, sc):
    s = 0
    for r in range(sr*3+1, sr*3+4):
        for c in range(sc*3+1, sc*3+4):
            s += grid[r][c]
    return s

for i in range(t):
    debug(""case"", i)
    a = int(fin.readline())

    r = 0
    while r*r < a:
        r += 3

    c = r
    while (c - 3) * r >= a:
        c -= 3
    debug(""rc"", r, c, a)

    grid = list(map(lambda x: [0]*(c+3), range(r+3)))

    solved = False
    used = 0

    for sr in range(r // 3):
        for sc in range(c // 3):
            while totalsum(grid, sr, sc) < 9:
                # debug(""P"", sc * 3 + 2, sr * 3 + 2, '|', totalsum(grid, sr, sc))
                print(sc*3 + 2, sr * 3 + 2)
                sys.stdout.flush()
                used += 1
                x, y = map(int, fin.readline().split())
                if x == -1 and y == -1:
                    debug('Broken :(')
                    sys.exit(1)

                if x == 0 and y == 0:
                    solved = True
                    break
                grid[y][x] = 1
    debug(""used"", used, a)


",,1371,61,183,Python,00000000000000cb,00000000000281ab,0000000000007a30,RalfKistner,2018
108945,0000000000026f88.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

from __future__ import print_function
import sys

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())
    v = list(map(int, fin.readline().split()))

    debug(n, v)

    evens = sorted(v[0::2])
    odds = sorted(v[1::2])

    result = []

    for i in range(n):
        if i % 2 == 0:
            result.append(evens[i // 2])
        else:
            result.append(odds[(i-1) // 2])


    broken_at = None
    for i in range(n-1):
        if result[i] > result[i+1]:
            broken_at = i
            break


    if broken_at is None:
        print(""Case #%d: %s"" % (case, 'OK'))
    else:
        print(""Case #%d: %s"" % (case, broken_at))

",,847,43,100,Python,00000000000000cb,0000000000026f88,00000000000079cb,RalfKistner,2018
108946,0000000000026bce.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

from __future__ import print_function
import sys

def debug(*args):
    print(*args, file=sys.stderr)

def score(p):
    result = 0
    strength = 1
    for c in p:
        if c == 'C':
            strength *= 2
        else:
            result += strength
    return result

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    ds, p = fin.readline().split()
    d = int(ds)

    debug(d, p)

    hacks = 0

    while score(p) > d:
        current = hacks
        for i, c in enumerate(p[:-1]):
            if c == 'C' and p[i+1] == 'S':
                p2 = p[:i] + 'SC' + p[i+2:]
                p = p2
                hacks += 1
                break

        if hacks == current:
            hacks = None
            break

    if hacks is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %s"" % (case, hacks))

",,983,49,129,Python,00000000000000cb,0000000000026bce,0000000000007966,RalfKistner,2018
108947,00000000000267c2.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

from __future__ import print_function
import sys

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    ds, p = fin.readline().split()
    d = int(ds)

    debug(d, p)

    hacks = 0
    if hacks is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %s"" % (case, hacks))

",,489,25,62,Python,00000000000000cb,00000000000267c2,0000000000007966,RalfKistner,2018
1152,0000000000159c91.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


# dout = open('b.log', 'w')
def debug(*args):
    # print(*args, file=dout)
    pass

# def debug(*args):
#     print(*args, file=sys.stderr)



fin = sys.stdin
T, W = map(int, fin.readline().split())

# L = 10**10
L = 10**10

for case in range(1, T + 1):
    splits = set([(1, L * 100 + 1)])
    is_wrong = False
    while True:
        p = int(fin.readline())  # split start
        if p == -1:
            is_wrong = True
        if p < 0:
            break
        q = p + L  # next split start
        for split in splits:

            if p >= split[0] and q <= split[1]:
                splits.remove(split)
                if p > split[0] and p - split[0] >= L:
                    splits.add((split[0], p))
                if q < split[1] and split[1] - q >= L:
                    splits.add((q, split[1]))
                break
        evens = 0
        odds = 0
        choices = 0

        debug(splits)

        for split in splits:
            l = split[1] - split[0]
            remainder = l % (2*L)
            if remainder < L:
                evens += 1
            elif remainder >= L:
                odds += 1

        # print(splits)
        split = list(splits)[0]
        l = split[1] - split[0]
        remainder = l % (2 * L)

        move = None
        if odds % 2 == 1:
            # perfect
            move = split[0]
        else:
            # need to adjust
            move = min(split[0] + L - 1, split[1] - L)

        splits.remove(split)
        p = move
        q = move + L
        if p >= split[0] and q <= split[1]:
            if p > split[0] and p - split[0] >= L:
                splits.add((split[0], p))
            if q < split[1] and split[1] - q >= L:
                splits.add((q, split[1]))
        else:
            # print(p, q, split, p >= split[0], q <= split[1])
            raise ""This is broken""

        # print(splits)
        print(move)
        sys.stdout.flush()
        debug('after move', splits)
    if is_wrong:
        break

",,2113,89,279,Python,0000000000051707,0000000000159c91,0000000000158f1a,RalfKistner,2019
1153,0000000000159adb.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T, W = map(int, fin.readline().split())

# L = 10**10
L = 10**10

for case in range(1, T + 1):
    splits = set([(1, L * 100 + 1)])
    is_wrong = False
    while True:
        p = int(fin.readline())  # split start
        if p == -1:
            is_wrong = True
        if p < 0:
            break
        q = p + L  # next split start
        for split in splits:

            if p >= split[0] and q <= split[1]:
                splits.remove(split)
                if p > split[0] and p - split[0] >= L:
                    splits.add((split[0], p))
                if q < split[1] and split[1] - q >= L:
                    splits.add((q, split[1]))
                break
        evens = 0
        odds = 0
        choices = 0

        debug(splits)

        for split in splits:
            l = split[1] - split[0]
            remainder = l % (2*L)
            if remainder < L:
                evens += 1
            elif remainder >= L:
                odds += 1

        # print(splits)
        split = list(splits)[0]
        l = split[1] - split[0]
        remainder = l % (2 * L)

        move = None
        if odds % 2 == 1:
            # perfect
            move = split[0]
        else:
            # need to adjust
            move = min(split[0] + L - 1, split[1] - L)

        splits.remove(split)
        p = move
        q = move + L
        if p >= split[0] and q <= split[1]:
            if p > split[0] and p - split[0] >= L:
                splits.add((split[0], p))
            if q < split[1] and split[1] - q >= L:
                splits.add((q, split[1]))
        else:
            # print(p, q, split, p >= split[0], q <= split[1])
            raise ""This is broken""

        # print(splits)
        print(move)
        sys.stdout.flush()
        debug('after move', splits)
    if is_wrong:
        break

",,2022,83,266,Python,0000000000051707,0000000000159adb,0000000000158f1a,RalfKistner,2019
1154,0000000000159b07.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from collections import defaultdict

P = 10**9 + 7

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    s = int(fin.readline())
    pancakes = list(map(int, fin.readline().split()))
    # stack = [(-0, 0)] # decreasing stack
    stack = []
    total = 0
    for i in range(s):
        p = pancakes[i]
        while stack and p >= stack[-1][1]:
            qi, qv = stack.pop()
            if stack:
                ri, rv = stack[-1]
                fill = (i - ri - 1) * (min(rv, p) - qv)
                left_multiplier = ri + 1
                right_multiplier = s - i
                # debug(fill, left_multiplier, right_multiplier)
                total += fill * left_multiplier * right_multiplier

        stack.append((i, p))
        # debug(stack)
    print(""Case #%d: %s"" % (case, total % P))



",,939,38,124,Python,0000000000051707,0000000000159b07,00000000001591be,RalfKistner,2019
1155,000000000015997b.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T, W = map(int, fin.readline().split())

# L = 10**10
L = 10

for case in range(1, T + 1):
    splits = set([(1, L * 100 + 1)])
    is_wrong = False
    while True:
        p = int(fin.readline())  # split start
        if p == -1:
            is_wrong = True
        if p < 0:
            break
        q = p + L  # next split start
        for split in splits:

            if p >= split[0] and q <= split[1]:
                splits.remove(split)
                if p > split[0] and p - split[0] >= L:
                    splits.add((split[0], p))
                if q < split[1] and split[1] - q >= L:
                    splits.add((q, split[1]))
                break
        evens = 0
        odds = 0
        choices = 0

        for split in splits:
            l = split[1] - split[0]
            remainder = l % (2*L)
            if remainder < L:
                evens += 1
            elif remainder >= L:
                odds += 1

        # print(splits)
        split = list(splits)[0]
        l = split[1] - split[0]
        remainder = l % (2 * L)

        move = None
        if odds % 2 == 1:
            # perfect
            move = split[0]
        else:
            # need to adjust
            move = min(split[0] + L - 1, split[1] - L)

        splits.remove(split)
        p = move
        q = move + L
        if p >= split[0] and q <= split[1]:
            if p > split[0] and p - split[0] >= L:
                splits.add((split[0], p))
            if q < split[1] and split[1] - q >= L:
                splits.add((q, split[1]))
        else:
            # print(p, q, split, p >= split[0], q <= split[1])
            raise ""This is broken""

        # print(splits)
        print(move)
        sys.stdout.flush()
    if is_wrong:
        break

",,1959,80,262,Python,0000000000051707,000000000015997b,0000000000158f1a,RalfKistner,2019
1156,0000000000159853.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T, W = map(int, fin.readline().split())

# L = 10**10
L = 10

for case in range(1, T + 1):
    splits = set([(1, L * 100 + 1)])
    while True:
        p = int(fin.readline())  # split start
        if p < 0:
            break
        q = p + L  # next split start
        for split in splits:

            if p >= split[0] and q <= split[1]:
                splits.remove(split)
                if p > split[0] and p - split[0] >= L:
                    splits.add((split[0], p))
                if q < split[1] and split[1] - q >= L:
                    splits.add((q, split[1]))
                break
        evens = 0
        odds = 0
        choices = 0

        for split in splits:
            l = split[1] - split[0]
            remainder = l % (2*L)
            if remainder < L:
                evens += 1
            elif remainder >= L:
                odds += 1

        # print(splits)
        split = list(splits)[0]
        l = split[1] - split[0]
        remainder = l % (2 * L)

        move = None
        if odds % 2 == 1:
            # perfect
            move = split[0]
        else:
            # need to adjust
            move = min(split[0] + L - 1, split[1] - L)

        splits.remove(split)
        p = move
        q = move + L
        if p >= split[0] and q <= split[1]:
            if p > split[0] and p - split[0] >= L:
                splits.add((split[0], p))
            if q < split[1] and split[1] - q >= L:
                splits.add((q, split[1]))
        else:
            # print(p, q, split, p >= split[0], q <= split[1])
            raise ""This is broken""

        # print(splits)
        print(move)
        sys.stdout.flush()

",,1859,75,249,Python,0000000000051707,0000000000159853,0000000000158f1a,RalfKistner,2019
1157,0000000000159712.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


fin = sys.stdin
T, W = map(int, fin.readline().split())

L = 10**10


for case in range(1, T + 1):
    splits = set([(1, 10 ** 12 + 1)])
    while True:
        p = int(fin.readline())  # split start
        if p < 0:
            break
        q = p + L  # next split start
        for split in splits:

            if p >= split[0] and q <= split[1]:
                splits.remove(split)
                if p > split[0] and split[0] - p >= L:
                    splits.add((split[0], p))
                if q < split[1] and split[1] - q >= L:
                    splits.add((q, split[1]))
                break
        evens = 0
        odds = 0
        choices = 0

        for split in splits:
            l = split[1] - split[0]
            remainder = l % (2*L)
            if remainder < L:
                evens += 1
            elif remainder >= L:
                odds += 1

        split = list(splits)[0]
        l = split[1] - split[0]
        remainder = l % (2 * L)

        move = None
        if odds % 2 == 1:
            # perfect
            move = split[0]
        else:
            # need to adjust
            max(split[0] + L - 1, split[1] - L)

        splits.remove(split)
        p = move
        q = move + L
        if p >= split[0] and q <= split[1]:
            splits.remove(split)
            if p > split[0] and split[0] - p >= L:
                splits.add((split[0], p))
            if q < split[1] and split[1] - q >= L:
                splits.add((q, split[1]))

        print(move)
        sys.stdout.flush()
   
",,1721,71,225,Python,0000000000051707,0000000000159712,0000000000158f1a,RalfKistner,2019
6665,000000000014c6a2.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import math
import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def find_fraction(min_fraction, max_fraction):
    for c in range(1, 10**5):
        j2 = math.floor(min_fraction * c)

        for j in range(j2, j2 + 3):
            f = Fraction(j, c)
            if min_fraction < f < max_fraction:
                return c, j
    raise ""Not found""


def mediant(a, b):
    return (a[0] + b[0], a[1] + b[1])

def find_fraction4(max_fraction, min_fraction):
    # Find using SternBrocot tree
    left = (0, 1)
    right = (1, 0)
    while True:
        current = mediant(left, right)
        # debug('c', current, left, right)
        f = Fraction(current[0], current[1])
        if min_fraction < f < max_fraction:
            return current
        elif max_fraction <= f:
            k = math.floor((current[0] - current[1] * max_fraction)/(left[1]*max_fraction - left[0])) - 1
            if k <= 0:
                k = 0
            right = left[0]*k + current[0], left[1]*k + current[1]
        elif min_fraction >= f:
            k = math.floor((current[1] * min_fraction - current[0]) / (right[0] - right[1] * min_fraction)) - 1
            if k <= 0:
                k = 0
            left = right[0] * k + current[0], right[1] * k + current[1]
        else:
            raise ""Something went wrong""



# debug(find_fraction(Fraction(500, 10003), Fraction(500, 10001)))
# # debug(find_fraction3(Fraction(10003, 500), Fraction(10001, 500)))
# # debug(find_fraction3(Fraction(10002, 9999), Fraction(10001, 9999)))
# debug('12', find_fraction4(Fraction(10002, 9999), Fraction(10001, 9999)))
# debug('11', find_fraction4(Fraction(10003, 500), Fraction(10001, 500)))
# debug('11', find_fraction4(Fraction(1000002, 40000), Fraction(1000001, 50000)))

def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # b2 > b1 or a2 > a1
        # a1 * p + b1 * q < a2 * p + b2 * q
        # (a1 - a2) * p < (b2 - b1) * q
        # if b2 > b1:
        #   q/p > (a1 - a2) / (b2 - b1)
        # else:
        #   q/p < (a1 - a2) / (b2 - b1)
        # x = q/p
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)


        num = b2 - b1
        denom = a1 - a2
        if b2 == b1:
            if a2 <= a1:
                return None
            else:
                # Any value will work
                continue
        if a2 == a1:
            if b2 <= b1:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if a2 > a1 and b2 > b1:
            # any value will work
            continue
        if a2 < a1 and b2 < b1:
            # No value will work
            return None

        if a2 < a1: # b2 > b1
            fractions_min.append(x)
        else:
            fractions_max.append(x)

    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    # debug(molecules)
    # debug(min_fraction, max_fraction)
    # debug(fractions_min)
    # debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    return find_fraction4(1/min_fraction, 1/max_fraction)


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,3848,138,502,Python,0000000000051679,000000000014c6a2,0000000000146184,RalfKistner,2019
6666,000000000014b15f.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import math
import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def find_fraction(min_fraction, max_fraction):
    for c in range(1, 10**5):
        j2 = math.floor(min_fraction * c)

        for j in range(j2, j2 + 3):
            f = Fraction(j, c)
            if min_fraction < f < max_fraction:
                return c, j
    raise ""Not found""


def find_fraction3(max_fraction, min_fraction):
    # debug(math.ceil(p))
    for c in range(1, 10**5):
        j2 = math.floor(1/max_fraction * c)
        if j2 == 0:
            j2 += 1

        for j in range(j2, j2 + 3):
            f = Fraction(c, j)
            if max_fraction > f > min_fraction:
                return c, j
    raise ""Not found""

def mediant(a, b):
    return (a[0] + b[0], a[1] + b[1])

def find_fraction4(max_fraction, min_fraction):
    left = (0, 1)
    right = (1, 0)
    while True:
        current = mediant(left, right)
        debug('c', current, left, right)
        f = Fraction(current[0], current[1])
        if min_fraction < f < max_fraction:
            return current
        elif max_fraction <= f:
            right = current
        elif min_fraction >= f:
            left = current
        else:
            raise ""Something went wrong""



# debug(find_fraction(Fraction(500, 10003), Fraction(500, 10001)))
# debug(find_fraction3(Fraction(10003, 500), Fraction(10001, 500)))
# debug(find_fraction3(Fraction(10002, 9999), Fraction(10001, 9999)))
# debug(find_fraction4(Fraction(10002, 9999), Fraction(10001, 9999)))
# debug(find_fraction4(Fraction(10003, 500), Fraction(10001, 500)))

def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # b2 > b1 or a2 > a1
        # a1 * p + b1 * q < a2 * p + b2 * q
        # (a1 - a2) * p < (b2 - b1) * q
        # if b2 > b1:
        #   q/p > (a1 - a2) / (b2 - b1)
        # else:
        #   q/p < (a1 - a2) / (b2 - b1)
        # x = q/p
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)


        num = b2 - b1
        denom = a1 - a2
        if b2 == b1:
            if a2 <= a1:
                return None
            else:
                # Any value will work
                continue
        if a2 == a1:
            if b2 <= b1:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if a2 > a1 and b2 > b1:
            # any value will work
            continue
        if a2 < a1 and b2 < b1:
            # No value will work
            return None

        if a2 < a1: # b2 > b1
            fractions_min.append(x)
        else:
            fractions_max.append(x)

    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    # debug(molecules)
    # debug(min_fraction, max_fraction)
    # debug(fractions_min)
    # debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    return find_fraction4(1/min_fraction, 1/max_fraction)


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,3676,143,477,Python,0000000000051679,000000000014b15f,0000000000146184,RalfKistner,2019
6667,0000000000148ba1.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import math
import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # b2 > b1 or a2 > a1
        # a1 * p + b1 * q < a2 * p + b2 * q
        # (a1 - a2) * p < (b2 - b1) * q
        # if b2 > b1:
        #   q/p > (a1 - a2) / (b2 - b1)
        # else:
        #   q/p < (a1 - a2) / (b2 - b1)
        # x = q/p
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)

        # (1, 2), (2, 1)
        # a1 = 1, b1 = 2
        # a2 = 2, b2 = 1
        # a1 - a2 = -1
        # b2 - b1 = -1
        # x = 1, min
        # p > q
        # q/p < 1


        num = b2 - b1
        denom = a1 - a2
        if b2 == b1:
            if a2 <= a1:
                return None
            else:
                # Any value will work
                continue
        if a2 == a1:
            if b2 <= b1:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if a2 > a1 and b2 > b1:
            # any value will work
            continue
        if a2 < a1 and b2 < b1:
            # No value will work
            return None

        if a2 < a1: # b2 > b1
            fractions_min.append(x)
        else:
            fractions_max.append(x)

    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    # debug(molecules)
    # debug(min_fraction, max_fraction)
    # debug(fractions_min)
    # debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    for c in range(1, 10**3):
        j2 = math.floor(min_fraction * c)

        for j in range(j2, j2 + 3):
            f = Fraction(j, c)
            if min_fraction < f < max_fraction:
                return c, j

    raise ""Not found""
    # return 1, 1


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,2534,110,387,Python,0000000000051679,0000000000148ba1,0000000000146184,RalfKistner,2019
6668,00000000001481d9.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # b2 > b1 or a2 > a1
        # a1 * p + b1 * q < a2 * p + b2 * q
        # (a1 - a2) * p < (b2 - b1) * q
        # if b2 > b1:
        #   q/p > (a1 - a2) / (b2 - b1)
        # else:
        #   q/p < (a1 - a2) / (b2 - b1)
        # x = q/p
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)

        # (1, 2), (2, 1)
        # a1 = 1, b1 = 2
        # a2 = 2, b2 = 1
        # a1 - a2 = -1
        # b2 - b1 = -1
        # x = 1, min
        # p > q
        # q/p < 1


        num = b2 - b1
        denom = a1 - a2
        if num == 0:
            if denom >= 0:
                return None
            else:
                # Any value will work
                continue
        if denom == 0:
            if num <= 0:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if num * denom <= 0:
            return None

        if a2 < a1: # b2 > b1
            fractions_min.append(x)
        else:
            fractions_max.append(x)

    # debug(molecules)
    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    # debug(min_fraction, max_fraction)
    # debug(fractions_min)
    # debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    for c in range(1, 10**4):
        for j in range(1, 10**3):
            f = Fraction(j, c)
            if f > min_fraction and f < max_fraction:
                return c, j

    raise ""Not found""
    # return 1, 1


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,2365,104,359,Python,0000000000051679,00000000001481d9,0000000000146184,RalfKistner,2019
6669,0000000000148182.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # b2 > b1 or a2 > a1
        # a1 * p + b1 * q < a2 * p + b2 * q
        # (a1 - a2) * p < (b2 - b1) * q
        # if b2 > b1:
        #   q/p > (a1 - a2) / (b2 - b1)
        # else:
        #   q/p < (a1 - a2) / (b2 - b1)
        # x = q/p
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)

        # (1, 2), (2, 1)
        # a1 = 1, b1 = 2
        # a2 = 2, b2 = 1
        # a1 - a2 = -1
        # b2 - b1 = -1
        # x = 1, min
        # p > q
        # q/p < 1


        num = b2 - b1
        denom = a1 - a2
        if num == 0:
            if denom >= 0:
                return None
            else:
                # Any value will work
                continue
        if denom == 0:
            if num <= 0:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if num * denom <= 0:
            return None

        if a2 < a1: # b2 > b1
            fractions_min.append(x)
        else:
            fractions_max.append(x)

    # debug(molecules)
    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    # debug(min_fraction, max_fraction)
    # debug(fractions_min)
    # debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    for c in range(1, 10**3):
        for j in range(1, 10**3):
            f = Fraction(j, c)
            if f > min_fraction and f < max_fraction:
                return c, j

    raise ""Not found""
    # return 1, 1


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,2365,104,359,Python,0000000000051679,0000000000148182,0000000000146184,RalfKistner,2019
6670,000000000014775d.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)
        num = b2 - b1
        denom = a1 - a2
        if num == 0:
            if denom >= 0:
                return None
            else:
                # Any value will work
                continue
        if denom == 0:
            if num <= 0:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if num * denom <= 0:
            return None

        if a2 < a1:
            # codium fraction cannot be bigger than this
            fractions_max.append(x)
        else:
            fractions_min.append(x)

    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    debug(min_fraction, max_fraction)
    debug(fractions_min)
    debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    for numerator in range(1, 10**3):
        for denominator in range(1, 10**5):
            f = Fraction(numerator, denominator)
            if f > min_fraction and f < max_fraction:
                return numerator, denominator

    raise ""Not found""
    # return 1, 1


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,2009,85,247,Python,0000000000051679,000000000014775d,0000000000146184,RalfKistner,2019
6671,0000000000147661.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)


def solve(molecules):
    fractions_max = [Fraction(10**18, 1)]
    fractions_min = [Fraction(1, 10**18)]

    for i in range(n - 1):
        j = i + 1
        m1 = molecules[i]
        m2 = molecules[j]
        a1, b1 = m1
        a2, b2 = m2
        # a1 - a2  = x * (b2 - b1)
        # x = (b2 - b1) / (a1 - a2)
        num = b2 - b1
        denom = a1 - a2
        if num == 0:
            if denom >= 0:
                return None
            else:
                # Any value will work
                continue
        if denom == 0:
            if num <= 0:
                return None
            else:
                # Any value will work
                continue

        x = Fraction(denom, num)
        # minimize a, b
        if num * denom <= 0:
            return None

        if a2 < a1:
            # codium fraction cannot be bigger than this
            fractions_max.append(x)
        else:
            fractions_min.append(x)

    max_fraction = min(fractions_max)
    min_fraction = max(fractions_min)
    debug(min_fraction, max_fraction)
    debug(fractions_min)
    debug(fractions_max)
    if min_fraction >= max_fraction:
        return None

    for numerator in range(1, 10**3):
        for denominator in range(1, 10**3):
            f = Fraction(numerator, denominator)
            if f > min_fraction and f < max_fraction:
                return numerator, denominator

    raise ""Not found""
    # return 1, 1


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    solution = solve(molecules)
    if solution is None:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        print(""Case #%d: %d %d"" % (case, solution[0], solution[1]))


",,2009,85,247,Python,0000000000051679,0000000000147661,0000000000146184,RalfKistner,2019
6672,0000000000146897.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
from fractions import Fraction


def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    molecules = []
    for i in range(n):
        ci, ji = map(int, fin.readline().split())
        molecules.append((ci, ji))

    fractions = set()
    for i in range(n-1):
        for j in range(i+1, n):
            m1 = molecules[i]
            m2 = molecules[j]
            a1, b1 = m1
            a2, b2 = m2
            # a1 - a2  = x * (b2 - b1)
            # x = (b2 - b1) / (a1 - a2)
            num = b2 - b1
            denom = a1 - a2
            if num == 0 or denom == 0:
                continue
            x = Fraction(num, denom)
            # debug(m1, m2, x)
            if num * denom > 0:
                fractions.add(x)

    # debug(fractions)
    print(""Case #%d: %s"" % (case, len(fractions) + 1))

",,968,42,137,Python,0000000000051679,0000000000146897,0000000000146183,RalfKistner,2019
96278,000000000010be88.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T, N, M = map(int, fin.readline().split())
factors = [17, 13, 11, 9, 7, 5, 4]

def is_valid(remainders, guess):
    for f, r in zip(factors, remainders):
        if guess % f != r:
            return False
    return True

def calc(remainders):
    guess = remainders[0]
    while guess <= 10**7:
        if is_valid(remainders, guess):
            return guess
        guess += factors[0]
    return -1
    

for case in range(1, T + 1):
    remainders = []
    for f in factors:
        print(' '.join([str(f)]*18))
        sys.stdout.flush()
        readings = map(int, fin.readline().split())
        remainders.append(sum(readings) % f)
    result = calc(remainders)
    print(result)
    sys.stdout.flush()
    verdict = int(fin.readline())
",,930,40,104,Python,51635,000000000010be88,0000000000104f1a,RalfKistner,2019
96279,000000000010bb93.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T, N, M = map(int, fin.readline().split())
factors = [17, 13, 11, 9, 7, 5, 4]

def is_valid(remainders, guess):
    for f, r in zip(factors, remainders):
        if guess % f != r:
            return False
    return True

def calc(remainders):
    guess = remainders[0]
    while guess <= 10**7:
        if is_valid(remainders, guess):
            return guess
        guess += factors[0]
    return -1
    

for case in range(1, T + 1):
    remainders = []
    for f in factors:
        print(' '.join([str(f)]*18))
        readings = map(int, fin.readline().split())
        remainders.append(sum(readings) % f)
    result = calc(remainders)
    print(result)
    verdict = int(fin.readline())
",,881,39,102,Python,51635,000000000010bb93,0000000000104f1a,RalfKistner,2019
96280,0000000000108f81.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


def solve(r, c, try2=False):
    swap = False
    if c > r:
        r, c = c, r
        swap = True
    if r <= 3:
        return None, False
    if (r, c) == (4, 2):
        return None, False
    if (r, c) == (4, 4):
        return [
            (0, 0),
            (1, 2),
            (3, 3),
            (2, 1),
            (0, 2),
            (2, 3),
            (3, 1),
            (1, 0),
            (0, 3),
            (2, 2),
            (0, 1),
            (2, 0),
            (3, 2),
            (1, 3),
            (3, 0),
            (1, 1)
        ], False
    
    grid = [[False]*c for i in range(r)]

    x, y = 0, 0
    moves = []
    for i in range(r*c):
        x2 = (x+1) % c
        if x2 == 0 and try2:
            y2 = 0
        else:
            y2 = (y+1) % r
        y3 = y2
        while grid[y2][x2] or y2 == y or y2 + x2 == y + x or y2 - x2 == y - x:
            y2 = (y2+1)%r
            if y2 == y3:
                return None, swap
        
        grid[y2][x2] = True
        x, y = (x2, y2)
        moves.append((x, y))
    return moves, swap

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    r, c = map(int, fin.readline().split())

    moves, swap = solve(r, c)
    if not moves:
        moves, swap = solve(r, c, True)
    
    if moves:
        print(""Case #%d: %s"" % (case, ""POSSIBLE""))
        for x, y in moves:
            if swap:
                x, y = y, x
            print(y+1, x+1)
    else:
        print(""Case #%d: %s"" % (case, ""IMPOSSIBLE""))



",,1692,82,241,Python,51635,0000000000108f81,0000000000104e03,RalfKistner,2019
96281,0000000000108fa0.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


def solve(r, c, try2=False):
    swap = False
    if c > r:
        r, c = c, r
        swap = True
    if r <= 3:
        return None, False
    if (r, c) == (4, 2):
        return None, False
    if (r, c) == (4, 4):
        return [
            (0, 0),
            (1, 2),
            (3, 3),
            (2, 1),
            (0, 2),
            (2, 3),
            (3, 1),
            (1, 0),
            (0, 3),
            (2, 2),
            (0, 1),
            (2, 0),
            (3, 2),
            (1, 3),
            (3, 0),
            (1, 1)
        ], False
    
    grid = [[False]*c for i in range(r)]

    x, y = 0, 0
    moves = []
    for i in range(r*c):
        x2 = (x+1) % c
        if x2 == 0 and try2:
            y2 = 0
        else:
            y2 = (y+1) % r
        y3 = y2
        while grid[y2][x2] or y2 == y or y2 + x2 == y + x or y2 - x2 == y - x:
            y2 = (y2+1)%r
            if y2 == y3:
                return None, swap
        
        grid[y2][x2] = True
        x, y = (x2, y2)
        moves.append((x, y))
    return moves, swap

assert(false)
fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    r, c = map(int, fin.readline().split())

    moves, swap = solve(r, c)
    if not moves:
        moves, swap = solve(r, c, True)
    
    if moves:
        print(""Case #%d: %s"" % (case, ""POSSIBLE""))
        for x, y in moves:
            if swap:
                x, y = y, x
            print(y+1, x+1)
    else:
        print(""Case #%d: %s"" % (case, ""IMPOSSIBLE""))



",,1706,83,242,Python,51635,0000000000108fa0,0000000000104e03,RalfKistner,2019
96282,000000000010859c.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


def solve(r, c, try2=False):
    swap = False
    if c > r:
        r, c = c, r
        swap = True
    if r <= 3:
        return None, False
    if (r, c) == (4, 2):
        return None, False
    
    
    grid = [[False]*c for i in range(r)]

    x, y = 0, 0
    moves = []
    for i in range(r*c):
        x2 = (x+1) % c
        if x2 == 0 and try2:
            y2 = 0
        else:
            y2 = (y+1) % r
        y3 = y2
        while grid[y2][x2] or y2 == y or y2 + x2 == y + x or y2 - x2 == y - x:
            y2 = (y2+1)%r
            if y2 == y3:
                return None, swap
        
        grid[y2][x2] = True
        x, y = (x2, y2)
        moves.append((x, y))
    return moves, swap

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    r, c = map(int, fin.readline().split())

    moves, swap = solve(r, c)
    if not moves:
        moves, swap = solve(r, c, True)
    
    if moves:
        print(""Case #%d: %s"" % (case, ""POSSIBLE""))
        for x, y in moves:
            if swap:
                x, y = y, x
            print(y+1, x+1)
    else:
        print(""Case #%d: %s"" % (case, ""IMPOSSIBLE""))



",,1319,64,199,Python,51635,000000000010859c,0000000000104e03,RalfKistner,2019
96283,00000000001083b2.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys


def debug(*args):
    print(*args, file=sys.stderr)


def solve(r, c, try2=False):
    swap = False
    if c > r:
        r, c = c, r
        swap = True
    if r <= 3:
        return None, False
    if (r, c) == (4, 2):
        return None, False
    
    
    grid = [[False]*c for i in range(r)]

    x, y = 0, 0
    moves = [(x, y)]
    for i in range(r*c):
        x2 = (x+1) % c
        if x2 == 0 and try2:
            y2 = 0
        else:
            y2 = (y+1) % r
        y3 = y2
        while grid[y2][x2] or y2 == y or y2 + x2 == y + x or y2 - x2 == y - x:
            y2 = (y2+1)%r
            if y2 == y3:
                return None, swap
        
        grid[y2][x2] = True
        x, y = (x2, y2)
        moves.append((x, y))
    return moves, swap

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    r, c = map(int, fin.readline().split())

    moves, swap = solve(r, c)
    if not moves:
        moves, swap = solve(r, c, True)
    
    if moves:
        print(""Case #%d: %s"" % (case, ""POSSIBLE""))
        for x, y in moves:
            if swap:
                x, y = y, x
            print(y+1, x+1)
    else:
        print(""Case #%d: %s"" % (case, ""IMPOSSIBLE""))



",,1325,64,200,Python,51635,00000000001083b2,0000000000104e03,RalfKistner,2019
96285,00000000001054ba.PYTHON3,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Uses https://github.com/rkistner/contest-algorithms

import sys
from collections import defaultdict

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())

    words = []
    for i in range(n):
        word = fin.readline().strip()
        words.append(word)

    suffixes = defaultdict(lambda: defaultdict(int))
    for word in words:
        for i in range(len(word)):
            suffix = word[i:]
            suffixes[len(suffix)][suffix] += 1

    subset_count = 0
    max_length = max(key for key in suffixes.keys())
    for suffix_length in range(max_length, -1, -1):
        ls = suffixes[suffix_length]
        for key, value in ls.items():
            if value >= 2:
                subset_count += 2
                for i in range(1, len(key)):
                    suffix = key[i:]
                    suffixes[len(suffix)][suffix] -= 2

    print(""Case #%d: %s"" % (case, subset_count))

",,1044,40,113,Python,51635,00000000001054ba,0000000000104e05,RalfKistner,2019
146937,00000000002662f0,"import sys

fin = sys.stdin

T = int(fin.readline())

for case in range(1, T + 1):
    n = int(fin.readline())

    activities = []
    for i in range(n):
        start, end = map(int, fin.readline().split())
        activities.append((start, end, i))
    activities.sort()
    print(activities, file=sys.stderr)

    last_c = 0
    last_j = 0

    assignments = {}
    failed = False
    for start, end, i in activities:
        if last_c <= start:
            assignments[i] = 'C'
            last_c = end
        elif last_j <= start:
            assignments[i] = 'J'
            last_j = end
        else:
            failed = True
            break

    if failed:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
    else:
        result = ''
        for i in range(n):
            result += assignments[i]
        print(""Case #%d: %s"" % (case, result))
",00000000002662f0.PYTHON3,864,40,104,Python,000000000019fd27,00000000002662f0,000000000020bdf9,RalfKistner,2020
146938,00000000002652b4,"import sys
import re

fin = sys.stdin

T = int(fin.readline())

for case in range(1, T + 1):
    digits = fin.readline().strip()
    def sub1(match):
        x = match.group()
        return ('(' * int(x)) + x + (')' * int(x))
    full = re.sub(r'\d', sub1, digits)
    reduced = full
    for i in range(10):
        reduced = reduced.replace(')(', '')
    # print(reduced, file=sys.stderr)

    print(""Case #%d: %s"" % (case, reduced))
",00000000002652b4.PYTHON3,436,20,60,Python,000000000019fd27,00000000002652b4,0000000000209a9f,RalfKistner,2020
146939,0000000000263faf,"import sys

fin = sys.stdin

T = int(fin.readline())

for case in range(1, T+1):
    n = int(fin.readline())
    trace = 0
    rrow = 0
    rcol = 0
    
    rows = []
    for i in range(n):
        row = list(map(int, fin.readline().split()))
        trace += row[i]
        rows.append(row)
        
        numbers = set()
        for k in row:
            numbers.add(k)
        if len(numbers) != n:
            rrow += 1
    for i in range(n):
        numbers = set()
        for j in range(n):
            numbers.add(rows[j][i])
        if len(numbers) != n:
            rcol += 1
        
    print(""Case #%d: %d %d %d"" % (case, trace, rrow, rcol))
    ",0000000000263faf.PYTHON3,662,32,84,Python,000000000019fd27,0000000000263faf,000000000020993c,RalfKistner,2020
146940,0000000000263f37,"import sys

fin = sys.stdin

T = int(fin.readline())

for case in range(1, T+1):
    n = int(fin.readline())
    trace = 0
    rrow = 0
    rcol = 0
    
    rows = []
    for i in range(n):
        row = list(map(int, fin.readline().split()))
        trace += row[i]
        rows.append(row)
        
        numbers = set()
        for k in row:
            numbers.add(k)
        if len(numbers) != n:
            rrow += 1
    for i in range(n):
        numbers = set()
        for j in range(n):
            numbers.add(rows[j][i])
        if len(numbers) != n:
            rcol += 1
        
    print(""Case %d: %d %d %d"" % (case, trace, rrow, rcol))
    ",0000000000263f37.PYTHON3,661,32,84,Python,000000000019fd27,0000000000263f37,000000000020993c,RalfKistner,2020
387357,00000000003069e8,"#!/usr/bin/env python3

import sys
from itertools import product

def debug(*args):
    print(*args, file=sys.stderr)

def sort_cards(R, S, cards):
    if len(cards) == 0:
        return []
    pos = R * S - len(cards)
    expected_rank = pos // S + 1
    if cards[0] == expected_rank:
        return sort_cards(R, S, cards[1:])

    options = []
    for i, r in enumerate(cards):
        if r == expected_rank:
            if i == 0:
                raise Exception(""WTF"")
            new_cards = cards[i+1:] + cards[:i]
            operations = sort_cards(R, S, new_cards)
            # operations = []
            operations.append((len(cards) - i, i))
            options.append((len(operations), operations))

    # debug('options', options)
    num_operations, operations = min(options)
    return operations


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    R, S = map(int, fin.readline().split())
    debug(R, S)

    cards = list([r for s, r in product(range(1, S + 1), range(1, R + 1))])
    debug('cards', cards)
    solution = sort_cards(R, S, cards)
    solution.reverse()
    # debug('solution', solution)

    print(""Case #%d: %s"" % (case, len(solution)))
    for a, b in solution:
        print(a, b)
",00000000003069e8.PYTHON3,1242,48,150,Python,000000000019fef2,00000000003069e8,00000000002d5b64,RalfKistner,2020
387358,0000000000304c0c,"#!/usr/bin/env python3

import sys
from collections import defaultdict
from itertools import product

def debug(*args):
    print(*args, file=sys.stderr)

def sort_cards(R, S, cards):
    if len(cards) == 0:
        return []
    pos = R * S - len(cards)
    expected_rank = pos // S + 1
    if cards[0][0] == expected_rank:
        return sort_cards(R, S, cards[1:])

    options = []
    for i, (r, s) in enumerate(cards):
        if r == expected_rank:
            if i == 0:
                raise Exception(""WTF"")
            new_cards = cards[i+1:] + cards[:i]
            operations = sort_cards(R, S, new_cards)
            # operations = []
            operations.append((len(cards) - i, i))
            options.append((len(operations), operations))

    # debug('options', options)
    num_operations, operations = min(options)
    return operations


fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    R, S = map(int, fin.readline().split())
    debug(R, S)

    cards = list([(r, s) for s, r in product(range(1, S + 1), range(1, R + 1))])
    # debug('cards', cards)
    solution = sort_cards(R, S, cards)
    solution.reverse()
    # debug('solution', solution)

    print(""Case #%d: %s"" % (case, len(solution)))
    for a, b in solution:
        print(a, b)

",0000000000304c0c.PYTHON3,1294,50,157,Python,000000000019fef2,0000000000304c0c,00000000002d5b64,RalfKistner,2020
387359,00000000002ffd2c,"#!/usr/bin/env python3

import sys


fin = sys.stdin


def debug(*args):
    print(*args, file=sys.stderr)


U = 10 ** 9
THIRD = 10 ** 9 // 3
# HX = -THIRD
# HY = THIRD
# HR = 10**9 * 2 // 3

# def aim(x, y):
#     if x == HX and y == HY:
#         return 'HIT'
#     if 0 < (HX - x)**2 + (HY - y)**2 <= HR**2:
#         return 'HIT'
#     return 'MISS'


class HitException(Exception):
    pass


def aim(x, y):
    if x < -U or x > U or y < -U or y > U:
        return 'MISS'
    # debug('aim', x, y)
    print(x, y)
    sys.stdout.flush()
    result = sys.stdin.readline().strip()
    if result == 'CENTER':
        raise HitException
    return result


def bisect_left(func, val, low, high):
    """"""
    Like bisect.bisect_left, but works on functions.

    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in a[i:] have e >= x.  So if x already appears
    in the list, a.insert(x) will insert just before the leftmost x already there.  Optional args lo (default 0) and hi
    (default len(a)) bound the slice of a to be searched.

    >>> bisect_left([1,2,3,3,4].__getitem__, 3, 0, 4)
    2
    >>> bisect_left([1,2,3,3,4].__getitem__, 4, 0, 4)
    4
    >>> bisect_left([1,2,3,6,8].__getitem__, 4, 0, 4)
    3
    """"""

    a = low
    b = high
    while b > a:
        guess = (a+b)//2

        if val > func(guess):
            a = guess+1
        else:
            b = guess

    return a


def locate_hit():
    for x, y in [(-THIRD, THIRD), (THIRD, THIRD), (THIRD, -THIRD), (-THIRD, -THIRD)]:
        result = aim(x, y)
        if result == 'HIT':
            return x, y
    raise Exception('Broken - cannot locate circle')


def find_x_points(x0, y):
    x1 = bisect_left(lambda x: aim(x, y) == 'HIT' and 1 or 0, 1, -U-1, x0)
    x2 = bisect_left(lambda x: aim(x, y) == 'MISS' and 1 or 0, 1, x0, U+1) - 1
    return x1, x2


def find_y_points(x, y0):
    y1 = bisect_left(lambda y: aim(x, y) == 'HIT' and 1 or 0, 1, -U-1, y0)
    y2 = bisect_left(lambda y: aim(x, y) == 'MISS' and 1 or 0, 1, y0, U+1) - 1
    return y1, y2


T, A, B = map(int, fin.readline().split())

for case in range(1, T + 1):
    try:
        x0, y0 = locate_hit()
        debug(x0, y0)
        x1, x2 = find_x_points(x0, y0)
        y1, y2 = find_y_points(x0, y0)
        xc = (x1 + x2) // 2
        yc = (y1 + y2) // 2
        debug('r', x1, x2, y1, y2, xc, yc)
        aim(xc, yc)
        for xd in [-1, 0, 1]:
            for yd in [-1, 0, 1]:
                # Just in case
                aim(xc + xd, yc + yd)
        raise Exception(""Failure at case %d"" % case)
    except HitException:
        # Success
        continue
",00000000002ffd2c.PYTHON3,2714,114,441,Python,000000000019fef2,00000000002ffd2c,00000000002d5b63,RalfKistner,2020
387360,00000000002fa85f,"#!/usr/bin/env python3

import sys
from collections import defaultdict

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    x, y = map(int, fin.readline().split())
    debug(x, y)

    sequences = [(x, y, '')]
    for i in range(32, -1, -1):
        k = 2 ** i

        # debug(k, sequences)
        next_sequences = []
        for x, y, s in sequences:
            xo = (x > 0 and x & k == k) or (x < 0 and (-x) & k == k)
            yo = (y > 0 and y & k == k) or (y < 0 and (-y) & k == k)

            # debug(i, k, started, x, y, xo, yo)
            if xo and yo:
                continue
            elif xo:
                if x > 0:
                    next_sequences.append((x - k, y, s + 'E'))
                else:
                    next_sequences.append((x + k, y, s + 'W'))
            elif yo:
                if y > 0:
                    next_sequences.append((x, y - k, s + 'N'))
                else:
                    next_sequences.append((x, y + k, s + 'S'))
            elif s:
                if x > 0:
                    next_sequences.append((x - k, y, s + 'E'))
                else:
                    next_sequences.append((x + k, y, s + 'W'))
                if y > 0:
                    next_sequences.append((x, y - k, s + 'N'))
                else:
                    next_sequences.append((x, y + k, s + 'S'))
            else:
                next_sequences.append((x, y, s))
                if x * 2 >= k:
                    next_sequences.append((x - k, y, s + 'E'))
                elif x * 2 <= -k:
                    next_sequences.append((x + k, y, s + 'W'))
                if y * 2 >= k:
                    next_sequences.append((x, y - k, s + 'N'))
                elif y * 2 <= -k:
                    next_sequences.append((x, y + k, s + 'S'))
        sequences = next_sequences

    answers = [s[::-1] for x, y, s in sequences if x == 0 and y == 0]
    debug(sequences, answers)
    if answers:
        debug(answers)
        print(""Case #%d: %s"" % (case, answers[0]))
    else:
        print(""Case #%d: %s"" % (case, 'IMPOSSIBLE'))
",00000000002fa85f.PYTHON3,2163,66,291,Python,000000000019fef2,00000000002fa85f,00000000002d5b62,RalfKistner,2020
489069,000000000033e09a,"#!/usr/bin/env python3

import sys
from collections import defaultdict

def debug(*args):
    print(*args, file=sys.stderr)


def validate(xlist, connection_list, connection_values):
    pass

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    c, d = map(int, fin.readline().split())

    xlist = list(map(int, fin.readline().split()))

    connections = defaultdict(list)
    connection_list = []

    for i in range(d):
        a, b = map(int, fin.readline().split())
        a -= 1
        b -= 1
        connections[a].append(b)
        connections[b].append(a)
        connection_list.append((a, b))

    fixed_times = []
    ordered_slots = defaultdict(list)
    for i in range(1, c):
        x = xlist[i-1]
        if x > 0:
            fixed_times.append((x, i))
        else:
            ordered_slots[-x].append(i)

    fixed_times.sort(reverse=True)
    ordered_times = [(0, 0)]
    for x in sorted(ordered_slots.keys()):
        while len(ordered_times) < x:
            ordered_times.append(fixed_times.pop())
        t = ordered_times[x - 1][0] + 1
        for i in ordered_slots[x]:
            ordered_times.append((t, i))

    times = [0] * c
    for t, i in ordered_times:
        times[i] = t

    connection_values = []
    for (a, b) in connection_list:
        at = times[a]
        bt = times[b]
        latency = max(1, abs(at - bt))
        connection_values.append(latency)


    print(""Case #%d: %s"" % (case, ' '.join(map(str, connection_values))))


",000000000033e09a.PYTHON3,1500,64,155,Python,000000000019ffb9,000000000033e09a,000000000033871f,RalfKistner,2020
489070,000000000033ded9,"#!/usr/bin/env python3

import sys
from collections import defaultdict

def debug(*args):
    print(*args, file=sys.stderr)


def validate(xlist, connection_list, connection_values):
    pass

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    c, d = map(int, fin.readline().split())

    xlist = list(map(int, fin.readline().split()))

    connections = defaultdict(list)
    connection_list = []

    for i in range(d):
        a, b = map(int, fin.readline().split())
        a -= 1
        b -= 1
        connections[a].append(b)
        connections[b].append(a)
        connection_list.append((a, b))

    times = [0]*c
    # ordered = defaultdict(list)
    for i in range(1, c):
        x = xlist[i-1]
        if x > 0:
            times[i] = x
        else:
            # ordered[-x-1].append(i)
            times[i] = -x
    # for i in range(0, c):
    #     debug(times, ordered)
    #     if i != 0 and times[i] == 0:
    #         raise Exception(""Fail"")
    #     for j in ordered[i]:
    #         times[j] = times[i] + 1
    #         debug(j, times[i] + 1)
    debug(times)

    connection_values = []
    for (a, b) in connection_list:
        at = times[a]
        bt = times[b]
        latency = max(1, abs(at - bt))
        connection_values.append(latency)


    print(""Case #%d: %s"" % (case, ' '.join(map(str, connection_values))))


",000000000033ded9.PYTHON3,1376,60,159,Python,000000000019ffb9,000000000033ded9,000000000033871f,RalfKistner,2020
489071,000000000033ce30,"#!/usr/bin/env python3

import sys
from collections import defaultdict

def bisect_left(func, val, low, high):
    """"""
    Like bisect.bisect_left, but works on functions.

    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in a[i:] have e >= x.  So if x already appears
    in the list, a.insert(x) will insert just before the leftmost x already there.  Optional args lo (default 0) and hi
    (default len(a)) bound the slice of a to be searched.

    >>> bisect_left([1,2,3,3,4].__getitem__, 3, 0, 4)
    2
    >>> bisect_left([1,2,3,3,4].__getitem__, 4, 0, 4)
    4
    >>> bisect_left([1,2,3,6,8].__getitem__, 4, 0, 4)
    3
    """"""

    a = low
    b = high
    while b > a:
        guess = (a+b)//2

        if val > func(guess):
            a = guess+1
        else:
            b = guess

    return a

def cumulative(i, n):
    return i * n + n * (n-1) // 2


def cumulative2(i, n):
    return i * n + n * (n-1)


def debug(*args):
    print(*args, file=sys.stderr)
# 
def diff(i, l, r):
    d = r - l
    if d >= i:
        n = max(1, bisect_left(lambda n: cumulative(i, n), d, 0, 10**9))
        sum = cumulative(i, n)
        if sum > r:
            n -= 1
            sum = cumulative(i, n)
        return (n, sum, 0)
    else:
        nr = bisect_left(lambda n: cumulative2(i, n), r, 0, 10 ** 9)
        nl = bisect_left(lambda n: cumulative2(i+1, n), l, 0, 10 ** 9)

        sumr = cumulative2(i, nr)
        suml = cumulative2(i + 1, nl)
        while sumr > r or suml > l:
            nr -= 1
            nl -= 1
            sumr = cumulative2(i, nr)
            suml = cumulative2(i + 1, nl)

        if nr <= 0:
            return (1, i, 0)

        return (nr + nl, sumr, suml)
    
fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    l, r = map(int, fin.readline().split())

    customers = 0
    i = 1
    while True:
        if l >= r and l >= i:
            n, sumr, suml = diff(i, r, l)
            l -= sumr
            r -= suml
            customers += n
            i += n
        elif r >= i:
            n, sumr, suml = diff(i, l, r)
            r -= sumr
            l -= suml
            customers += n
            i += n
        else:
            break

    print(""Case #%d: %s %d %d"" % (case, customers, l, r))


",000000000033ce30.PYTHON3,2370,99,369,Python,000000000019ffb9,000000000033ce30,00000000003384ea,RalfKistner,2020
489072,000000000033cb59,"#!/usr/bin/env python3

import sys
from collections import defaultdict

def bisect_left(func, val, low, high):
    """"""
    Like bisect.bisect_left, but works on functions.

    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e < x, and all e in a[i:] have e >= x.  So if x already appears
    in the list, a.insert(x) will insert just before the leftmost x already there.  Optional args lo (default 0) and hi
    (default len(a)) bound the slice of a to be searched.

    >>> bisect_left([1,2,3,3,4].__getitem__, 3, 0, 4)
    2
    >>> bisect_left([1,2,3,3,4].__getitem__, 4, 0, 4)
    4
    >>> bisect_left([1,2,3,6,8].__getitem__, 4, 0, 4)
    3
    """"""

    a = low
    b = high
    while b > a:
        guess = (a+b)//2

        if val > func(guess):
            a = guess+1
        else:
            b = guess

    return a

def cumulative(i, n):
    return i * n + n * (n-1) // 2


def cumulative2(i, n):
    return i * n + n * (n-1)


def debug(*args):
    print(*args, file=sys.stderr)
# 
def diff(i, l, r):
    d = r - l
    if d > i:
        n = max(1, bisect_left(lambda n: cumulative(i, n), d, 0, 10**9))
        sum = cumulative(i, n)
        if sum > r:
            n -= 1
            sum = cumulative(i, n)
        return (n, sum, 0)
    else:
        nr = bisect_left(lambda n: cumulative2(i, n), r, 0, 10 ** 9)
        nl = bisect_left(lambda n: cumulative2(i+1, n), l, 0, 10 ** 9)

        sumr = cumulative2(i, nr)
        suml = cumulative2(i + 1, nl)
        while sumr > r or suml > l:
            nr -= 1
            nl -= 1
            sumr = cumulative2(i, nr)
            suml = cumulative2(i + 1, nl)

        if nr <= 0:
            return (1, i, 0)

        return (nr + nl, sumr, suml)
    
fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    l, r = map(int, fin.readline().split())

    customers = 0
    i = 1
    while True:
        if l >= r and l >= i:
            n, sumr, suml = diff(i, r, l)
            l -= sumr
            r -= suml
            customers += n
            i += n
        elif r >= i:
            n, sumr, suml = diff(i, l, r)
            r -= sumr
            l -= suml
            customers += n
            i += n
        else:
            break

    print(""Case #%d: %s %d %d"" % (case, customers, l, r))


",000000000033cb59.PYTHON3,2369,99,369,Python,000000000019ffb9,000000000033cb59,00000000003384ea,RalfKistner,2020
489073,000000000033bb86,"#!/usr/bin/env python3

import sys
from collections import defaultdict
import math

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())
    points = []
    for i in range(n):
        x, y = map(int, fin.readline().split())
        points.append((x, y))

    directions = defaultdict(lambda: defaultdict(list))
    for i in range(n):
        a = points[i]
        for j in range(n):
            if i == j:
                continue
            b = points[j]
            diff = (b[0]-a[0], b[1]-a[1])
            g = math.gcd(diff[0], diff[1])
            direction = (diff[0]//g, diff[1]//g)
            if direction[0] > 0 or (direction[0] == 0 and direction[1] > 0):
                directions[direction][a].append((abs(diff[0]) + abs(diff[1]), b))

    results = dict()
    for d in directions:
        incoming = defaultdict(int)
        outgoing = dict()
        origins = directions[d]
        for a in origins:
            dist, b = min(origins[a])
            outgoing[a] = b
            incoming[b] += 1

        queue = []
        for a in origins:
            if incoming[a] == 0:
                queue.append(a)

        sequences = []

        while queue:
            a = queue.pop()
            l = 1
            while a in outgoing:
                a = outgoing[a]
                l += 1
            sequences.append(l)
        odds = 0
        counter = 0
        for s in sequences:
            if s % 2 == 0:
                counter += s
            else:
                counter += s - 1
                odds += 1

        results[d] = counter + (odds // 2)

    if results:
        best = max(results.values())
    else:
        best = 0
    result = min(best + 2, n)
    print(""Case #%d: %s"" % (case, result))
",000000000033bb86.PYTHON3,1828,73,215,Python,000000000019ffb9,000000000033bb86,00000000003386d0,RalfKistner,2020
489074,000000000033b86c,"#!/usr/bin/env python3

import sys
from collections import defaultdict
import math

def debug(*args):
    print(*args, file=sys.stderr)

fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    n = int(fin.readline())
    points = []
    for i in range(n):
        x, y = map(int, fin.readline().split())
        points.append((x, y))

    directions = defaultdict(lambda: defaultdict(list))
    for i in range(n):
        a = points[i]
        for j in range(n):
            if i == j:
                continue
            b = points[j]
            diff = (b[0]-a[0], b[1]-a[1])
            g = math.gcd(diff[0], diff[1])
            direction = (diff[0]//g, diff[1]//g)
            directions[direction][a].append((abs(diff[0]) + abs(diff[1]), b))

    results = dict()
    for d in directions:
        incoming = defaultdict(int)
        outgoing = dict()
        origins = directions[d]
        for a in origins:
            dist, b = min(origins[a])
            outgoing[a] = b
            incoming[b] += 1

        queue = []
        for a in origins:
            if incoming[a] == 0:
                queue.append(a)

        sequences = []

        while queue:
            a = queue.pop()
            l = 1
            while a in outgoing:
                a = outgoing[a]
                l += 1
            sequences.append(l)
        odds = 0
        counter = 0
        for s in sequences:
            if s % 2 == 0:
                counter += s
            else:
                counter += s - 1
                odds += 1

        results[d] = counter + (odds // 2)

    if results:
        best = max(results.values())
    else:
        best = 0
    result = min(best + 2, n)
    print(""Case #%d: %s"" % (case, result))
",000000000033b86c.PYTHON3,1747,72,203,Python,000000000019ffb9,000000000033b86c,00000000003386d0,RalfKistner,2020
489075,0000000000339c48,"#!/usr/bin/env python3

import sys
from collections import defaultdict

def debug(*args):
    print(*args, file=sys.stderr)
# 
# def diff(i, l, r):
#     d = r - l
#     guess = 
#     d*2 <= n*(n-1)
    
fin = sys.stdin
T = int(fin.readline())
for case in range(1, T + 1):
    l, r = map(int, fin.readline().split())

    customers = 0
    for i in range(1, 10**9):
        if l >= r and l >= i:
            l -= i
            customers += 1
        elif r >= i:
            r -= i
            customers += 1
        else:
            break

    print(""Case #%d: %s %d %d"" % (case, customers, l, r))
",0000000000339c48.PYTHON3,601,31,93,Python,000000000019ffb9,0000000000339c48,00000000003384ea,RalfKistner,2020
5922,B.py,"#!/usr/bin/env python
 #coding=utf-8
 #!/usr/bin/env python
 #coding=utf-8
 
 import math
 
 
 def seive(n):
     assert n > 1
     pl = [2]
     ln = (n-1)/2
     cad = [1]*ln
     for i in xrange(ln):
         if cad[i] == 1:
             p = 2*i+3
             pl.append(p)
             for j in xrange(i+p,ln, p):
                 cad[j] = 0
     return pl
 
 
 def is_prime(n, pl=[], ext=False):
     assert n > 0
     if n == 1:
         return False
     if n == 2:
         return True
     if n%2 == 0:
         return False
     if n in pl:
         return True
     if len(pl)>0 and n < pl[-1]:
         return False
     r = math.floor(n**0.5)
     for p in pl:
         if p > r:
             return True
         if n%p == 0:
             return False
     cad = len(pl) and (pl[-1]+2) or 3
     if ext and len(pl) == 0:
         pl.append(2)
     while cad <= r:
         if ext and is_prime(cad, pl, ext):
             pl.append(cad)
         if n%cad == 0:
             return False
         cad += 2
     return True
 
 
 def iter_factorial(n):
     assert n >= 0
     if n == 0:
         yield 1
         raise StopIteration
     i = 1
     m = 1
     while i < n:
         yield m
         i += 1
         m *= i
     raise StopIteration
 
 
 def iter_permutation(n, m):
     assert n >= 0
     assert m >= 0
     assert n >= m
     shadow = [1]*n
     nexti = 0
     cad = []
     while True:
         if nexti < n:
             if shadow[nexti] == 1:
                 shadow[nexti] = 0
                 cad.append(nexti)
                 if len(cad) == m:
                     yield cad
                     nexti = cad.pop()
                     shadow[nexti] = 1
                 else:
                     nexti = -1
             nexti += 1
         elif len(cad) == 0:
             break
         else:
             nexti = cad.pop()
             shadow[nexti] = 1
             nexti += 1
     raise StopIteration
 
 
 def iter_combination(n, m):
     assert n >= 0
     assert m >= 0
     assert n >= m
     if m == n:
         yield range(n)
         raise StopIteration
     shadow = [1]*n
     static = range(n)
     nexti = 0
     cad = []
     ln = 0
     while True:
         if nexti < n:
             if shadow[nexti] == 1:
                 shadow[nexti] = 0
                 cad.append(nexti)
                 ln += 1
                 if ln == m:
                     yield cad
                     nexti = cad.pop()
                     ln -= 1
                     shadow[nexti] = 1
             nexti += 1
         elif ln == 0:
             break
         else:
             nexti = cad.pop()
             ln -= 1
             shadow[nexti] = 1
             if m-ln > n-nexti-1:
                 nexti = n
             else:
                 nexti += 1
     raise StopIteration
 
 
 def iter_BFS(matrix, root=0):
     n = len(matrix)
     assert n > 0
     for i in xrange(n):
         assert len(matrix[i]) == n
     visit = [False]*n
     queue = []
     qlen = 0
     visit[root] = True
     queue.append(root)
     qlen += 1
     yield root
     while qlen != 0:
         current = queue.pop(0)
         qlen -= 1
         for i in xrange(n):
             if matrix[current][i] != 0:
                 if not visit[i]:
                     visit[i] = True
                     queue.append(i)
                     qlen += 1
                     yield i
     raise StopIteration
 
 
 def iter_DFS(matrix, root=0):
     n = len(matrix)
     assert n > 0
     for i in xrange(n):
         assert len(matrix[i]) == n
     visit = [False]*n
     queue = []
     qlen = 0
     visit[root] = True
     queue.append(root)
     qlen += 1
     yield root
     current = root
     nexti = 0
     while True:
         nonext = True
         for i in xrange(nexti, n):
             if matrix[current][i] != 0 and not visit[i]:
                 visit[i] = True
                 queue.append(i)
                 qlen += 1
                 current = i
                 yield current
                 nonext = False
                 nexti = 0
                 break
         if nonext:
             nexti = queue.pop()
             qlen -= 1
             if qlen == 0:
                 raise StopIteration
             else:
                 current = queue[-1]
 
 
 def B():
     test = False
     sample = """"""3
 2
 2
 1 2 1
 2 1 1 2 0
 5
 3
 1 1 1
 2 1 0 2 0
 1 5 0
 1
 2
 1 1 0
 1 1 1""""""
     infile = iter(sample.split('\n'))
     if not test:
         infile = open(""B-small-attempt1.in"",'r')
     outfile = open(""B-small-attempt1.out"",'w')
     N = int(infile.next())
     for n in xrange(N):
         fn = int(infile.next())
         cn = int(infile.next())
         cf = []
         for i in xrange(cn):
             cf.append([int(x) for x in infile.next().split()])
         best = 2**fn-1
         bc = fn
         impossible = True
         for mask in xrange(2**fn):
             mimp = False
             for c in cf:
                 cimp = True
                 for i in xrange(c[0]):
                     if 0 == (((mask >> (c[2*i+1]-1)) & 1) ^ c[2*i+2]):
                         cimp = False
                         break
                 if cimp:
                     mimp = True
                     break
             if not mimp:
                 impossible = False
                 i = 1
                 tc = 0
                 while i < 2**fn:
                     if (i & mask) != 0:
                         tc += 1
                     i = i << 1
                 if tc < bc:
                     best = mask
                     bc = tc
         case_out = ""Case #%d: ""%(n+1)
         if impossible:
             case_out += ""IMPOSSIBLE""
         else:
             for i in xrange(fn):
                 best, r = divmod(best,2)
                 case_out += str(r)+' '
         print case_out
         outfile.write(case_out+'\n')
     if not test:
         infile.close()
     outfile.close()
 
 if __name__ == '__main__':
     import time
     start = time.clock()
     B()
     print ""done in %f""%(time.clock()-start)
",gcj/2008/32016/graygrass/24482/0/extracted/B.py,6078,262,721,Python,32016,0,24482,graygrass,2008
5923,A.py,"#!/usr/bin/env python
 #coding=utf-8
 #!/usr/bin/env python
 #coding=utf-8
 
 import math
 
 
 def seive(n):
     assert n > 1
     pl = [2]
     ln = (n-1)/2
     cad = [1]*ln
     for i in xrange(ln):
         if cad[i] == 1:
             p = 2*i+3
             pl.append(p)
             for j in xrange(i+p,ln, p):
                 cad[j] = 0
     return pl
 
 
 def is_prime(n, pl=[], ext=False):
     assert n > 0
     if n == 1:
         return False
     if n == 2:
         return True
     if n%2 == 0:
         return False
     if n in pl:
         return True
     if len(pl)>0 and n < pl[-1]:
         return False
     r = math.floor(n**0.5)
     for p in pl:
         if p > r:
             return True
         if n%p == 0:
             return False
     cad = len(pl) and (pl[-1]+2) or 3
     if ext and len(pl) == 0:
         pl.append(2)
     while cad <= r:
         if ext and is_prime(cad, pl, ext):
             pl.append(cad)
         if n%cad == 0:
             return False
         cad += 2
     return True
 
 
 def iter_factorial(n):
     assert n >= 0
     if n == 0:
         yield 1
         raise StopIteration
     i = 1
     m = 1
     while i < n:
         yield m
         i += 1
         m *= i
     raise StopIteration
 
 
 def iter_permutation(n, m):
     assert n >= 0
     assert m >= 0
     assert n >= m
     shadow = [1]*n
     nexti = 0
     cad = []
     while True:
         if nexti < n:
             if shadow[nexti] == 1:
                 shadow[nexti] = 0
                 cad.append(nexti)
                 if len(cad) == m:
                     yield cad
                     nexti = cad.pop()
                     shadow[nexti] = 1
                 else:
                     nexti = -1
             nexti += 1
         elif len(cad) == 0:
             break
         else:
             nexti = cad.pop()
             shadow[nexti] = 1
             nexti += 1
     raise StopIteration
 
 
 def iter_combination(n, m):
     assert n >= 0
     assert m >= 0
     assert n >= m
     if m == n:
         yield range(n)
         raise StopIteration
     shadow = [1]*n
     static = range(n)
     nexti = 0
     cad = []
     ln = 0
     while True:
         if nexti < n:
             if shadow[nexti] == 1:
                 shadow[nexti] = 0
                 cad.append(nexti)
                 ln += 1
                 if ln == m:
                     yield cad
                     nexti = cad.pop()
                     ln -= 1
                     shadow[nexti] = 1
             nexti += 1
         elif ln == 0:
             break
         else:
             nexti = cad.pop()
             ln -= 1
             shadow[nexti] = 1
             if m-ln > n-nexti-1:
                 nexti = n
             else:
                 nexti += 1
     raise StopIteration
 
 
 def iter_BFS(matrix, root=0):
     n = len(matrix)
     assert n > 0
     for i in xrange(n):
         assert len(matrix[i]) == n
     visit = [False]*n
     queue = []
     qlen = 0
     visit[root] = True
     queue.append(root)
     qlen += 1
     yield root
     while qlen != 0:
         current = queue.pop(0)
         qlen -= 1
         for i in xrange(n):
             if matrix[current][i] != 0:
                 if not visit[i]:
                     visit[i] = True
                     queue.append(i)
                     qlen += 1
                     yield i
     raise StopIteration
 
 
 def iter_DFS(matrix, root=0):
     n = len(matrix)
     assert n > 0
     for i in xrange(n):
         assert len(matrix[i]) == n
     visit = [False]*n
     queue = []
     qlen = 0
     visit[root] = True
     queue.append(root)
     qlen += 1
     yield root
     current = root
     nexti = 0
     while True:
         nonext = True
         for i in xrange(nexti, n):
             if matrix[current][i] != 0 and not visit[i]:
                 visit[i] = True
                 queue.append(i)
                 qlen += 1
                 current = i
                 yield current
                 nonext = False
                 nexti = 0
                 break
         if nonext:
             nexti = queue.pop()
             qlen -= 1
             if qlen == 0:
                 raise StopIteration
             else:
                 current = queue[-1]
 
 
 def A():
     test = False
     sample = """"""2
 3
 1 3 -5
 -2 4 1
 5
 1 2 3 4 5
 1 0 1 0 1""""""
     infile = iter(sample.split('\n'))
     if not test:
         infile = open(""A-large.in"",'r')
     outfile = open(""A-large.out"",'w')
     N = int(infile.next())
     for n in xrange(N):
         case_out = ""Case #%d: ""%(n)
         ln = int(infile.next())
         v1 = [int(x) for x in infile.next().split()]
         v2 = [int(x) for x in infile.next().split()]
         v1.sort()
         v2.sort(reverse=True)
         #print v1
         #print v2
         rslt = sum([v1[i]*v2[i] for i in xrange(ln)])
         case_out = ""Case #%d: %d""%(n+1, rslt)
         print case_out
         outfile.write(case_out+'\n')
     if not test:
         infile.close()
     outfile.close()
 
 if __name__ == '__main__':
     import time
     start = time.clock()
     A()
     print ""done in %f""%(time.clock()-start)
",gcj/2008/32016/graygrass/24484/1/extracted/A.py,5196,228,621,Python,32016,1,24484,graygrass,2008
5924,A.py,"#!/usr/bin/env python
 #coding=utf-8
 #!/usr/bin/env python
 #coding=utf-8
 
 import math
 
 
 def seive(n):
     assert n > 1
     pl = [2]
     ln = (n-1)/2
     cad = [1]*ln
     for i in xrange(ln):
         if cad[i] == 1:
             p = 2*i+3
             pl.append(p)
             for j in xrange(i+p,ln, p):
                 cad[j] = 0
     return pl
 
 
 def is_prime(n, pl=[], ext=False):
     assert n > 0
     if n == 1:
         return False
     if n == 2:
         return True
     if n%2 == 0:
         return False
     if n in pl:
         return True
     if len(pl)>0 and n < pl[-1]:
         return False
     r = math.floor(n**0.5)
     for p in pl:
         if p > r:
             return True
         if n%p == 0:
             return False
     cad = len(pl) and (pl[-1]+2) or 3
     if ext and len(pl) == 0:
         pl.append(2)
     while cad <= r:
         if ext and is_prime(cad, pl, ext):
             pl.append(cad)
         if n%cad == 0:
             return False
         cad += 2
     return True
 
 
 def iter_factorial(n):
     assert n >= 0
     if n == 0:
         yield 1
         raise StopIteration
     i = 1
     m = 1
     while i < n:
         yield m
         i += 1
         m *= i
     raise StopIteration
 
 
 def iter_permutation(n, m):
     assert n >= 0
     assert m >= 0
     assert n >= m
     shadow = [1]*n
     nexti = 0
     cad = []
     while True:
         if nexti < n:
             if shadow[nexti] == 1:
                 shadow[nexti] = 0
                 cad.append(nexti)
                 if len(cad) == m:
                     yield cad
                     nexti = cad.pop()
                     shadow[nexti] = 1
                 else:
                     nexti = -1
             nexti += 1
         elif len(cad) == 0:
             break
         else:
             nexti = cad.pop()
             shadow[nexti] = 1
             nexti += 1
     raise StopIteration
 
 
 def iter_combination(n, m):
     assert n >= 0
     assert m >= 0
     assert n >= m
     if m == n:
         yield range(n)
         raise StopIteration
     shadow = [1]*n
     static = range(n)
     nexti = 0
     cad = []
     ln = 0
     while True:
         if nexti < n:
             if shadow[nexti] == 1:
                 shadow[nexti] = 0
                 cad.append(nexti)
                 ln += 1
                 if ln == m:
                     yield cad
                     nexti = cad.pop()
                     ln -= 1
                     shadow[nexti] = 1
             nexti += 1
         elif ln == 0:
             break
         else:
             nexti = cad.pop()
             ln -= 1
             shadow[nexti] = 1
             if m-ln > n-nexti-1:
                 nexti = n
             else:
                 nexti += 1
     raise StopIteration
 
 
 def iter_BFS(matrix, root=0):
     n = len(matrix)
     assert n > 0
     for i in xrange(n):
         assert len(matrix[i]) == n
     visit = [False]*n
     queue = []
     qlen = 0
     visit[root] = True
     queue.append(root)
     qlen += 1
     yield root
     while qlen != 0:
         current = queue.pop(0)
         qlen -= 1
         for i in xrange(n):
             if matrix[current][i] != 0:
                 if not visit[i]:
                     visit[i] = True
                     queue.append(i)
                     qlen += 1
                     yield i
     raise StopIteration
 
 
 def iter_DFS(matrix, root=0):
     n = len(matrix)
     assert n > 0
     for i in xrange(n):
         assert len(matrix[i]) == n
     visit = [False]*n
     queue = []
     qlen = 0
     visit[root] = True
     queue.append(root)
     qlen += 1
     yield root
     current = root
     nexti = 0
     while True:
         nonext = True
         for i in xrange(nexti, n):
             if matrix[current][i] != 0 and not visit[i]:
                 visit[i] = True
                 queue.append(i)
                 qlen += 1
                 current = i
                 yield current
                 nonext = False
                 nexti = 0
                 break
         if nonext:
             nexti = queue.pop()
             qlen -= 1
             if qlen == 0:
                 raise StopIteration
             else:
                 current = queue[-1]
 
 
 def A():
     test = False
     sample = """"""2
 3
 1 3 -5
 -2 4 1
 5
 1 2 3 4 5
 1 0 1 0 1""""""
     infile = iter(sample.split('\n'))
     if not test:
         infile = open(""A-small-attempt0.in"",'r')
     outfile = open(""A-small-attempt0.out"",'w')
     N = int(infile.next())
     for n in xrange(N):
         case_out = ""Case #%d: ""%(n)
         ln = int(infile.next())
         v1 = [int(x) for x in infile.next().split()]
         v2 = [int(x) for x in infile.next().split()]
         v1.sort()
         v2.sort(reverse=True)
         #print v1
         #print v2
         rslt = sum([v1[i]*v2[i] for i in xrange(ln)])
         case_out = ""Case #%d: %d""%(n+1, rslt)
         print case_out
         outfile.write(case_out+'\n')
     if not test:
         infile.close()
     outfile.close()
 
 if __name__ == '__main__':
     import time
     start = time.clock()
     A()
     print ""done in %f""%(time.clock()-start)
",gcj/2008/32016/graygrass/24484/0/extracted/A.py,5214,228,621,Python,32016,0,24484,graygrass,2008
20953,A.py,"#!/usr/bin/env python
 #coding=utf-8
 
 sample =""""""2
 5
 Yeehaw
 NSM
 Dont Ask
 B9
 Googol
 10
 Yeehaw
 Yeehaw
 Googol
 B9
 Googol
 NSM
 B9
 NSM
 Dont Ask
 Googol
 5
 Yeehaw
 NSM
 Dont Ask
 B9
 Googol
 7
 Googol
 Dont Ask
 NSM
 NSM
 Yeehaw
 Yeehaw
 Googol""""""
 
 #infile = iter(sample.split('\n'))
 infile = open(""A-large.in"",'r')
 outfile = open(""A-large.out"",'w')
 
 N = int(infile.next().strip())
 for n in xrange(N):
     S = int(infile.next().strip())
     engine = []
     for s in xrange(S):
         engine.append(infile.next().strip())
     Q = int(infile.next().strip())
     query = []
     for q in xrange(Q):
         query.append(engine.index(infile.next().strip()))
     mask = []
     switch = 0
     mask[:] = engine
     while len(query) > 0:
         i = query.pop(0)
         mask[i] = 0
         if not any(mask):
             query.insert(0,i)
             switch += 1
             mask[:] = engine
     print ""Case #%d: %d""%(n+1,switch)
     outfile.write(""Case #%d: %d\n""%(n+1,switch))
 
 infile.close()
 outfile.close()",gcj/2008/32013/graygrass/24480/1/extracted/A.py,1043,65,116,Python,32013,1,24480,graygrass,2008
20954,A.py,"#!/usr/bin/env python
 #coding=utf-8
 
 sample =""""""2
 5
 Yeehaw
 NSM
 Dont Ask
 B9
 Googol
 10
 Yeehaw
 Yeehaw
 Googol
 B9
 Googol
 NSM
 B9
 NSM
 Dont Ask
 Googol
 5
 Yeehaw
 NSM
 Dont Ask
 B9
 Googol
 7
 Googol
 Dont Ask
 NSM
 NSM
 Yeehaw
 Yeehaw
 Googol""""""
 
 #infile = iter(sample.split('\n'))
 infile = open(""A-small-attempt1.in"",'r')
 outfile = open(""A-small-attempt1.out"",'w')
 
 N = int(infile.next().strip())
 for n in xrange(N):
     S = int(infile.next().strip())
     engine = []
     for s in xrange(S):
         engine.append(infile.next().strip())
     Q = int(infile.next().strip())
     query = []
     for q in xrange(Q):
         query.append(engine.index(infile.next().strip()))
     mask = []
     switch = 0
     mask[:] = engine
     while len(query) > 0:
         i = query.pop(0)
         mask[i] = 0
         if not any(mask):
             query.insert(0,i)
             switch += 1
             mask[:] = engine
     print ""Case #%d: %d""%(n+1,switch)
     outfile.write(""Case #%d: %d\n""%(n+1,switch))
 
 infile.close()
 outfile.close()",gcj/2008/32013/graygrass/24480/0/extracted/A.py,1061,65,116,Python,32013,0,24480,graygrass,2008
20955,C.py,"#!/usr/bin/env python
 #coding=utf-8
 
 from math import *
 
 sample = """"""5
 0.25 1.0 0.1 0.01 0.5
 0.25 1.0 0.1 0.01 0.9
 0.00001 10000 0.00001 0.00001 1000
 0.4 10000 0.00001 0.00001 700
 1 100 1 1 10""""""
 
 
 def area(r,x,y,d):
     R = lambda p: sqrt(p[0]**2+p[1]**2)
     p1 = [x-d,y-d]
     p2 = [x+d,y-d]
     p3 = [x+d,y+d]
     p4 = [x-d,y+d]
     if R(p1) >= r:
         return 0
     elif R(p2) >= r:
         p12 = [sqrt(r**2-(y-d)**2),y-d]
         p14 = [x-d,sqrt(r**2-(x-d)**2)]
         phi = atan(p14[1]/p14[0])-atan(p12[1]/p12[0])
         a = (r**2*phi-r**2*sin(phi))/2.
         a += (p12[0]-p1[0])*(p14[1]-p1[1])/2.
         return a
     elif R(p4) >= r:
         p23 = [x+d,sqrt(r**2-(x+d)**2)]
         p14 = [x-d, sqrt(r**2-(x-d)**2)]
         phi = atan(p14[1]/p14[0])-atan(p23[1]/p23[0])
         a = (r**2*phi-r**2*sin(phi))/2.
         a += (p14[1]-p1[1]+p23[1]-p2[1])*d
         return a
     elif R(p3) >= r:
         p23 = [x+d,sqrt(r**2-(x+d)**2)]
         p34 = [sqrt(r**2-(y+d)**2),y+d]
         phi = atan(p34[1]/p34[0])-atan(p23[1]/p23[0])
         a = (r**2*phi-r**2*sin(phi))/2.
         a += 4*d**2 - (p3[0]-p34[0])*(p3[1]-p23[1])/2.
         return a
     else:
         return 4*d**2
         
 infile = iter(sample.split('\n'))
 infile = open(""C-large.in"",'r')
 outfile = open(""C-large.out"",'w')
 
 N = int(infile.next().strip())
 for n in xrange(N):
     f,R,t,r,g = [float(x) for x in infile.next().strip().split()]
     AA = pi*R**2/8.
     gg = g-2*f
     rr = r+f
     RR = R-t-f
     dd = 2*rr+gg
     p = 0
     if gg <= 0 or RR <= 0:
         p = 1.
     else:
         ii = RR/(sqrt(2)*dd)
         aoh = 0
         for i in xrange(int(floor(ii))):
             aoh += gg*gg/2.
             LL = sqrt(RR**2-((i+1)*dd)**2)-(i+1)*dd
             k = floor(LL/dd)
             aoh += k*gg*gg
             xx = (i+1)*dd-dd/2
             yy = xx+(k+1)*dd
             ta = area(RR,xx,yy,gg/2)
             while ta != 0:
                 aoh += ta
                 yy += dd
                 ta = area(RR,xx,yy,gg/2)
         cii = ceil(ii)
         if cii != ii:
             xx = cii*dd-dd/2
             yy = xx
             ta = area(RR,xx,yy,gg/2)/2.
             while ta != 0:
                 aoh += ta
                 yy += dd
                 ta = area(RR,xx,yy,gg/2)
         #print aoh,AA
         p = 1.-aoh/AA
     print ""Case #%d: %1.6f""%(n+1,p)
     outfile.write(""Case #%d: %1.6f\n""%(n+1,p))
 
 infile.close()
 outfile.close()
                 
             
             
             
     
",gcj/2008/32013/graygrass/24479/1/extracted/C.py,2557,97,269,Python,32013,1,24479,graygrass,2008
20956,C.py,"#!/usr/bin/env python
 #coding=utf-8
 
 from math import *
 
 sample = """"""5
 0.25 1.0 0.1 0.01 0.5
 0.25 1.0 0.1 0.01 0.9
 0.00001 10000 0.00001 0.00001 1000
 0.4 10000 0.00001 0.00001 700
 1 100 1 1 10""""""
 
 
 def area(r,x,y,d):
     R = lambda p: sqrt(p[0]**2+p[1]**2)
     p1 = [x-d,y-d]
     p2 = [x+d,y-d]
     p3 = [x+d,y+d]
     p4 = [x-d,y+d]
     if R(p1) >= r:
         return 0
     elif R(p2) >= r:
         p12 = [sqrt(r**2-(y-d)**2),y-d]
         p14 = [x-d,sqrt(r**2-(x-d)**2)]
         phi = atan(p14[1]/p14[0])-atan(p12[1]/p12[0])
         a = (r**2*phi-r**2*sin(phi))/2.
         a += (p12[0]-p1[0])*(p14[1]-p1[1])/2.
         return a
     elif R(p4) >= r:
         p23 = [x+d,sqrt(r**2-(x+d)**2)]
         p14 = [x-d, sqrt(r**2-(x-d)**2)]
         phi = atan(p14[1]/p14[0])-atan(p23[1]/p23[0])
         a = (r**2*phi-r**2*sin(phi))/2.
         a += (p14[1]-p1[1]+p23[1]-p2[1])*d
         return a
     elif R(p3) >= r:
         p23 = [x+d,sqrt(r**2-(x+d)**2)]
         p34 = [sqrt(r**2-(y+d)**2),y+d]
         phi = atan(p34[1]/p34[0])-atan(p23[1]/p23[0])
         a = (r**2*phi-r**2*sin(phi))/2.
         a += 4*d**2 - (p3[0]-p34[0])*(p3[1]-p23[1])/2.
         return a
     else:
         return 4*d**2
         
 infile = iter(sample.split('\n'))
 infile = open(""C-small-attempt0.in"",'r')
 outfile = open(""C-small-attempt0.out"",'w')
 
 N = int(infile.next().strip())
 for n in xrange(N):
     f,R,t,r,g = [float(x) for x in infile.next().strip().split()]
     AA = pi*R**2/8.
     gg = g-2*f
     rr = r+f
     RR = R-t-f
     dd = 2*rr+gg
     p = 0
     if gg <= 0 or RR <= 0:
         p = 1.
     else:
         ii = RR/(sqrt(2)*dd)
         aoh = 0
         for i in xrange(int(floor(ii))):
             aoh += gg*gg/2.
             LL = sqrt(RR**2-((i+1)*dd)**2)-(i+1)*dd
             k = floor(LL/dd)
             aoh += k*gg*gg
             xx = (i+1)*dd-dd/2
             yy = xx+(k+1)*dd
             ta = area(RR,xx,yy,gg/2)
             while ta != 0:
                 aoh += ta
                 yy += dd
                 ta = area(RR,xx,yy,gg/2)
         cii = ceil(ii)
         if cii != ii:
             xx = cii*dd-dd/2
             yy = xx
             ta = area(RR,xx,yy,gg/2)/2.
             while ta != 0:
                 aoh += ta
                 yy += dd
                 ta = area(RR,xx,yy,gg/2)
         #print aoh,AA
         p = 1.-aoh/AA
     print ""Case #%d: %1.6f""%(n+1,p)
     outfile.write(""Case #%d: %1.6f\n""%(n+1,p))
 
 infile.close()
 outfile.close()
                 
             
             
             
     
",gcj/2008/32013/graygrass/24479/0/extracted/C.py,2575,97,269,Python,32013,0,24479,graygrass,2008
20957,B.py,"#!/usr/bin/env python
 #coding=utf-8
 
 import time
 
 sample = """"""1
 1
 2 2
 12:04 12:05
 12:07 12:10
 12:03 12:06
 12:10 12:11""""""
 
 #infile = iter(sample.split('\n'))
 infile = open('B-large.in','r')
 outfile = open('B-large.out','w')
 
 def m(tt):
     return reduce(lambda x,y: x*60+y, map(lambda x: int(x), tt.split(':')))
 
 def scmp(x,y):
     if x[0] < y[0]:
         return -1
     elif x[0] > y[0]:
         return 1
     else:
         if x[1] == 'da' or x[1] == 'db':
             return 1
         else:
             return -1
         
 
 N = int(infile.next().strip())
 for n in xrange(N):
     axis = []
     t = int(infile.next().strip())
     nn = infile.next().strip().split()
     NA, NB = [int(x) for x in nn]
     for na in xrange(NA):
         trip = infile.next().strip().split()
         axis.append((m(trip[0]),'da'))
         axis.append((m(trip[1]),'ab'))
     for nb in xrange(NB):
         trip = infile.next().strip().split()
         axis.append((m(trip[0]),'db'))
         axis.append((m(trip[1]),'aa'))
     axis.sort(cmp=scmp)
     docka = []
     dockb = []
     starta = 0
     startb = 0
     for e in axis:
         if e[1] == 'da':
             if len(docka) == 0:
                 starta += 1
             elif docka[0]+t > e[0]:
                 starta += 1
             else:
                 docka.pop(0)
         elif e[1] == 'db':
             if len(dockb) == 0:
                 startb += 1
             elif dockb[0]+t > e[0]:
                 startb += 1
             else:
                 dockb.pop(0)
         elif e[1] == 'aa':
             docka.append(e[0])
         elif e[1] == 'ab':
             dockb.append(e[0])
     print ""Case #%d: %d %d""%(n+1, starta, startb)
     outfile.write(""Case #%d: %d %d\n""%(n+1, starta, startb))
 
 infile.close()
 outfile.close()    
",gcj/2008/32013/graygrass/24481/1/extracted/B.py,1827,76,190,Python,32013,1,24481,graygrass,2008
20958,B.py,"#!/usr/bin/env python
 #coding=utf-8
 
 import time
 
 sample = """"""1
 1
 2 2
 12:04 12:05
 12:07 12:10
 12:03 12:06
 12:10 12:11""""""
 
 #infile = iter(sample.split('\n'))
 infile = open('B-small-attempt2.in','r')
 outfile = open('B-small-attempt2.out','w')
 
 def m(tt):
     return reduce(lambda x,y: x*60+y, map(lambda x: int(x), tt.split(':')))
 
 def scmp(x,y):
     if x[0] < y[0]:
         return -1
     elif x[0] > y[0]:
         return 1
     else:
         if x[1] == 'da' or x[1] == 'db':
             return 1
         else:
             return -1
         
 
 N = int(infile.next().strip())
 for n in xrange(N):
     axis = []
     t = int(infile.next().strip())
     nn = infile.next().strip().split()
     NA, NB = [int(x) for x in nn]
     for na in xrange(NA):
         trip = infile.next().strip().split()
         axis.append((m(trip[0]),'da'))
         axis.append((m(trip[1]),'ab'))
     for nb in xrange(NB):
         trip = infile.next().strip().split()
         axis.append((m(trip[0]),'db'))
         axis.append((m(trip[1]),'aa'))
     axis.sort(cmp=scmp)
     docka = []
     dockb = []
     starta = 0
     startb = 0
     for e in axis:
         if e[1] == 'da':
             if len(docka) == 0:
                 starta += 1
             elif docka[0]+t > e[0]:
                 starta += 1
             else:
                 docka.pop(0)
         elif e[1] == 'db':
             if len(dockb) == 0:
                 startb += 1
             elif dockb[0]+t > e[0]:
                 startb += 1
             else:
                 dockb.pop(0)
         elif e[1] == 'aa':
             docka.append(e[0])
         elif e[1] == 'ab':
             dockb.append(e[0])
     print ""Case #%d: %d %d""%(n+1, starta, startb)
     outfile.write(""Case #%d: %d %d\n""%(n+1, starta, startb))
 
 infile.close()
 outfile.close()    
",gcj/2008/32013/graygrass/24481/0/extracted/B.py,1845,76,190,Python,32013,0,24481,graygrass,2008
7588,c.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'c'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 3 4
 1 2 3 4
 2 3 4 6
 6 5 4 3
 3 3
 5 5 5
 4 4 6
 4 5 4
 5 2
 1 1
 2 2
 5 4
 4 4
 4 1
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         nn, kk = map(lambda x: int(x), input[iLine].strip().split())
         iLine += 1
         stk = []
         for i in range(nn):
             stk.append(map(lambda x: int(x), input[iLine].strip().split()))
             iLine += 1
         print stk
 
         ##########################
         # Solve the case here
         intsc = []
         for i in range(nn):
             intsc.append([False]*nn)
         for i in range(nn-1):
             for j in range(i+1,nn):
                 for k in range(kk-1):
                     if 0 >= (stk[i][k] - stk[j][k])*(stk[i][k+1] - stk[j][k+1]):
                         intsc[i][j] = True
                         intsc[j][i] = True
                         break
         
         for i in intsc:
             print i
         
         result = 1
         ss = []
         for i in range(nn):
             ns = [[i]]
             for s in ss:
                 flag = True
                 for j in s:
                     if intsc[i][j] == False:
                         flag = False
                         break
                 if flag:
                     ts = []
                     ts[:] = s[:]
                     ts.append(i)
                     if len(ts) > result:
                         result = len(ts)
                     ns.append(ts)
             ss.extend(ns)
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/204113/graygrass/244101/0/extracted/c.py,2751,112,302,Python,204113,0,244101,graygrass,2009
7589,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'aa'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 2
 10
 11
 3
 001
 100
 010
 4
 1110
 1100
 1100
 1000
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         nn = int(input[iLine].strip())
         iLine += 1
         N = []
         for i in range(nn):
             ss = input[iLine].strip()
             N.append(-1)
             for i in range(nn-1, -1, -1):
                 if ss[i] == '1':
                     N[-1] = i
                     break
             iLine += 1
 #        print N
 
         ##########################
         # Solve the case here
         result = 0
         for i in range(nn-1):
             if N[i] <= i:
                 continue
             ii = -1
             for j in range(i+1, nn):
 #                print nn, j, len(N)
                 if N[j] <= i:
                     ii = j
                     break
             for k in range(ii, i, -1):
                 N[k], N[k-1] = N[k-1], N[k]
                 result += 1
                     
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/204113/graygrass/241102/1/extracted/a.py,2204,96,244,Python,204113,1,241102,graygrass,2009
7590,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'a'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 2
 10
 11
 3
 001
 100
 010
 4
 1110
 1100
 1100
 1000
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         nn = int(input[iLine].strip())
         iLine += 1
         N = []
         for i in range(nn):
             ss = input[iLine].strip()
             N.append(-1)
             for i in range(nn-1, -1, -1):
                 if ss[i] == '1':
                     N[-1] = i
                     break
             iLine += 1
 #        print N
 
         ##########################
         # Solve the case here
         result = 0
         for i in range(nn-1):
             if N[i] <= i:
                 continue
             ii = -1
             for j in range(i+1, nn):
 #                print nn, j, len(N)
                 if N[j] <= i:
                     ii = j
                     break
             for k in range(ii, i, -1):
                 N[k], N[k-1] = N[k-1], N[k]
                 result += 1
                     
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/204113/graygrass/241102/0/extracted/a.py,2203,96,244,Python,204113,0,241102,graygrass,2009
7591,tmp.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'a'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         nn = int(input[iLine].strip())
         iLine += 1
         for i in range(nn):
             input[iLine].strip()
             iLine += 1
         
 
         ##########################
         # Solve the case here
         result = 0
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/204113/graygrass/250101/0/extracted/tmp.py,1553,65,165,Python,204113,0,250101,graygrass,2009
28852,b.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'bb'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""5
 3 3
 9 6 3
 5 9 6
 3 5 9
 1 10
 0 1 2 3 4 5 6 7 8 7
 2 3
 7 6 7
 7 6 7
 5 5
 1 2 3 4 5
 2 9 3 9 6
 3 3 0 8 7
 4 9 8 9 8
 5 6 7 8 9
 2 13
 8 8 8 8 8 8 8 8 8 8 8 8 8
 8 8 8 8 8 8 8 8 8 8 8 8 8
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         H, W = map(lambda x: int(x), input[iLine].strip().split())
         iLine += 1
         b = []
         for h in range(H):
             b.append(map(lambda x: int(x), input[iLine].strip().split()))
             iLine += 1
             
                 
 
         ##########################
         # Solve the case here
         result = []
         
         bb = [[]]*H*W
         sink = 0
         for h in range(H):
             for w in range(W):
                 mina = 10000
                 minh,minw = -1,-1
                 if h > 0 and mina > b[h-1][w]:
                     minh,minw = h-1,w
                     mina = b[minh][minw]
                 if w > 0 and mina > b[h][w-1]:
                     minh,minw = h,w-1
                     mina = b[minh][minw]
                 if w < W-1 and mina > b[h][w+1]:
                     minh,minw = h,w+1
                     mina = b[minh][minw]
                 if h < H-1 and mina > b[h+1][w]:
                     minh,minw = h+1,w
                     mina = b[minh][minw]
                                     
 #                print minh,minw
                 if b[h][w] > mina:
                     bb[h*W+w] = [minh,minw,-1]
                 else:
                     bb[h*W+w] = [-1,-1,sink]
                     sink += 1
                     
         for i in range(H*W):
             ss = []
             j = i
             while -1==bb[j][2]:
                 ss.append(bb[j])
                 j = bb[j][0]*W+bb[j][1]
             while ss != []:
                 e = ss.pop(-1)
                 e[2] = bb[j][2]
         
         dd = {}
         c = ord('a')
         for h in range(H):
             rslt = []
             for w in range(W):
                 e = bb[h*W+w]
 #                print (e[0],e[1]),
                 if e[2] not in dd:
                     dd[e[2]] = chr(c)
                     c+=1
                 rslt.append(dd[e[2]])
             result.append("" "".join(rslt))
 #            print
                 
                     
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1)
             for line in output[i]:
                 print >> ofile, line
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1)
         for line in output[i]:
             print line
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/90101/graygrass/111101/1/extracted/b.py,3667,143,429,Python,90101,1,111101,graygrass,2009
28853,b.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'b'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""5
 3 3
 9 6 3
 5 9 6
 3 5 9
 1 10
 0 1 2 3 4 5 6 7 8 7
 2 3
 7 6 7
 7 6 7
 5 5
 1 2 3 4 5
 2 9 3 9 6
 3 3 0 8 7
 4 9 8 9 8
 5 6 7 8 9
 2 13
 8 8 8 8 8 8 8 8 8 8 8 8 8
 8 8 8 8 8 8 8 8 8 8 8 8 8
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         H, W = map(lambda x: int(x), input[iLine].strip().split())
         iLine += 1
         b = []
         for h in range(H):
             b.append(map(lambda x: int(x), input[iLine].strip().split()))
             iLine += 1
             
                 
 
         ##########################
         # Solve the case here
         result = []
         
         bb = [[]]*H*W
         sink = 0
         for h in range(H):
             for w in range(W):
                 mina = 10000
                 minh,minw = -1,-1
                 if h > 0 and mina > b[h-1][w]:
                     minh,minw = h-1,w
                     mina = b[minh][minw]
                 if w > 0 and mina > b[h][w-1]:
                     minh,minw = h,w-1
                     mina = b[minh][minw]
                 if w < W-1 and mina > b[h][w+1]:
                     minh,minw = h,w+1
                     mina = b[minh][minw]
                 if h < H-1 and mina > b[h+1][w]:
                     minh,minw = h+1,w
                     mina = b[minh][minw]
                                     
 #                print minh,minw
                 if b[h][w] > mina:
                     bb[h*W+w] = [minh,minw,-1]
                 else:
                     bb[h*W+w] = [-1,-1,sink]
                     sink += 1
                     
         for i in range(H*W):
             ss = []
             j = i
             while -1==bb[j][2]:
                 ss.append(bb[j])
                 j = bb[j][0]*W+bb[j][1]
             while ss != []:
                 e = ss.pop(-1)
                 e[2] = bb[j][2]
         
         dd = {}
         c = ord('a')
         for h in range(H):
             rslt = []
             for w in range(W):
                 e = bb[h*W+w]
 #                print (e[0],e[1]),
                 if e[2] not in dd:
                     dd[e[2]] = chr(c)
                     c+=1
                 rslt.append(dd[e[2]])
             result.append("" "".join(rslt))
 #            print
                 
                     
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1)
             for line in output[i]:
                 print >> ofile, line
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1)
         for line in output[i]:
             print line
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/90101/graygrass/111101/0/extracted/b.py,3666,143,429,Python,90101,0,111101,graygrass,2009
28854,c.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'cc'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 elcomew elcome to code jam
 wweellccoommee to code qps jam
 welcome to codejam
 """"""
 test_data = None
 
 S = ""welcome to code jam""
 SS = []
 for i in xrange(len(S)+1):
     SS.append(S[:i])
 L = len(SS)
 #print SS
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         s = input[iLine].strip()
         iLine+=1
                 
 
         ##########################
         # Solve the case here
         result = 0
         
         cnt = [0]*L
         cnt[0] = 1
         print s
         for c in s:
             for i in range(1,L):
                 if SS[i-1]+c == SS[i]:
                     cnt[i] += cnt[i-1]
 #        print cnt
         result = cnt[-1]
         
         output.append(""%04d""%(result % 10000))
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/90101/graygrass/122101/1/extracted/c.py,1942,84,218,Python,90101,1,122101,graygrass,2009
28855,c.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'c'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 elcomew elcome to code jam
 wweellccoommee to code qps jam
 welcome to codejam
 """"""
 test_data = None
 
 S = ""welcome to code jam""
 SS = []
 for i in xrange(len(S)+1):
     SS.append(S[:i])
 L = len(SS)
 #print SS
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         s = input[iLine].strip()
         iLine+=1
                 
 
         ##########################
         # Solve the case here
         result = 0
         
         cnt = [0]*L
         cnt[0] = 1
         print s
         for c in s:
             for i in range(1,L):
                 if SS[i-1]+c == SS[i]:
                     cnt[i] += cnt[i-1]
 #        print cnt
         result = cnt[-1]
         
         output.append(""%04d""%(result % 10000))
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/90101/graygrass/122101/0/extracted/c.py,1941,84,218,Python,90101,0,122101,graygrass,2009
28856,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'aa'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3 5 4
 abc
 bca
 dac
 dbc
 cba
 (ab)(bc)(ca)
 abc
 (abc)(abc)(abc)
 (zyx)bc
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     L, D, N = map(lambda x: int(x), input[iLine].strip().split())
     iLine += 1
     
     w = []
     for i in range(D):
         w.append(input[iLine].strip())
         iLine += 1
 #    print w
     
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         c = input[iLine].strip()
         iLine += 1
         cl = []
         p = 0
         for i in range(L):
             if '(' != c[p]:
                 cl.append(c[p])
                 p += 1
             else:
                 ep = c.find(')', p)
                 cl.append(c[p+1:ep])
                 p = ep + 1
 #        print cl
         
 
         ##########################
         # Solve the case here
         result = 0
         
         for s in w:
             flag = 1
             for i in range(L):
                 if s[i] not in cl[i]:
                     flag = 0
                     break
             result += flag
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/90101/graygrass/116101/1/extracted/a.py,2196,98,242,Python,90101,1,116101,graygrass,2009
28857,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'a'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3 5 4
 abc
 bca
 dac
 dbc
 cba
 (ab)(bc)(ca)
 abc
 (abc)(abc)(abc)
 (zyx)bc
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     L, D, N = map(lambda x: int(x), input[iLine].strip().split())
     iLine += 1
     
     w = []
     for i in range(D):
         w.append(input[iLine].strip())
         iLine += 1
 #    print w
     
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         c = input[iLine].strip()
         iLine += 1
         cl = []
         p = 0
         for i in range(L):
             if '(' != c[p]:
                 cl.append(c[p])
                 p += 1
             else:
                 ep = c.find(')', p)
                 cl.append(c[p+1:ep])
                 p = ep + 1
 #        print cl
         
 
         ##########################
         # Solve the case here
         result = 0
         
         for s in w:
             flag = 1
             for i in range(L):
                 if s[i] not in cl[i]:
                     flag = 0
                     break
             result += flag
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/90101/graygrass/116101/0/extracted/a.py,2195,98,242,Python,90101,0,116101,graygrass,2009
51056,b.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'bb'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 3
 3 0 -4 0 0 3
 -3 -2 -1 3 0 0
 -3 -1 2 0 3 0
 3
 -5 0 0 1 0 0
 -7 0 0 1 0 0
 -6 3 0 1 0 0
 4
 1 2 3 1 2 3
 3 2 1 3 2 1
 1 0 0 0 0 -1
 0 10 0 0 -10 -1
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         nn = int(input[iLine].strip())
         iLine += 1
         x = []
         y = []
         z = []
         vx = []
         vy = []
         vz = []
         for i in range(nn):
             _x, _y, _z, _vx, _vy, _vz = map(lambda a: int(a), input[iLine].strip().split())
             iLine += 1
             x.append(_x)
             y.append(_y)
             z.append(_z)
             vx.append(_vx)
             vy.append(_vy)
             vz.append(_vz)
 #        print x
 #        print y
 #        print z
 #        print vx
 #        print vy
 #        print vz
 
         ##########################
         # Solve the case here
         result = 0
         
         NcxA = 0
         NcxB = 0
         NcyA = 0
         NcyB = 0
         NczA = 0
         NczB = 0
         for i in range(nn):
             NcxA += vx[i]
             NcxB += x[i]
             NcyA += vy[i]
             NcyB += y[i]
             NczA += vz[i]
             NczB += z[i]
         
         NcxA /= 1.*nn
         NcxB /= 1.*nn
         NcyA /= 1.*nn
         NcyB /= 1.*nn
         NczA /= 1.*nn
         NczB /= 1.*nn
         
         NA = NcxA**2 + NcyA**2 + NczA**2
         NB = (NcxA*NcxB + NcyA*NcyB + NczA*NczB)*2
         NC = NcxB**2 + NcyB**2 + NczB**2
 #        print NA, NB, NC
         if 0 == NA:
             t = 0
         else:
             t = -NB/(2.*NA)
         if t < 0:
             t = 0
 #        print t
         Nd2 = NA*t**2 + NB*t + NC
         if Nd2 < 0:
             Nd2 = 0
 #        d = (Nd2/nn**2)**0.5
         d = Nd2**0.5
         result = ""%.8f %.8f""%(d, t)
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/189252/graygrass/156117/1/extracted/b.py,3073,135,411,Python,189252,1,156117,graygrass,2009
51057,b.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'b'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""3
 3
 3 0 -4 0 0 3
 -3 -2 -1 3 0 0
 -3 -1 2 0 3 0
 3
 -5 0 0 1 0 0
 -7 0 0 1 0 0
 -6 3 0 1 0 0
 4
 1 2 3 1 2 3
 3 2 1 3 2 1
 1 0 0 0 0 -1
 0 10 0 0 -10 -1
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         nn = int(input[iLine].strip())
         iLine += 1
         x = []
         y = []
         z = []
         vx = []
         vy = []
         vz = []
         for i in range(nn):
             _x, _y, _z, _vx, _vy, _vz = map(lambda a: int(a), input[iLine].strip().split())
             iLine += 1
             x.append(_x)
             y.append(_y)
             z.append(_z)
             vx.append(_vx)
             vy.append(_vy)
             vz.append(_vz)
 #        print x
 #        print y
 #        print z
 #        print vx
 #        print vy
 #        print vz
 
         ##########################
         # Solve the case here
         result = 0
         
         NcxA = 0
         NcxB = 0
         NcyA = 0
         NcyB = 0
         NczA = 0
         NczB = 0
         for i in range(nn):
             NcxA += vx[i]
             NcxB += x[i]
             NcyA += vy[i]
             NcyB += y[i]
             NczA += vz[i]
             NczB += z[i]
         
         NcxA /= 1.*nn
         NcxB /= 1.*nn
         NcyA /= 1.*nn
         NcyB /= 1.*nn
         NczA /= 1.*nn
         NczB /= 1.*nn
         
         NA = NcxA**2 + NcyA**2 + NczA**2
         NB = (NcxA*NcxB + NcyA*NcyB + NczA*NczB)*2
         NC = NcxB**2 + NcyB**2 + NczB**2
 #        print NA, NB, NC
         if 0 == NA:
             t = 0
         else:
             t = -NB/(2.*NA)
         if t < 0:
             t = 0
 #        print t
         Nd2 = NA*t**2 + NB*t + NC
         if Nd2 < 0:
             Nd2 = 0
 #        d = (Nd2/nn**2)**0.5
         d = Nd2**0.5
         result = ""%.8f %.8f""%(d, t)
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/189252/graygrass/156117/0/extracted/b.py,3072,135,411,Python,189252,0,156117,graygrass,2009
51058,c.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'c'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""2
 8 1
 3
 20 3
 3 6 14
 """"""
 test_data = None
 
 
 #def solve(p, q, ql):
 def solve(p, q, ql, ci):
     print p, q, ql, ci
 #    res = p-1
     if ql[ci] == 0 or ql[ci] == p-1:
         res = p-2
     else:
         res = p-1
         
 #    res = p - 1
         
     if 1 == q:
 #        print ""r:"",res
         return res
 #    ci = -1
     mm = p
 #    for i in range(q):
 #        tt = abs(ql[i] - p/2.)
 #        if mm >= tt:
 #            mm = tt
 #            ci = i
 #    print ""ci %d, ql[ci] %d""%(ci, ql[ci])
     qla = ql[:ci]
     qa = ci
     pa = ql[ci]
     if 0 != qa:
 #        res += solve(pa, qa, qla)
         mina = -1
         for cci in range(qa):
             tres = solve(pa, qa, qla, cci)
             if -1 == mina or mina > tres:
                 mina = tres
         res += mina
     
     qb = q-1-ci
     pb = p-ql[ci]-1
     qlb = map(lambda x: x - ql[ci], ql[ci+1:])
     if 0 != qb:
 #        res += solve(pb, qb, qlb)
         minb = -1
         for cci in range(qb):
             tres = solve(pb, qb, qlb, cci)
             if -1 == minb or minb > tres:
                 minb = tres
         res += minb
     
 #    print ""res 2:"", res
     return res
             
 
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         P, Q = map(lambda x: int(x), input[iLine].strip().split())
         iLine += 1
         ql = map(lambda x: int(x)-1, input[iLine].strip().split())
         iLine += 1
         ql.sort()
 
         ##########################
         # Solve the case here
         result = 0
 #        result = solve(P, Q, ql)
         mint = -1
         for ci in range(Q):
             tres = solve(P, Q, ql, ci)
             if -1 == mint or mint > tres:
                 mint = tres
         result = tres
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/189252/graygrass/192120/0/extracted/c.py,2990,127,402,Python,189252,0,192120,graygrass,2009
51059,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'aa'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""4
 11001001
 cats
 zig
 111111111
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         ss = input[iLine].strip()
         iLine += 1
         print ss
         
         
 
         ##########################
         # Solve the case here
         result = 0
         dd = dict()
         nset = set(range(40))
         c = ss[0]
         dd[c] = 1
         nset.remove(1)
         for c in ss[1:]:
             if c not in dd:
                 mi = min(nset)
                 dd[c] = mi
                 nset.remove(mi)
         bb = len(dd)
         if 1 == bb:
             bb = 2
         sl = list(ss)
 #        sl.reverse()
 #        print ""base"", bb
         for x in sl:
             result *= bb
             result += dd[x]
 #            print dd[x]
         print ""r:"",result
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/189252/graygrass/171121/1/extracted/a.py,2061,90,226,Python,189252,1,171121,graygrass,2009
51060,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'a'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""4
 11001001
 cats
 zig
 111111111
 """"""
 test_data = None
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         ss = input[iLine].strip()
         iLine += 1
         print ss
         
         
 
         ##########################
         # Solve the case here
         result = 0
         dd = dict()
         nset = set(range(40))
         c = ss[0]
         dd[c] = 1
         nset.remove(1)
         for c in ss[1:]:
             if c not in dd:
                 mi = min(nset)
                 dd[c] = mi
                 nset.remove(mi)
         bb = len(dd)
         if 1 == bb:
             bb = 2
         sl = list(ss)
 #        sl.reverse()
 #        print ""base"", bb
         for x in sl:
             result *= bb
             result += dd[x]
 #            print dd[x]
         print ""r:"",result
         
         output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         for i in range(len(output)):
             print >> ofile, ""Case #%d:""%(i + 1), output[i]
         ofile.close()
     for i in range(len(output)):
         print ""Case #%d:""%(i + 1), output[i]
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/189252/graygrass/171121/0/extracted/a.py,2060,90,226,Python,189252,0,171121,graygrass,2009
59994,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'aa'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""2
 3
 (0.5 cool
   ( 1.000)
   (0.5 ))
 2
 anteater 1 cool
 cockroach 0
 13
 (0.2 furry
   (0.81 fast
     (0.3)
     (0.2)
   )
   (0.1 fishy
     (0.3 freshwater
       (0.01)
       (0.01)
     )
     (0.1)
   )
 )
 3
 beaver 2 furry freshwater
 trout 4 fast freshwater fishy rainbowy
 dodo 1 extinct
 """"""
 test_data = None
 
 
 class NODE(object):
     def __init__(self, p, f):
         self.p = p
         self.f = f
         self.first = None
         self.second = None
     
     def go(self, fset, p):
 #        print self.p, self.f
         p *= self.p
         if '' == self.f:
             return p
         else:
             if self.f in fset:
                 return self.first.go(fset, p)
             else:
                 return self.second.go(fset, p)
 
 
 def gen_tree(raw):
     assert(raw[0] == '(')
     assert(raw[-1] == ')')
     
     tmp = raw[1:-1].strip()
     pos = tmp.find('(')
     if -1 == pos:
         #leaf
         node = NODE(float(tmp), """")
         return node
     
     pos2 = tmp.find(' ')
     p = float(tmp[:pos2])
     f = tmp[pos2:pos].strip()
     node = NODE(p, f)
     nest = 0
     pos2 = -1
     for i in range(pos, len(tmp)):
         if '(' == tmp[i]:
             nest += 1
         elif ')' == tmp[i]:
             nest -= 1
         if 0 == nest:
             pos2 = i+1
             break
     node.first = gen_tree(tmp[pos:pos2])
     node.second = gen_tree(tmp[tmp.find('(', pos2):])
     return node
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         L = int(input[iLine].strip())
         iLine += 1
         raw_tree = """"
         for i in range(L):
             raw_tree += input[iLine].strip()
             iLine += 1
         raw_tree = raw_tree.strip()
 #        print raw_tree
         root = gen_tree(raw_tree)
         A = int(input[iLine].strip())
         iLine += 1
         aa = list()
         for i in range(A):
             aaline = input[iLine].strip()
             iLine += 1
             aaf = aaline.split()
             tset = set()
             k = int(aaf[1])
             for j in range(k):
                 tset.add(aaf[j+2])
             aa.append(tset)
 #        for _k in aa:
 #            print _k
         
 
         ##########################
         # Solve the case here
         output.append(case)
         output.append(A)
         for a in aa:
             result = root.go(a, 1)
             output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         ii = 0
         while ii < len(output):
             print >> ofile, ""Case #%d:""%(output[ii])
             ii += 1
             nn = output[ii]
             ii += 1
             for jj in range(nn):
                 print >> ofile, ""%.7f""%output[ii]
                 ii += 1        
         ofile.close()
         
     ii = 0
     while ii < len(output):
         print ""Case #%d:""%(output[ii])
         ii += 1
         nn = output[ii]
         ii += 1
         for jj in range(nn):
             print ""%.7f""%output[ii]
             ii += 1
             
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/186264/graygrass/171116/1/extracted/a.py,3995,176,439,Python,186264,1,171116,graygrass,2009
59995,a.py,"#!/usr/bin/env python
 #coding=utf-8
 
 problem = 'a'
 input_file_name = problem + "".in""
 output_file_name = problem + "".out""
 test_data = """"""2
 3
 (0.5 cool
   ( 1.000)
   (0.5 ))
 2
 anteater 1 cool
 cockroach 0
 13
 (0.2 furry
   (0.81 fast
     (0.3)
     (0.2)
   )
   (0.1 fishy
     (0.3 freshwater
       (0.01)
       (0.01)
     )
     (0.1)
   )
 )
 3
 beaver 2 furry freshwater
 trout 4 fast freshwater fishy rainbowy
 dodo 1 extinct
 """"""
 test_data = None
 
 
 class NODE(object):
     def __init__(self, p, f):
         self.p = p
         self.f = f
         self.first = None
         self.second = None
     
     def go(self, fset, p):
 #        print self.p, self.f
         p *= self.p
         if '' == self.f:
             return p
         else:
             if self.f in fset:
                 return self.first.go(fset, p)
             else:
                 return self.second.go(fset, p)
 
 
 def gen_tree(raw):
     assert(raw[0] == '(')
     assert(raw[-1] == ')')
     
     tmp = raw[1:-1].strip()
     pos = tmp.find('(')
     if -1 == pos:
         #leaf
         node = NODE(float(tmp), """")
         return node
     
     pos2 = tmp.find(' ')
     p = float(tmp[:pos2])
     f = tmp[pos2:pos].strip()
     node = NODE(p, f)
     nest = 0
     pos2 = -1
     for i in range(pos, len(tmp)):
         if '(' == tmp[i]:
             nest += 1
         elif ')' == tmp[i]:
             nest -= 1
         if 0 == nest:
             pos2 = i+1
             break
     node.first = gen_tree(tmp[pos:pos2])
     node.second = gen_tree(tmp[tmp.find('(', pos2):])
     return node
 
 def process(input):
     output = []
     iLine = 0
     N = int(input[iLine].strip())
     iLine += 1
     for case in range(1, N + 1):
         print ""Case %d""%case
         
         ##########################
         # Get source data here
         L = int(input[iLine].strip())
         iLine += 1
         raw_tree = """"
         for i in range(L):
             raw_tree += input[iLine].strip()
             iLine += 1
         raw_tree = raw_tree.strip()
 #        print raw_tree
         root = gen_tree(raw_tree)
         A = int(input[iLine].strip())
         iLine += 1
         aa = list()
         for i in range(A):
             aaline = input[iLine].strip()
             iLine += 1
             aaf = aaline.split()
             tset = set()
             k = int(aaf[1])
             for j in range(k):
                 tset.add(aaf[j+2])
             aa.append(tset)
 #        for _k in aa:
 #            print _k
         
 
         ##########################
         # Solve the case here
         output.append(case)
         output.append(A)
         for a in aa:
             result = root.go(a, 1)
             output.append(result)
         ##########################
         
         
     return output
 
 def main():
     input = None
     if test_data is None:
         ifile = open(input_file_name)
         input = ifile.readlines()
         ifile.close()
     else:
         input = test_data.split('\n')
         
     output = process(input)
     
     if test_data is None:
         ofile = open(output_file_name, 'w')
         ii = 0
         while ii < len(output):
             print >> ofile, ""Case #%d:""%(output[ii])
             ii += 1
             nn = output[ii]
             ii += 1
             for jj in range(nn):
                 print >> ofile, ""%.7f""%output[ii]
                 ii += 1        
         ofile.close()
         
     ii = 0
     while ii < len(output):
         print ""Case #%d:""%(output[ii])
         ii += 1
         nn = output[ii]
         ii += 1
         for jj in range(nn):
             print ""%.7f""%output[ii]
             ii += 1
             
         
     return len(output)
         
 if __name__ == ""__main__"":
     import time
     start = time.time()
     N = main()
     print ""Done in %f seconds""%(time.time() - start)
     print ""Average %f milliseconds""%((time.time() - start) * 1000 / N)
     
",gcj/2009/186264/graygrass/171116/0/extracted/a.py,3994,176,439,Python,186264,0,171116,graygrass,2009
3269,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 
 def coding(key, line):
     rslt = 0
     for c in line:
         rslt = rslt << 1
         rslt += c == key and 1 or 0
     return rslt
 
 
 def row_win(kk, vv):
     for v in vv:
         count = 0
         while v != 0:
             t = v & 1
             v = v >> 1
             if t == 1:
                 count += 1
             else:
                 count = 0
             if count == kk:
                 return True
     return False
 
 
 def colum_win(kk, vv):
     for i in xrange(len(vv) - kk + 1):
         if vv[i] != 0:
             t = reduce(lambda x, y: x & y, vv[i:i+kk])
             if 0 != t:
                 return True
     return False
 
 
 def diag1_win(kk, vv):
     for i in xrange(len(vv) - kk + 1):
         if vv[i] != 0:
             t = vv[i]
             for j in xrange(kk):
                 t &= vv[i + j] >> j
                 if t == 0:
                     break
             else:
                 return True
     return False
 
     
 def diag2_win(kk, vv):
     for i in xrange(len(vv) - kk + 1):
         if vv[i] != 0:
             t = vv[i]
             for j in xrange(kk):
                 t &= vv[i + j] << j
                 if t == 0:
                     break
             else:
                 return True
     return False
 
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N, K = [int(x) for x in case_input[0].split()]
     rt = [line.replace('.', '') for line in case_input[1:]]
     rcodes = [coding('R', line) for line in rt]
     bcodes = [coding('B', line) for line in rt]
     
     winc = 0
     if row_win(K, rcodes) or colum_win(K, rcodes) or diag1_win(K, rcodes) or diag2_win(K, rcodes):
         winc |= 1
     if row_win(K, bcodes) or colum_win(K, bcodes) or diag1_win(K, bcodes) or diag2_win(K, bcodes):
         winc |= 2
         
     if winc == 0:
         case_output += 'Neither'
     elif winc == 1:
         case_output += 'Red'
     elif winc == 2:
         case_output += 'Blue'
     elif winc == 3:
         case_output += 'Both'
     else:
         raise ""WRONG""
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 2
     for icase in range(1, T + 1):
         input = []
         N, K = [int(x) for x in data[iLine].split()]
         caseLineNum = N
         input.append(data[iLine])
         iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 7 3
 .......
 .......
 .......
 ...R...
 ...BB..
 ..BRB..
 .RRBR..
 6 4
 ......
 ......
 .R...R
 .R..BB
 .R.RBR
 RB.BBB
 4 4
 R...
 BR..
 BR..
 BR..
 3 3
 B..
 RB.
 RB.""""""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/544101/graygrass/567116/1/extracted/QA.py,3487,159,438,Python,544101,1,567116,graygrass,2010
3270,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 
 def coding(key, line):
     rslt = 0
     for c in line:
         rslt = rslt << 1
         rslt += c == key and 1 or 0
     return rslt
 
 
 def row_win(kk, vv):
     for v in vv:
         count = 0
         while v != 0:
             t = v & 1
             v = v >> 1
             if t == 1:
                 count += 1
             else:
                 count = 0
             if count == kk:
                 return True
     return False
 
 
 def colum_win(kk, vv):
     for i in xrange(len(vv) - kk + 1):
         if vv[i] != 0:
             t = reduce(lambda x, y: x & y, vv[i:i+kk])
             if 0 != t:
                 return True
     return False
 
 
 def diag1_win(kk, vv):
     for i in xrange(len(vv) - kk + 1):
         if vv[i] != 0:
             t = vv[i]
             for j in xrange(kk):
                 t &= vv[i + j] >> j
                 if t == 0:
                     break
             else:
                 return True
     return False
 
     
 def diag2_win(kk, vv):
     for i in xrange(len(vv) - kk + 1):
         if vv[i] != 0:
             t = vv[i]
             for j in xrange(kk):
                 t &= vv[i + j] << j
                 if t == 0:
                     break
             else:
                 return True
     return False
 
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N, K = [int(x) for x in case_input[0].split()]
     rt = [line.replace('.', '') for line in case_input[1:]]
     rcodes = [coding('R', line) for line in rt]
     bcodes = [coding('B', line) for line in rt]
     
     winc = 0
     if row_win(K, rcodes) or colum_win(K, rcodes) or diag1_win(K, rcodes) or diag2_win(K, rcodes):
         winc |= 1
     if row_win(K, bcodes) or colum_win(K, bcodes) or diag1_win(K, bcodes) or diag2_win(K, bcodes):
         winc |= 2
         
     if winc == 0:
         case_output += 'Neither'
     elif winc == 1:
         case_output += 'Red'
     elif winc == 2:
         case_output += 'Blue'
     elif winc == 3:
         case_output += 'Both'
     else:
         raise ""WRONG""
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 2
     for icase in range(1, T + 1):
         input = []
         N, K = [int(x) for x in data[iLine].split()]
         caseLineNum = N
         input.append(data[iLine])
         iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 7 3
 .......
 .......
 .......
 ...R...
 ...BB..
 ..BRB..
 .RRBR..
 6 4
 ......
 ......
 .R...R
 .R..BB
 .R.RBR
 RB.BBB
 4 4
 R...
 BR..
 BR..
 BR..
 3 3
 B..
 RB.
 RB.""""""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/544101/graygrass/567116/0/extracted/QA.py,3496,159,438,Python,544101,0,567116,graygrass,2010
3271,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def eu(a, b):
     m = max(a, b)
     n = min(a, b)
     if 1 == n:
         return 1
     
     while 0 != n:
         m, n = n, m % n
         
     return m
 
 
 def tell(a, b):
     m = max(a, b)
     n = min(a, b)
     
     count = 0
     while 0 != n:
         d, r = divmod(m, n)
         if d == 1:
             count += 1
         m, n = n, r
     
     return count & 1 == 0
 
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     count = 0
     A1, A2, B1, B2 = [int(x) for x in case_input[0].split()]
     for aa in xrange(A1, A2+1):
         for bb in xrange(B1, B2+1):
             mm = eu(aa, bb)
             a = aa / mm
             b = bb / mm
             count += tell(a, b) and 1 or 0
 #            if not tell(a, b):
 #                print aa, bb, tell(a, b)
     
     case_output += ""%d""%count
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
 #        N, K = [int(x) for x in data[iLine].split()]
 #        caseLineNum = N
 #        input.append(data[iLine])
 #        iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 5 5 8 8
 11 11 2 2
 1 6 1 6""""""
     use_test_data = False
     
     test_file = 'C-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/544101/graygrass/583114/0/extracted/QC.py,2124,96,281,Python,544101,0,583114,graygrass,2010
12274,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 factor = [1, 1]
 
 def fac(n):
     global factor
     while n > len(factor) - 1:
         factor.append(len(factor) * factor[-1])
     return factor[n]
 
 def comb(m, n):
     return fac(m)/fac(n)/fac(m-n)
 
 def sss(n, k):
     if 1 == k:
         return 1
     
     count = 0
     for m in xrange(1, k):
         r = k - m - 1
         if 0 <= r <= n-k-1:
             count += comb(n-k-1, r)*sss(k, m)
     return count
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N = [int(x) for x in case_input[0].split()]
     n = N[0]
     count = 0
     for i in xrange(1, n):
         count += sss(n, i)
         
     case_output += '%d'%count
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
 #        N, K = [int(x) for x in data[iLine].split()]
 #        caseLineNum = N + K
 #        input.append(data[iLine])
 #        iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
 5
 6""""""
     use_test_data = False
     
     test_file = 'C-small-attempt1.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/635101/graygrass/598111/0/extracted/QC.py,1934,86,229,Python,635101,0,598111,graygrass,2010
12275,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def add(tree, node):
     ns = node.split('/')[1:]
     ct = 0
     crt = tree
     for n in ns:
         if not crt.has_key(n):
             ct += 1
             crt[n] = dict()
         crt = crt[n]
     return ct
             
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N, K = [int(x) for x in case_input[0].split()]
     root = dict()
     for i in xrange(N):
         add(root, case_input[1 + i])
     count = 0
     for i in xrange(K):
         count += add(root, case_input[1 + N + i])
         
     case_output += '%d'%count
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         N, K = [int(x) for x in data[iLine].split()]
         caseLineNum = N + K
         input.append(data[iLine])
         iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 0 2
 /home/gcj/finals
 /home/gcj/quals
 2 1
 /chicken
 /chicken/egg
 /chicken
 1 3
 /a
 /a/b
 /a/c
 /b/b""""""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/635101/graygrass/563117/1/extracted/QA.py,1917,88,219,Python,635101,1,563117,graygrass,2010
12276,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def add(tree, node):
     ns = node.split('/')[1:]
     ct = 0
     crt = tree
     for n in ns:
         if not crt.has_key(n):
             ct += 1
             crt[n] = dict()
         crt = crt[n]
     return ct
             
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N, K = [int(x) for x in case_input[0].split()]
     root = dict()
     for i in xrange(N):
         add(root, case_input[1 + i])
     count = 0
     for i in xrange(K):
         count += add(root, case_input[1 + N + i])
         
     case_output += '%d'%count
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         N, K = [int(x) for x in data[iLine].split()]
         caseLineNum = N + K
         input.append(data[iLine])
         iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 0 2
 /home/gcj/finals
 /home/gcj/quals
 2 1
 /chicken
 /chicken/egg
 /chicken
 1 3
 /a
 /a/b
 /a/c
 /b/b""""""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/635101/graygrass/563117/0/extracted/QA.py,1926,88,219,Python,635101,0,563117,graygrass,2010
12277,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N, K, B, T = [int(x) for x in case_input[0].split()]
     xx = [int(x) for x in case_input[1].split()]
     vv = [int(x) for x in case_input[2].split()]
     pp = [(xx[i] + T * vv[i] >= B) for i in xrange(N)]
     if pp.count(True) < K:
         case_output += 'IMPOSSIBLE'
         return case_output
     pp.reverse()
     count = 0
     idx = -1
     for i in xrange(K):
         idx = pp.index(True, idx + 1)
         count += idx - i
         
     case_output += '%d'%count
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 3
     for icase in range(1, T + 1):
         input = []
 #        N, K = [int(x) for x in data[iLine].split()]
 #        caseLineNum = N + K
 #        input.append(data[iLine])
 #        iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 5 3 10 5
 0 2 5 6 7
 1 1 1 1 4
 5 3 10 5
 0 2 3 5 7
 2 1 1 1 4
 5 3 10 5
 0 2 3 4 7
 2 1 1 1 4""""""
     use_test_data = False
     
     test_file = 'B-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/635101/graygrass/542118/1/extracted/QB.py,1899,80,254,Python,635101,1,542118,graygrass,2010
12278,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
 #    print icase, case_input
     N, K, B, T = [int(x) for x in case_input[0].split()]
     xx = [int(x) for x in case_input[1].split()]
     vv = [int(x) for x in case_input[2].split()]
     pp = [(xx[i] + T * vv[i] >= B) for i in xrange(N)]
     if pp.count(True) < K:
         case_output += 'IMPOSSIBLE'
         return case_output
     pp.reverse()
     count = 0
     idx = -1
     for i in xrange(K):
         idx = pp.index(True, idx + 1)
         count += idx - i
         
     case_output += '%d'%count
     
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 3
     for icase in range(1, T + 1):
         input = []
 #        N, K = [int(x) for x in data[iLine].split()]
 #        caseLineNum = N + K
 #        input.append(data[iLine])
 #        iLine += 1
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 5 3 10 5
 0 2 5 6 7
 1 1 1 1 4
 5 3 10 5
 0 2 3 5 7
 2 1 1 1 4
 5 3 10 5
 0 2 3 4 7
 2 1 1 1 4""""""
     use_test_data = False
     
     test_file = 'B-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/635101/graygrass/542118/0/extracted/QB.py,1908,80,254,Python,635101,0,542118,graygrass,2010
36169,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 
 def ff(kk, nn, ii, ga):
     jj = ii
     ss = 0
     while kk >= ss + ga[jj]:
         ss += ga[jj]
         jj = (jj + 1) % nn
     return jj, ss
     
     
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
     R, k, N = [int(x) for x in case_input[0].split()]
     gg = [int(x) for x in case_input[1].split()]
     
     tt = sum(gg)
     if k >= tt:
         case_output += '%d'%(R * tt)
         return case_output
     
     rslt = [0] * N
     rslt_r = [0] * N
     icurrent = 0
     for i in range(1, R + 1):
         inext, s = ff(k, N, icurrent, gg)
         rslt[icurrent] = s
         rslt_r[icurrent] = i
         if rslt[inext] != 0:
             break
         icurrent = inext
     else:
         case_output += '%d'%sum(rslt)
         return case_output
     
     r_pre = rslt_r[inext] - 1
     r_cyc = i - r_pre
     rrr = [0] * (r_cyc + 1)
     for i in range(N):
         if rslt_r[i] > r_pre:
             rrr[rslt_r[i] - r_pre] = rslt[i]
     
     for i in range(1, r_cyc + 1):
         rrr[i] += rrr[i - 1]
     
     result = sum(rslt)
     nn, rr = divmod(R - r_cyc - r_pre, r_cyc)
     result += nn * rrr[-1] + rrr[rr]
     
     case_output += '%d'%result
     return case_output  
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 2
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 4 6 4
 1 4 2 1
 100 10 1
 1
 5 5 10
 2 4 2 3 4 2 1 2 1 3""""""
     use_test_data = False
     
     test_file = 'C-small-attempt2.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/433101/graygrass/509101/0/extracted/QC.py,2345,102,311,Python,433101,0,509101,graygrass,2010
36170,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def eu(a, b):
     m = max(a, b)
     n = min(a, b)
     if 1 == n:
         return 1
     
     while 0 != n:
         m, n = n, m % n
         
     return m
     
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
     tt = [int(x) for x in case_input[0].split()]
     nn = tt[0]
     tt = tt[1:]
     tt.sort()
     gap = [tt[x] - tt[x-1] for x in range(1, len(tt))]
     mm = reduce(eu, gap)
     r = tt[0] % mm
     rslt = (0 != r) and (mm - r) or 0
     
     case_output += '%d'%rslt
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 3 26000000 11000000 6000000
 3 1 10 11
 2 800000000000000000001 900000000000000000001""""""
     use_test_data = False
     
     test_file = 'B-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/433101/graygrass/506101/1/extracted/QB.py,1671,74,204,Python,433101,1,506101,graygrass,2010
36171,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def eu(a, b):
     m = max(a, b)
     n = min(a, b)
     if 1 == n:
         return 1
     
     while 0 != n:
         m, n = n, m % n
         
     return m
     
 def solve(icase, case_input):
     case_output = 'Case #%d: '%icase
     
     tt = [int(x) for x in case_input[0].split()]
     nn = tt[0]
     tt = tt[1:]
     tt.sort()
     gap = [tt[x] - tt[x-1] for x in range(1, len(tt))]
     mm = reduce(eu, gap)
     r = tt[0] % mm
     rslt = (0 != r) and (mm - r) or 0
     
     case_output += '%d'%rslt
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 3 26000000 11000000 6000000
 3 1 10 11
 2 800000000000000000001 900000000000000000001""""""
     use_test_data = False
     
     test_file = 'B-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()
     ",gcj/2010/433101/graygrass/506101/0/extracted/QB.py,1680,74,204,Python,433101,0,506101,graygrass,2010
36172,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
     
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     N, K = [int(x) for x in case_input[0].split()]
     
     nn = 2 ** N
     kk = K + 1
     if 0 == kk % nn:
         case_output += 'ON'
     else:
         case_output += 'OFF'
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
     1 0
     1 1
     4 0
     4 47
     """"""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2010/433101/graygrass/502103/1/extracted/QA.py,1368,63,156,Python,433101,1,502103,graygrass,2010
36173,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
     
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     N, K = [int(x) for x in case_input[0].split()]
     
     nn = 2 ** N
     kk = K + 1
     if 0 == kk % nn:
         case_output += 'ON'
     else:
         case_output += 'OFF'
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
     1 0
     1 1
     4 0
     4 47
     """"""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2010/433101/graygrass/502103/0/extracted/QA.py,1377,63,156,Python,433101,0,502103,graygrass,2010
31019,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 fn = lambda x, y: (x|y) - (x&y)
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     data = [int(x) for x in case_input[1].split()]
     
     if 0 == reduce(fn, data):
         case_output += '%d'%(sum(data) - min(data))
     else:
         case_output += 'NO'
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 2
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
     5
     1 2 3 4 5
     3
     3 5 6
     """"""
     use_test_data = False
     
     test_file = 'C-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/975485/graygrass/1059486/1/extracted/QC.py,1399,62,156,Python,975485,1,1059486,graygrass,2011
31020,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 fn = lambda x, y: (x|y) - (x&y)
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     data = [int(x) for x in case_input[1].split()]
     
     if 0 == reduce(fn, data):
         case_output += '%d'%(sum(data) - min(data))
     else:
         case_output += 'NO'
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 2
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
     5
     1 2 3 4 5
     3
     3 5 6
     """"""
     use_test_data = False
     
     test_file = 'C-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/975485/graygrass/1059486/0/extracted/QC.py,1408,62,156,Python,975485,0,1059486,graygrass,2011
31021,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     raw = case_input[0].split()
     N = int(raw[0])
     turn = raw[1::2]
     orange = []
     blue = []
     for i, v in enumerate(turn):
         if v == 'O':
             orange.append(int(raw[2*i+2]))
         else:
             blue.append(int(raw[2*i+2]))
     for i in xrange(len(orange) - 1, 0, -1):
         orange[i] = abs(orange[i] - orange[i - 1]) + 1
     for i in xrange(len(blue) - 1, 0, -1):
         blue[i] = abs(blue[i] - blue[i-1]) + 1
 #    print turn
 #    print orange
 #    print blue
     
     step = 0
     for t in turn:
         if t == 'O':
             a = orange
             b = blue
         else:
             a = blue
             b = orange
         s = a.pop(0)
         step += s
         if len(b):
             s = b[0] - s
             if s < 1:
                 s = 1
             b[0] = s
             
     
 
     case_output += '%d'%step
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
     4 O 2 B 1 B 2 O 4
     3 O 5 O 8 B 100
     2 B 2 B 1
     """"""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/975485/graygrass/1080487/1/extracted/QA.py,2089,90,256,Python,975485,1,1080487,graygrass,2011
31022,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     raw = case_input[0].split()
     N = int(raw[0])
     turn = raw[1::2]
     orange = []
     blue = []
     for i, v in enumerate(turn):
         if v == 'O':
             orange.append(int(raw[2*i+2]))
         else:
             blue.append(int(raw[2*i+2]))
     for i in xrange(len(orange) - 1, 0, -1):
         orange[i] = abs(orange[i] - orange[i - 1]) + 1
     for i in xrange(len(blue) - 1, 0, -1):
         blue[i] = abs(blue[i] - blue[i-1]) + 1
 #    print turn
 #    print orange
 #    print blue
     
     step = 0
     for t in turn:
         if t == 'O':
             a = orange
             b = blue
         else:
             a = blue
             b = orange
         s = a.pop(0)
         step += s
         if len(b):
             s = b[0] - s
             if s < 1:
                 s = 1
             b[0] = s
             
     
 
     case_output += '%d'%step
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
     4 O 2 B 1 B 2 O 4
     3 O 5 O 8 B 100
     2 B 2 B 1
     """"""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/975485/graygrass/1080487/0/extracted/QA.py,2098,90,256,Python,975485,0,1080487,graygrass,2011
31023,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     comb = {}
     oppo = {}
     
     raw = case_input[0].split()
     ii = 0
     C = int(raw[ii])
     ii += 1
     if C:
         for i in xrange(ii, ii+C):
             comb[raw[i][0]] = {raw[i][1]:raw[i][2]}
             comb[raw[i][1]] = {raw[i][0]:raw[i][2]}
         ii += C
     D = int(raw[ii])
     ii += 1
     if D:
         for i in xrange(ii, ii+D):
             oppo[raw[i][0]] = raw[i][1]
             oppo[raw[i][1]] = raw[i][0]
         ii += D
     N = int(raw[ii])
     ii += 1
     ss = raw[ii]
     
 #    print ss
 #    print comb
 #    print oppo
     
     rr = []
     for c in ss:
         rr.append(c)
         if len(rr) > 1:
             if (rr[-1] in comb) and (rr[-2] in comb[rr[-1]]):
                 t = comb[rr[-1]][rr[-2]]
                 rr.pop()
                 rr[-1] = t
             elif rr[-1] in oppo:
 #                for i in xrange(len(rr) - 2, -1, -1):
                 for i in xrange(len(rr) - 1):
                     if rr[i] in oppo[rr[-1]]:
 #                        rr = rr[:i]
                         rr = []
                         break
 
     case_output += '['
     if len(rr) > 0:
         for c in rr[:-1]:
             case_output += '%c, '%c
         case_output += rr[-1]
     case_output += ']'
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""5
     0 0 2 EA
     1 QRI 0 4 RRQR
     1 QFT 1 QF 7 FAQFDFQ
     1 EEZ 1 QE 7 QEEEERA
     0 1 QW 2 QW
     """"""
     use_test_data = False
     
     test_file = 'B-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/975485/graygrass/1026487/1/extracted/QB.py,2515,104,296,Python,975485,1,1026487,graygrass,2011
31024,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     comb = {}
     oppo = {}
     
     raw = case_input[0].split()
     ii = 0
     C = int(raw[ii])
     ii += 1
     if C:
         for i in xrange(ii, ii+C):
             comb[raw[i][0]] = {raw[i][1]:raw[i][2]}
             comb[raw[i][1]] = {raw[i][0]:raw[i][2]}
         ii += C
     D = int(raw[ii])
     ii += 1
     if D:
         for i in xrange(ii, ii+D):
             oppo[raw[i][0]] = raw[i][1]
             oppo[raw[i][1]] = raw[i][0]
         ii += D
     N = int(raw[ii])
     ii += 1
     ss = raw[ii]
     
 #    print ss
 #    print comb
 #    print oppo
     
     rr = []
     for c in ss:
         rr.append(c)
         if len(rr) > 1:
             if (rr[-1] in comb) and (rr[-2] in comb[rr[-1]]):
                 t = comb[rr[-1]][rr[-2]]
                 rr.pop()
                 rr[-1] = t
             elif rr[-1] in oppo:
 #                for i in xrange(len(rr) - 2, -1, -1):
                 for i in xrange(len(rr) - 1):
                     if rr[i] in oppo[rr[-1]]:
 #                        rr = rr[:i]
                         rr = []
                         break
 
     case_output += '['
     if len(rr) > 0:
         for c in rr[:-1]:
             case_output += '%c, '%c
         case_output += rr[-1]
     case_output += ']'
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""5
     0 0 2 EA
     1 QRI 0 4 RRQR
     1 QFT 1 QF 7 FAQFDFQ
     1 EEZ 1 QE 7 QEEEERA
     0 1 QW 2 QW
     """"""
     use_test_data = False
     
     test_file = 'B-small-attempt2.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/975485/graygrass/1026487/0/extracted/QB.py,2524,104,296,Python,975485,0,1026487,graygrass,2011
69980,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
 #    for _d in case_input:
 #        print _d
     case_output = 'Case #%i: '%icase
     R, C = [int(x) for x in case_input[0].split()]
     mm = []
     for x in case_input[1:]:
         mm.append(list(x))
     bimp = False
     for i in xrange(R):
         for j in xrange(C):
             if mm[i][j] == '#':
                 if i+1 >= R or j+1 >= C:
                     bimp = True
                     break
                 elif mm[i][j+1] == '#' and mm[i+1][j] == '#' and mm[i+1][j+1] == '#':
                     mm[i][j] = '/'
                     mm[i+1][j+1] = '/'
                     mm[i][j+1] = '\\'
                     mm[i+1][j] = '\\'
                 else:
                     bimp = True
                     break
         if bimp:
             break
     if bimp:
         case_output += '\nImpossible'
     else:
         for s in mm:
             case_output += '\n%s'%''.join(s)
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         caseLineNum = int(data[iLine].split()[0]) + 1
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 2 3
 ###
 ###
 1 1
 .
 4 5
 .##..
 .####
 .####
 .##..
     """"""
     use_test_data = False    
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1128486/graygrass/1060485/1/extracted/QA.py,2121,88,231,Python,1128486,1,1060485,graygrass,2011
69981,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
 #    for _d in case_input:
 #        print _d
     case_output = 'Case #%i: '%icase
     R, C = [int(x) for x in case_input[0].split()]
     mm = []
     for x in case_input[1:]:
         mm.append(list(x))
     bimp = False
     for i in xrange(R):
         for j in xrange(C):
             if mm[i][j] == '#':
                 if i+1 >= R or j+1 >= C:
                     bimp = True
                     break
                 elif mm[i][j+1] == '#' and mm[i+1][j] == '#' and mm[i+1][j+1] == '#':
                     mm[i][j] = '/'
                     mm[i+1][j+1] = '/'
                     mm[i][j+1] = '\\'
                     mm[i+1][j] = '\\'
                 else:
                     bimp = True
                     break
         if bimp:
             break
     if bimp:
         case_output += '\nImpossible'
     else:
         for s in mm:
             case_output += '\n%s'%''.join(s)
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         caseLineNum = int(data[iLine].split()[0]) + 1
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 2 3
 ###
 ###
 1 1
 .
 4 5
 .##..
 .####
 .####
 .##..
     """"""
     use_test_data = False    
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1128486/graygrass/1060485/0/extracted/QA.py,2130,88,231,Python,1128486,0,1060485,graygrass,2011
69982,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def eu(x, y):
     xx = min(x, y)
     yy = max(x, y)
     while True:
         d, r = divmod(yy, xx)
         if 0 == r:
             return xx
         xx, yy = r, xx
 
 
 def solve(icase, case_input):
 #    for _d in case_input:
 #        print _d
     case_output = 'Case #%i: '%icase
     
     N, L, H = [int(x) for x in case_input[0].split()]
     if 1 == L:
         case_output += '1'
     else:
         raw = [int(x) for x in case_input[1].split()]
         raw.sort()
     #    print raw
         cad = raw[:]
         rm = []
         while cad:
             x = cad.pop(0)
             bkp = True
             for y in cad:
                 if y % x == 0:
                     cad.remove(y)
                     bkp = False
             if bkp:
                 rm.append(x)
 #        print rm
         if rm:
             m = reduce(lambda x, y: x * y / eu(x, y), rm)
     #        print m
             if m > H:
                 case_output += 'NO'
             elif m >= L:
                 case_output += '%d'%m
             else:
                 d, r = divmod(L, m)
                 if 0 == r:
                     case_output += '%d'%(d*m)
                 elif m*(d+1) <= H:
                     case_output += '%d'%(d*m + m)
                 else:
                     case_output += 'NO'
         else:
             bfound = False
             for ii in xrange(L, H+1):
                 for r in raw:
                     if ii % r == 0 or r % ii == 0:
                         bfound = True
                         break
                 if bfound:
                     case_output += '%d'%ii
                     break
             if not bfound:
                 case_output += 'NO'
         
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 2
     for icase in range(1, T + 1):
 #        caseLineNum = int(data[iLine].split()[0]) + 1
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
 3 2 100
 3 5 7
 4 8 16
 1 20 5 2
     """"""
     use_test_data = False    
     
     test_file = 'C-small-attempt2.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1128486/graygrass/1076485/0/extracted/QC.py,2892,114,333,Python,1128486,0,1076485,graygrass,2011
92160,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def eu(x, y):
     xx = min(x, y)
     yy = max(x, y)
     while True:
         d, r = divmod(yy, xx)
         if 0 == r:
             return xx
         xx, yy = r, xx
         
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     raw = case_input[0].split()
     N = int(raw[0])
     pd = int(raw[1])
     pg = int(raw[2])
     
     if pg == 100:
         if pd != 100:
             case_output += 'Broken'
         else:
             case_output += 'Possible'
     elif pg == 0:
         if pd != 0:
             case_output += 'Broken'
         else:
             case_output += 'Possible'
     elif pd == 0:
         case_output += 'Possible'
     else:
         bd = 100 / eu(100, pd)
         if bd <= N:
             case_output += 'Possible'
         else:
             case_output += 'Broken'
     
 
 #    case_output += '%d'%step
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 1 100 50
 10 10 100
 9 80 56
     """"""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1145485/graygrass/1040487/1/extracted/QA.py,1970,89,226,Python,1145485,1,1040487,graygrass,2011
92161,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def eu(x, y):
     xx = min(x, y)
     yy = max(x, y)
     while True:
         d, r = divmod(yy, xx)
         if 0 == r:
             return xx
         xx, yy = r, xx
         
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     raw = case_input[0].split()
     N = int(raw[0])
     pd = int(raw[1])
     pg = int(raw[2])
     
     if pg == 100:
         if pd != 100:
             case_output += 'Broken'
         else:
             case_output += 'Possible'
     elif pg == 0:
         if pd != 0:
             case_output += 'Broken'
         else:
             case_output += 'Possible'
     elif pd == 0:
         case_output += 'Possible'
     else:
         bd = 100 / eu(100, pd)
         if bd <= N:
             case_output += 'Possible'
         else:
             case_output += 'Broken'
     
 
 #    case_output += '%d'%step
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 1 100 50
 10 10 100
 9 80 56
     """"""
     use_test_data = False
     
     test_file = 'A-small-attempt1.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1145485/graygrass/1040487/0/extracted/QA.py,1979,89,226,Python,1145485,0,1040487,graygrass,2011
102378,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
 #    for _d in case_input:
 #        print _d
     case_output = 'Case #%i: '%icase
     
     C, D = [int(x) for x in case_input[0].split()]
     pp = []
     for i in xrange(C):
         P, V = [int(x) for x in case_input[1+i].split()]
         for ii in xrange(V):
             pp.append(P)
     pp.sort()
 ##    print pp
 #    kk = [D*i-p for i, p in enumerate(pp)]
 ##    print kk
 #    r = (max(kk) - min(kk))/2.0
 #    case_output += '%.7f'%r
 
     ss = 0
     prev = pp[0]
     for pv in pp[1:]:
         s = pv-prev
         if s < D:
             ss += D-s
         prev = pv
     r = ss / 2.0
     case_output += '%.7f'%r
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         caseLineNum = int(data[iLine].split()[0]) + 1
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
 3 2
 0 1
 3 2
 6 1
 2 2
 0 3
 1 1
     """"""
     use_test_data = False
     
     test_file = 'B-small-attempt1.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1150485/graygrass/1058489/0/extracted/QB.py,1826,81,229,Python,1150485,0,1058489,graygrass,2011
102379,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
 #    for _d in case_input:
 #        print _d
     case_output = 'Case #%i: '%icase
 
     N = int(case_input[0])
     mm = case_input[1:]
     w = []
     t = []
     for i in xrange(N):
         w.append(mm[i].count('1'))
         t.append(w[i]+mm[i].count('0'))
     wp = []
     owp = []
     oowp = []
     for i in xrange(N):
         wp.append(1.*w[i]/t[i])
     for i in xrange(N):
         s = 0
         for ii in xrange(N):
             if mm[i][ii] == '1':
                 s += 1.*w[ii]/(t[ii] - 1)
             elif mm[i][ii] == '0':
                 s += 1.*(w[ii]-1)/(t[ii] - 1)
         owp.append(s/t[i])
     for i in xrange(N):
         s = 0
         for ii in xrange(N):
             if mm[i][ii] != '.':
                 s += owp[ii]
         oowp.append(s/t[i])
     for i in xrange(N):
         rpi = 0.25*wp[i]+0.5*owp[i]+0.25*oowp[i]
         case_output += '\n%.7f'%rpi
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         caseLineNum = int(data[iLine]) + 1
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
 3
 .10
 0.1
 10.
 4
 .11.
 0.00
 01.1
 .10.
     """"""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1150485/graygrass/1048486/1/extracted/QA.py,2086,91,230,Python,1150485,1,1048486,graygrass,2011
102380,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
 #    for _d in case_input:
 #        print _d
     case_output = 'Case #%i: '%icase
 
     N = int(case_input[0])
     mm = case_input[1:]
     w = []
     t = []
     for i in xrange(N):
         w.append(mm[i].count('1'))
         t.append(w[i]+mm[i].count('0'))
     wp = []
     owp = []
     oowp = []
     for i in xrange(N):
         wp.append(1.*w[i]/t[i])
     for i in xrange(N):
         s = 0
         for ii in xrange(N):
             if mm[i][ii] == '1':
                 s += 1.*w[ii]/(t[ii] - 1)
             elif mm[i][ii] == '0':
                 s += 1.*(w[ii]-1)/(t[ii] - 1)
         owp.append(s/t[i])
     for i in xrange(N):
         s = 0
         for ii in xrange(N):
             if mm[i][ii] != '.':
                 s += owp[ii]
         oowp.append(s/t[i])
     for i in xrange(N):
         rpi = 0.25*wp[i]+0.5*owp[i]+0.25*oowp[i]
         case_output += '\n%.7f'%rpi
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         caseLineNum = int(data[iLine]) + 1
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""2
 3
 .10
 0.1
 10.
 4
 .11.
 0.00
 01.1
 .10.
     """"""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2011/1150485/graygrass/1048486/0/extracted/QA.py,2095,91,230,Python,1150485,0,1048486,graygrass,2011
49146,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = 0
     raw = [int(x) for x in case_input[0].split()]
     ts = raw[3:]
     ct = raw[1]
     n = raw[2]
     cc = 0
     for i in ts:
         if i > 3*n-3:
             result += 1
         elif i > max(3*n-5, 0):
             cc += 1
     result += min(cc, ct)
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 3 1 5 15 13 11
 3 0 8 23 22 21
 2 1 1 8 0
 6 2 8 29 20 8 18 18 21
 """"""
     use_test_data = False
     
     test_file = 'B-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1460488/graygrass/1595491/1/extracted/QB.py,1516,68,191,Python,1460488,1,1595491,graygrass,2012
49147,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = 0
     raw = [int(x) for x in case_input[0].split()]
     ts = raw[3:]
     ct = raw[1]
     n = raw[2]
     cc = 0
     for i in ts:
         if i > 3*n-3:
             result += 1
         elif i > max(3*n-5, 0):
             cc += 1
     result += min(cc, ct)
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 3 1 5 15 13 11
 3 0 8 23 22 21
 2 1 1 8 0
 6 2 8 29 20 8 18 18 21
 """"""
     use_test_data = False
     
     test_file = 'B-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1460488/graygrass/1595491/0/extracted/QB.py,1525,68,191,Python,1460488,0,1595491,graygrass,2012
49148,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = 0
     raw = case_input[0].split()
     n = len(raw[0])
     a = int(raw[0])
     b = int(raw[1])
     
     for i in xrange(a, b):
         rslt = set()
         for t in xrange(1, n):
             tt = 10**t
             tn = 10**(n-t)
             ia, ib = divmod(i, tt)
             ii = ib*tn + ia
             if ii > i and ii <= b:
                 rslt.add(ii)
         result += len(rslt)
         
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""5
 1 9
 10 40
 100 500
 1111 2222
 1000000 2000000
 """"""
     use_test_data = False
     
     test_file = 'C-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1460488/graygrass/1483488/1/extracted/QC.py,1643,74,186,Python,1460488,1,1483488,graygrass,2012
49149,QC.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = 0
     raw = case_input[0].split()
     n = len(raw[0])
     a = int(raw[0])
     b = int(raw[1])
     
     for i in xrange(a, b):
         rslt = set()
         for t in xrange(1, n):
             tt = 10**t
             tn = 10**(n-t)
             ia, ib = divmod(i, tt)
             ii = ib*tn + ia
             if ii > i and ii <= b:
                 rslt.add(ii)
         result += len(rslt)
         
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""5
 1 9
 10 40
 100 500
 1111 2222
 1000000 2000000
 """"""
     use_test_data = False
     
     test_file = 'C-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1460488/graygrass/1483488/0/extracted/QC.py,1652,74,186,Python,1460488,0,1483488,graygrass,2012
49150,QD.py,"#! /usr/bin/env python
 #coding=utf-8
 
 #import matplotlib.pyplot as plt
 import math
 
 class Mirror(object):
     def __init__(self, type, pos, dir, range=None):
         self.type = type
         self.pos = pos
         self.dir = dir
         self.range = range
         
     def getImg(self, pnt):
         if self.type == 'h':
             d = pnt[1] - self.pos
             if d * self.dir > 0:
                 return (pnt[0], self.pos - d)
             else:
                 return None
         else:
             d = pnt[0] - self.pos
             if d * self.dir > 0:
                 return (self.pos - d, pnt[1])
             else:
                 return None
         
     def getId(self):
         return (self.type, self.pos, self.dir)
     
 def gen_mrs(map, w, h):
     mrs = {}
     for ix in xrange(w):
         for iy in xrange(h):
             if map[iy][ix] == '#':
                 if ix - 1 >= 0 and map[iy][ix-1] != '#':
                     m = Mirror('v', ix, -1)
                     if m.getId() not in mrs:
                         mrs[m.getId()] = m
                 if ix + 1 < w and map[iy][ix+1] != '#':
                     m = Mirror('v', ix+1, 1)
                     if m.getId() not in mrs:
                         mrs[m.getId()] = m
                 if iy - 1 >= 0 and map[iy-1][ix] != '#':
                     m = Mirror('h', iy, -1)
                     if m.getId() not in mrs:
                         mrs[m.getId()] = m
                 if iy + 1 < h and map[iy+1][ix] != '#':
                     m = Mirror('h', iy+1, 1)
                     if m.getId() not in mrs:
                         mrs[m.getId()] = m
     return mrs
                 
 def collectImgs(orig, pnt, imgs, mrs, dis, _pnts):
     dx = pnt[0] - orig[0]
     dy = pnt[1] - orig[1]
     if (dx, dy) in _pnts:
         return
     
     if dx != 0 or dy != 0:
         len = (dx*dx+dy*dy)**0.5
         if len > dis:
             return
         
         ray = (dx/len, dy/len)
         _pnts.add((dx, dy))
         rad = math.atan2(dy, dx)
         if rad not in imgs:
             imgs.add(rad)
 #            print ray
     
     for k, m in mrs.items():
 #        print m.getId(), pnt,
         p = m.getImg(pnt)
         if p:
 #            print p
             collectImgs(orig, p, imgs, mrs, dis, _pnts)
 #            pnts.append(p)
         else:
 #            print None
             pass
     pass
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     ns = case_input[0]
     rn, cn, dis = [int(x) for x in ns.split()]
     map = case_input[1:]
     mrs = gen_mrs(map, cn, rn)
     
     for oy in xrange(rn):
         for ox in xrange(cn):
             if map[oy][ox] == 'X':
                 orig = (ox+0.5, oy+0.5)
                 
     imgs = set()
     imglist = [orig,]
     imgpnts = set()
     collectImgs(orig, orig, imgs, mrs, dis, imgpnts)
     result = len(imgs)
 #    print imgs
 
 #    for p in imgpnts:
 #        xx = [0, p[0]]
 #        yy = [0, p[1]]
 #        plt.plot(xx, yy, 'o-')
 #    plt.show()
 
     case_output += '%d'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         caseLineNum = 1 + int(data[iLine].split()[0])
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""6
 3 3 1
 ###
 #X#
 ###
 3 3 2
 ###
 #X#
 ###
 4 3 8
 ###
 #X#
 #.#
 ###
 7 7 4
 #######
 #.....#
 #.....#
 #..X..#
 #....##
 #.....#
 #######
 5 6 3
 ######
 #..X.#
 #.#..#
 #...##
 ######
 5 6 10
 ######
 #..X.#
 #.#..#
 #...##
 ######
 """"""
     use_test_data = False
     
     test_file = 'D-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1460488/graygrass/1285485/0/extracted/QD.py,4438,188,528,Python,1460488,0,1285485,graygrass,2012
49151,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = """"
     for c in case_input[0]:
         if c in map:
             result += map[c]
         else:
             result += c
 
     case_output += '%s'%result
     
     return case_output
 
 
 def getmap():
     inputs = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
               ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
               ""de kr kd eoya kw aej tysr re ujdr lkgc jv""]
     outputs = [""our language is impossible to understand"",
                ""there are twenty six factorial possibilities"",
                ""so it is okay if you want to just give up""]
     map = {}
     for case in xrange(3):
         for i, c in enumerate(inputs[case]):
             map[c] = outputs[case][i]
     
     map['q'] = 'z'
     map['z'] = 'q'
     
     print map
     print len(map)
     for c in ""abcdefghijklmnopqrstuvwxyz"":
         if c not in map:
             print c
     return map
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     caseLineNum = 1
     for icase in range(1, T + 1):
         input = []
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 ejp mysljylc kd kxveddknmc re jsicpdrysi
 rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
 de kr kd eoya kw aej tysr re ujdr lkgc jv
     """"""
     use_test_data = False
     
     map = getmap()
     
     test_file = 'A-small-attempt2.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1460488/graygrass/1483485/0/extracted/QA.py,2187,86,254,Python,1460488,0,1483485,graygrass,2012
87873,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 #import matplotlib.pyplot as plt
 from itertools import permutations as perm
 from itertools import combinations as comb
 from fractions import gcd
 
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     td, tt = [int(x) for x in case_input[0].split()]
     p = [float(x) for x in case_input[1].split()]
     pp = list(p)
     for i in xrange(1, len(pp)):
         pp[i] *= pp[i-1]
     
     mine = tt + 2
     for n in xrange(td+1):
         lp = pp[td-n-1]
         c = n+n+(tt-td)+1
         e = (lp*c)+((1-lp)*(c+tt+1))
         if e < mine:
             mine = e
     
     result = mine
 
     case_output += '%.6f'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     for icase in range(1, T + 1):
         input = []
         
         caseLineNum = 2
 #        caseLineNum = 1 + int(data[iLine].split()[0])
         
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 2 5
 0.6 0.6
 1 20
 1
 3 4
 1 0.9 0.1
 """"""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1645485/graygrass/1673486/1/extracted/QA.py,1841,82,212,Python,1645485,1,1673486,graygrass,2012
87874,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 #import matplotlib.pyplot as plt
 from itertools import permutations as perm
 from itertools import combinations as comb
 from fractions import gcd
 
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     td, tt = [int(x) for x in case_input[0].split()]
     p = [float(x) for x in case_input[1].split()]
     pp = list(p)
     for i in xrange(1, len(pp)):
         pp[i] *= pp[i-1]
     
     mine = tt + 2
     for n in xrange(td+1):
         lp = pp[td-n-1]
         c = n+n+(tt-td)+1
         e = (lp*c)+((1-lp)*(c+tt+1))
         if e < mine:
             mine = e
     
     result = mine
 
     case_output += '%.6f'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     for icase in range(1, T + 1):
         input = []
         
         caseLineNum = 2
 #        caseLineNum = 1 + int(data[iLine].split()[0])
         
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""3
 2 5
 0.6 0.6
 1 20
 1
 3 4
 1 0.9 0.1
 """"""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1645485/graygrass/1673486/0/extracted/QA.py,1850,82,212,Python,1645485,0,1673486,graygrass,2012
87875,QB.py,"#! /usr/bin/env python
 #coding=utf-8
 
 #import matplotlib.pyplot as plt
 from itertools import permutations as perm
 from itertools import combinations as comb
 from fractions import gcd
 
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = ""Too Bad""
     
     lv = []
     for line in case_input[1:]:
         lv.append([int(x) for x in line.split()])
 
 #    print lv
 
     tt = len(lv)
     
     s1 = []
     s2 = []
     
 #    print(len(lv) * 2)
     
     for i in xrange(len(lv)):
         t = (i, lv[i][0], lv[i][1])
         s1.append(t)
         s2.append(t)
     
     s1.sort(lambda x, y: cmp(x[1], y[1]))
     s2.sort(lambda x, y: cmp(x[2], y[2]))
     
 #    print s1
 #    print s2
 
     cnt = 0
     cs = 0
     while len(s2) > 0:
         if s2[0][2] <= cs:
             if s2[0] in s1:
                 cs += 2
                 s1.remove(s2[0])
                 cnt += 1
             else:
                 cs += 1
             s2.pop(0)
         else:
             if len(s1) == 0:
                 break
             elif s1[0][1] <= cs:
                 cs += 1
                 s1.pop(0)
             else:
                 break
 
     if len(s2) > 0:
         result = ""Too Bad""
     else:
         result = ""%d""%(tt+tt-cnt)
     case_output += '%s'%result
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     for icase in range(1, T + 1):
         input = []
         
         caseLineNum = 1
         caseLineNum = 1 + int(data[iLine].split()[0])
         
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""5
 1
 0 2
 2
 0 1
 0 2
 3
 2 2
 0 0
 4 4
 1
 1 1
 5
 0 5
 0 1
 1 1
 4 7
 5 6
 """"""
     use_test_data = False
     
     test_file = 'B-small-attempt1.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1645485/graygrass/1482494/0/extracted/QB.py,2512,127,291,Python,1645485,0,1482494,graygrass,2012
98878,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 #import matplotlib.pyplot as plt
 from itertools import permutations as perm
 from itertools import combinations as comb
 from fractions import gcd
 
 
 def ffind(i, inh, cc):
 #    print 'ffind', i, inh
     qq = []
     for x in inh[i]:
         qq.append(x)
     while len(qq) > 0:
 #        print cc
         chd = qq.pop(0)
         if chd in cc:
             return 'Yes'
         else:
             cc.add(chd)
             if chd in inh:
                 for x in inh[chd]:
                     qq.append(x)
     return 'No'
     
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = None
     
     inh = {}
     rs = []
     for i in xrange(1, len(case_input)):
         raw = [int(x) for x in case_input[i].split()]
         if raw[0] == 0:
             rs.append(i)
         else:
             dfcs = raw[1:]
             for f in dfcs:
                 if f not in inh:
                     inh[f] = []
                 inh[f].append(i)
     
     for i in rs:
         if i in inh:
             result = ffind(i, inh, set())
             if result == 'Yes':
                 break
 
     case_output += '%s'%str(result)
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     for icase in range(1, T + 1):
         input = []
         
 #        caseLineNum = 1
         caseLineNum = 1 + int(data[iLine].split()[0])
         
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 3
 2 2 3
 1 3
 0
 3
 1 2
 1 3
 0
 5
 2 2 3
 1 4
 1 5
 1 5
 0
 3
 2 2 3
 1 3
 0
 
 """"""
     use_test_data = False
     
     test_file = 'A-large.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1781488/graygrass/1674486/1/extracted/QA.py,2398,118,284,Python,1781488,1,1674486,graygrass,2012
98879,QA.py,"#! /usr/bin/env python
 #coding=utf-8
 
 #import matplotlib.pyplot as plt
 from itertools import permutations as perm
 from itertools import combinations as comb
 from fractions import gcd
 
 
 def ffind(i, inh, cc):
 #    print 'ffind', i, inh
     qq = []
     for x in inh[i]:
         qq.append(x)
     while len(qq) > 0:
 #        print cc
         chd = qq.pop(0)
         if chd in cc:
             return 'Yes'
         else:
             cc.add(chd)
             if chd in inh:
                 for x in inh[chd]:
                     qq.append(x)
     return 'No'
     
 
 def solve(icase, case_input):
     case_output = 'Case #%i: '%icase
     
     result = None
     
     inh = {}
     rs = []
     for i in xrange(1, len(case_input)):
         raw = [int(x) for x in case_input[i].split()]
         if raw[0] == 0:
             rs.append(i)
         else:
             dfcs = raw[1:]
             for f in dfcs:
                 if f not in inh:
                     inh[f] = []
                 inh[f].append(i)
     
     for i in rs:
         if i in inh:
             result = ffind(i, inh, set())
             if result == 'Yes':
                 break
 
     case_output += '%s'%str(result)
     
     return case_output
 
 
 def main():
     global use_test_data
     global test_data
     global input_file
     global output_file
     
     if use_test_data:
         data = [x.strip() for x in test_data.split('\n')]
     else:
         data = [x.strip() for x in input_file.readlines()]
     
     T = int(data[0])
     iLine = 1
     for icase in range(1, T + 1):
         input = []
         
 #        caseLineNum = 1
         caseLineNum = 1 + int(data[iLine].split()[0])
         
         for i in range(caseLineNum):
             input.append(data[iLine])
             iLine += 1
         rslt = solve(icase, input)
         print rslt
         if not use_test_data:
             print >> output_file, rslt
     
     if not use_test_data:
         input_file.close()
         output_file.close()
     
     
 if __name__ == '__main__':
     test_data = """"""4
 3
 2 2 3
 1 3
 0
 3
 1 2
 1 3
 0
 5
 2 2 3
 1 4
 1 5
 1 5
 0
 3
 2 2 3
 1 3
 0
 
 """"""
     use_test_data = False
     
     test_file = 'A-small-attempt0.in'
     if not use_test_data and '' != test_file:
         input_file = open(test_file)
         output_file = open(test_file + '.out', 'w')
     
     main()",gcj/2012/1781488/graygrass/1674486/0/extracted/QA.py,2407,118,284,Python,1781488,0,1674486,graygrass,2012
5054,PB.py,"import math
 import itertools
 
 _dbg = 0
 
 
 # search maximume integer'x' keeping 'func(x)' true.
 def _find_mx(func, x=0, step=1):
     while True:
         assert func(x)
         nx = x + step
         if func(nx):
             x = nx
             step += step
         elif 1 == step:
             return x
         else:
             step /= 2
             
 
 def stupid_s(e, n):
     cx = 0
     cy = 0
     step = 1
     p = []
     if cx < e:
         d = e - cx
         for i in xrange(d):
             p.append('WE')
     elif cx > e:
         d = cx - e
         for i in xrange(d):
             p.append('EW')
     if cy < n:
         d = n - cy
         for i in xrange(d):
             p.append('SN')
     elif cy > n:
         d = cy - n
         for i in xrange(d):
             p.append('NS')
 
     return ''.join(p)
     
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     if _dbg:
         for line in in_lines:
             print line
             
     e, n = [int(x) for x in in_lines[0].split()]
 
     return out + stupid_s(e, n)
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         endln = ln + 1
         while ln < endln and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""2
 3 4
 -3 4""""""
     force_no_file = 0
     in_file_name = '' if force_no_file else 'B-small-attempt0.in'
     base_path = 'G:/workspace/py/codejam2013/R1C/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2437488/graygrass/2749486/0/extracted/PB.py,1948,91,249,Python,2437488,0,2749486,graygrass,2013
16319,PA.py,"import math
 import itertools
 
 _dbg = 0
 
 
 # search maximume integer'x' keeping 'func(x)' true.
 def _find_mx(func, x=0, step=1):
     while True:
         assert func(x)
         nx = x + step
         if func(nx):
             x = nx
             step += step
         elif 1 == step:
             return x
         else:
             step /= 2
     
 
 def tot(s, t):
     n = 0
     ns = s
     while ns <= t:
         ns += ns - 1
         n += 1
     return n, ns
 
 
 def subsolve(s, mm):
     if 1 == s:
         return len(mm)
     if len(mm) == 0:
         return 0
     
     ts = s
     i = 0
     while i < len(mm) and ts > mm[i]:
         ts += mm[i]
         i += 1
     
     if i == len(mm):
         return 0
     
     nd = len(mm) - i
     nn, ns = tot(ts, mm[i])
     nr = subsolve(ns, mm[i:])
     return min(nd, nn + nr)
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     if _dbg:
         for line in in_lines:
             print line
             
     s, foo = [int(x) for x in in_lines[0].split()]
     mm = [int(x) for x in in_lines[1].split()]
     mm.sort()
     
     n = subsolve(s, mm)
     
 #     n = 0
 #     while True:
 #         n1 = len(mm)
 #         while n1 > 0 and s > mm[0]:
 #             s += mm.pop(0)
 #             n1 -= 1
 #         if 0 == n1:
 #             break
 #         if s == 1:
 #             n += n1
 #             break
 #         nr, sn = tot(s, mm[0])
 #         c = 0
 #         tsn = sn
 #         while c < n1 and mm[c] < tsn:
 #             tsn += mm[c]
 #             c += 1
 #         n2 = n1 - c + nr
 #         if n2 > n1:
 #             n += n1
 #             break
 #         else:
 #             n += nr
 #             s = sn
 
     return out+str(n)
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         endln = ln + 2
         while ln < endln and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""5
 1 1
 1
 10 4
 25 20 9 100
 2 2
 2 1
 2 4
 2 1 1 6
 1 4
 1 1 1 1""""""
     force_no_file = 0
     in_file_name = '' if force_no_file else 'A-large.in'
     base_path = 'G:/workspace/py/codejam2013/R1B/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2434486/graygrass/2692487/1/extracted/PA.py,2665,132,396,Python,2434486,1,2692487,graygrass,2013
16320,PA.py,"import math
 import itertools
 
 _dbg = 0
 
 
 # search maximume integer'x' keeping 'func(x)' true.
 def _find_mx(func, x=0, step=1):
     while True:
         assert func(x)
         nx = x + step
         if func(nx):
             x = nx
             step += step
         elif 1 == step:
             return x
         else:
             step /= 2
     
 
 def tot(s, t):
     n = 0
     ns = s
     while ns <= t:
         ns += ns - 1
         n += 1
     return n, ns
 
 
 def subsolve(s, mm):
     if 1 == s:
         return len(mm)
     if len(mm) == 0:
         return 0
     
     ts = s
     i = 0
     while i < len(mm) and ts > mm[i]:
         ts += mm[i]
         i += 1
     
     if i == len(mm):
         return 0
     
     nd = len(mm) - i
     nn, ns = tot(ts, mm[i])
     nr = subsolve(ns, mm[i:])
     return min(nd, nn + nr)
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     if _dbg:
         for line in in_lines:
             print line
             
     s, foo = [int(x) for x in in_lines[0].split()]
     mm = [int(x) for x in in_lines[1].split()]
     mm.sort()
     
     n = subsolve(s, mm)
     
 #     n = 0
 #     while True:
 #         n1 = len(mm)
 #         while n1 > 0 and s > mm[0]:
 #             s += mm.pop(0)
 #             n1 -= 1
 #         if 0 == n1:
 #             break
 #         if s == 1:
 #             n += n1
 #             break
 #         nr, sn = tot(s, mm[0])
 #         c = 0
 #         tsn = sn
 #         while c < n1 and mm[c] < tsn:
 #             tsn += mm[c]
 #             c += 1
 #         n2 = n1 - c + nr
 #         if n2 > n1:
 #             n += n1
 #             break
 #         else:
 #             n += nr
 #             s = sn
 
     return out+str(n)
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         endln = ln + 2
         while ln < endln and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""5
 1 1
 1
 10 4
 25 20 9 100
 2 2
 2 1
 2 4
 2 1 1 6
 1 4
 1 1 1 1""""""
     force_no_file = 0
     in_file_name = '' if force_no_file else 'A-small-attempt3.in'
     base_path = 'G:/workspace/py/codejam2013/R1B/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2434486/graygrass/2692487/0/extracted/PA.py,2674,132,396,Python,2434486,0,2692487,graygrass,2013
35845,PB.py,"import math
 import itertools
 
 _dbg = 0
 
 cnt = 0
 
 def fm(act, pos, end):
     mm = 0
     mi = -1
     for i in range(pos, end):
         if act[i] > mm:
             mm = act[i]
             mi = i
     return mi
 
 def ff(act, pos, ce, end, lmte, maxe, reg):
     if pos >= end:
         return
     global cnt
     
     i = fm(act, pos, end)
     dst = end - i
     pdst = i - pos
     if dst * reg > lmte:
         ae = ce + pdst * reg
         if ae > maxe:
             cnt += maxe * act[i]
             plmte = maxe
         else:
             cnt += ae * act[i]
             plmte = ae
         ff(act, pos, ce, i, plmte, maxe, reg)
         ff(act, i+1, reg, end, lmte, maxe, reg)
     else:
         ae = ce + pdst * reg
         if ae > maxe:
             plmte = (maxe - (lmte - dst * reg))
             if plmte < 0:
                 plmte = maxe
             cnt += act[i] * plmte
         else:
             plmte = ae - (lmte - dst * reg)
             if plmte < 0:
                 plmte = ae
             cnt += act[i] * plmte
         ff(act, pos, ce, i, plmte, maxe, reg)
         ff(act, i+1, reg, end, lmte, maxe, reg)
             
     
     
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     if _dbg:
         for line in in_lines:
             print line
             
     eng, reg, dummy = [int(x) for x in in_lines[0].split()]
     act = [int(x) for x in in_lines[1].split()]
 
     global cnt
     cnt = 0
     
     
     if reg >= eng:
         cnt = sum(act) * eng
     else:
         ff(act, 0, eng, len(act), 0, eng, reg)
 #         r = 0
 #         e = eng
 #         for i in range(len(act) - 1):
 #             if act[i] > act[i+1]:
 #                 r += act[i] * e
 #                 e = reg
 #             else:
 #                 r += act[i] * reg
 #                 e = eng
 #         r += act[-1] * e
                 
     return out + str(cnt)
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         endln = ln + 2
         while ln < endln and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""3
 5 2 2
 2 1
 5 2 2
 1 2
 3 3 4
 4 1 3 5""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'B-small-attempt1.in'
     base_path = 'G:/workspace/py/codejam2013/R1A/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2418487/graygrass/2645486/0/extracted/PB.py,2819,121,405,Python,2418487,0,2645486,graygrass,2013
35846,PA.py,"import math
 import itertools
 
 _dbg = 0
     
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     if _dbg:
         for line in in_lines:
             print line
             
     r, t = [int(x) for x in in_lines[0].split()]
     
     a = 2
     b = 2 * r + 3
     c = 2 * r + 1 - t
     d = math.sqrt(b*b - 4*a*c)
     k = (d-b)/2/a
     k = int(k)
     k2 = k + 1
     k1 = k - 1
     if a*k*k + b*k + c > 0:
         k = k1
     elif a*k2*k2 + b*k2 + c <= 0:
         k = k2
 
     return out+str(k+1)
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         endln = ln + 1
         while ln < endln and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""5
 1 9
 1 10
 3 40
 1 1000000000000000000
 10000000000000000 1000000000000000000""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'A-large.in'
     base_path = 'G:/workspace/py/codejam2013/R1A/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2418487/graygrass/2464487/1/extracted/PA.py,1458,67,203,Python,2418487,1,2464487,graygrass,2013
35847,PA.py,"import math
 import itertools
 
 _dbg = 0
     
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     if _dbg:
         for line in in_lines:
             print line
             
     r, t = [int(x) for x in in_lines[0].split()]
     
     a = 2
     b = 2 * r + 3
     c = 2 * r + 1 - t
     d = math.sqrt(b*b - 4*a*c)
     k = (d-b)/2/a
     k = int(k)
     k2 = k + 1
     k1 = k - 1
     if a*k*k + b*k + c > 0:
         k = k1
     elif a*k2*k2 + b*k2 + c <= 0:
         k = k2
 
     return out+str(k+1)
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         endln = ln + 1
         while ln < endln and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""5
 1 9
 1 10
 3 40
 1 1000000000000000000
 10000000000000000 1000000000000000000""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'A-small-attempt0.in'
     base_path = 'G:/workspace/py/codejam2013/R1A/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2418487/graygrass/2464487/0/extracted/PA.py,1467,67,203,Python,2418487,0,2464487,graygrass,2013
91024,PA.py,"import math
 
 mm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
     s = ''.join(in_lines)
     x = 0
     o = 0
     nc = False
     for i in xrange(16):
         m = 1 << i
         c = s[i]
         if c == 'X':
             x |= m
         elif c == 'O':
             o |= m
         elif c == 'T':
             x |= m
             o |= m
         else:
             nc = True
     r = ''
     for m in mm:
         if m & x == m:
             r = 'X won'
             break
         if m & o == m:
             r = 'O won'
             break
     if not r:
         if nc:
             r = 'Game has not completed'
         else:
             r = 'Draw'
     
     return out + r
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 0
     outs = []
     for case in xrange(1, n+1):
         buff = []
         ln += 1
         while ln < len(lines) and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""6
 XXXT
 ....
 OO..
 ....
 
 XOXT
 XXOO
 OXOX
 XXOO
 
 XOX.
 OX..
 ....
 ....
 
 OOXX
 OXXX
 OX.T
 O..O
 
 XXXO
 ..O.
 .O..
 T...
 
 OXXX
 XO..
 ..O.
 ...O""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'A-large.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2270488/graygrass/2453486/1/extracted/PA.py,1783,100,242,Python,2270488,1,2453486,graygrass,2013
91025,PA.py,"import math
 
 mm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
     s = ''.join(in_lines)
     x = 0
     o = 0
     nc = False
     for i in xrange(16):
         m = 1 << i
         c = s[i]
         if c == 'X':
             x |= m
         elif c == 'O':
             o |= m
         elif c == 'T':
             x |= m
             o |= m
         else:
             nc = True
     r = ''
     for m in mm:
         if m & x == m:
             r = 'X won'
             break
         if m & o == m:
             r = 'O won'
             break
     if not r:
         if nc:
             r = 'Game has not completed'
         else:
             r = 'Draw'
     
     return out + r
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 0
     outs = []
     for case in xrange(1, n+1):
         buff = []
         ln += 1
         while ln < len(lines) and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""6
 XXXT
 ....
 OO..
 ....
 
 XOXT
 XXOO
 OXOX
 XXOO
 
 XOX.
 OX..
 ....
 ....
 
 OOXX
 OXXX
 OX.T
 O..O
 
 XXXO
 ..O.
 .O..
 T...
 
 OXXX
 XO..
 ..O.
 ...O""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'A-small-attempt0.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2270488/graygrass/2453486/0/extracted/PA.py,1792,100,242,Python,2270488,0,2453486,graygrass,2013
91026,PC.py,"import math
 import itertools
 
 def ttt(m):
     n = int(math.sqrt(m))
     if n*n == m:
         return n
     else:
         return 0
 
 def rsame(m):
     t = str(m)
     rt = list(t)
     rt.reverse()
     t = list(t)
     return t == rt
 
 cst = set([1, 2, 3])
 def fs(hn):
     rn = hn - 1
     tpdt = 10**rn
     tp = 10**hn
     if rn >= 3:
         g3 = itertools.combinations(range(rn), 3)
         try:
             while True:
                 hcde = tpdt
                 item = g3.next()
                 for e in item:
                     hcde += 10**e
                 strh = str(hcde)[-1::-1]
                 ii = int(strh)
                 ee = ii + hcde * tp
                 oo = ii + hcde * 10*tp
                 oo1 = oo + tp
                 cst.add(ee)
                 cst.add(oo)
                 cst.add(oo1)
         except StopIteration:
             pass
     if rn >= 2:
         g2 = itertools.combinations(range(rn), 2)
         try:
             while True:
                 hcde = tpdt
                 item = g2.next()
                 for e in item:
                     hcde += 10**e
                 strh = str(hcde)[-1::-1]
                 ii = int(strh)
                 ee = ii + hcde * tp
                 oo = ii + hcde * 10*tp
                 oo1 = oo + tp
                 cst.add(ee)
                 cst.add(oo)
                 cst.add(oo1)
         except StopIteration:
             pass
     if rn >= 1:
         g1 = itertools.combinations(range(rn), 1)
         try:
             while True:
                 hcde = tpdt
                 item = g1.next()
                 for e in item:
                     hcde += 10**e
                 strh = str(hcde)[-1::-1]
                 ii = int(strh)
                 ee = ii + hcde * tp
                 oo = ii + hcde * 10*tp
                 oo1 = oo + tp
                 oo2 = oo1 + tp
                 cst.add(ee)
                 cst.add(oo)
                 cst.add(oo1)
                 cst.add(oo2)
         except StopIteration:
             pass
     hcde = tpdt
     ii = 1
     ee = ii + hcde * tp
     eex2 = ee + ee
     oo = ii + hcde * 10*tp
     oox2 = oo + oo
     oo1 = oo + tp
     oo1x2 = oo1 + oo
     oo2 = oo1 + tp
     cst.add(ee)
     cst.add(eex2)
     cst.add(oo)
     cst.add(oox2)
     cst.add(oo1)
     cst.add(oo1x2)
     cst.add(oo2)
 
 gl = []    
 def bake():
     for n in range(1,25):
         fs(n)
     global gl
     gl = list(cst)
     gl.sort()
     gl = [x*x for x in gl]
     
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     a, b = [int(x) for x in in_lines[0].split()]
     c = 0
         
     for x in range(a, b+1):
         y = ttt(x)
         if y and rsame(x) and rsame(y):
             print x,
             c += 1
 
     return out + str(c)
 
 def solve2(case, in_lines):
     out = 'Case #%d: '%case
  
     a, b = [int(x) for x in in_lines[0].split()]
     c = len([x for x in gl if b >= x >= a])
  
     return out + str(c)
 
 def main(raw):
     bake()
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         cl = ln + 1
         while ln < cl and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve2(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""4
 1 10000000
 1 4
 10 120
 100 1000""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'C-large-2.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2270488/graygrass/2463486/2/extracted/PC.py,3902,163,480,Python,2270488,2,2463486,graygrass,2013
91027,PC.py,"import math
 import itertools
 
 def ttt(m):
     n = int(math.sqrt(m))
     if n*n == m:
         return n
     else:
         return 0
 
 def rsame(m):
     t = str(m)
     rt = list(t)
     rt.reverse()
     t = list(t)
     return t == rt
 
 cst = set([1, 2, 3])
 def fs(hn):
     rn = hn - 1
     tpdt = 10**rn
     tp = 10**hn
     if rn >= 3:
         g3 = itertools.combinations(range(rn), 3)
         try:
             while True:
                 hcde = tpdt
                 item = g3.next()
                 for e in item:
                     hcde += 10**e
                 strh = str(hcde)[-1::-1]
                 ii = int(strh)
                 ee = ii + hcde * tp
                 oo = ii + hcde * 10*tp
                 oo1 = oo + tp
                 cst.add(ee)
                 cst.add(oo)
                 cst.add(oo1)
         except StopIteration:
             pass
     if rn >= 2:
         g2 = itertools.combinations(range(rn), 2)
         try:
             while True:
                 hcde = tpdt
                 item = g2.next()
                 for e in item:
                     hcde += 10**e
                 strh = str(hcde)[-1::-1]
                 ii = int(strh)
                 ee = ii + hcde * tp
                 oo = ii + hcde * 10*tp
                 oo1 = oo + tp
                 cst.add(ee)
                 cst.add(oo)
                 cst.add(oo1)
         except StopIteration:
             pass
     if rn >= 1:
         g1 = itertools.combinations(range(rn), 1)
         try:
             while True:
                 hcde = tpdt
                 item = g1.next()
                 for e in item:
                     hcde += 10**e
                 strh = str(hcde)[-1::-1]
                 ii = int(strh)
                 ee = ii + hcde * tp
                 oo = ii + hcde * 10*tp
                 oo1 = oo + tp
                 oo2 = oo1 + tp
                 cst.add(ee)
                 cst.add(oo)
                 cst.add(oo1)
                 cst.add(oo2)
         except StopIteration:
             pass
     hcde = tpdt
     ii = 1
     ee = ii + hcde * tp
     eex2 = ee + ee
     oo = ii + hcde * 10*tp
     oox2 = oo + oo
     oo1 = oo + tp
     oo1x2 = oo1 + oo
     oo2 = oo1 + tp
     cst.add(ee)
     cst.add(eex2)
     cst.add(oo)
     cst.add(oox2)
     cst.add(oo1)
     cst.add(oo1x2)
     cst.add(oo2)
 
 gl = []    
 def bake():
     for n in range(1,25):
         fs(n)
     global gl
     gl = list(cst)
     gl.sort()
     gl = [x*x for x in gl]
     
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     a, b = [int(x) for x in in_lines[0].split()]
     c = 0
         
     for x in range(a, b+1):
         y = ttt(x)
         if y and rsame(x) and rsame(y):
             print x,
             c += 1
 
     return out + str(c)
 
 def solve2(case, in_lines):
     out = 'Case #%d: '%case
  
     a, b = [int(x) for x in in_lines[0].split()]
     c = len([x for x in gl if b >= x >= a])
  
     return out + str(c)
 
 def main(raw):
     bake()
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         cl = ln + 1
         while ln < cl and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve2(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""4
 1 10000000
 1 4
 10 120
 100 1000""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'C-large-1.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2270488/graygrass/2463486/1/extracted/PC.py,3902,163,480,Python,2270488,1,2463486,graygrass,2013
91028,PC.py,"import math
 
 def ss(t, amap, bmap):
     s = 0
     for m in amap:
         if len(m) == 1 and t == m.keys()[0]:
             s += m[t]
             for b in bmap:
                 if t in b:
                     b[t] -= 1
                     if b[t] == 0:
                         b.pop(t)
             m.clear()
     return s           
 
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     rn, cn = [int(x) for x in in_lines[0].split()]
     mtx = []
     for i in xrange(rn):
         mtx.append([int(x) for x in in_lines[i+1].split()])
     rmap = [{} for x in xrange(rn)]
     cmap = [{} for x in xrange(cn)]
     td = {}
     
     for i in xrange(rn):
         for j in range(cn):
             k = mtx[i][j]
             if k in rmap[i]:
                 rmap[i][k] += 1
             else:
                 rmap[i][k] = 1
             if k in cmap[j]:
                 cmap[j][k] += 1
             else:
                 cmap[j][k] = 1
             if k in td:
                 td[k] += 1
             else:
                 td[k] = 1
                 
     while len(td):
         k = min(td.keys())
         sb = ss(k, rmap, cmap)
         sb += ss(k, cmap, rmap)
         if sb == 0:
             break;
         td[k] -= sb
         if td[k] == 0:
             td.pop(k)
 
     return out + ('YES' if sb else 'NO')
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         cl = int(lines[ln].split()[0]) + ln + 1
         while ln < cl and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""4
 4 3
 2 5 2
 1 1 1
 2 4 2
 2 3 2
 3 3
 2 1 2
 1 1 1
 2 1 2
 5 5
 2 2 2 2 2
 2 1 1 1 2
 2 1 2 1 2
 2 1 1 1 2
 2 2 2 2 2
 1 3
 1 2 1""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'B-large.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2270488/graygrass/2463486/0/extracted/PC.py,2354,105,325,Python,2270488,0,2463486,graygrass,2013
91030,PB.py,"import math
 
 def ss(t, amap, bmap):
     s = 0
     for m in amap:
         if len(m) == 1 and t == m.keys()[0]:
             s += m[t]
             for b in bmap:
                 if t in b:
                     b[t] -= 1
                     if b[t] == 0:
                         b.pop(t)
             m.clear()
     return s           
 
 
 def solve(case, in_lines):
     out = 'Case #%d: '%case
  
     rn, cn = [int(x) for x in in_lines[0].split()]
     mtx = []
     for i in xrange(rn):
         mtx.append([int(x) for x in in_lines[i+1].split()])
     rmap = [{} for x in xrange(rn)]
     cmap = [{} for x in xrange(cn)]
     td = {}
     
     for i in xrange(rn):
         for j in range(cn):
             k = mtx[i][j]
             if k in rmap[i]:
                 rmap[i][k] += 1
             else:
                 rmap[i][k] = 1
             if k in cmap[j]:
                 cmap[j][k] += 1
             else:
                 cmap[j][k] = 1
             if k in td:
                 td[k] += 1
             else:
                 td[k] = 1
                 
     while len(td):
         k = min(td.keys())
         sb = ss(k, rmap, cmap)
         sb += ss(k, cmap, rmap)
         if sb == 0:
             break;
         td[k] -= sb
         if td[k] == 0:
             td.pop(k)
 
     return out + ('YES' if sb else 'NO')
 
 
 def main(raw):
     lines = raw.split('\n')
     n = int(lines[0])
     ln = 1
     outs = []
     for case in xrange(1, n+1):
         buff = []
         cl = int(lines[ln].split()[0]) + ln + 1
         while ln < cl and lines[ln]:
             buff.append(lines[ln])
             ln += 1
         s = solve(case, buff)
         print s
         outs.append(s)
     return '\n'.join(outs)
     pass
 
 if __name__ == '__main__':
     test_input = """"""4
 4 3
 2 5 2
 1 1 1
 2 4 2
 2 3 2
 3 3
 2 1 2
 1 1 1
 2 1 2
 5 5
 2 2 2 2 2
 2 1 1 1 2
 2 1 2 1 2
 2 1 1 1 2
 2 2 2 2 2
 1 3
 1 2 1""""""
     force_no_file = False
     in_file_name = '' if force_no_file else 'B-small-attempt0.in'
     base_path = 'G:/workspace/py/codejam2013/RQ/'
     if in_file_name:
         with open(base_path + in_file_name) as f:
             raw = f.read()
     else:
         raw = test_input
     out = main(raw)
     if in_file_name:
         with open(base_path + in_file_name + '.out', 'w') as f:
             f.write(out)
     pass",gcj/2013/2270488/graygrass/2449486/0/extracted/PB.py,2363,105,325,Python,2270488,0,2449486,graygrass,2013
60658,pd.py,"import os
 import bisect
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         nn = [float(x) for x in inputs[1].split()]
         nn.sort()
         kk = [float(x) for x in inputs[2].split()]
         kk.sort()
         dw = self.dwar(nn[:], kk[:])
         w = self.war(nn[:], kk[:])
         return '%d %d'%(dw, w)
         pass
     
     def dwar(self, nn, kk):
         turn = len(nn)
         cnt = 0
         for i in range(turn):
             i = i
             if nn[-1] < kk[-1]:
                 nn.pop(0)
                 kk.pop(-1)
             elif nn[0] < kk[0]:
                 nn.pop(0)
                 kk.pop(-1)
             else:
                 cnt += 1
                 nn.pop(0)
                 kk.pop(0)
         return cnt
     
     def war(self, nn, kk):
         turn = len(nn)
         cnt = 0
         for i in range(turn):
             i = i
             j = bisect.bisect_left(kk, nn[0])
             if j == len(kk):
                 cnt += 1
                 kk.pop(0)
             else:
                 kk.pop(j)
             nn.pop(0)
         return cnt
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 3
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'D-large.in'
 #     iname = 'foo'
     sample_in = '''
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
     '''
     sample_out = '''
 Case #1: 0 0
 Case #2: 1 0
 Case #3: 2 1
 Case #4: 8 4
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5644738749267968/1/extracted/pd.py,2926,110,322,Python,2974486,1,5644738749267968,graygrass,2014
60659,pd.py,"import os
 import bisect
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         nn = [float(x) for x in inputs[1].split()]
         nn.sort()
         kk = [float(x) for x in inputs[2].split()]
         kk.sort()
         dw = self.dwar(nn[:], kk[:])
         w = self.war(nn[:], kk[:])
         return '%d %d'%(dw, w)
         pass
     
     def dwar(self, nn, kk):
         turn = len(nn)
         cnt = 0
         for i in range(turn):
             i = i
             if nn[-1] < kk[-1]:
                 nn.pop(0)
                 kk.pop(-1)
             elif nn[0] < kk[0]:
                 nn.pop(0)
                 kk.pop(-1)
             else:
                 cnt += 1
                 nn.pop(0)
                 kk.pop(0)
         return cnt
     
     def war(self, nn, kk):
         turn = len(nn)
         cnt = 0
         for i in range(turn):
             i = i
             j = bisect.bisect_left(kk, nn[0])
             if j == len(kk):
                 cnt += 1
                 kk.pop(0)
             else:
                 kk.pop(j)
             nn.pop(0)
         return cnt
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 3
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'D-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
     '''
     sample_out = '''
 Case #1: 0 0
 Case #2: 1 0
 Case #3: 2 1
 Case #4: 8 4
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5644738749267968/0/extracted/pd.py,2935,110,322,Python,2974486,0,5644738749267968,graygrass,2014
60660,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         c, f, x = [float(t) for t in inputs[0].split()]
         if x <= c:
             return '%.7f'%(x/2)
         ii = int(math.ceil((f*x-2*c)/(f*c)-1))
         if ii <= 0:
             return '%.7f'%(x/2)
         t = 0
         for i in range(ii):
             t += c/(2+i*f)
         t += x/(2+ii*f)
         return '%.7f'%t
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-large.in'
 #     iname = 'foo'
     sample_in = '''
     4
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
     '''
     sample_out = '''
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5709773144064000/1/extracted/pb.py,2178,75,236,Python,2974486,1,5709773144064000,graygrass,2014
60661,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         c, f, x = [float(t) for t in inputs[0].split()]
         if x <= c:
             return '%.7f'%(x/2)
         ii = int(math.ceil((f*x-2*c)/(f*c)-1))
         if ii <= 0:
             return '%.7f'%(x/2)
         t = 0
         for i in range(ii):
             t += c/(2+i*f)
         t += x/(2+ii*f)
         return '%.7f'%t
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
     4
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
     '''
     sample_out = '''
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5709773144064000/0/extracted/pb.py,2187,75,236,Python,2974486,0,5709773144064000,graygrass,2014
60662,pc.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         R, C, M = [int(x) for x in inputs[0].split()]
         mp = []
         for r in range(R):
             mp.append(['.']*C)
         mp[0][0] = 'c'
         outputs = []
         if M == 0:
             for row in mp:
                 outputs.append(''.join(row))
             return outputs
         rr, cc, rm = R, C, M
         while rm >= min(rr, cc):
             if rr <= cc:
                 for r in range(rr):
                     mp[r][cc-1] = '*'
                 cc -= 1
                 rm -= rr
             else:
                 for c in range(cc):
                     mp[rr-1][c] = '*'
                 rr -= 1
                 rm -= cc
         
         if rm == 0:
             if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:
                 return ['Impossible']
         else:
             if min(rr, cc) - rm >= 2:
                 if rr <= cc:
                     for r in range(rr-rm, rr):
                         mp[r][cc-1] = '*'
                 else:
                     for c in range(cc-rm, cc):
                         mp[rr-1][c] = '*'
             else:
                 if min(rr, cc) >= 4:
                     if rr <= cc:
                         for r in range(2, rr):
                             mp[r][cc-1] = '*'
                         mp[rr-1][cc-2] = '*'
                     else:
                         for c in range(2, cc):
                             mp[rr-1][c] = '*'
                         mp[rr-2][cc-1]='*'
                 elif min(rr,cc) == 3:
                     if max(rr, cc) == 3:
                         return ['Impossible']
                     else:
                         if rr <= cc:
                             mp[2][cc-1] = '*'
                             mp[2][cc-2] = '*'
                         else:
                             mp[rr-1][2] = '*'
                             mp[rr-2][2] = '*'
                 else:
                     return ['Impossible']
                     
         for row in mp:
             outputs.append(''.join(row))
         return outputs
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             R, C, M = [int(x) for x in case_inputs[0].split()]
             rslt = self.solve(case_inputs)
             if self.verify(rslt, R, C, M):
                 outputs.append(rslt)
             else:
                 raise 'Failed'
         return outputs
     
     def verify(self, outputs, RR, CC, MCNT):
         if 'Impossible' == outputs[0]:
             return True
         rr = len(outputs)
         cc = len(outputs[0])
         if RR != rr or CC != cc:
             return False
         bd = []
         mask = []
         for i in range(rr):
             mask.append([1]*cc)
             bd.append([0]*cc)
             for j in range(cc):
                 if outputs[i][j] == '*':
                     bd[i][j] = 9
                 elif outputs[i][j] == 'c':
                     start = (i, j)
         for r in range(rr):
             for c in range(cc):
                 if bd[r][c] == 9:
                     for i in [r-1,r,r+1]:
                         for j in [c-1,c,c+1]:
                             if 0 <= i < rr and 0 <= j < cc:
                                 if bd[i][j] != 9:
                                     bd[i][j] += 1
 #         for i, row in enumerate(bd):
 #             print i, row
 
         nlist = [start]
         while len(nlist):
             i, j = nlist.pop(0)
             if mask[i][j] != 0:
                 mask[i][j] = 0
                 if bd[i][j] == 9:
                     raise '!!! BOMB'
                 elif bd[i][j] == 0:
                     for ii in [i-1,i,i+1]:
                         for jj in [j-1,j,j+1]:
                             if 0<=ii<rr and 0<=jj<cc:
                                 if ii != i or jj != j:
                                     nlist.append((ii,jj))
         mcnt = 0
         for r in range(rr):
 #             print mask[r]
             for c in range(cc):
                 if mask[r][c] == 1:
                     mcnt += 1
                 if mask[r][c] == 1 and bd[r][c] != 9:
                     return False
                 if mask[r][c] != 1 and bd[r][c] == 9:
                     return False
         return (mcnt == MCNT)
                 
 
 if __name__ == '__main__':
     iname = 'C-large.in'
 #     iname = 'foo'
     sample_in = '''
 7
 5 5 23
 3 1 1
 2 2 1
 4 7 3
 10 10 82
 3 4 0
 2 2 3
     '''
     sample_out = '''
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d:'%(i+1)
                 print >> f, '\n'.join(v)
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d:'%(i+1)
         print '\n'.join(v)
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5690574640250880/1/extracted/pc.py,5742,180,589,Python,2974486,1,5690574640250880,graygrass,2014
60663,pc.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         R, C, M = [int(x) for x in inputs[0].split()]
         mp = []
         for r in range(R):
             mp.append(['.']*C)
         mp[0][0] = 'c'
         outputs = []
         if M == 0:
             for row in mp:
                 outputs.append(''.join(row))
             return outputs
         rr, cc, rm = R, C, M
         while rm >= min(rr, cc):
             if rr <= cc:
                 for r in range(rr):
                     mp[r][cc-1] = '*'
                 cc -= 1
                 rm -= rr
             else:
                 for c in range(cc):
                     mp[rr-1][c] = '*'
                 rr -= 1
                 rm -= cc
         
         if rm == 0:
             if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:
                 return ['Impossible']
         else:
             if min(rr, cc) - rm >= 2:
                 if rr <= cc:
                     for r in range(rr-rm, rr):
                         mp[r][cc-1] = '*'
                 else:
                     for c in range(cc-rm, cc):
                         mp[rr-1][c] = '*'
             else:
                 if min(rr, cc) >= 4:
                     if rr <= cc:
                         for r in range(2, rr):
                             mp[r][cc-1] = '*'
                         mp[rr-1][cc-2] = '*'
                     else:
                         for c in range(2, cc):
                             mp[rr-1][c] = '*'
                         mp[rr-2][cc-1]='*'
                 elif min(rr,cc) == 3:
                     if max(rr, cc) == 3:
                         return ['Impossible']
                     else:
                         if rr <= cc:
                             mp[2][cc-1] = '*'
                             mp[2][cc-2] = '*'
                         else:
                             mp[rr-1][2] = '*'
                             mp[rr-2][2] = '*'
                 else:
                     return ['Impossible']
                     
         for row in mp:
             outputs.append(''.join(row))
         return outputs
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             R, C, M = [int(x) for x in case_inputs[0].split()]
             rslt = self.solve(case_inputs)
             if self.verify(rslt, R, C, M):
                 outputs.append(rslt)
             else:
                 raise 'Failed'
         return outputs
     
     def verify(self, outputs, RR, CC, MCNT):
         if 'Impossible' == outputs[0]:
             return True
         rr = len(outputs)
         cc = len(outputs[0])
         if RR != rr or CC != cc:
             return False
         bd = []
         mask = []
         for i in range(rr):
             mask.append([1]*cc)
             bd.append([0]*cc)
             for j in range(cc):
                 if outputs[i][j] == '*':
                     bd[i][j] = 9
                 elif outputs[i][j] == 'c':
                     start = (i, j)
         for r in range(rr):
             for c in range(cc):
                 if bd[r][c] == 9:
                     for i in [r-1,r,r+1]:
                         for j in [c-1,c,c+1]:
                             if 0 <= i < rr and 0 <= j < cc:
                                 if bd[i][j] != 9:
                                     bd[i][j] += 1
 #         for i, row in enumerate(bd):
 #             print i, row
 
         nlist = [start]
         while len(nlist):
             i, j = nlist.pop(0)
             if mask[i][j] != 0:
                 mask[i][j] = 0
                 if bd[i][j] == 9:
                     raise '!!! BOMB'
                 elif bd[i][j] == 0:
                     for ii in [i-1,i,i+1]:
                         for jj in [j-1,j,j+1]:
                             if 0<=ii<rr and 0<=jj<cc:
                                 if ii != i or jj != j:
                                     nlist.append((ii,jj))
         mcnt = 0
         for r in range(rr):
 #             print mask[r]
             for c in range(cc):
                 if mask[r][c] == 1:
                     mcnt += 1
                 if mask[r][c] == 1 and bd[r][c] != 9:
                     return False
                 if mask[r][c] != 1 and bd[r][c] == 9:
                     return False
         return (mcnt == MCNT)
                 
 
 if __name__ == '__main__':
     iname = 'C-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 7
 5 5 23
 3 1 1
 2 2 1
 4 7 3
 10 10 82
 3 4 0
 2 2 3
     '''
     sample_out = '''
 Case #1: 1.0000000
 Case #2: 39.1666667
 Case #3: 63.9680013
 Case #4: 526.1904762
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d:'%(i+1)
                 print >> f, '\n'.join(v)
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d:'%(i+1)
         print '\n'.join(v)
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5690574640250880/0/extracted/pc.py,5751,180,589,Python,2974486,0,5690574640250880,graygrass,2014
60664,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         r1 = int(inputs[0])
         cs1 = set([int(x) for x in inputs[r1].split()])
         r2 = int(inputs[5])
         cs2 = set([int(x) for x in inputs[5+r2].split()])
         r = cs1.intersection(cs2)
         cnt = len(r)
         if 1 == cnt:
             return max(r)
         elif 0 == cnt:
             return 'Volunteer cheated!'
         else:
             return 'Bad magician!'
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 10
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
     3
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 5 4
 3 11 6 15
 9 10 7 12
 13 14 8 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 2
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
 3
 1 2 3 4
 5 6 7 8
 9 10 11 12
 13 14 15 16
     '''
     sample_out = '''
  Case #1: 7
 Case #2: Bad magician!
 Case #3: Volunteer cheated!
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/2974486/graygrass/5756407898963968/0/extracted/pa.py,2418,100,327,Python,2974486,0,5756407898963968,graygrass,2014
138116,pa.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def gcd(self, a, b):
         a, b = max(a, b), min(a, b)
         while b != 0:
             a, b = b, a % b
         return a
     
     def solve(self, inputs):
         p, q = [int(x) for x in inputs[0].split('/')]
         g = self.gcd(q, p)
         qq = q / g
         pp = p / g
         genf = math.log(qq, 2)
         pl = int(math.floor(genf))
         ph = int(math.ceil(genf))
         x = -1
         if (1 << pl) == qq:
             x = pl
         if (1 << ph) == qq:
             x = ph
         if x == -1:
             return ""impossible""
         for i in range(x+1):
             if pp >= 2**(x-i):
                 return i
         pass
     
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
 #     iname = 'foo'
     sample_in = '''
 5
 1/2
 3/4
 1/4
 2/23
 123/31488
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 1
 Case #3: 2
 Case #4: impossible
 Case #5: 8
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/3004486/graygrass/5706278382862336/1/extracted/pa.py,2407,90,286,Python,3004486,1,5706278382862336,graygrass,2014
138117,pa.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def gcd(self, a, b):
         a, b = max(a, b), min(a, b)
         while b != 0:
             a, b = b, a % b
         return a
     
     def solve(self, inputs):
         p, q = [int(x) for x in inputs[0].split('/')]
         g = self.gcd(q, p)
         qq = q / g
         pp = p / g
         genf = math.log(qq, 2)
         pl = int(math.floor(genf))
         ph = int(math.ceil(genf))
         x = -1
         if (1 << pl) == qq:
             x = pl
         if (1 << ph) == qq:
             x = ph
         if x == -1:
             return ""impossible""
         for i in range(x+1):
             if pp >= 2**(x-i):
                 return i
         pass
     
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 5
 1/2
 3/4
 1/4
 2/23
 123/31488
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 1
 Case #3: 2
 Case #4: impossible
 Case #5: 8
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2014/3004486/graygrass/5706278382862336/0/extracted/pa.py,2416,90,286,Python,3004486,0,5706278382862336,graygrass,2014
4605,pa.py,"import os
 
 d_up = '^'
 d_down = 'v'
 d_left = '<'
 d_right = '>'
 d_no = '.'
         
 class Solver(object):
     def __init__(self):
         pass
     
     def fd(self, mtx, arrow):
         rr = len(mtx)
         cc = len(mtx[0])
         tr, tc, d = arrow
         if d == d_up:
             for r in range(tr-1, -1, -1):
                 if mtx[r][tc] != d_no:
                     return r, tc, mtx[r][tc]
         elif d == d_down:
             for r in range(tr+1, rr):
                 if mtx[r][tc] != d_no:
                     return r, tc, mtx[r][tc]
         elif d == d_left:
             for c in range(tc-1, -1, -1):
                 if mtx[tr][c] != d_no:
                     return tr, c, mtx[tr][c]
         elif d == d_right:
             for c in range(tc+1, cc):
                 if mtx[tr][c] != d_no:
                     return tr, c, mtx[tr][c]
     
     def solve(self, inputs):
         rr, cc = [int(x) for x in inputs[0].split()]
         mtx = []
         for line in inputs[1:]:
             line.strip()
             mtx.append(list(line))
         arr = []
         for tr in range(rr):
             for tc in range(cc):
                 if mtx[tr][tc] != d_no:
                     arr.append((tr, tc, mtx[tr][tc]))
         cnt = 0
         for a in arr:
             next = self.fd(mtx, a)
             if next:
                 continue
             found = False
             a_up = (a[0], a[1], d_up)
             a_down = (a[0], a[1], d_down)
             a_left = (a[0], a[1], d_left)
             a_right = (a[0], a[1], d_right)
             if a_up != a and not found:
                 if self.fd(mtx, a_up):
                     found = True
             if a_down != a and not found:
                 if self.fd(mtx, a_down):
                     found = True
             if a_left != a and not found:
                 if self.fd(mtx, a_left):
                     found = True
             if a_right != a and not found:
                 if self.fd(mtx, a_right):
                     found = True
             if not found:
                 return 'IMPOSSIBLE'
             else:
                 cnt += 1
         return cnt
             
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             r = int(lines[cur].split()[0])
             case_line_cnt = 1 + r
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
 #     iname = 'foo'
     sample_in = '''
 4
 2 1
 ^
 ^
 2 2
 >v
 ^<
 3 3
 ...
 .^.
 ...
 1 1
 .
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 0
 Case #3: IMPOSSIBLE
 Case #4: 0
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/8234486/graygrass/5708208098246656/1/extracted/pa.py,3880,135,435,Python,8234486,1,5708208098246656,graygrass,2015
4606,pa.py,"import os
 
 d_up = '^'
 d_down = 'v'
 d_left = '<'
 d_right = '>'
 d_no = '.'
         
 class Solver(object):
     def __init__(self):
         pass
     
     def fd(self, mtx, arrow):
         rr = len(mtx)
         cc = len(mtx[0])
         tr, tc, d = arrow
         if d == d_up:
             for r in range(tr-1, -1, -1):
                 if mtx[r][tc] != d_no:
                     return r, tc, mtx[r][tc]
         elif d == d_down:
             for r in range(tr+1, rr):
                 if mtx[r][tc] != d_no:
                     return r, tc, mtx[r][tc]
         elif d == d_left:
             for c in range(tc-1, -1, -1):
                 if mtx[tr][c] != d_no:
                     return tr, c, mtx[tr][c]
         elif d == d_right:
             for c in range(tc+1, cc):
                 if mtx[tr][c] != d_no:
                     return tr, c, mtx[tr][c]
     
     def solve(self, inputs):
         rr, cc = [int(x) for x in inputs[0].split()]
         mtx = []
         for line in inputs[1:]:
             line.strip()
             mtx.append(list(line))
         arr = []
         for tr in range(rr):
             for tc in range(cc):
                 if mtx[tr][tc] != d_no:
                     arr.append((tr, tc, mtx[tr][tc]))
         cnt = 0
         for a in arr:
             next = self.fd(mtx, a)
             if next:
                 continue
             found = False
             a_up = (a[0], a[1], d_up)
             a_down = (a[0], a[1], d_down)
             a_left = (a[0], a[1], d_left)
             a_right = (a[0], a[1], d_right)
             if a_up != a and not found:
                 if self.fd(mtx, a_up):
                     found = True
             if a_down != a and not found:
                 if self.fd(mtx, a_down):
                     found = True
             if a_left != a and not found:
                 if self.fd(mtx, a_left):
                     found = True
             if a_right != a and not found:
                 if self.fd(mtx, a_right):
                     found = True
             if not found:
                 return 'IMPOSSIBLE'
             else:
                 cnt += 1
         return cnt
             
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             r = int(lines[cur].split()[0])
             case_line_cnt = 1 + r
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 4
 2 1
 ^
 ^
 2 2
 >v
 ^<
 3 3
 ...
 .^.
 ...
 1 1
 .
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 0
 Case #3: IMPOSSIBLE
 Case #4: 0
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/8234486/graygrass/5708208098246656/0/extracted/pa.py,3889,135,435,Python,8234486,0,5708208098246656,graygrass,2015
13481,pb.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
 
     def helper1(self, t):
         if 0 == t % 2:
             mmax = t / 2
             cor = 1
             edge = t / 2 - 1
             return mmax, cor, edge
         else:
             mmax = (t + 1) / 2
             cor = 0
             edge = t - mmax
             return mmax, cor, edge
             
     def helper(self, r, c):
         mmax = -1
         cor = -1
         edge = -1
         mid = -1
         if 0 == r % 2:
             if 0 == c % 2:
                 mmax = r * c / 2
                 cor = 2
                 edge = r + c - cor
                 mid = r*c - mmax - cor - edge
             else:
                 mmax = r*c/2
                 cor = 2
                 edge = r+c-cor
                 mid = r*c -mmax - cor - edge
         else:
             if 0 == c % 2:
                 mmax = r*c/2
                 cor = 2
                 edge = r+c-cor
                 mid = r*c - mmax - cor - edge
             else:
                 mmax = (r-1)*(c-1)/2 + (r+c)/2
                 cor = 0
                 edge = r + c - 2
                 mid = r*c - mmax - cor - edge
         return mmax, cor, edge, mid
     
     def solve(self, inputs):
         rr, cc, nn = [int(x) for x in inputs[0].split()]
         if rr < cc:
             rr, cc = cc, rr
         if rr == cc == 3 and 8 == nn:
             return 8
         if cc == 1:
             mmax, cor, edge = self.helper1(rr)
             if nn <= mmax:
                 return 0
             elif nn <= mmax + cor:
                 return nn - mmax
             else:
                 return cor + 2*(nn - mmax - cor)
         else:
             mmax, cor, edge, mid = self.helper(rr, cc)
             if nn <= mmax:
                 return 0
             elif nn <= mmax + cor:
                 return (nn - mmax) * 2
             elif nn <= mmax + cor + edge:
                 return 2*cor + (nn - mmax - cor)*3
             else:
                 return 2*cor + 3*edge + (nn-mmax-cor-edge)*4
                 
             
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 4
 2 3 6
 4 1 2
 3 3 8
 5 2 0
     '''
     sample_out = '''
 Case #1: 7
 Case #2: 0
 Case #3: 8
 Case #4: 0
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/8224486/graygrass/5769900270288896/0/extracted/pb.py,3730,128,482,Python,8224486,0,5769900270288896,graygrass,2015
13482,pa.py,"import os
 
 class Solver(object):
     MM = 1000010
     def __init__(self):
         self.d = [0] * self.MM
         for i in range(self.MM):
             self.d[i] = i
         for i in range(1, self.MM):
             si = str(i)
             tr = list(si)
             tr.reverse()
             ri = int(''.join(tr))
             sri = str(ri)
             if len(sri) == len(si) and ri < i:
                 self.d[i] = min(self.d[i-1], self.d[ri]) + 1
             else:
                 self.d[i] = self.d[i-1] + 1
         pass
     
     def solve(self, inputs):
 #         print inputs
         k = int(inputs[0])
         return self.d[k]
             
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 3
 1
 19
 23
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 19
 Case #3: 15
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/8224486/graygrass/5688567749672960/0/extracted/pa.py,2268,78,243,Python,8224486,0,5688567749672960,graygrass,2015
63120,pd.py,"import os
 import bisect
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         whatever = 'GABRIEL'
         incase = 'RICHARD'
         x, r, c = [int(x) for x in inputs[0].split()]
         if r > c:
             r, c = c, r
         if x == 1:
             return whatever
         if x == 2:
             if (r*c) % 2 == 0:
                 return whatever
             else:
                 return incase
         if x == 3:
             if r == 1:
                 return incase
             elif r == 2:
                 if c == 3:
                     return whatever
                 else:
                     return incase
             elif r == 3:
                 return whatever
             else:
                 return incase
         if x == 4:
             if r == 1:
                 return incase
             elif r == 2:
                 return incase
             elif r == 3:
                 if c == 4:
                     return whatever
                 else:
                     return incase
             else:
                 return whatever
             
         pass
     
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'D-small-attempt1.in'
 #     iname = 'foo'
     sample_in = '''
 4
 2 2 2
 2 1 3
 4 4 1
 3 2 3
     '''
     sample_out = '''
 Case #1: GABRIEL
 Case #2: RICHARD
 Case #3: RICHARD
 Case #4: GABRIEL
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/6224486/graygrass/5658571765186560/0/extracted/pd.py,2817,102,306,Python,6224486,0,5658571765186560,graygrass,2015
63121,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def add(self, d, n, k=1):
         if n not in d:
             d[n] = k
         else:
             d[n] += k
             
     def sub(self, d, n):
         if n in d:
             if d[n] == 1:
                 d.pop(n)
             else:
                 d[n] -= 1
                 return False
         return True
     
     def solve(self, inputs):
         tmp = [int(x) for x in inputs[1].split()]
         dd = dict()
         for i in tmp:
             self.add(dd, i)
         
         sp = 0
         x = max(dd.keys())
         min = x
         while x > 3:
             sp += dd[x]
             s1 = x / 2
             s2 = x - s1
             self.add(dd, s1, dd[x])
             self.add(dd, s2, dd[x])
             dd.pop(x)
             x = max(dd.keys())
             if sp + x < min:
                 min = sp + x
             
         return min
         
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt1.in'
 #     iname = 'foo'
     sample_in = '''
 3
 5
 8 8 8 8 8
 4
 1 2 1 2
 1
 4
     '''
     sample_out = '''
 Case #1: 3
 Case #2: 2
 Case #3: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/6224486/graygrass/5686275109552128/0/extracted/pb.py,2611,101,298,Python,6224486,0,5686275109552128,graygrass,2015
63122,pc.py,"import os
 import bisect
 
 def neg(a):
     if isinstance(a, int):
         return -a
     if isinstance(a, list):
         return [-x for x in a]
 
 def cross(a, b):
     if a == b:
         return -1
     if a == neg(b):
         return 1
     c = [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]]
 
     return c
 
 def mul(a, b):
     if isinstance(a, list) and isinstance(b, list):
         return cross(a, b)
     if isinstance(a, list) and isinstance(b, int):
         return [b*x for x in a]
     if isinstance(a, int) and isinstance(b, list):
         return [a*x for x in b]
     if isinstance(a, int) and isinstance(b, int):
         return a*b
         
 ii = [1, 0, 0]
 jj = [0, 1, 0]
 kk = [0, 0, 1]
 yes = 'YES'
 no = 'NO'
 
 def vec(ch):
     if ch == 'i':
         return ii
     if ch == 'j':
         return jj
     if ch == 'k':
         return kk
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         
         ll, xx = [int(x) for x in inputs[0].split()]
         if xx >= 12:
             xx = 12 + xx % 12
         
         if xx % 4 == 0:
             return no
         
         ss = inputs[1]*xx
         
         iflag = False
         
         t = 1
         i = 0
         end = len(ss)
         while i < end:
             v = vec(ss[i])
             i += 1
             t = mul(t, v)
             if t == ii:
                 iflag = True
                 break
 
         if not iflag:
             return no
         
         t = 1        
         jflag = False
         while i < end:
             v = vec(ss[i])
             i += 1
             t = mul(t, v)
             if t == jj:
                 jflag = True
                 break
         
         if not jflag:
             return no
         
         t = 1
         while i < end:
             v = vec(ss[i])
             i += 1
             t = mul(t, v)
         
         if t == kk:
             return yes
         else:
             return no
             
         pass
     
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-large.in'
 #     iname = 'foo'
     sample_in = '''
 5
 2 1
 ik
 3 1
 ijk
 3 1
 kji
 2 6
 ji
 1 10000
 i
     '''
     sample_out = '''
 Case #1: NO
 Case #2: YES
 Case #3: NO
 Case #4: YES
 Case #5: NO
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/6224486/graygrass/5670465267826688/1/extracted/pc.py,3741,163,460,Python,6224486,1,5670465267826688,graygrass,2015
63123,pc.py,"import os
 import bisect
 
 def neg(a):
     if isinstance(a, int):
         return -a
     if isinstance(a, list):
         return [-x for x in a]
 
 def cross(a, b):
     if a == b:
         return -1
     if a == neg(b):
         return 1
     c = [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]]
 
     return c
 
 def mul(a, b):
     if isinstance(a, list) and isinstance(b, list):
         return cross(a, b)
     if isinstance(a, list) and isinstance(b, int):
         return [b*x for x in a]
     if isinstance(a, int) and isinstance(b, list):
         return [a*x for x in b]
     if isinstance(a, int) and isinstance(b, int):
         return a*b
         
 ii = [1, 0, 0]
 jj = [0, 1, 0]
 kk = [0, 0, 1]
 yes = 'YES'
 no = 'NO'
 
 def vec(ch):
     if ch == 'i':
         return ii
     if ch == 'j':
         return jj
     if ch == 'k':
         return kk
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         
         ll, xx = [int(x) for x in inputs[0].split()]
         if xx >= 12:
             xx = 12 + xx % 12
         
         if xx % 4 == 0:
             return no
         
         ss = inputs[1]*xx
         
         iflag = False
         
         t = 1
         i = 0
         end = len(ss)
         while i < end:
             v = vec(ss[i])
             i += 1
             t = mul(t, v)
             if t == ii:
                 iflag = True
                 break
 
         if not iflag:
             return no
         
         t = 1        
         jflag = False
         while i < end:
             v = vec(ss[i])
             i += 1
             t = mul(t, v)
             if t == jj:
                 jflag = True
                 break
         
         if not jflag:
             return no
         
         t = 1
         while i < end:
             v = vec(ss[i])
             i += 1
             t = mul(t, v)
         
         if t == kk:
             return yes
         else:
             return no
             
         pass
     
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-small-attempt2.in'
 #     iname = 'foo'
     sample_in = '''
 5
 2 1
 ik
 3 1
 ijk
 3 1
 kji
 2 6
 ji
 1 10000
 i
     '''
     sample_out = '''
 Case #1: NO
 Case #2: YES
 Case #3: NO
 Case #4: YES
 Case #5: NO
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/6224486/graygrass/5670465267826688/0/extracted/pc.py,3750,163,460,Python,6224486,0,5670465267826688,graygrass,2015
63124,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         n, ss = inputs[0].split()
         n = int(n) + 1
         ss = [int(x) for x in ss]
         
         std = 0
         ivt = 0
         
         for i in range(n):
             if std < i:
                 nivt = i - std
                 ivt += nivt
                 std += nivt
             std += ss[i]
         
         return ivt
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
 #     iname = 'foo'
     sample_in = '''
     4
 4 11111
 1 09
 5 110011
 0 1
     '''
     sample_out = '''
 Case #1: 0
 Case #2: 1
 Case #3: 2
 Case #4: 0
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/6224486/graygrass/5639104758808576/1/extracted/pa.py,2095,78,237,Python,6224486,1,5639104758808576,graygrass,2015
63125,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         n, ss = inputs[0].split()
         n = int(n) + 1
         ss = [int(x) for x in ss]
         
         std = 0
         ivt = 0
         
         for i in range(n):
             if std < i:
                 nivt = i - std
                 ivt += nivt
                 std += nivt
             std += ss[i]
         
         return ivt
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
     4
 4 11111
 1 09
 5 110011
 0 1
     '''
     sample_out = '''
 Case #1: 0
 Case #2: 1
 Case #3: 2
 Case #4: 0
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/6224486/graygrass/5639104758808576/0/extracted/pa.py,2104,78,237,Python,6224486,0,5639104758808576,graygrass,2015
118970,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         cc = [int(x) for x in inputs[1].split()]
         y = 0
         for i in range(1, len(cc)):
             if cc[i] < cc[i-1]:
                 y += cc[i-1] - cc[i]
         
         tx = 0
         for i in range(1, len(cc)):
             if tx < cc[i-1] - cc[i]:
                 tx = cc[i-1] - cc[i]
         z = 0
         for i in range(len(cc) - 1):
             if cc[i] > tx:
                 z += tx
             else:
                 z += cc[i]
         
         return '%d %d'%(y, z)
             
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
 #     iname = 'foo'
     sample_in = '''
 4
 4
 10 5 15 5
 2
 100 100
 8
 81 81 81 81 81 81 81 0
 6
 23 90 40 0 100 9
     '''
     sample_out = '''
 Case #1: 15 25
 Case #2: 0 0
 Case #3: 81 567
 Case #4: 181 244
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/4224486/graygrass/6404600001200128/1/extracted/pa.py,2315,85,277,Python,4224486,1,6404600001200128,graygrass,2015
118971,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         cc = [int(x) for x in inputs[1].split()]
         y = 0
         for i in range(1, len(cc)):
             if cc[i] < cc[i-1]:
                 y += cc[i-1] - cc[i]
         
         tx = 0
         for i in range(1, len(cc)):
             if tx < cc[i-1] - cc[i]:
                 tx = cc[i-1] - cc[i]
         z = 0
         for i in range(len(cc) - 1):
             if cc[i] > tx:
                 z += tx
             else:
                 z += cc[i]
         
         return '%d %d'%(y, z)
             
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 4
 4
 10 5 15 5
 2
 100 100
 8
 81 81 81 81 81 81 81 0
 6
 23 90 40 0 100 9
     '''
     sample_out = '''
 Case #1: 15 25
 Case #2: 0 0
 Case #3: 81 567
 Case #4: 181 244
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/4224486/graygrass/6404600001200128/0/extracted/pa.py,2324,85,277,Python,4224486,0,6404600001200128,graygrass,2015
134952,pc.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         cc, dd, vv = [int(x) for x in inputs[0].split()]
         dd = [int(x) for x in inputs[1].split()]
         dd.sort()
         cnt = 0
         idx = 0
         if dd[0] != 1:
             dd.insert(0, 1)
             cnt += 1
         idx = 1
         t = cc
         while t < vv:
             if (idx >= len(dd)) or (dd[idx] > t + 1):
                 dd.insert(idx, t+1)
                 cnt += 1
                 t += cc*(t+1)
             else:
                 t += cc*dd[idx]
             idx += 1
         return cnt
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-large.in'
 #     iname = 'foo'
     sample_in = '''
 4
 1 2 3
 1 2
 1 3 6
 1 2 5
 2 1 3
 3
 1 6 100
 1 5 10 25 50 100
     '''
     sample_out = '''
 Case #1: 0
 Case #2: 1
 Case #3: 1
 Case #4: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/4244486/graygrass/5646553574277120/1/extracted/pc.py,2302,85,275,Python,4244486,1,5646553574277120,graygrass,2015
134953,pc.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         cc, dd, vv = [int(x) for x in inputs[0].split()]
         dd = [int(x) for x in inputs[1].split()]
         dd.sort()
         cnt = 0
         idx = 0
         if dd[0] != 1:
             dd.insert(0, 1)
             cnt += 1
         idx = 1
         t = cc
         while t < vv:
             if (idx >= len(dd)) or (dd[idx] > t + 1):
                 dd.insert(idx, t+1)
                 cnt += 1
                 t += cc*(t+1)
             else:
                 t += cc*dd[idx]
             idx += 1
         return cnt
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 4
 1 2 3
 1 2
 1 3 6
 1 2 5
 2 1 3
 3
 1 6 100
 1 5 10 25 50 100
     '''
     sample_out = '''
 Case #1: 0
 Case #2: 1
 Case #3: 1
 Case #4: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/4244486/graygrass/5646553574277120/0/extracted/pc.py,2311,85,275,Python,4244486,0,5646553574277120,graygrass,2015
134954,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         rr, cc, ww = [int(x) for x in inputs[0].split()]
         
         if ww == 1:
             return rr*cc
         n, d = divmod(cc, ww)
         t = ww if d != 0 else ww-1
         k = rr*n + t
         return k
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
 #     iname = 'foo'
     sample_in = '''
 3
 1 4 2
 1 7 7
 2 5 1
     '''
     sample_out = '''
 Case #1: 3
 Case #2: 7
 Case #3: 10
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/4244486/graygrass/5640146288377856/1/extracted/pa.py,1936,68,224,Python,4244486,1,5640146288377856,graygrass,2015
134955,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         rr, cc, ww = [int(x) for x in inputs[0].split()]
         
         if ww == 1:
             return rr*cc
         n, d = divmod(cc, ww)
         t = ww if d != 0 else ww-1
         k = rr*n + t
         return k
         
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''
 3
 1 4 2
 1 7 7
 2 5 1
     '''
     sample_out = '''
 Case #1: 3
 Case #2: 7
 Case #3: 10
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2015/4244486/graygrass/5640146288377856/0/extracted/pa.py,1945,68,224,Python,4244486,0,5640146288377856,graygrass,2015
99476,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         n = int(inputs[0].strip())
         if n == 0:
             return 'INSOMNIA'
         ds = set()
         cnt = 0
         tn = n
         while len(ds) < 10:
             sn = str(tn)
             for c in sn:
                 ds.add(c)
             cnt += 1
             tn += n
         return cnt * n
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
 #     iname = 'foo'
     sample_in = '''5
 0
 1
 2
 11
 1692
     '''
     sample_out = '''
 Case #1: INSOMNIA
 Case #2: 10
 Case #3: 90
 Case #4: 110
 Case #5: 5076
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5652388522229760/1/extracted/pa.py,2072,77,230,Python,6254486,1,5652388522229760,graygrass,2016
99477,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         n = int(inputs[0].strip())
         if n == 0:
             return 'INSOMNIA'
         ds = set()
         cnt = 0
         tn = n
         while len(ds) < 10:
             sn = str(tn)
             for c in sn:
                 ds.add(c)
             cnt += 1
             tn += n
         return cnt * n
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
 #     iname = 'foo'
     sample_in = '''5
 0
 1
 2
 11
 1692
     '''
     sample_out = '''
 Case #1: INSOMNIA
 Case #2: 10
 Case #3: 90
 Case #4: 110
 Case #5: 5076
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5652388522229760/0/extracted/pa.py,2081,77,230,Python,6254486,0,5652388522229760,graygrass,2016
99478,pd.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         K, C, S = [int(x) for x in inputs[0].split()]
         if C*S < K:
             return 'IMPOSSIBLE'
         pos = []
         i = 0
         while i < K:
             n = 0
             for cc in range(1, C):
                 n = n*K + i
                 if i < K-1:
                     i += 1
             pos.append(n*K + i + 1)
             i = i+1
         return str(pos).strip('[]').replace(',', '').replace('L', '')    
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'D-large.in'
     sample_in = '''5
 2 3 2
 1 1 1
 2 1 1
 2 1 2
 3 2 3
     '''
     sample_out = '''
 Case #1: 2
 Case #2: 1
 Case #3: IMPOSSIBLE
 Case #4: 1 2
 Case #5: 2 6
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5636311922769920/1/extracted/pd.py,2207,78,257,Python,6254486,1,5636311922769920,graygrass,2016
99479,pd.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         K, C, S = [int(x) for x in inputs[0].split()]
         if C*S < K:
             return 'IMPOSSIBLE'
         pos = []
         i = 0
         while i < K:
             n = 0
             for cc in range(1, C):
                 n = n*K + i
                 if i < K-1:
                     i += 1
             pos.append(n*K + i + 1)
             i = i+1
         return str(pos).strip('[]').replace(',', '').replace('L', '')    
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'D-small-attempt0.in'
     sample_in = '''5
 2 3 2
 1 1 1
 2 1 1
 2 1 2
 3 2 3
     '''
     sample_out = '''
 Case #1: 2
 Case #2: 1
 Case #3: IMPOSSIBLE
 Case #4: 1 2
 Case #5: 2 6
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5636311922769920/0/extracted/pd.py,2216,78,257,Python,6254486,0,5636311922769920,graygrass,2016
99480,pc.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def getnum(self, nn, ones, base):
         num = 1
         for w in ones:
             num += base**w
         num += base**(nn-1)
         return num
         pass
     
     def getdiv(self, num):
         if num % 2 == 0:
             return 2
         if num % 3 == 0:
             return 3
         if num % 5 == 0:
             return 5
         if num % 7 == 0:
             return 7
         k = int(num**0.5) + 1
         for i in range(5, k, 2):
             if num % i == 0:
                 return i;
         return 1
         pass
     
     def solve(self, inputs):
         N, J = [int(x) for x in inputs[0].split()]
         cnt = 0
         rs = []
         for odd in itertools.combinations(range(1, N-1, 2), 5):
             for even in itertools.combinations(range(2, N-1, 2), 5):
                 ones = odd + even
                 bp = False
                 ds = []
                 for base in range(2, 11):
                     num = self.getnum(N, ones, base)
                     div = self.getdiv(num)
                     ds.append(div)
                     if base == 10:
                         ds.insert(0, num)
                     if div == 1 or div == num:
                         bp = True
                         break
                 if not bp:
                     cnt += 1
                     rr = str(ds).strip('[]').replace(',', '').replace('L', '')
 #                     print rr
                     rs.append(rr)
                 if cnt >= J:
                     break
             if cnt >= J:
                 break
 #         return ""found %d""%cnt
         return '\n'+'\n'.join(rs)    
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-large.in'
     sample_in = '''1
 32 50
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 1
 Case #3: 2
 Case #4: 0
 Case #5: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5738606668808192/1/extracted/pc.py,3347,112,365,Python,6254486,1,5738606668808192,graygrass,2016
99481,pc.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def getnum(self, nn, ones, base):
         num = 1
         for w in ones:
             num += base**w
         num += base**(nn-1)
         return num
         pass
     
     def getdiv(self, num):
         if num % 2 == 0:
             return 2
         if num % 3 == 0:
             return 3
         if num % 5 == 0:
             return 5
         if num % 7 == 0:
             return 7
         k = int(num**0.5) + 1
         for i in range(5, k, 2):
             if num % i == 0:
                 return i;
         return 1
         pass
     
     def solve(self, inputs):
         N, J = [int(x) for x in inputs[0].split()]
         cnt = 0
         rs = []
         for odd in itertools.combinations(range(1, N-1, 2), 5):
             for even in itertools.combinations(range(2, N-1, 2), 5):
                 ones = odd + even
                 bp = False
                 ds = []
                 for base in range(2, 11):
                     num = self.getnum(N, ones, base)
                     div = self.getdiv(num)
                     ds.append(div)
                     if base == 10:
                         ds.insert(0, num)
                     if div == 1 or div == num:
                         bp = True
                         break
                 if not bp:
                     cnt += 1
                     rr = str(ds).strip('[]').replace(',', '').replace('L', '')
 #                     print rr
                     rs.append(rr)
                 if cnt >= J:
                     break
             if cnt >= J:
                 break
 #         return ""found %d""%cnt
         return '\n'+'\n'.join(rs)    
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-small-attempt0.in'
     sample_in = '''1
 32 50
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 1
 Case #3: 2
 Case #4: 0
 Case #5: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5738606668808192/0/extracted/pc.py,3356,112,365,Python,6254486,0,5738606668808192,graygrass,2016
99482,pb.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     
     def solve(self, inputs):
         stack = inputs[0].strip()
         cnt = 0
         pc = 'x'
         for c in stack:
             if c != pc:
                 cnt += 1
                 pc = c
         if stack[-1] == '+':
             return cnt - 1
         else:
             return cnt
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-large.in'
     sample_in = '''5
 -
 -+
 +-
 +++
 --+-
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 1
 Case #3: 2
 Case #4: 0
 Case #5: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5634697451274240/1/extracted/pb.py,1998,75,220,Python,6254486,1,5634697451274240,graygrass,2016
99483,pb.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     
     def solve(self, inputs):
         stack = inputs[0].strip()
         cnt = 0
         pc = 'x'
         for c in stack:
             if c != pc:
                 cnt += 1
                 pc = c
         if stack[-1] == '+':
             return cnt - 1
         else:
             return cnt
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt0.in'
     sample_in = '''5
 -
 -+
 +-
 +++
 --+-
     '''
     sample_out = '''
 Case #1: 1
 Case #2: 1
 Case #3: 2
 Case #4: 0
 Case #5: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/6254486/graygrass/5634697451274240/0/extracted/pb.py,2007,75,220,Python,6254486,0,5634697451274240,graygrass,2016
191715,pa.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         ss = inputs[0].strip()
         c = [0]*10 
         c[0] = ss.count('Z')
         c[2] = ss.count('W')
         c[4] = ss.count('U')
         c[6] = ss.count('X')
         c[8] = ss.count('G')
         c[7] = ss.count('S') - c[6]
         c[5] = ss.count('F') - c[4]
         c[3] = ss.count('H') - c[8]
         c[9] = ss.count('I') - c[5] - c[6] - c[8]
         c[1] = ss.count('N') - c[9] - c[9] - c[7]
         r = []
         for i, cc in enumerate(c):
             for t in range(cc):
                 r.append(str(i))
         return ''.join(r)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
     sample_in = '''4
 OZONETOWER
 WEIGHFOXTOURIST
 OURNEONFOE
 ETHER
     '''
     sample_out = '''
 Case #1: 012
 Case #2: 2468
 Case #3: 114
 Case #4: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/11254486/graygrass/5648941810974720/1/extracted/pa.py,2326,79,253,Python,11254486,1,5648941810974720,graygrass,2016
191716,pa.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         ss = inputs[0].strip()
         c = [0]*10 
         c[0] = ss.count('Z')
         c[2] = ss.count('W')
         c[4] = ss.count('U')
         c[6] = ss.count('X')
         c[8] = ss.count('G')
         c[7] = ss.count('S') - c[6]
         c[5] = ss.count('F') - c[4]
         c[3] = ss.count('H') - c[8]
         c[9] = ss.count('I') - c[5] - c[6] - c[8]
         c[1] = ss.count('N') - c[9] - c[9] - c[7]
         r = []
         for i, cc in enumerate(c):
             for t in range(cc):
                 r.append(str(i))
         return ''.join(r)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
     sample_in = '''4
 OZONETOWER
 WEIGHFOXTOURIST
 OURNEONFOE
 ETHER
     '''
     sample_out = '''
 Case #1: 012
 Case #2: 2468
 Case #3: 114
 Case #4: 3
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/11254486/graygrass/5648941810974720/0/extracted/pa.py,2335,79,253,Python,11254486,0,5648941810974720,graygrass,2016
213831,pb.py,"import os
 import math
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
 
     def get(self, i, j, k, r, b):
         if j <= i:
             return 0
         if j == b:
             if i <= k+1:
                 return 1
             elif i > k+2:
                 return 0
             else:
                 if int(r) > 0:
                     return 1
                 else:
                     return 0
         if j <= k+1:
             return 1
         if j > k+2:
             return 0
         if i == 1:
             return 0
         jj = k+2-j
         if r[jj] == '1':
             return 1
         else:
             return 0
             
     
     def solve(self, inputs):
         b, m = [int(x) for x in inputs[0].strip().split()]
         maxm = 2**(b-2)
         if m > maxm:
             return ""IMPOSSIBLE""
         k = int(math.floor(math.log(m, 2)))
         tt = '{0:0%db}'%(k+1)
         r = tt.format(m - 2**k)
         result = []
         for i in range(b):
             row = []
             for j in range(b):
                 t = self.get(i+1, j+1, k, r, b)
                 row.append(str(t))
             result.append(''.join(row))
         result.insert(0, 'POSSIBLE')
         return '\n'.join(result)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt7.in'
     sample_in = '''3
 5 5
 5 4
 2 1
 4 20
     '''
     sample_out = '''
 Case #1: POSSIBLE
 01001
 00110
 00001
 00101
 00000
 Case #2: POSSIBLE
 01
 00
 Case #3: IMPOSSIBLE
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/4314486/graygrass/5744014401732608/0/extracted/pb.py,2942,111,319,Python,4314486,0,5744014401732608,graygrass,2016
213832,pa.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         ss = inputs[1].strip()
         ss = [(int(x), chr(ord('A') + i)) for i, x in enumerate(ss.split())]
         ss.sort(key=lambda x: x[0])
         ss.reverse()
         rslt = []
         while ss[0][0] > ss[1][0]:
             rslt.append(ss[0][1])
             ss[0] = (ss[0][0] - 1, ss[0][1])
         for t in ss[2:]:
             x = t[0]
             while x > 0:
                 rslt.append(t[1])
                 x -= 1
         for i in range(ss[1][0]):
             rslt.append(ss[0][1]+ss[1][1])
         return ' '.join(rslt)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
     sample_in = '''4
 2
 2 2
 3
 3 2 2
 3
 1 1 2
 3
 2 3 1
     '''
     sample_out = '''
 Case #1: AB BA
 Case #2: AA BC C BA
 Case #3: C C AB
 Case #4: BA BB CA
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/4314486/graygrass/5753053697277952/1/extracted/pa.py,2320,82,258,Python,4314486,1,5753053697277952,graygrass,2016
213833,pa.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         ss = inputs[1].strip()
         ss = [(int(x), chr(ord('A') + i)) for i, x in enumerate(ss.split())]
         ss.sort(key=lambda x: x[0])
         ss.reverse()
         rslt = []
         while ss[0][0] > ss[1][0]:
             rslt.append(ss[0][1])
             ss[0] = (ss[0][0] - 1, ss[0][1])
         for t in ss[2:]:
             x = t[0]
             while x > 0:
                 rslt.append(t[1])
                 x -= 1
         for i in range(ss[1][0]):
             rslt.append(ss[0][1]+ss[1][1])
         return ' '.join(rslt)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 2
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
     sample_in = '''4
 2
 2 2
 3
 3 2 2
 3
 1 1 2
 3
 2 3 1
     '''
     sample_out = '''
 Case #1: AB BA
 Case #2: AA BC C BA
 Case #3: C C AB
 Case #4: BA BB CA
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2016/4314486/graygrass/5753053697277952/0/extracted/pa.py,2329,82,258,Python,4314486,0,5753053697277952,graygrass,2016
7050,pa.py,"import os
 
 class Rect(object):
     def __init__(self, char, r, c):
         self.char = char
         self.left = c
         self.right = c
         self.top = r
         self.bottom = r
     
     def include(self, r, c, cad):
         if c < self.left:
             self.left = c
         if c > self.right:
             self.right = c
         if r < self.top:
             self.top = r
         if r > self.bottom:
             self.bottom = r
             
     def fill(self, cad):
         for r in range(self.top, self.bottom+1):
             for c in range(self.left, self.right+1):
                 cad[r][c] = self.char
         
     def exLeft(self, cad):
         if self.left == 0:
             return False
             
         c = self.left - 1
         for r in range(self.top, self.bottom+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for r in range(self.top, self.bottom+1):
             cad[r][c] = self.char
         self.left = c    
         return True
         
     def exRight(self, cad):
         if self.right == len(cad[0])-1:
             return False
             
         c = self.right + 1
         for r in range(self.top, self.bottom+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for r in range(self.top, self.bottom+1):
             cad[r][c] = self.char
         self.right = c    
         return True
             
     def exBottom(self, cad):
         if self.bottom == len(cad)-1:
             return False
             
         r = self.bottom + 1
         for c in range(self.left, self.right+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for c in range(self.left, self.right+1):
             cad[r][c] = self.char
         self.bottom = r    
         return True
         
     def exTop(self, cad):
         if self.top == 0:
             return False
             
         r = self.top - 1
         for c in range(self.left, self.right+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for c in range(self.left, self.right+1):
             cad[r][c] = self.char
         self.top = r    
         return True
 
 class Solver(object):
     def __init__(self):
         pass
     
     def ff(self, row):
         for i in range(len(row)):
             if row[i] != '?':
                 return i, row[i]
         return -1, '?'
     
     def solve(self, inputs):
         R, C = [int(x) for x in inputs[0].split()]
         
         
         cad = [list(x) for x in inputs[1:]]
 
         dd = {}
         for r in range(R):
             for c in range(C):
                 char = cad[r][c]
                 if char != '?':
                     if char not in dd:
                         dd[char] = Rect(char, r, c)
                     else:
                         dd[char].include(r, c)
         for v in dd.values():
             v.fill(cad)
         
         for v in dd.values():
             while v.exLeft(cad): pass
             while v.exTop(cad): pass
             while v.exRight(cad): pass
             while v.exBottom(cad): pass
         
         return '\n' + '\n'.join([''.join(x) for x in cad])
             
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             r, c = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1 + r
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
     # iname = 'foo'
     sample_in = '''3
 3 3
 G??
 ?C?
 ??J
 3 4
 CODE
 ????
 ?JAM
 2 2
 CA
 KE
     '''
     sample_out = '''
 Case #1:
 GGJ
 CCJ
 CCJ
 Case #2:
 CODE
 COAE
 JJAM
 Case #3:
 CA
 KE
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/5304486/graygrass/5760761888505856/1/extracted/pa.py,5133,187,539,Python,5304486,1,5760761888505856,graygrass,2017
7051,pa.py,"import os
 
 class Rect(object):
     def __init__(self, char, r, c):
         self.char = char
         self.left = c
         self.right = c
         self.top = r
         self.bottom = r
     
     def include(self, r, c, cad):
         if c < self.left:
             self.left = c
         if c > self.right:
             self.right = c
         if r < self.top:
             self.top = r
         if r > self.bottom:
             self.bottom = r
             
     def fill(self, cad):
         for r in range(self.top, self.bottom+1):
             for c in range(self.left, self.right+1):
                 cad[r][c] = self.char
         
     def exLeft(self, cad):
         if self.left == 0:
             return False
             
         c = self.left - 1
         for r in range(self.top, self.bottom+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for r in range(self.top, self.bottom+1):
             cad[r][c] = self.char
         self.left = c    
         return True
         
     def exRight(self, cad):
         if self.right == len(cad[0])-1:
             return False
             
         c = self.right + 1
         for r in range(self.top, self.bottom+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for r in range(self.top, self.bottom+1):
             cad[r][c] = self.char
         self.right = c    
         return True
             
     def exBottom(self, cad):
         if self.bottom == len(cad)-1:
             return False
             
         r = self.bottom + 1
         for c in range(self.left, self.right+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for c in range(self.left, self.right+1):
             cad[r][c] = self.char
         self.bottom = r    
         return True
         
     def exTop(self, cad):
         if self.top == 0:
             return False
             
         r = self.top - 1
         for c in range(self.left, self.right+1):
             if cad[r][c] != '?' and cad[r][c] != self.char:
                 return False
                 
         for c in range(self.left, self.right+1):
             cad[r][c] = self.char
         self.top = r    
         return True
 
 class Solver(object):
     def __init__(self):
         pass
     
     def ff(self, row):
         for i in range(len(row)):
             if row[i] != '?':
                 return i, row[i]
         return -1, '?'
     
     def solve(self, inputs):
         R, C = [int(x) for x in inputs[0].split()]
         
         
         cad = [list(x) for x in inputs[1:]]
 
         dd = {}
         for r in range(R):
             for c in range(C):
                 char = cad[r][c]
                 if char != '?':
                     if char not in dd:
                         dd[char] = Rect(char, r, c)
                     else:
                         dd[char].include(r, c)
         for v in dd.values():
             v.fill(cad)
         
         for v in dd.values():
             while v.exLeft(cad): pass
             while v.exTop(cad): pass
             while v.exRight(cad): pass
             while v.exBottom(cad): pass
         
         return '\n' + '\n'.join([''.join(x) for x in cad])
             
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             r, c = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1 + r
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
     # iname = 'foo'
     sample_in = '''3
 3 3
 G??
 ?C?
 ??J
 3 4
 CODE
 ????
 ?JAM
 2 2
 CA
 KE
     '''
     sample_out = '''
 Case #1:
 GGJ
 CCJ
 CCJ
 Case #2:
 CODE
 COAE
 JJAM
 Case #3:
 CA
 KE
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/5304486/graygrass/5760761888505856/0/extracted/pa.py,5142,187,539,Python,5304486,0,5760761888505856,graygrass,2017
83902,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         n = int(inputs[0].strip())
         nn = list(str(n))
         if len(nn) == 1:
             return n
         pre = 0
         for i in range(1, len(nn)):
             if int(nn[i]) > int(nn[i-1]):
                 pre = i
             if int(nn[i]) < int(nn[i-1]):
                 nn[pre] = str(int(nn[pre])-1)
                 for j in range(pre+1, len(nn)):
                     nn[j] = '9'
                 break
         
         return int(''.join(nn))
         
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-large.in'
     sample_in = '''4
 132
 1000
 7
 111111111111111110
     '''
     sample_out = '''
 Case #1: 129
 Case #2: 999
 Case #3: 7
 Case #4: 99999999999999999
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5633382285312000/1/extracted/pb.py,2239,78,229,Python,3264486,1,5633382285312000,graygrass,2017
83903,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         n = int(inputs[0].strip())
         nn = list(str(n))
         if len(nn) == 1:
             return n
         pre = 0
         for i in range(1, len(nn)):
             if int(nn[i]) > int(nn[i-1]):
                 pre = i
             if int(nn[i]) < int(nn[i-1]):
                 nn[pre] = str(int(nn[pre])-1)
                 for j in range(pre+1, len(nn)):
                     nn[j] = '9'
                 break
         
         return int(''.join(nn))
         
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt0.in'
     sample_in = '''4
 132
 1000
 7
 111111111111111110
     '''
     sample_out = '''
 Case #1: 129
 Case #2: 999
 Case #3: 7
 Case #4: 99999999999999999
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5633382285312000/0/extracted/pb.py,2248,78,229,Python,3264486,0,5633382285312000,graygrass,2017
83904,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def subs(self, s, k):
         r = 0
         i = 0
         while i + k < len(s):
             if s[i] == '+':
                 i += 1
                 continue
             for j in range(i, i + k):
                 if s[j] == '+':
                     break
             r += 1
             t = j
             for j in range(i, i + k):
                 s[j] = '+' if s[j] == '-' else '-'
             i = t
 
         last = s[-1]
         for i in range(k):
             if s[-1-i] != last:
                 return -1
         if last == '-':
             return r + 1
         return r
     
     def solve(self, inputs):
         s, k = inputs[0].split()
         k = int(k)
         s = list(s)
         r = self.subs(s, k)
         if r == -1:
             return 'IMPOSSIBLE'
         else:
             return r
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
     # iname = 'foo'
     sample_in = '''3
 ---+-++- 3
 +++++ 4
 -+-+- 4
     '''
     sample_out = '''
 Case #1: 3
 Case #2: 0
 Case #3: IMPOSSIBLE
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5736519012712448/1/extracted/pa.py,2536,92,292,Python,3264486,1,5736519012712448,graygrass,2017
83905,pa.py,"import os
 
 class Solver(object):
     def __init__(self):
         pass
     
     def subs(self, s, k):
         r = 0
         i = 0
         while i + k < len(s):
             if s[i] == '+':
                 i += 1
                 continue
             for j in range(i, i + k):
                 if s[j] == '+':
                     break
             r += 1
             t = j
             for j in range(i, i + k):
                 s[j] = '+' if s[j] == '-' else '-'
             i = t
 
         last = s[-1]
         for i in range(k):
             if s[-1-i] != last:
                 return -1
         if last == '-':
             return r + 1
         return r
     
     def solve(self, inputs):
         s, k = inputs[0].split()
         k = int(k)
         s = list(s)
         r = self.subs(s, k)
         if r == -1:
             return 'IMPOSSIBLE'
         else:
             return r
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt1.in'
     # iname = 'foo'
     sample_in = '''3
 ---+-++- 3
 +++++ 4
 -+-+- 4
     '''
     sample_out = '''
 Case #1: 3
 Case #2: 0
 Case #3: IMPOSSIBLE
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5736519012712448/0/extracted/pa.py,2545,92,292,Python,3264486,0,5736519012712448,graygrass,2017
83906,pc.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         N, K = [int(x) for x in inputs[0].split()]
         k = K
         cad = {N : 1}
         cads = [cad]
         while k > 0:
             ncad = {}
             keys = cad.keys()
             keys.sort(reverse=True)
             for key in keys:
                 value = cad[key]
                 c1 = (key - 1) / 2
                 c2 = key - 1 - c1
                 k -= value
                 if k <= 0:
                     return '%d %d'%(max(c1, c2), min(c1, c2))
                 if c1 not in ncad:
                     ncad[c1] = value
                 else:
                     ncad[c1] += value
                 if c2 not in ncad:
                     ncad[c2] = value
                 else:
                     ncad[c2] += value
             cads.append(ncad)
             cad = ncad
             
                 
 
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-large.in'
     sample_in = '''5
 4 2
 5 2
 6 2
 1000 1000
 1000 1
     '''
     sample_out = '''
 Case #1: 1 0
 Case #2: 1 0
 Case #3: 1 1
 Case #4: 0 0
 Case #5: 500 499
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5654742835396608/2/extracted/pc.py,2609,92,290,Python,3264486,2,5654742835396608,graygrass,2017
83907,pc.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         N, K = [int(x) for x in inputs[0].split()]
         k = K
         cad = {N : 1}
         cads = [cad]
         while k > 0:
             ncad = {}
             keys = cad.keys()
             keys.sort(reverse=True)
             for key in keys:
                 value = cad[key]
                 c1 = (key - 1) / 2
                 c2 = key - 1 - c1
                 k -= value
                 if k <= 0:
                     return '%d %d'%(max(c1, c2), min(c1, c2))
                 if c1 not in ncad:
                     ncad[c1] = value
                 else:
                     ncad[c1] += value
                 if c2 not in ncad:
                     ncad[c2] = value
                 else:
                     ncad[c2] += value
             cads.append(ncad)
             cad = ncad
             
                 
 
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-small-2-attempt0.in'
     sample_in = '''5
 4 2
 5 2
 6 2
 1000 1000
 1000 1
     '''
     sample_out = '''
 Case #1: 1 0
 Case #2: 1 0
 Case #3: 1 1
 Case #4: 0 0
 Case #5: 500 499
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5654742835396608/1/extracted/pc.py,2620,92,290,Python,3264486,1,5654742835396608,graygrass,2017
83908,pc.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         N, K = [int(x) for x in inputs[0].split()]
         k = K
         cad = {N : 1}
         cads = [cad]
         while k > 0:
             ncad = {}
             keys = cad.keys()
             keys.sort(reverse=True)
             for key in keys:
                 value = cad[key]
                 c1 = (key - 1) / 2
                 c2 = key - 1 - c1
                 k -= value
                 if k <= 0:
                     return '%d %d'%(max(c1, c2), min(c1, c2))
                 if c1 not in ncad:
                     ncad[c1] = value
                 else:
                     ncad[c1] += value
                 if c2 not in ncad:
                     ncad[c2] = value
                 else:
                     ncad[c2] += value
             cads.append(ncad)
             cad = ncad
             
                 
 
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-small-1-attempt0.in'
     sample_in = '''5
 4 2
 5 2
 6 2
 1000 1000
 1000 1
     '''
     sample_out = '''
 Case #1: 1 0
 Case #2: 1 0
 Case #3: 1 1
 Case #4: 0 0
 Case #5: 500 499
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3264486/graygrass/5654742835396608/0/extracted/pc.py,2620,92,290,Python,3264486,0,5654742835396608,graygrass,2017
158843,pa.py,"import os
 
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         dist, N = [int(x) for x in inputs[0].split()]
         latest = 0
         for input in inputs[1:]:
             pos, speed = [int(x) for x in input.split()]
             eta = (dist - pos) * 1.0 / speed
             if eta > latest:
                 latest = eta
         return '%.6f'%(dist / latest)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1 + ns[1]
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
     # iname = 'foo'
     sample_in = '''3
 2525 1
 2400 5
 300 2
 120 60
 60 90
 100 2
 80 100
 70 10
     '''
     sample_out = '''
 Case #1: 101.000000
 Case #2: 100.000000
 Case #3: 33.333333
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/8294486/graygrass/5630967708385280/1/extracted/pa.py,2163,75,247,Python,8294486,1,5630967708385280,graygrass,2017
158844,pa.py,"import os
 
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         dist, N = [int(x) for x in inputs[0].split()]
         latest = 0
         for input in inputs[1:]:
             pos, speed = [int(x) for x in input.split()]
             eta = (dist - pos) * 1.0 / speed
             if eta > latest:
                 latest = eta
         return '%.6f'%(dist / latest)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1 + ns[1]
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt0.in'
     # iname = 'foo'
     sample_in = '''3
 2525 1
 2400 5
 300 2
 120 60
 60 90
 100 2
 80 100
 70 10
     '''
     sample_out = '''
 Case #1: 101.000000
 Case #2: 100.000000
 Case #3: 33.333333
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/8294486/graygrass/5630967708385280/0/extracted/pa.py,2172,75,247,Python,8294486,0,5630967708385280,graygrass,2017
158845,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def dump(self, cc, rslt):
         if cc in self.dd:
             co = self.dd.pop(cc)
             for i in range(co[1]):
                 self.dump(cc, rslt)
                 self.dump(co[0], rslt)
         rslt.append(cc)
     
     def solve(self, inputs):
         N, R, O, Y, G, B, V = [int(x) for x in inputs[0].split()]
         self.dd = {'R':('G', G), 'Y':('V', V), 'B':('O', O)}
         rslt = []
         rr = R - G
         yy = Y - V
         bb = B - O
         #print rr, yy, bb
         if (rr < 0) or (yy < 0) or (bb < 0):
             return 'IMPOSSIBLE'
         if (rr == 0) and (G != 0):
             if (any([O, Y, B, V])):
                 return 'IMPOSSIBLE'
             else:
                 self.dump('R', rslt)
                 return ''.join(rslt[:-1])
         if (rr == 0) and (V != 0):
             if (any([R, O, G, B])):
                 return 'IMPOSSIBLE'
             else:
                 self.dump('Y', rslt)
                 return ''.join(rslt[:-1])
         if (rr == 0) and (O != 0):
             if (any([R, Y, G, V])):
                 return 'IMPOSSIBLE'
             else:
                 self.dump('B', rslt)
                 return ''.join(rslt[:-1])
         cad = [(rr, 'R'), (yy, 'Y'), (bb, 'B')]
         cad.sort(key=lambda x: x[0])
         if cad[0][0] + cad[1][0] < cad[2][0]:
             return 'IMPOSSIBLE'
         a = cad[0][0]
         b = cad[2][0] - a
         c = cad[1][0] - b
         for i in range(b):
             self.dump(cad[2][1], rslt)
             self.dump(cad[1][1], rslt)
         for i in range(c):
             self.dump(cad[2][1], rslt)
             self.dump(cad[1][1], rslt)
             self.dump(cad[0][1], rslt)
         for i in range(a-c):
             self.dump(cad[2][1], rslt)
             self.dump(cad[0][1], rslt)
         return ''.join(rslt)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-large.in'
     sample_in = '''4
 6 2 0 2 0 2 0
 3 1 0 2 0 0 0
 6 2 0 1 1 2 0
 4 0 0 2 0 0 2
     '''
     sample_out = '''
 Case #1: RYBRBY
 Case #2: IMPOSSIBLE
 Case #3: YBRGRB
 Case #4: YVYV
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/8294486/graygrass/5654117850546176/1/extracted/pb.py,3661,116,412,Python,8294486,1,5654117850546176,graygrass,2017
158846,pb.py,"import os
 import math
 
 class Solver(object):
     def __init__(self):
         pass
     
     def dump(self, cc, rslt):
         if cc in self.dd:
             co = self.dd.pop(cc)
             for i in range(co[1]):
                 self.dump(cc, rslt)
                 self.dump(co[0], rslt)
         rslt.append(cc)
     
     def solve(self, inputs):
         N, R, O, Y, G, B, V = [int(x) for x in inputs[0].split()]
         self.dd = {'R':('G', G), 'Y':('V', V), 'B':('O', O)}
         rslt = []
         rr = R - G
         yy = Y - V
         bb = B - O
         #print rr, yy, bb
         if (rr < 0) or (yy < 0) or (bb < 0):
             return 'IMPOSSIBLE'
         if (rr == 0) and (G != 0):
             if (any([O, Y, B, V])):
                 return 'IMPOSSIBLE'
             else:
                 self.dump('R', rslt)
                 return ''.join(rslt[:-1])
         if (rr == 0) and (V != 0):
             if (any([R, O, G, B])):
                 return 'IMPOSSIBLE'
             else:
                 self.dump('Y', rslt)
                 return ''.join(rslt[:-1])
         if (rr == 0) and (O != 0):
             if (any([R, Y, G, V])):
                 return 'IMPOSSIBLE'
             else:
                 self.dump('B', rslt)
                 return ''.join(rslt[:-1])
         cad = [(rr, 'R'), (yy, 'Y'), (bb, 'B')]
         cad.sort(key=lambda x: x[0])
         if cad[0][0] + cad[1][0] < cad[2][0]:
             return 'IMPOSSIBLE'
         a = cad[0][0]
         b = cad[2][0] - a
         c = cad[1][0] - b
         for i in range(b):
             self.dump(cad[2][1], rslt)
             self.dump(cad[1][1], rslt)
         for i in range(c):
             self.dump(cad[2][1], rslt)
             self.dump(cad[1][1], rslt)
             self.dump(cad[0][1], rslt)
         for i in range(a-c):
             self.dump(cad[2][1], rslt)
             self.dump(cad[0][1], rslt)
         return ''.join(rslt)
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'B-small-attempt0.in'
     sample_in = '''4
 6 2 0 2 0 2 0
 3 1 0 2 0 0 0
 6 2 0 1 1 2 0
 4 0 0 2 0 0 2
     '''
     sample_out = '''
 Case #1: RYBRBY
 Case #2: IMPOSSIBLE
 Case #3: YBRGRB
 Case #4: YVYV
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/8294486/graygrass/5654117850546176/0/extracted/pb.py,3670,116,412,Python,8294486,0,5654117850546176,graygrass,2017
178789,pa.py,"import os
 import math
 
 pi = math.acos(-1)
 
 class Solver(object):
     def __init__(self):
         pass
         
     def subsolve(self, cakes, K):
         if K > len(cakes):
             return 0
         subc = cakes[0:-1]
         subc.sort(key=lambda x: x[0]*x[1])
         c = cakes[-1]
         v = c[0]*c[0] + 2*c[0]*c[1]
         for i in range(-1,-K,-1):
             c = subc[i]
             v += 2*c[0]*c[1]
         return pi*v
     
     def solve(self, inputs):
         N, K = [int(x) for x in inputs[0].split()]
         cakes = []
         for i in range(N):
             r, h = [int(x) for x in inputs[i+1].split()]
             cakes.append((r, h))
         cakes.sort(key=lambda x: x[0])
         max_ = 0
         for i in range(K,N+1):
             v = self.subsolve(cakes[:i], K)
             if v > max_:
                 max_ = v
         return '%.9f'%max_
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1 + ns[0]
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-large.in'
     #iname = 'foo'
     sample_in = '''4
 2 1
 100 20
 200 10
 2 2
 100 20
 200 10
 3 2
 100 10
 100 10
 100 10
 4 2
 9 3
 7 1
 10 1
 8 4
     '''
     sample_out = '''
 Case #1: 138230.076757951
 Case #2: 150796.447372310
 Case #3: 43982.297150257
 Case #4: 625.176938064
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3274486/graygrass/5768968631484416/1/extracted/pa.py,2707,101,309,Python,3274486,1,5768968631484416,graygrass,2017
178790,pa.py,"import os
 import math
 
 pi = math.acos(-1)
 
 class Solver(object):
     def __init__(self):
         pass
         
     def subsolve(self, cakes, K):
         if K > len(cakes):
             return 0
         subc = cakes[0:-1]
         subc.sort(key=lambda x: x[0]*x[1])
         c = cakes[-1]
         v = c[0]*c[0] + 2*c[0]*c[1]
         for i in range(-1,-K,-1):
             c = subc[i]
             v += 2*c[0]*c[1]
         return pi*v
     
     def solve(self, inputs):
         N, K = [int(x) for x in inputs[0].split()]
         cakes = []
         for i in range(N):
             r, h = [int(x) for x in inputs[i+1].split()]
             cakes.append((r, h))
         cakes.sort(key=lambda x: x[0])
         max_ = 0
         for i in range(K,N+1):
             v = self.subsolve(cakes[:i], K)
             if v > max_:
                 max_ = v
         return '%.9f'%max_
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 1 + ns[0]
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'A-small-attempt3.in'
     #iname = 'foo'
     sample_in = '''4
 2 1
 100 20
 200 10
 2 2
 100 20
 200 10
 3 2
 100 10
 100 10
 100 10
 4 2
 9 3
 7 1
 10 1
 8 4
     '''
     sample_out = '''
 Case #1: 138230.076757951
 Case #2: 150796.447372310
 Case #3: 43982.297150257
 Case #4: 625.176938064
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3274486/graygrass/5768968631484416/0/extracted/pa.py,2716,101,309,Python,3274486,0,5768968631484416,graygrass,2017
178791,pc.py,"import os
 import itertools
 
 class Solver(object):
     def __init__(self):
         pass
     
     def solve(self, inputs):
         N, K = [int(x) for x in inputs[0].split()]
         U = [float(x) for x in inputs[1].split()][0]
         P = [float(x) for x in inputs[2].split()]
         P.sort()
         P.append(1.0)
         
         ru = U
         d = 1
         while ru > 0 and d > 0:
             I = N
             d = 0.0
             for i in range(1, len(P)):
                 if P[i] > P[i-1]:
                     I = i
                     d = P[i] - P[i-1]
                     break
             if ru > d * I:
                 du = d
             else:
                 du = ru / I
             for i in range(I):
                 P[i] += du
             ru -= du * I
             
         fp = reduce(lambda x,y: x*y, P)
         return '%.6f'%fp
         pass
     
     def feed(self, inputs):
         lines = [x.strip() for x in inputs]
         outputs = []
         test_case_n = int(lines[0])
         cur = 1
         for i in range(test_case_n):
             i = i
             ns = [int(x) for x in lines[cur].split()]
             case_line_cnt = 3
             case_inputs = lines[cur:cur+case_line_cnt]
             cur += case_line_cnt
             outputs.append(self.solve(case_inputs))
         return outputs
 
 if __name__ == '__main__':
     iname = 'C-small-1-attempt0.in'
     sample_in = '''4
 4 4
 1.4000
 0.5000 0.7000 0.8000 0.6000
 2 2
 1.0000
 0.0000 0.0000
 2 1
 0.0000
 0.9000 0.8000
 2 1
 0.1000
 0.4000 0.5000
     '''
     sample_out = '''
 Case #1: 1.000000
 Case #2: 0.250000
 Case #3: 0.980000
 Case #4: 0.760000
     '''
     if os.path.exists(iname):
         with open(iname) as f:
             inputs = f.readlines()
     else:
         inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]
     solver = Solver()
     outputs = solver.feed(inputs)
     fail_flag = False
     if os.path.exists(iname):
         with open(iname+'.out', 'w') as f:
             for i, v in enumerate(outputs):
                 print >> f, 'Case #%d: %s'%(i+1, str(v))
     else:
         ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])
         for i, v in enumerate(outputs):
             t = 'Case #%d: %s'%(i+1, str(v))
             if t not in ans:
                 print '!!! Wrong:', t
                 fail_flag = True
     print '===================================================='
     for i, v in enumerate(outputs):
         print 'Case #%d: %s'%(i+1, str(v))
     print '===================================================='
     print 'done' if not fail_flag else 'fail'
     pass",gcj/2017/3274486/graygrass/5633143511973888/0/extracted/pc.py,2676,97,306,Python,3274486,0,5633143511973888,graygrass,2017
86507,000000000001673e.PYTHON,"import math

s2 = math.sqrt(2)

def dot(m, v):
    r = []
    for i in range(3):
        s = 0
        for j in range(3):
            s += m[i][j]*v[j]
        r.append(s)
    return r

def _solve(A):
    ph = A / math.sqrt(2)
    cos_a = math.sqrt(2) / 2 / math.sqrt(3./2)
    cos_b = ph / math.sqrt(3./2)
    da = math.acos(cos_a) - math.acos(cos_b)
    ca = math.cos(da)
    sa = math.sin(da)
    ry = [[s2/2, 0, s2/2],
          [0, 1, 0],
          [-s2/2, 0, s2/2]]
    rx = [[1, 0, 0],
          [0, ca, -sa],
          [0, sa, ca]]
    result = [dot(rx, dot(ry, [0.5, 0, 0])),
              dot(rx, dot(ry, [0, 0.5, 0])),
              dot(rx, dot(ry, [0, 0, 0.5]))]
    return result

def _output(n, r):
    print 'Case #{}:\n{:.20f} {:.20f} {:.20f}\n{:.20f} {:.20f} {:.20f}\n{:.20f} {:.20f} {:.20f}'.format(
        n, r[0][0], r[0][1], r[0][2], r[1][0], r[1][1], r[1][2], r[2][0], r[2][1], r[2][2])

T = int(raw_input())
for i in xrange(1, T + 1):
    A = float(raw_input())
    _output(i, _solve(A))
",,1012,40,136,Python,00000000000000cb,000000000001673e,00000000000079cc,graygrass,2018
86509,0000000000015de1.PYTHON,"import math
import numpy as np

s2 = math.sqrt(2)

def _solve(A):
    ph = A / math.sqrt(2)
    cos_a = math.sqrt(2) / 2 / math.sqrt(3./2)
    cos_b = ph / math.sqrt(3./2)
    da = math.acos(cos_a) - math.acos(cos_b)
    ca = math.cos(da)
    sa = math.sin(da)
    ry = [[s2/2, 0, s2/2],
          [0, 1, 0],
          [-s2/2, 0, s2/2]]
    rx = [[1, 0, 0],
          [0, ca, -sa],
          [0, sa, ca]]
    result = [np.dot(rx, np.dot(ry, [0.5, 0, 0])),
              np.dot(rx, np.dot(ry, [0, 0.5, 0])),
              np.dot(rx, np.dot(ry, [0, 0, 0.5]))]
    return result

def _output(n, r):
    print 'Case #{}:\n{:.20f} {:.20f} {:.20f}\n{:.20f} {:.20f} {:.20f}\n{:.20f} {:.20f} {:.20f}'.format(
        n, r[0][0], r[0][1], r[0][2], r[1][0], r[1][1], r[1][2], r[2][0], r[2][1], r[2][2])

T = int(raw_input())
for i in xrange(1, T + 1):
    A = float(raw_input())
    _output(i, _solve(A))
",,895,32,117,Python,00000000000000cb,0000000000015de1,00000000000079cc,graygrass,2018
86510,0000000000013266.PYTHON,"import sys
import math

count = 0

def _read():
    return [int(x) for x in raw_input().split(' ')]

def _write(p):
    global count
    count += 1
    # print >> sys.stderr, 'out: {} {}'.format(p[0] + 100, p[1] + 100)
    sys.stderr.flush()
    print '{} {}'.format(p[0] + 100, p[1] + 100)
    sys.stdout.flush()
    r = _read()
    # print >> sys.stderr, 'in: {} {}'.format(r[0], r[1])
    sys.stderr.flush()
    if 0 == r[0] and 0 == r[1]:
        raise Exception(""DONE"")
    if -1 == r[0] and -1 == r[1]:
        raise Exception(""FAIL"")
    return (r[0]-100, r[1]-100)

def _solve(A):
    global count
    count = 0
    row = int(math.sqrt(A))
    col = row
    if row * col < A:
        row += 1
    if row * col < A:
        col += 1
    mm = []
    for i in range(row):
        mm.append([0]*col)
    r1 = 1
    r2 = row - 2
    c1 = 1
    c2 = col - 2

    cp = {}
    for r in range(r1, r2+1):
        for c in range(c1, c2+1):
            cp[(r, c)] = [(x, y) for x in range(r-1, r+2) for y in range(c-1, c+2)]
    while len(cp) > 0:
        delcan = []
        for p, ps in cp.items():
            full = True
            for pnt in ps:
                if 0 == mm[pnt[0]][pnt[1]]:
                    full = False
                    break
            if full:
                delcan.append(p)
            else:
                rd = _write(p)
                mm[rd[0]][rd[1]] = 1
        for p in delcan:
            # print >> sys.stderr, 'pop {}'.format(p)
            cp.pop(p)
    print >> sys.stderr, 'All is done'
    sys.stderr.flush()


T = int(raw_input())
for i in xrange(1, T + 1):
    A = int(raw_input())
    # print >> sys.stderr, 'Case {}'.format(i)
    sys.stderr.flush()
    try:
        _solve(A)
    except Exception, e:
        if e.message == 'DONE':
            print >> sys.stderr, 'Case {}: DONE in {}'.format(i, count)
            sys.stderr.flush()
        elif e.message == 'FAIL':
            print >> sys.stderr, 'Case {}: FAIL at {}'.format(i, count)
            sys.stderr.flush()
            exit(0)
        else:
            exit(0)

",,2078,84,274,Python,00000000000000cb,0000000000013266,0000000000007a30,graygrass,2018
86512,000000000000dab9.PYTHON,"

def _solve(d, p):
    op = p[1::2]
    ep = p[::2]
    ep.sort()
    op.sort()
    for i in range(len(op)):
        if ep[i] > op[i]:
            return 2*i
        if len(ep) > i+1 and ep[i+1] < op[i]:
            return 2*i+1
    return 'OK'

def _output(n, r):
    print 'Case #{}: {}'.format(n, r)

T = int(raw_input())
for i in xrange(1, T + 1):
    D = int(raw_input())
    P = [int(x) for x in raw_input().split(' ')]
    _output(i, _solve(D, P))
",,456,23,65,Python,00000000000000cb,000000000000dab9,00000000000079cb,graygrass,2018
86513,000000000000cd6f.PYTHON,"

def _solve(d, p):
    a = []
    strength = 1
    tt = 0
    for c in p:
        if 'S' == c:
            a.append(strength)
            tt += strength
        else:
            a.append(0)
            strength += strength
    if tt <= d:
        return 0
    swap = 0
    i = len(a) - 1
    while i >= 0:
        if a[i] > 0:
            j = i - 1
            while j >= 0:
                if a[j] == 0:
                    break
                else:
                    j -= 1
            if -1 == j:
                return 'IMPOSSIBLE'
            for k in range(i - j):
                a[j+k] = a[j+k+1] / 2
                a[j+k+1] = 0
                swap += 1
                tt -= a[j+k]
                if tt <= d:
                    return swap
        i -= 1
    if -1 == i:
        return 'IMPOSSIBLE'
    else:
        return swap

def _output(n, r):
    print 'Case #{}: {}'.format(n, r)

T = int(raw_input())
for i in xrange(1, T + 1):
    D, P = raw_input().split(' ')
    D = int(D)
    _output(i, _solve(D, P))
",,1033,49,142,Python,00000000000000cb,000000000000cd6f,0000000000007966,graygrass,2018
106687,000000000010738b.PYTHON,"from __future__ import print_function
import sys

def f(ww, n):
    ks = set()
    i = 0
    while i < len(ww) - 1:
        if len(ww[i]) >= n:
            k = ww[i][:n]
            if k not in ks:
                if k == ww[i + 1][:n]:
                    ks.add(k)
                    del ww[i:i + 2]
                    continue
        i += 1
    return len(ks) * 2

def solve(W):
    ww = [list(x) for x in W]
    [x.reverse() for x in ww]
    ww = [''.join(x) for x in ww]
    ww.sort()
    # print(ww)
    m = max([len(x) for x in ww])
    cnt = 0
    for i in range(m, 0, -1):
        cnt += f(ww, i)
    return cnt

def main():
    T = int(raw_input())
    for i in range(T):
        N = int(raw_input())
        W = []
        for j in range(N):
            W.append(raw_input())
        print('Case #{}: {}'.format(i + 1, solve(W)))

if __name__ == '__main__':
    main()",,882,40,129,Python,51635,000000000010738b,0000000000104e05,graygrass,2019
185749,00000000000d711b.PYTHON,"from __future__ import print_function
import sys

def gcd(a, b):
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a
    return a

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    j = 0
    while ll[j] == ll[j + 1]:
        j += 1
    p = []
    p1 = gcd(ll[j], ll[j + 1])
    p.append(ll[j] / p1)
    p.append(p1)
    for i in range(j + 1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    p1 = p[0]
    for i in range(j - 1, -1, -1):
        p2 = ll[i] / p1
        p.insert(0, p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    return 'Case #{}: {}'.format(case, ''.join([d[x] for x in p]))

def main():
    N = int(raw_input())
    for i in range(N):
        ii = []
        ii.append(raw_input())
        ii.append(raw_input())
        print(solve(i + 1, ii))
        # sys.stdout.flush()

if __name__ == '__main__':
    main()",,1061,49,163,Python,51705,00000000000d711b,000000000008830b,graygrass,2019
185751,00000000000cf267.PYTHON,"# import sys

def gcd(a, b):
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a
    return a

def solve(icase, jj):
    N, L = [int(x) for x in jj[0].split(' ')]
    ll = [int(x) for x in jj[1].split(' ')]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    return 'Case #{}: {}'.format(icase, ''.join([d[x] for x in p]))


N = int(raw_input())
for i in range(N):
    ii = []
    ii.append(raw_input())
    ii.append(raw_input())
    print(solve(i + 1, ii))
    # sys.stdout.flush()
",,780,38,118,Python,51705,00000000000cf267,000000000008830b,graygrass,2019
185752,00000000000ce65f.PYTHON,"# import sys

def gcd(a, b):
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a
    return a

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split(' ')]
    ll = [int(x) for x in ii[1].split(' ')]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    return 'Case #{}: {}'.format(case, ''.join([d[x] for x in p]))


N = int(raw_input())
for i in range(N):
    ii = []
    ii.append(raw_input())
    ii.append(raw_input())
    print(solve(i + 1, ii))
    # sys.stdout.flush()
",,778,38,118,Python,51705,00000000000ce65f,000000000008830b,graygrass,2019
185753,00000000000ccd3c.PYTHON3,"# import sys

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].rstrip().split()]
    ll = [int(x) for x in ii[1].rstrip().split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))


N = int(input())
for i in range(N):
    ii = []
    ii.append(input())
    ii.append(input())
    print(solve(i + 1, ii))
    # sys.stdout.flush()
",,827,41,120,Python,51705,00000000000ccd3c,000000000008830b,graygrass,2019
185754,00000000000ccbaa.PYTHON3,"# import sys

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))


N = int(input())
for i in range(N):
    ii = []
    ii.append(input())
    ii.append(input())
    print(solve(i + 1, ii))
    # sys.stdout.flush()
",,809,41,120,Python,51705,00000000000ccbaa,000000000008830b,graygrass,2019
185755,00000000000cc4af.PYTHON3,"import sys

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))

def main():
    N = int(input())
    for i in range(N):
        ii = []
        ii.append(input())
        ii.append(input())
        print(solve(i + 1, ii))
        sys.stdout.flush()


# if __name__ == '__main__':
main()",,881,44,126,Python,51705,00000000000cc4af,000000000008830b,graygrass,2019
185756,00000000000cc6a7.PYTHON3,"import sys

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))

def main():
    N = int(raw_input())
    for i in range(N):
        ii = []
        ii.append(raw_input())
        ii.append(raw_input())
        print(solve(i + 1, ii))
        sys.stdout.flush()


# if __name__ == '__main__':
main()",,893,44,126,Python,51705,00000000000cc6a7,000000000008830b,graygrass,2019
185757,00000000000cbf02.PYTHON,"import sys

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))

def main():
    N = int(raw_input())
    for i in range(N):
        ii = []
        ii.append(raw_input())
        ii.append(raw_input())
        print(solve(i + 1, ii))
        sys.stdout.flush()


if __name__ == '__main__':
    main()",,895,44,125,Python,51705,00000000000cbf02,000000000008830b,graygrass,2019
185758,00000000000cbfb9.PYTHON,"import sys

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))

def main():
    N = int(input())
    for i in range(N):
        ii = []
        ii.append(input())
        ii.append(input())
        print(solve(i + 1, ii))
        sys.stdout.flush()


if __name__ == '__main__':
    main()",,883,44,125,Python,51705,00000000000cbfb9,000000000008830b,graygrass,2019
185762,00000000000c7ee8.PYTHON3,"import fileinput
import sys

def solve(case, ii):
    N = int(ii[0])
    P = ii[1]
    y = []
    for step in P:
        mine = 'S' if 'E' == step else 'E'
        y.append(mine)
    return 'Case #{0}: {1}'.format(case, ''.join(y))

case = -1
ii = []
ans = []
for line in fileinput.input():
    if case == -1:
        case += 1
        continue
    ii.append(line.rstrip())
    if len(ii) == 2:
        ans.append(solve(case, ii))
        ii = []
        case += 1
print('\n'.join(ans))
sys.stdout.flush()
",,506,27,71,Python,51705,00000000000c7ee8,00000000000881da,graygrass,2019
185764,00000000000c6e6f.PYTHON3,"import fileinput
import system

def solve(case, ii):
    N = int(ii[0])
    P = ii[1]
    y = []
    for step in P:
        mine = 'S' if 'E' == step else 'E'
        y.append(mine)
    return 'Case #{0}: {1}'.format(case, ''.join(y))

case = -1
ii = []
ans = []
for line in fileinput.input():
    if case == -1:
        case += 1
        continue
    ii.append(line.rstrip())
    if len(ii) == 2:
        ans.append(solve(case, ii))
        ii = []
        case += 1
print('\n'.join(ans))
system.stdout.flush()
",,512,27,71,Python,51705,00000000000c6e6f,00000000000881da,graygrass,2019
185765,00000000000c6a61.PYTHON3,"import fileinput

def solve(case, ii):
    N = int(ii[0])
    P = ii[1]
    y = []
    for step in P:
        mine = 'S' if 'E' == step else 'E'
        y.append(mine)
    return 'Case #{0}: {1}'.format(case, ''.join(y))

case = -1
ii = []
ans = []
for line in fileinput.input():
    if case == -1:
        case += 1
        continue
    ii.append(line.rstrip())
    if len(ii) == 2:
        ans.append(solve(case, ii))
        ii = []
        case += 1
print('\n'.join(ans))
",,476,25,68,Python,51705,00000000000c6a61,00000000000881da,graygrass,2019
185766,00000000000c52f8.PYTHON3,"import fileinput

def solve(case, ii):
    N = int(ii[0])
    P = ii[1]
    y = []
    for step in P:
        if 'E' == step:
            y.append('S')
        if 'S' == step:
            y.append('E')
    return 'Case #{0}: {1}'.format(case, ''.join(y))

def main():
    case = -1
    ii = []
    for line in fileinput.input():
        if case == -1:
            case += 1
            continue
        ii.append(line.rstrip())
        if len(ii) == 2:
            print(solve(case, ii))
            ii = []
            case += 1
            
if __name__ == '__main__':
    main()
    ",,585,29,71,Python,51705,00000000000c52f8,00000000000881da,graygrass,2019
185767,00000000000c4942.PYTHON,"import fileinput

def solve(case, ii):
    N = int(ii[0])
    P = ii[1]
    y = []
    for step in P:
        if 'E' == step:
            y.append('S')
        if 'S' == step:
            y.append('E')
    return 'Case #{0}: {1}'.format(case, ''.join(y))

case = -1
ii = []
for line in fileinput.input():
    if case == -1:
        case += 1
        continue
    ii.append(line.rstrip())
    if len(ii) == 2:
        print(solve(case, ii))
        ii = []
        case += 1
    ",,478,25,64,Python,51705,00000000000c4942,00000000000881da,graygrass,2019
185770,00000000000c46ff.PYTHON3,"import fileinput

def gcd(a, b):
    if a < b:
        a, b = b, a
    if 0 == b:
        return a
    else:
        return gcd(b, a % b)

def solve(case, ii):
    N, L = [int(x) for x in ii[0].split()]
    ll = [int(x) for x in ii[1].split()]
    p = []
    p1 = gcd(ll[0], ll[1])
    p.append(ll[0] / p1)
    p.append(p1)
    for i in range(1, L):
        p2 = ll[i] / p1
        p.append(p2)
        p1 = p2
    ps = list(set(p))
    ps.sort()
    vv = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    d = dict()
    for k, v in zip(ps, vv):
        d[k] = v
    r = []
    for i in range(len(p)):
        r.append(d[p[i]])
    return 'Case #{0}: {1}'.format(case, ''.join(r))

ii = []
case = -1
for line in fileinput.input():
    if -1 == case:
        case += 1
        continue
    ii.append(line.rstrip())
    if len(ii) == 2:
        print(solve(case, ii))
        ii = []
        case += 1",,882,43,132,Python,51705,00000000000c46ff,000000000008830b,graygrass,2019
185772,00000000000be48c.PYTHON3,"import fileinput

def solve(case, ii):
    N = int(ii[0])
    P = ii[1]
    y = []
    for step in P:
        mine = 'S' if 'E' == step else 'E'
        y.append(mine)
    return 'Case #{0}: {1}'.format(case, ''.join(y))

case = -1
ii = []
for line in fileinput.input():
    if case == -1:
        case += 1
        continue
    ii.append(line.rstrip())
    if len(ii) == 2:
        print(solve(case, ii))
        ii = []
        case += 1
    ",,444,23,64,Python,51705,00000000000be48c,00000000000881da,graygrass,2019
185774,00000000000a2ec5.PYTHON3,"import fileinput

def solve(case, N):
    A = []
    B = []
    for d in N:
        if d == '4':
            A.append('2')
            B.append('2')
        else:
            A.append(d)
            B.append('0')
    a = int(''.join(A))
    b = int(''.join(B))
    return 'Case #{0}: {1} {2}'.format(case, a, b)

case = -1
for line in fileinput.input():
    case += 1
    if 0 == case:
        continue
    N = line.rstrip()
    print(solve(case, N))

",,452,25,57,Python,51705,00000000000a2ec5,0000000000088231,graygrass,2019
3878,a.py,"import sys
 
 T = int(sys.stdin.readline())
 
 def sumsq(n, b):
     if n == 0:
         return 0
     m = n%b
     return m**2 + sumsq(n/b, b)
 
 def isHappy(n, b, happy, not_happy):
     if n in happy:
         return True
     if n in not_happy:
         return False
 
     chain = set([])
 
     while n != 1 and not n in chain:
         chain.add(n)
         n = sumsq(n, b)
 
     if n == 1:
         happy.update(chain)
         return True
     else:
         not_happy.update(chain)
         return False
         
 
 for t in xrange(T):
     bases = [int(s) for s in sys.stdin.readline().split()]
 
     happy = dict([(b, set([])) for b in bases])
     not_happy = dict([(b, set([])) for b in bases])
 
     n = 2
     while True:
         for b in bases:
             if not isHappy(n, b, happy[b], not_happy[b]):
                 # print ""%d is not happy in %d"" % (n, b)
                 break
         else:
             print ""Case #%d: %d"" % (t+1, n)
             break
         n += 1
",gcj/2009/188266/kmod/168107/0/extracted/a.py,1002,47,133,Python,188266,0,168107,kmod,2009
3879,c.py,"import sys
 
 t = int(sys.stdin.readline())
 
 def ncr(n, r):
     if r < 0 or r > n:
         return 0
     t = 1
     for i in xrange(n-r+1, n+1):
         t *= i
     for i in xrange(1, r+1):
         t /= i
     return t
 
 for _t in xrange(t):
     n, c = [int(s) for s in sys.stdin.readline().split()]
 
     e = []
     e.append(0.0)
     poss = ncr(n, c) * 1.0
     for left in xrange(1, n+1):
         have = n - left
         exp = 0.0
         # print left, ""left""
         for new in xrange(1, c+1):
             if new > left:
                 break
             prob = ncr(left, new) * ncr(have, c - new) / poss
             # print ""prob of getting %d new when have %d left: %f"" % (new, left, prob)
             exp += prob * e[left-new]
 
         prob0 = ncr(left, 0) * ncr(have, c) / poss
         exp = (1 + exp) / (1 - prob0)
         e.append(exp)
 
     print ""Case #%d: %f"" % (_t+1, e[-1])
",gcj/2009/188266/kmod/190103/1/extracted/c.py,913,37,146,Python,188266,1,190103,kmod,2009
45147,a.py,"import sys
 
 def main(fname):
     f = open(fname)
 
     l,d,n = [int(s) for s in f.readline().split()]
 
     words = [f.readline().strip() for _i in xrange(d)]
 
     messages = [f.readline().strip() for _i in xrange(n)]
 
     for i in xrange(n):
         print ""Case #%d:"" % (i+1),
         total = 0
 
         m = messages[i]
 
         sets = []
         cur = 0
         while len(sets) < l:
             if m[cur] != '(':
                 sets.append(set([m[cur]]))
                 cur += 1
             else:
                 s = set([])
                 cur += 1
                 while m[cur] != ')':
                     s.add(m[cur])
                     cur += 1
                 cur += 1
                 sets.append(s)
 
         for j in xrange(d):
             for k in xrange(l):
                 if not words[j][k] in sets[k]:
                     break
             else:
                 total += 1
 
         print total
         # print sets
 
     f.close()
 
 if __name__ == ""__main__"":
     main(sys.argv[1])
",gcj/2009/90101/kmod/116101/1/extracted/a.py,1039,47,109,Python,90101,1,116101,kmod,2009
6171,a.py,"import sys, os
 from math import *
 
 T = int(sys.stdin.readline())
 
 def wins(name, board, x, y, dirx, diry, K):
     for i in xrange(K):
         _x = x + dirx * i
         _y = y + diry * i
         if board[_x][_y] != name:
             return False
     return True
 
 def winsatall(name, board, N, K):
     for x in xrange(N-K+1):
         for y in xrange(N-K+1):
             if wins(name, board, x, y, 1, 1, K):
                 return True
             if wins(name, board, x + K - 1, y, -1, 1, K):
                 return True
     for x in xrange(N-K+1):
         for y in xrange(N):
             if wins(name, board, x, y, 1, 0, K):
                 return True
             if wins(name, board, y, x, 0, 1, K):
                 return True
     return False
 
 for _t in xrange(T):
     N, K = map(int, sys.stdin.readline().split())
     board = []
     for i in xrange(N):
         board.append(['.'] * N)
 
     for i in xrange(N):
         s = sys.stdin.readline().strip()
         n = 0
         for j in xrange(N):
             if s[N-j-1] != '.':
                 board[i][N-n-1] = s[N-j-1]
                 n += 1
     # print '\n'.join([''.join(s) for s in board])
     # print
 
     r = winsatall('R', board, N, K)
     b = winsatall('B', board, N, K)
 
     print ""Case #%d:"" % (_t+1),
     if r and b:
         print ""Both""
     elif r:
         print ""Red""
     elif b:
         print ""Blue""
     else:
         print ""Neither""
 
",gcj/2010/544101/kmod/567116/1/extracted/a.py,1457,58,197,Python,544101,1,567116,kmod,2010
6173,c.py,"import sys, os
 from math import *
 
 T = int(sys.stdin.readline())
 
 mem = {}
 def wins_slow(a, b):
     if (a, b) in mem:
         return mem[(a,b)]
 
     if a == b:
         return False
     if a > b:
         return wins_slow(b, a)
 
     _b = b
     b -= a
     while b > 0:
         if not wins_slow(a, b):
             mem[(a,_b)] = True
             return True
         b -= a
     mem[(a,_b)] = False
     return False
 
 def wins(a,b):
     if a == b:
         return False
     if a > b:
         return wins(b, a)
 
     if b >= 2 * a:
         return True
     return not wins(b-a, a)
 
 def gcd(a, b):
     if a == 0:
         return b
     return gcd(b%a, a)
 
 phi = .5 * (sqrt(5) + 1)
 iphi = 1 / phi
 
 def total_slow(a1, a2, b1, b2):
     t = 0
     for a in xrange(a1, a2+1):
         for b in xrange(b1, b2+1):
             if wins(a,b):
                 t += 1
     return t
 
 def intersect(x1, x2, b1, b2):
     if x2 < b1:
         return 0
     if x1 > b2:
         return 0
     return min(x2,b2) - max(x1, b1) + 1
 
 def subtotal(a, b1, b2):
     lose = intersect(int(a * iphi + 1), int(a * phi), b1, b2)
     return b2 - b1 + 1 - lose
 
 def total_fast(a1, a2, b1, b2):
     if a2 - a1 > b2 - b1:
         return total_fast(b1, b2, a1, a2)
     t = 0
     for a in xrange(a1, a2+1):
         t += subtotal(a, b1, b2)
     return t
 
 for _t in range(T):
     a1, a2, b1, b2 = map(int, sys.stdin.readline().split())
     t = total_fast(a1, a2, b1, b2)
     print ""Case #%d: %d"" % (_t+1, t)
     sys.stdout.flush()
     # t2 = total_slow(a1, a2, b1, b2)
     # print t2
",gcj/2010/544101/kmod/583114/1/extracted/c.py,1601,78,255,Python,544101,1,583114,kmod,2010
6174,c.py,"import sys, os
 from math import *
 
 T = int(sys.stdin.readline())
 
 mem = {}
 def wins_slow(a, b):
     if (a, b) in mem:
         return mem[(a,b)]
 
     if a == b:
         return False
     if a > b:
         return wins_slow(b, a)
 
     _b = b
     b -= a
     while b > 0:
         if not wins_slow(a, b):
             mem[(a,_b)] = True
             return True
         b -= a
     mem[(a,_b)] = False
     return False
 
 def wins(a,b):
     if a == b:
         return False
     if a > b:
         return wins(b, a)
 
     if b >= 2 * a:
         return True
     return not wins(b-a, a)
 
 def gcd(a, b):
     if a == 0:
         return b
     return gcd(b%a, a)
 
 phi = .5 * (sqrt(5) + 1)
 iphi = 1 / phi
 
 def total_slow(a1, a2, b1, b2):
     t = 0
     for a in xrange(a1, a2+1):
         for b in xrange(b1, b2+1):
             if wins(a,b):
                 t += 1
     return t
 
 def intersect(x1, x2, b1, b2):
     if x2 < b1:
         return 0
     if x1 > b2:
         return 0
     return min(x2,b2) - max(x1, b1) + 1
 
 def subtotal(a, b1, b2):
     lose = intersect(int(a * iphi + 1), int(a * phi), b1, b2)
     return b2 - b1 + 1 - lose
 
 def total_fast(a1, a2, b1, b2):
     if a2 - a1 > b2 - b1:
         return total_fast(b1, b2, a1, a2)
     t = 0
     for a in xrange(a1, a2+1):
         t += subtotal(a, b1, b2)
     return t
 
 for _t in range(T):
     a1, a2, b1, b2 = map(int, sys.stdin.readline().split())
     t = total_fast(a1, a2, b1, b2)
     print ""Case #%d: %d"" % (_t+1, t)
     # t2 = total_slow(a1, a2, b1, b2)
     # print t2
",gcj/2010/544101/kmod/583114/0/extracted/c.py,1577,77,254,Python,544101,0,583114,kmod,2010
6176,b.py,"import sys, os
 from math import *
 
 T = int(sys.stdin.readline())
 
 INF = 999999999
 
 def inrange(x, l, h):
     if l > h:
         l, h = h, l
     if x < l or x > h:
         return False
     return True
 
 for _t in xrange(T):
     D, I, M, N = map(int, sys.stdin.readline().split())
     nums = map(int, sys.stdin.readline().split())
 
     if N == 1:
         print ""Case #%d: 0"" % (_t+1)
         continue
 
     ninsert = [0]
     _m = 0
     if M == 0:
         ninsert.extend([INF]*255)
     else:
         while len(ninsert) < 256:
             for i in xrange(M):
                 ninsert.append(_m)
             _m += 1
 
     cheapest = []
     for i in xrange(N+1):
         cheapest.append([INF]*256)
     for i in xrange(256):
         cheapest[0][i] = 0
 
 
     for i in xrange(N):
         n = nums[i]
         cn = cheapest[i+1]
         c = cheapest[i]
 
         for j in xrange(256):
             cn[j] = INF
 
         themin = 256
         themax = -1
         themin = min(nums[i], themin)
         themax = max(nums[i], themax)
         if i > 0:
             themin = min(nums[i-1], themin)
             themax = max(nums[i-1], themax)
         if i < N-1:
             themin = min(nums[i+1], themin)
             themax = max(nums[i+1], themax)
         for x in xrange(themin, themax+1):
             # ok = False
             # if i > 0:
                 # if inrange(x, nums[i], nums[i-1]):
                     # ok = True
             # if i < N-1:
                 # if inrange(x, nums[i], nums[i+1]):
                     # ok = True
             # if not ok:
                 # continue
             v = abs(x - n)
             for j in xrange(256):
             # for j in xrange(max(0, x-M), min(255,x+M)+1):
                 ins = ninsert[abs(x - j)]
                 if ins > 0 and M == 0:
                     continue
                 cn[x] = min(cn[x], c[j] + v + I * ins)
         for j in xrange(256):
             cn[j] = min(cn[j], c[j] + D)
 
 
     best = INF
     for i in xrange(256):
         best = min(best, cheapest[N][i])
     print ""Case #%d: %d"" % (_t+1, best)
     sys.stdout.flush()
",gcj/2010/544101/kmod/566101/0/extracted/b.py,2150,84,273,Python,544101,0,566101,kmod,2010
53287,c.py,"import sys, os
 
 def calcnext(next, cur, d):
     if (cur,d) in next:
         return next[(cur,d)]
     _cur = cur
     _d = d
     t = 0
     if d & 1:
         cur,t = next[(cur,1)]
         d -= 1
     cur, _t = calcnext(next, cur, d/2)
     t += _t
     cur, _t = calcnext(next, cur, d/2)
     t += _t
     next[(_cur, _d)] = (cur, t)
     return (cur, t)
 
 
 T = int(sys.stdin.readline())
 for _t in xrange(T):
     r,k,n = map(int, sys.stdin.readline().split())
     groups = map(int, sys.stdin.readline().split())
     next = {}
     for i in xrange(n):
         t = 0
         for j in xrange(n):
             x = groups[(i+j)%n]
             if t + x > k:
                 next[(i, 1)] = ((i+j)%n, t)
                 break
             t += x
         else:
             next[(i, 1)] = (i, t)
 
     total = 0
     cur = 0
     # for i in xrange(r):
         # cur,t = next[(cur, 1)]
         # total += t
     cur, total = calcnext(next, 0, r)
     print ""Case #%d: %d"" % (_t+1, total)
",gcj/2010/433101/kmod/509101/1/extracted/c.py,1000,43,144,Python,433101,1,509101,kmod,2010
53289,b.py,"import sys, os
 
 c = int(sys.stdin.readline())
 
 def gcd(a, b):
     if b == 0:
         return a
     return gcd(b, a%b)
 
 for i in xrange(c):
     times = map(int, sys.stdin.readline().split())[1:]
     times.sort()
     g = times[1] - times[0]
     for j in xrange(1, len(times)):
         g = gcd(g, times[j] - times[j-1])
     next = ((times[0] + g - 1) / g) * g
     print ""Case #%d: %d"" % (i+1, next - times[0])
",gcj/2010/433101/kmod/506101/1/extracted/b.py,422,18,63,Python,433101,1,506101,kmod,2010
53291,a.py,"import sys, os
 
 t = int(sys.stdin.readline())
 
 for i in xrange(t):
     s = sys.stdin.readline().split()
     n, k = map(int, s)
     print ""Case #%d:"" % (i+1),
     for j in xrange(n):
         if k & (2**j) == 0:
             print ""OFF""
             break
     else:
         print ""ON""
",gcj/2010/433101/kmod/502103/1/extracted/a.py,294,15,39,Python,433101,1,502103,kmod,2010
59879,c.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n = int(f.readline())
         nums = map(int, f.readline().split())
         tot = 0
         for x in nums:
             tot ^= x
 
         if tot != 0:
             ans = ""NO""
         else:
             ans = sum(nums) - min(nums)
         print ""Case #%d: %s"" % (_t+1, ans)
 
 
",gcj/2011/975485/kmod/1059486/1/extracted/c.py,511,25,67,Python,975485,1,1059486,kmod,2011
59881,a.py,"import sys
 
 def doit(points):
     last_pos = [1,1]
     last_time = [0,0]
     last_press = 0
 
     for i, x in points:
         diff = abs(x - last_pos[i])
         last_time[i] += diff
         last_pos[i] = x
         last_time[i] = max(last_time[i], last_press)
 
         last_time[i] += 1
         last_press = last_time[i]
 
     return last_press
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     d = {'O':0, 'B':1}
     for _t in xrange(t):
         s = f.readline().split()[1:]
         points = [(d[s[i]], int(s[i+1])) for i in xrange(0, len(s), 2)]
         n = doit(points)
         print ""Case #%d: %d"" % (_t+1, n)
 
",gcj/2011/975485/kmod/1080487/1/extracted/a.py,771,34,96,Python,975485,1,1080487,kmod,2011
59883,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n = int(f.readline())
         nums = map(int, f.readline().split())
         bad = 0
         for i in xrange(n):
             if nums[i] != i+1:
                 bad += 1
 
         print ""Case #%d: %.6f"" % (_t+1, bad)
 
 
 
",gcj/2011/975485/kmod/992486/1/extracted/d.py,454,23,58,Python,975485,1,992486,kmod,2011
59885,b.py,"import sys
 
 def doit(combines, opposed, l):
     # print combines, opposed, l
     cur = []
     for c in l:
         cur.append(c)
         while len(l) > 2 and tuple(sorted(cur[-2:])) in combines:
             new = combines[tuple(sorted(cur[-2:]))]
             cur.pop()
             cur.pop()
             cur.append(new)
         cont = set(cur)
         for o in opposed:
             if o[0] in cont and o[1] in cont:
                 cur = []
     return cur
 
 class Str(object):
     def __init__(self, s):
         self.s = s
 
     def __str__(self):
         return self.s
 
     def __repr__(self):
         return self.s
 
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         s = f.readline().split()
         c = int(s[0])
         combines = []
         for i in xrange(1, c+1):
             combines.append(s[i])
         combines = dict([(tuple(sorted(cm[:2])), cm[2]) for cm in combines])
         d = int(s[c+1])
         opposed = []
         for i in xrange(2 + c, 2 + c + d):
             opposed.append(s[i])
         n = doit(combines, opposed, s[-1])
         print ""Case #%d:"" % (_t+1), str(map(Str, n))
 
",gcj/2011/975485/kmod/1026487/1/extracted/b.py,1300,52,150,Python,975485,1,1026487,kmod,2011
95645,a.py,"import sys
 
 def doit():
     pass
 
 def gcd(a, b):
     if a > b:
         a, b = b, a
     if a == 0:
         return b
     return gcd(b % a, a)
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     d = {'O':0, 'B':1}
     for _t in xrange(t):
         t, pd, pg = map(int, f.readline().split())
 
         gd = gcd(pd, 100)
         won_today = pd / gd
         played_today = 100 / gd
         if played_today > t or (pg == 0 and pd != 0) or (pg == 100 and pd != 100):
             print ""Case #%d: Broken"" % (_t+1)
             continue
         else:
             print ""Case #%d: Possible"" % (_t+1)
 
 
",gcj/2011/1145485/kmod/1040487/1/extracted/a.py,745,35,114,Python,1145485,1,1040487,kmod,2011
95647,b.py,"import sys
 
 def same(w1, w2, l):
     for i in xrange(len(w1)):
         c1 = w1[i]
         c2 = w2[i]
         if c1 == c2:
             continue
         if c1 in l or c2 in l:
             return False
     return True
 
 def score(ans, words, l):
     candidates = [w for w in words if len(w) == len(ans)]
     sc = 0
     for i, c in enumerate(l):
         for w in candidates:
             if c in w:
                 break
         else:
             continue
 
         candidates = [w for w in candidates if same(w, ans, l[:i+1])]
 
         if not c in ans:
             sc += 1
     return sc
 
 def doit(l):
     best = -1
     bestw = None
     for w in words:
         sc = score(w, words, l)
         if sc > best:
             best = sc
             bestw = w
     return bestw
 
 def gcd(a, b):
     if a > b:
         a, b = b, a
     if a == 0:
         return b
     return gcd(b % a, a)
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n, m = map(int, f.readline().split())
         words = []
         lists = []
         for i in xrange(n):
             words.append(f.readline().strip())
         for j in xrange(m):
             lists.append(f.readline().strip())
 
         print ""Case #%d: %s"" % (_t + 1, "" "".join(map(doit, lists)))
 
",gcj/2011/1145485/kmod/1062486/0/extracted/b.py,1432,65,200,Python,1145485,0,1062486,kmod,2011
6771,c.py,"import math
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n = int(f.readline())
 
         peaks = map(int, f.readline().split())
 
         assert len(peaks) == n-1
 
         heights = [10000000] + [0] * (n-1)
 
         works = True
         changed = True
         while changed and works:
             changed = False
             # print heights
             for i in xrange(n-1):
                 highest = i + 1
                 for j in xrange(i + 2, n):
                     if (heights[j] - heights[i]) * (highest - i) > (heights[highest] - heights[i]) * (j - i):
                         highest = j
 
                 p = peaks[i] - 1
                 # print highest, p
                 if highest != p:
                     newheight = heights[i] + (p - i) * (heights[highest] - heights[i]) / (highest - i) + 1
                     if newheight > 1e9:
                         works = False
                         break
                     assert newheight > heights[p], (newheight, heights[p])
                     heights[p] = newheight
                     changed = True
 
                     # print heights
 
         if works:
             print ""Case #%d: %s"" % (_t + 1, ' '.join(map(str, heights)))
         else:
             print ""Case #%d: Impossible"" % (_t + 1)
",gcj/2012/1842485/kmod/1486492/0/extracted/c.py,1477,49,176,Python,1842485,0,1486492,kmod,2012
6772,d.py,"import time
 import collections
 import math
 import sys
 import random
 
 rand_map = {}
 for i in xrange(60):
     for j in xrange(60):
         rand_map[(i,j)] = random.randrange(0, 1e9)
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         R, C = map(int, f.readline().split())
 
         themap = []
         caves = {}
         for _r in xrange(R):
             line = f.readline().strip()
             assert len(line) == C
             for digit in xrange(10):
                 if chr(ord('0') + digit) in line:
                     caves[digit] = (_r, line.find(chr(ord('0') + digit)))
             themap.append(line)
 
         assert sorted(caves.keys()) == range(len(caves))
 
         total = 0
         print ""Case #%d:"" % (_t + 1)
         for cave in xrange(len(caves)):
             reachable = set([caves[cave]])
             q = collections.deque([caves[cave]])
 
             while q:
                 r, c = q.pop()
                 def trymove(_r, _c):
                     if (_r, _c) not in reachable and themap[_r][_c] != '#':
                         reachable.add((_r, _c))
                         q.append((_r, _c))
                 trymove(r-1, c)
                 trymove(r, c-1)
                 trymove(r, c+1)
 
 
             def mkhash(s):
                 total = 0
                 for r, c in s:
                     total += rand_map[(r,c)]
                 return total
                 return (tuple(sorted(s)))
             visited = set([mkhash(reachable)])
             q = collections.deque([reachable])
             lucky = False
             while q:
                 cur_plan = q.pop()
                 # print cur_plan
                 if len(cur_plan) == 1:
                     assert cur_plan.__iter__().next() in reachable
                     # print len(visited)
                     lucky = True
                     break
 
                 for move in ""left"", ""right"", ""down"":
                     new_plan = set()
                     works = True
                     for r, c in cur_plan:
                         if move == ""left"":
                             r2, c2 = r, c-1
                         if move == ""right"":
                             r2, c2 = r, c+1
                         if move == ""down"":
                             r2, c2 = r+1, c
                         new_p = r2, c2
 
                         if new_p in reachable:
                             new_plan.add(new_p)
                         elif themap[r2][c2] == '#':
                             new_plan.add((r, c))
                         else:
                             works = False
                             break
 
                     start = time.time()
                     if works:
                         h = mkhash(new_plan)
                         if h not in visited:
                             # print len(visited)
                             visited.add(h)
                             q.append(new_plan)
                     total += time.time() - start
 
                 if len(visited) > 100000:
                     lucky = False
                     break
 
             print ""%d: %d %s"" % (cave, len(reachable), ""Lucky"" if lucky else ""Unlucky"")
 
 
     # print total
",gcj/2012/1842485/kmod/1480495/1/extracted/d.py,3409,106,304,Python,1842485,1,1480495,kmod,2012
6773,d.py,"import collections
 import math
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         R, C = map(int, f.readline().split())
 
         themap = []
         caves = {}
         for _r in xrange(R):
             line = f.readline().strip()
             assert len(line) == C
             for digit in xrange(10):
                 if chr(ord('0') + digit) in line:
                     caves[digit] = (_r, line.find(chr(ord('0') + digit)))
             themap.append(line)
 
         assert sorted(caves.keys()) == range(len(caves))
 
         print ""Case #%d:"" % (_t + 1)
         for cave in xrange(len(caves)):
             reachable = set([caves[cave]])
             q = collections.deque([caves[cave]])
 
             while q:
                 r, c = q.pop()
                 def trymove(_r, _c):
                     if (_r, _c) not in reachable and themap[_r][_c] != '#':
                         reachable.add((_r, _c))
                         q.append((_r, _c))
                 trymove(r-1, c)
                 trymove(r, c-1)
                 trymove(r, c+1)
 
 
             visited = set([tuple(sorted(reachable))])
             q = collections.deque([reachable])
             lucky = False
             while q:
                 cur_plan = q.pop()
                 # print cur_plan
                 if len(cur_plan) == 1:
                     assert cur_plan.__iter__().next() in reachable
                     lucky = True
                     break
 
                 for move in ""left"", ""right"", ""down"":
                     new_plan = set()
                     works = True
                     for r, c in cur_plan:
                         if move == ""left"":
                             new_p = (r, c-1)
                         if move == ""right"":
                             new_p = (r, c+1)
                         if move == ""down"":
                             new_p = (r+1, c)
 
                         if new_p in reachable:
                             new_plan.add(new_p)
                         elif themap[new_p[0]][new_p[1]] == '#':
                             new_plan.add((r, c))
                         else:
                             works = False
                             break
 
                     p = tuple(sorted(new_plan))
                     if works and p not in visited:
                         visited.add(p)
                         q.append(p)
                         # print move, ""is good""
                     else:
                         pass
                         # print move, ""is no good"", works, tuple(sorted(new_plan)) in visited
 
             print ""%d: %d %s"" % (cave, len(reachable), ""Lucky"" if lucky else ""Unlucky"")
 
 
",gcj/2012/1842485/kmod/1480495/0/extracted/d.py,2878,86,250,Python,1842485,0,1480495,kmod,2012
6774,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n = int(f.readline())
 
         dists = []
         lengths = []
         for i in xrange(n):
             d, l = map(int, f.readline().split())
             dists.append(d)
             lengths.append(l)
 
         D = int(f.readline())
         dists.append(D)
         lengths.append(0)
         n += 1
 
         max_swing = [-1] * n
 
         assert lengths[0] >= dists[0]
 
         max_swing[0] = dists[0]
         for i in xrange(n):
             for j in xrange(i+1, n):
                 if dists[j] - dists[i] > max_swing[i]:
                     break
 
                 swing = min(lengths[j], dists[j] - dists[i])
                 max_swing[j] = max(max_swing[j], swing)
 
         # print max_swing
 
         print ""Case #%d: %s"" % (_t+1, ""NO"" if max_swing[-1] == -1 else ""YES"")
",gcj/2012/1842485/kmod/1481486/1/extracted/a.py,1023,42,112,Python,1842485,1,1481486,kmod,2012
6776,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n, w, l = map(int, f.readline().split())
         students = map(int, f.readline().split())
         assert len(students) == n
 
         students, indexes = zip(*sorted([(students[i], i) for i in xrange(n)], reverse=True))
 
         positions = []
 
         for i in xrange(0, n):
             found = False
             for j in xrange(-1, i):
                 if j == -1:
                     x = 0
                 else:
                     x = positions[j][0] + students[i] + students[j]
                 if x > w:
                     continue
                 for k in xrange(-1, i):
                     if k == -1:
                         y = 0
                     else:
                         y = positions[k][1] + students[i] + students[k]
                     if y > l:
                         continue
 
                     good = True
                     for h in xrange(0, i):
                         _x, _y = positions[h]
                         if (x-_x)**2 + (y-_y)**2 < (students[h] + students[i])**2:
                             good = False
                             break
                     if good:
                         positions.append((x, y))
                         found = True
                         break
 
                 if found == True:
                     break
 
             assert found
 
         real_pos = [None] * n
         for i in xrange(n):
             # print i, indexes[i]
             real_pos[indexes[i]] = positions[i]
         # for i in xrange(n):
             # print real_pos[i]
 
         for i in xrange(n):
             x, y = positions[i]
             assert 0 <= x <= w
             assert 0 <= y <= l
             for j in xrange(i):
                 _x, _y = positions[j]
                 assert (x-_x)**2 + (y-_y)**2 >= (students[i] + students[j]) ** 2
 
         print ""Case #%d: %s"" % (_t+1, ' '.join(""%d %d"" % p for p in real_pos))
",gcj/2012/1842485/kmod/1484495/0/extracted/b.py,2152,69,231,Python,1842485,0,1484495,kmod,2012
79262,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         ns = map(int, f.readline().split())
         n = ns[0]
         s = ns[1]
         p = ns[2]
         assert len(ns) == n + 3
         scores = ns[3:3+n]
 
         sure = 0
         if_surprising = 0
         for x in scores:
             not_surprising = (x + 2) / 3
             is_surprising = (x + 4) / 3
             if not_surprising >= p:
                 sure += 1
             elif (2 <= x <= 28) and is_surprising >= p:
                 if_surprising += 1
         print ""Case #%d: %d"" % (_t+1, sure + min(if_surprising, s))
",gcj/2012/1460488/kmod/1595491/1/extracted/b.py,763,29,106,Python,1460488,1,1595491,kmod,2012
79264,c.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, f.readline().split())
 
         total = 0
         for i in xrange(a, b):
             # print i
             s = set()
             cs = str(i)
             for j in xrange(1, len(cs)):
                 k = int(cs[j:] + cs[:j])
                 if i < k <= b:
                     s.add(k)
             # print s
             # print
             total += len(s)
 
         print ""Case #%d: %d"" % (_t + 1, total)
",gcj/2012/1460488/kmod/1483488/1/extracted/c.py,658,28,86,Python,1460488,1,1483488,kmod,2012
79266,d.py,"import sys
 
 def gcd(a, b):
     if a > b:
         return gcd(b, a)
 
     if a == 0:
         return b
     return gcd(b % a, a)
 
 def lcm(a, b):
     return a * b / gcd(a,b)
 def does_hit(mirrors, sx, sy, dx, dy, d):
     k = 1
     if dx:
         k = lcm(abs(dx), k)
     if dy:
         k = lcm(abs(dy), k)
     k *= 2
     # print dx, dy, k
 
     x = sx * k + k / 2
     y = sy * k + k / 2
     sx = x
     sy = y
 
     tx = 0
     ty = 0
     # print ""starting at %d,%d"" % (x, y)
     while True:
         x += dx
         y += dy
         tx += abs(dx)
         ty += abs(dy)
 
         if tx ** 2 + ty ** 2 > (k * d) ** 2:
             break
         # print ""at %d,%d, travelled %d,%d (out of %d)"" % (x, y, tx, ty, k*d)
 
         if x == sx and y == sy:
             # print ""back!""
             return True
 
         mx = (x % k) == 0
         my = (y % k) == 0
 
         if mx and not my:
             kx = x / k
             ky = y / k
             assert dx
             if dx < 0:
                 kx -= 1
 
             if mirrors[ky][kx]:
                 dx *= -1
                 # print ""hitting the wall at"", kx, ky
 
         elif my and not mx:
             kx = x / k
             ky = y / k
             assert dy
             if dy < 0:
                 ky -= 1
 
             if mirrors[ky][kx]:
                 dy *= -1
                 # print ""hitting the wall at"", kx, ky
 
         elif mx and my:
             assert dx
             assert dy
 
             kkx = kx = x / k
             kky = ky = y / k
 
             if dx < 0:
                 kkx -= 1
             else:
                 kx -= 1
             if dy < 0:
                 kky -= 1
             else:
                 ky -= 1
 
             # print ""going %d %d"" % (dx, dy)
             # print ""corner is %d %d"" % (kkx, kky)
             # print ""x side is %d %d"" % (kx, kky)
             # print ""y side is %d %d"" % (kkx, ky)
 
             hc = mirrors[kky][kkx]
             hx = mirrors[kky][kx]
             hy = mirrors[ky][kkx]
 
             if hc:
                 if hx and hy:
                     # print ""bounce back""
                     dx *= -1
                     dy *= -1
                 elif hx:
                     # print ""horizontal wall""
                     dy *= -1
                 elif hy:
                     # print ""vertical wall""
                     dx *= -1
                 else:
                     # print ""corner dead on""
                     return False
 
     return False
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         h,w,d = map(int, f.readline().split())
 
         mirrors = []
         for i in xrange(h):
             l = f.readline()
             m = []
             mirrors.append(m)
             for j in xrange(w):
                 if l[j] == '#':
                     m.append(True)
                 elif l[j] == '.':
                     m.append(False)
                 elif l[j] == 'X':
                     m.append(False)
                     start_x, start_y = j, i
                 else:
                     assert False
 
         num = 0
         for dx in xrange(-d, d+1):
             for dy in xrange(-d, d+1):
                 if gcd(abs(dx), abs(dy)) > 1:
                     continue
                 if dx ** 2 + dy ** 2 > d ** 2:
                     continue
                 if dx == 0 and dy == 0:
                     continue
 
                 if does_hit(mirrors, start_x, start_y, dx, dy, d):
                     # print ""HIT""
                     # print dx, dy
                     num += 1
                 # print
 
 
         del start_x, start_y
         print ""Case #%d: %d"" % (_t + 1, num)
",gcj/2012/1460488/kmod/1285485/1/extracted/d.py,3864,157,524,Python,1460488,1,1285485,kmod,2012
79268,a.py,"import sys
 
 d = {
         'a':'y',
         'o':'e',
         'z':'q',
         ' ':' ',
         'r':'p',
         'l':'m',
         'n':'s',
         'g':'l',
         'u':'j',
         'e':'c',
         'i':'k',
         's':'d',
         'm':'x',
         'p':'v',
         't':'r',
         'd':'i',
         'b':'n',
         'h':'b',
         'w':'t',
         'y':'a',
         'x':'h',
         'f':'w',
         'c':'f',
         'k':'o',
         'j':'u',
         'v':'g',
         'q':'z',
         '\n':'\n',
         }
 
 r = dict((v,k) for (k,v) in d.items())
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     f.readline()
     i = 1
     for l in f:
         sys.stdout.write(""Case #%d: "" % i)
         for c in l:
             # sys.stdout.write(r.get(c, '?'))
             sys.stdout.write(r[c])
         i += 1
 
",gcj/2012/1460488/kmod/1483485/0/extracted/a.py,945,52,88,Python,1460488,0,1483485,kmod,2012
92925,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, sys.stdin.readline().split())
         p = map(float, sys.stdin.readline().split())
         assert len(p) == a
 
         best = float(b+2)
         # print best
 
         # print a,b
         pright = 1.0
         for i in xrange(0, a+1):
             pright = 1.0
             for j in xrange(a-i):
                 pright *= p[j]
             expected = pright * (i + i + (b-a) + 1) + (1 - pright) * (i + i + (b-a) + 1 + b + 1)
             # print i, expected
             best = min(best, expected)
 
         print ""Case #%d: %.6f"" % (_t + 1, best)
",gcj/2012/1645485/kmod/1673486/1/extracted/a.py,800,30,114,Python,1645485,1,1673486,kmod,2012
92926,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, sys.stdin.readline().split())
         p = map(float, sys.stdin.readline().split())
         assert len(p) == a
 
         best = float(b+2)
         # print best
 
         # print a,b
         for i in xrange(0, a+1):
             pright = 1.0
             for j in xrange(a-i):
                 pright *= p[j]
             expected = pright * (i + i + (b-a) + 1) + (1 - pright) * (i + i + (b-a) + 1 + b + 1)
             # print i, expected
             best = min(best, expected)
 
         print ""Case #%d: %.6f"" % (_t + 1, best)
",gcj/2012/1645485/kmod/1673486/0/extracted/a.py,778,29,111,Python,1645485,0,1673486,kmod,2012
92927,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n = int(f.readline())
         stages = []
         for i in xrange(n):
             stages.append(map(int, sys.stdin.readline().split()))
 
         stars = 0
         progress = [0 for s in stages]
         games = 0
 
         bad = False
         while stars < 2 * n:
             found = False
             for i in xrange(n):
                 if progress[i] < 2 and stages[i][1] <= stars:
                     games += 1
                     stars += 2 - progress[i]
                     progress[i] = 2
                     found = True
                     break
 
             if found:
                 continue
 
             best = -1
             best_size = -1
             for i in xrange(n):
                 if progress[i] == 0 and stages[i][0] <= stars:
                     if stages[i][1] > best_size:
                         best = i
                         best_size = stages[i][1]
 
             if best_size == -1:
                 bad = True
                 break
             assert best_size >= 0
             progress[best] = 1
             stars += 1
             games += 1
 
         if bad:
             print ""Case #%d: Too Bad"" % (_t + 1,)
         else:
             print ""Case #%d: %d"" % (_t + 1, games)
",gcj/2012/1645485/kmod/1482494/1/extracted/b.py,1471,55,167,Python,1645485,1,1482494,kmod,2012
94825,c-slow2.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         M, F, N = map(int, f.readline().split())
         foods = []
 
         for i in xrange(N):
             foods.append(map(int, f.readline().split()))
         foods.sort()
 
         best = 0
         for norders in xrange(1, M / F + 1):
             meals = 0
             money = M - norders * F
             for p, s in foods:
                 if p > money:
                     break
                 can_buy = min(norders * (s + 1) - meals, money / p)
                 if can_buy >= 0:
                     meals += can_buy
                     money -= p * can_buy
             best = max(meals, best)
         print ""Case #%d: %d"" % (_t + 1, best)
",gcj/2012/1835486/kmod/1481492/0/extracted/c-slow2.py,882,32,115,Python,1835486,0,1481492,kmod,2012
94826,a.py,"import sys
 
 def cmp(idx1, idx2):
     # print idx1, idx2, p, l
     # print p[idx1] * l[idx2], p[idx2] * l[idx1]
     if p[idx1] * l[idx2] > p[idx2] * l[idx1]:
         return -1
     if p[idx1] * l[idx2] < p[idx2] * l[idx1]:
         return 1
     return idx1 - idx2
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n = int(f.readline())
 
         l = map(int, f.readline().split())
         p = map(int, f.readline().split())
 
         assert len(l) == n
         assert len(p) == n
         idx = range(n)
         idx.sort(cmp=cmp)
         print ""Case #%d:"" % (_t+1),
         for _i, ix in enumerate(idx):
             if _i != n-1:
                 print ix,
             else:
                 print ix
",gcj/2012/1835486/kmod/1475486/1/extracted/a.py,882,36,113,Python,1835486,1,1475486,kmod,2012
94828,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         k = int(f.readline())
         assert k == 2
         s = f.readline().strip()
 
         pairs = set()
         mult = ""oieastbg""
         for i in xrange(len(s)-1):
             pairs.add(s[i:i+2])
 
         _edges = {}
         _rev_edges = {}
         for p in pairs:
             if p[0] in mult:
                 c1 = (p[0], p[0].upper())
             else:
                 c1 = (p[0],)
             if p[1] in mult:
                 c2 = (p[1], p[1].upper())
             else:
                 c2 = (p[1],)
             for _c1 in c1:
                 for _c2 in c2:
                     _edges.setdefault(_c1, []).append(_c2)
                     _rev_edges.setdefault(_c2, []).append(_c1)
 
         def find_cycle(start):
             paths = {start:start}
             queue = [start]
             while queue:
                 c = queue.pop()
                 if c not in edges:
                     continue
                 for next in edges[c]:
                     if next == start:
                         return paths[c]
                     if next in queue or next in paths:
                         continue
                     paths[next] = paths[c] + next
                     queue.append(next)
             return None
 
         best = 1e9
         for i in xrange(100):
             edges = dict((k, list(l)) for k,l in _edges.iteritems())
             rev_edges = dict((k, list(l)) for k,l in _rev_edges.iteritems())
 
             need = 0
             while edges:
                 used = set()
 
                 need += 1
                 import random
                 start = c = random.choice(edges.keys())
                 used.add(c)
                 while c in edges:
                     cn = edges[c].pop()
                     if not edges[c]:
                         edges.pop(c)
                     rev_edges[cn].remove(c)
                     if not rev_edges[cn]:
                         rev_edges.pop(cn)
                     c = cn
                     need += 1
                     used.add(c)
 
                 c = start
                 while c in rev_edges:
                     cn = rev_edges[c].pop()
                     if not rev_edges[c]:
                         rev_edges.pop(c)
                     edges[cn].remove(c)
                     if not edges[cn]:
                         edges.pop(cn)
                     c = cn
                     need += 1
                     used.add(c)
 
                 while True:
                     found = False
                     for c in used:
                         cycle = find_cycle(c)
                         if not cycle:
                             continue
                         found = True
                         for i in xrange(len(cycle)):
                             c1 = cycle[i]
                             c2 = cycle[i+1] if i != len(cycle) -1 else cycle[0]
                             edges[c1].remove(c2)
                             if not edges[c1]:
                                 del edges[c1]
                             rev_edges[c2].remove(c1)
                             if not rev_edges[c2]:
                                 del rev_edges[c2]
                             need += 1
                             used.add(c1)
                         break
                     if not found:
                         break
 
             best = min(best, need)
 
         print ""Case #%d: %d"" % (_t+1, best)
",gcj/2012/1835486/kmod/1481496/0/extracted/d.py,3691,114,302,Python,1835486,0,1481496,kmod,2012
28298,a.py,"import sys
 
 P = 1000002013
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, M = map(int, f.readline().split())
         peep = []
         stops = set()
         for i in xrange(M):
             peep.append(map(int, f.readline().split()))
             stops.add(peep[-1][0])
             stops.add(peep[-1][1])
         assert all(len(p) == 3 for p in peep)
         stops = list(stops)
         stops.sort()
         # print peep, stops
 
         loss = 0
         total_loss = 0
         tickets = {}
 
         def grab(p, l):
             t = 0
             for k, v in sorted(tickets.items()):
                 x = min(v, p)
                 t += (l - k) * x
                 p -= x
                 tickets[k] -= x
                 if not tickets[k]:
                     del tickets[k]
                 if not p:
                     break
             return t
 
         prev = 0
         for s in stops:
             # print ""Loss from %d to %d: %d per, %d total"" % (prev, s, loss, (s - prev) * loss)
             total_loss += (s - prev) * loss
             tickets = dict((k + (s - prev), v) for (k, v) in tickets.iteritems())
             for o, e, p in peep:
                 if s == o:
                     tickets[0] = tickets.get(0, 0) + p
             for o, e, p in peep:
                 if s == e:
                     loss += grab(p, (e - o))
             prev = s
 
         print ""Case #%d: %d"" % (_T+1, total_loss % P)
",gcj/2013/2442487/kmod/2772486/1/extracted/a.py,1617,57,207,Python,2442487,1,2772486,kmod,2013
28300,c2.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         A = map(int, f.readline().split())
         B = map(int, f.readline().split())
         assert len(A) == N
         assert len(B) == N, len(B)
 
         gt = [[False] * N for i in xrange(N)]
         for i in xrange(N):
             for j in xrange(i+1, N):
                 if A[i] >= A[j]:
                     gt[i][j] = True
             for j in xrange(i-1, -1, -1):
                 if A[j] == A[i] - 1:
                     gt[i][j] = True
                     break
 
             for j in xrange(i):
                 if B[i] >= B[j]:
                     gt[i][j] = True
             for j in xrange(i+1, N):
                 if B[j] == B[i] - 1:
                     gt[i][j] = True
                     break
         # print
         # for i in xrange(N):
             # print i, map(int, gt[i])
 
         v = [0] * N
         r = 0
         while r < N:
             for i in xrange(N):
                 if v[i] == 0 and all(not gt[i][j] or v[j] for j in xrange(N)):
                     v[i] = r + 1
                     r += 1
                     break
             else:
                 raise Exception()
         print ""Case #%d: %s"" % (_T+1, ' '.join(map(str, v)))
",gcj/2013/2442487/kmod/2779487/1/extracted/c2.py,1445,50,179,Python,2442487,1,2779487,kmod,2013
28301,c2.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         A = map(int, f.readline().split())
         B = map(int, f.readline().split())
 
         gt = [[False] * N for i in xrange(N)]
         for i in xrange(N):
             for j in xrange(i+1, N):
                 if A[i] >= A[j]:
                     gt[i][j] = True
             for j in xrange(i-1, -1, -1):
                 if A[j] == A[i] - 1:
                     gt[i][j] = True
                     break
 
             for j in xrange(i):
                 if B[i] >= B[j]:
                     gt[i][j] = True
             for j in xrange(i+1, N):
                 if B[j] == B[i] - 1:
                     gt[i][j] = True
                     break
         # print
         # for i in xrange(N):
             # print i, map(int, gt[i])
 
         v = [0] * N
         r = 0
         while r < N:
             for i in xrange(N):
                 if v[i] == 0 and all(not gt[i][j] or v[j] for j in xrange(N)):
                     v[i] = r + 1
                     r += 1
                     break
         print ""Case #%d: %s"" % (_T+1, ' '.join(map(str, v)))
",gcj/2013/2442487/kmod/2779487/0/extracted/c2.py,1327,46,167,Python,2442487,0,2779487,kmod,2013
28302,b2.py,"import sys
 
 def worst_record(p, n):
     better = 0
     record = []
     for i in xrange(n):
         if better >= p - 1:
             record.append(""W"")
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, P = map(int, f.readline().split())
 
         p = 2**N - 1
         r = 2**N - 1
 
         b = 0
         for i in xrange(N):
             if r < P:
                 b = max(b, p)
             p -= 2**i
             r -= 2**(N-i-1)
 
         g = 0
         p = 0
         r = 0
         if P == 2**N:
             g = 2**N-1
         for i in xrange(N):
             if r < P:
                 g = max(g, p)
             p += 2**(i+1)
             r += 2**(N-i-1)
 
         print ""Case #%d: %d %d"" % (_T+1, g, b)
",gcj/2013/2442487/kmod/2766487/1/extracted/b2.py,892,43,129,Python,2442487,1,2766487,kmod,2013
43159,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         E, R, N = map(int, f.readline().split())
         days = map(int, f.readline().split())
 
         if R > E:
             R = E
 
         total = 0
         first = 0
         energy_at = [E]
         for cur in xrange(N):
             amount = R if (cur != N-1) else E
 
             # print ""end of day"", cur
             while amount:
                 best_idx = -1
                 best = 0
                 for i in xrange(first, cur+1):
                     assert energy_at[i]
                     if energy_at[i] and days[i] > best:
                         best_idx = i
                         best = days[i]
                 assert best
                 used = min(energy_at[best_idx], amount)
                 # print ""spending %d on day %d"" % (used, best_idx)
                 assert used > 0
 
                 for i in xrange(best_idx, cur+1):
                     energy_at[i] -= used
                     if energy_at[i] == 0:
                         first = i+1
                 amount -= used
                 total += best * used
             energy_at.append(E)
         print ""Case #%d: %d"" % (_T+1, total)
",gcj/2013/2418487/kmod/2645486/1/extracted/b.py,1358,46,153,Python,2418487,1,2645486,kmod,2013
43161,c.py,"#!pypy
 import multiprocessing
 import os
 import sys
 import cPickle
 from collections import defaultdict
 
 def _pmap_worker_func(f, q, results):
     while True:
         work = q.get()
         if work is None:
             q.task_done()
             return
 
         i, a = work
         try:
             r = f(a)
             print >>sys.stderr, i
             results.put((i, r))
         except:
             import traceback
             traceback.print_exc()
         q.task_done()
 
 def parallel_map(f, args, num_procs=8):
     procs = []
     q = multiprocessing.JoinableQueue()
     results = multiprocessing.Queue()
     while len(procs) < num_procs:
         p = multiprocessing.Process(target=_pmap_worker_func, args=(f, q, results))
         procs.append(p)
         p.daemon = True
         p.start()
 
     for i, a in enumerate(args):
         q.put((i, a))
     # add shutdown commands:
     for i in xrange(num_procs):
         q.put(None)
 
     q.join()
 
     assert results.qsize() == len(args)
     results_dict = {}
     for i in xrange(len(args)):
         idx, r = results.get()
         results_dict[idx] = r
 
     rtn = []
     for i in xrange(len(args)):
         r = results_dict[i]
         rtn.append(r)
 
     return rtn
 
 possibilities = []
 def gen_all(l, idx, minval):
     if idx == len(l):
         # print l
         possibilities.append(list(l))
         return
     for i in xrange(minval, M+1):
         l[idx] = i
         gen_all(l, idx+1, i)
 
 def fact(n):
     if n <= 2:
         return n
     return n * fact(n-1)
 
 def occurrences(nums):
     nom = fact(len(nums))
 
     counts = defaultdict(int)
     for n in nums:
         counts[n] += 1
     for v in counts.values():
         nom /= fact(v)
     return nom
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     GEN = True
 
     T = int(f.readline())
     for _T in xrange(T):
         R, N, M, K = map(int, f.readline().split())
         gen_all([0]*N, 0, 2)
 
         print ""Case #1:""
 
         fn = ""%d%d.pkl"" % (N, M)
         if not os.path.exists(fn):
             product_counts = []
             for nums in possibilities:
                 if nums[-1] == 7:
                     print nums
                 products = defaultdict(int)
                 for bitmask in xrange(2**N):
                     product = 1
                     bad = False
                     for i in xrange(N):
                         if bitmask & (2**i):
                             product *= nums[i]
                         else:
                             minv = nums[i]+1
                     products[product] += 1
                 product_counts.append(dict(products))
             cPickle.dump(product_counts, open(fn, 'w'))
         else:
             product_counts = cPickle.load(open(fn))
 
         # print zip(possibilities, product_counts)
         # print len(product_counts)
 
         def calc(products):
             assert len(products) == K
             best = 0
             best_idx = -1
             for i in xrange(len(possibilities)):
                 cur = occurrences(possibilities[i])
                 pc = product_counts[i]
                 for p in products:
                     if p not in pc:
                         break
                     cur *= pc[p]
                 else:
                     if cur > best:
                         best = cur
                         best_idx = i
 
             assert best
             assert best_idx >= 0
             return ''.join(map(str, possibilities[best_idx]))
 
         test_cases = []
         for _r in xrange(R):
             products = map(int, f.readline().split())
             test_cases.append(products)
         # results = map(calc, test_cases)
         results = parallel_map(calc, test_cases)
         for r in results:
             print r
 
             # print products
             # print best
             # print
 
 
",gcj/2013/2418487/kmod/2652486/1/extracted/c.py,4039,155,387,Python,2418487,1,2652486,kmod,2013
43162,c.py,"import os
 import sys
 import cPickle
 from collections import defaultdict
 
 possibilities = []
 def gen_all(l, idx, minval):
     if idx == len(l):
         # print l
         possibilities.append(list(l))
         return
     for i in xrange(minval, M+1):
         l[idx] = i
         gen_all(l, idx+1, i)
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     GEN = True
 
     T = int(f.readline())
     for _T in xrange(T):
         R, N, M, K = map(int, f.readline().split())
         gen_all([0]*N, 0, 2)
 
         print ""Case #1:""
 
         fn = ""%d%d.pkl"" % (N, M)
         if not os.path.exists(fn):
             product_counts = []
             for nums in possibilities:
                 if nums[-1] == 7:
                     print nums
                 products = defaultdict(int)
                 for bitmask in xrange(2**N):
                     product = 1
                     minv = 1
                     bad = False
                     for i in xrange(N):
                         if bitmask & (2**i):
                             if nums[i] < minv:
                                 bad = True
                                 break
                             product *= nums[i]
                         else:
                             minv = nums[i]+1
                     else:
                         products[product] += 1
                 product_counts.append(dict(products))
             cPickle.dump(product_counts, open(fn, 'w'))
         else:
             product_counts = cPickle.load(open(fn))
 
         # print zip(possibilities, product_counts)
         # print len(product_counts)
 
         for _r in xrange(R):
             products = map(int, f.readline().split())
             assert len(products) == K
             best = 0, 1
             best_idx = -1
             for i in xrange(len(possibilities)):
                 nom = denom = 1
                 total = sum(product_counts[i].values())
                 for p in products:
                     nom *= product_counts[i].get(p, 0)
                     denom *= total
                 if nom * best[1] > best[0] * denom:
                     best = nom, denom
                     best_idx = i
 
             print ''.join(map(str, possibilities[best_idx]))
 
             # print products
             # print best
             # print
 
 
",gcj/2013/2418487/kmod/2652486/0/extracted/c.py,2452,83,229,Python,2418487,0,2652486,kmod,2013
43163,a.py,"import sys
 
 def num_paint(r, k):
     return 2 * k * r + 2 * k * k - k
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         r, t = map(int, f.readline().split())
 
         low = 1
         high = 10**18
 
         while high > low:
             guess = (low + high + 1) / 2
             if num_paint(r, guess) > t:
                 high = guess - 1
             else:
                 low = guess
         print ""Case #%d: %d"" % (_T+1, low)
",gcj/2013/2418487/kmod/2464487/1/extracted/a.py,607,27,92,Python,2418487,1,2464487,kmod,2013
136837,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         m = []
         for i in xrange(4):
             l = f.readline().strip()
             assert len(l) == 4
             m.append(l)
         f.readline()
 
         def check(x, y, dx, dy):
             s = set()
             for i in xrange(4):
                 s.add(m[x][y])
                 x += dx
                 y += dy
             # print x, y, dx, dy, s
             if 'T' in s:
                 s.remove('T')
             if '.' in s:
                 return None
             if len(s) == 1:
                 return list(s)[0]
             return None
 
         winner = None
         for i in xrange(4):
             winner = winner or check(0, i, 1, 0)
             winner = winner or check(i, 0, 0, 1)
         winner = winner or check(0, 0, 1, 1)
         winner = winner or check(0, 3, 1, -1)
 
         print ""Case #%d:"" % (_t+1),
         if winner:
             print ""%s won"" % winner
         elif any('.' in l for l in m):
             print ""Game has not completed""
         else:
             print ""Draw""
",gcj/2013/2270488/kmod/2453486/1/extracted/a.py,1260,48,158,Python,2270488,1,2453486,kmod,2013
136839,c5.py,"import math
 import sys
 
 def ispal(n):
     s = str(n)
     return s == s[::-1]
 
 def ispalsq(n):
     sqrt = int(math.sqrt(n) + .01)
     if sqrt ** 2 != n:
         return False
     return ispal(n) and ispal(sqrt)
 
 nums = set()
 def search(s, l, idx):
     if l % 2 == 0:
         m = s + s[::-1]
     else:
         m = s[:-1] + s[::-1]
     assert ispal(m)
     n = int(m) ** 2
     if not ispal(n):
         # print m, False
         return 0
     # print m, int(m)**2
 
     nums.add(n)
     for i in xrange(idx, len(s)):
         s2 = list(s)
         s2[i] = str(int(s2[i])+1)
         s2 = ''.join(s2)
         search(s2, l, i)
 
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     for l in xrange(1, 75):
         search(""1"" + ""0"" * ((l-1)/2), l, 0)
     assert any(n > 10**120 for n in nums)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, f.readline().split())
 
         total = len([n for n in nums if a <= n <= b])
         print ""Case #%d: %d"" % (_t+1, total)
 
",gcj/2013/2270488/kmod/2463486/2/extracted/c5.py,1123,53,167,Python,2270488,2,2463486,kmod,2013
136840,c4.py,"import math
 import sys
 
 def ispal(n):
     s = str(n)
     return s == s[::-1]
 
 def ispalsq(n):
     sqrt = int(math.sqrt(n) + .01)
     if sqrt ** 2 != n:
         return False
     return ispal(n) and ispal(sqrt)
 
 def search(s, l, idx):
     if l % 2 == 0:
         m = s + s[::-1]
     else:
         m = s[:-1] + s[::-1]
     assert ispal(m)
     n = int(m) ** 2
     if not ispal(n):
         # print m, False
         return 0
     # print m, int(m)**2
 
     r = 1 if (a <= n <= b) else 0
     for i in xrange(idx, len(s)):
         s2 = list(s)
         s2[i] = str(int(s2[i])+1)
         s2 = ''.join(s2)
         r += search(s2, l, i)
     return r
 
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         a, b = map(int, f.readline().split())
 
         total = 0
         for l in xrange(1, 150):
             if 10 ** (l-1) > b:
                 break
             total += search(""1"" + ""0"" * ((l-1)/2), l, 0)
         print ""Case #%d: %d"" % (_t+1, total)
 
",gcj/2013/2270488/kmod/2463486/1/extracted/c4.py,1139,53,169,Python,2270488,1,2463486,kmod,2013
136842,b2.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
     for _t in xrange(t):
         n, m = map(int, f.readline().split())
         b = []
         for i in xrange(n):
             b.append(map(int, f.readline().split()))
             assert len(b[-1]) == m
         # print b
 
         max_h = [0] * n
         max_v = [0] * m
 
         for i in xrange(n):
             for j in xrange(m):
                 t = b[i][j]
                 max_h[i] = max(max_h[i], t)
                 max_v[j] = max(max_v[j], t)
         can = True
         for i in xrange(n):
             if not can:
                 break
             for j in xrange(m):
                 t = b[i][j]
                 if max_h[i] > t and max_v[j] > t:
                     can = False
                     break
 
         print ""Case #%d: %s"" % (_t+1, ""YES"" if can else ""NO"")
",gcj/2013/2270488/kmod/2449486/1/extracted/b2.py,989,38,121,Python,2270488,1,2449486,kmod,2013
136844,d.py,"from collections import defaultdict
 import math
 import sys
 
 def numones(n):
     return bin(n).count('1')
 
 def addchest(keys, chest):
     keys[chest[0]] -= 1
     for k in chest[1]:
         keys[k] += 1
 
 def canchest(keys, chest):
     keys = dict(keys)
     for k in chest[1]:
         keys[k] -= 1
     return not any(v < 0 for v in keys.values())
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     t = int(f.readline())
 
     confs = range(2**20)
     confs.sort(key=numones, reverse=True)
     # print confs
     for _t in xrange(t):
         k, n = map(int, f.readline().split())
         _keys = map(int, f.readline().split())
         assert len(_keys) == k
         starting_keys = defaultdict(int)
         for k in _keys:
             starting_keys[k] += 1
         # print starting_keys
 
         chests = []
         for i in xrange(n):
             _data = map(int, f.readline().split())
             assert len(_data) == _data[1] + 2
             chests.append((_data[0], _data[2:]))
         # print chests
 
         # possible = { (2**n - 1) : None }
         possible = {}
         ending_keys = defaultdict(int, starting_keys)
         for c in chests:
             addchest(ending_keys, c)
         # print ending_keys
         if not any(v < 0 for v in ending_keys.values()):
             possible[2**n - 1] = None
 
         for c in confs:
             if c not in possible:
                 continue
 
             keys = defaultdict(int, starting_keys)
             for i in xrange(n):
                 if c & (1 << i):
                     addchest(keys, chests[i])
             # print bin(c), keys
             # assert not any(v < 0 for v in keys.values())
 
             for i in xrange(n):
                 if not (c & (1 << i)):
                     continue
                 if not canchest(keys, chests[i]):
                     continue
 
                 c2 = c & (~(1<<i))
                 if c2 not in possible or i < possible[c2]:
                     possible[c2] = i
 
         if 0 not in possible:
             print ""Case #%d: IMPOSSIBLE"" % (_t+1,)
         else:
             print ""Case #%d:"" % (_t+1,),
             cur = 0
             while True:
                 n = possible[cur]
                 if n is None:
                     break
                 print n + 1,
                 cur |= (1<<n)
             print
",gcj/2013/2270488/kmod/2458486/0/extracted/d.py,2489,89,283,Python,2270488,0,2458486,kmod,2013
142621,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         _o = f.readline().strip()
         N = len(_o)
         occupied = 0
         for i in xrange(N):
             if _o[i] == 'X':
                 occupied += (1<<i)
 
         mem = {}
         def ex(o):
             if o in mem:
                 return mem[o]
             if o == (1<<N) - 1:
                 return 0.0
 
             total = 0.0
             for i in xrange(N):
                 for wait in xrange(N):
                     bm = (1<<((i+wait)%N))
                     if o & bm == 0:
                         break
                 else:
                     raise Exception()
                 total += N - wait + ex(o | bm)
             mem[o] = total / N
             return total / N
         print ""Case #%d: %.12f"" % (_T+1, ex(occupied))
",gcj/2013/2433487/kmod/2846487/0/extracted/d.py,989,38,118,Python,2433487,0,2846487,kmod,2013
142622,a2.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         B, N = map(int, f.readline().split())
         _bets = map(int, f.readline().split())
         assert len(_bets) == N
 
         while len(_bets) < 37:
             _bets.append(0)
         _bets.sort()
         # print _bets
 
         best = 0.0
         total_bet = 0
 
         for num_min in xrange(1, 37):
             bets = list(_bets)
 
             def cost(size):
                 t = 0
                 for i in xrange(num_min):
                     assert size >= bets[i]
                     t += size - bets[i]
                 for i in xrange(num_min, 37):
                     if bets[i] <= size:
                         t += (size+1) - bets[i]
                 return t
 
             low = max(bets[:num_min])-1
             high = 10000000000000
             while high > low:
                 g = (high + low + 1) / 2
                 c = cost(g)
                 # print num_min, g, c
                 if c > B:
                     high = g - 1
                 else:
                     low = g
                     amount_bet = g * num_min - sum(bets[:num_min])
                     best = max(amount_bet * 36.0 / num_min - c, best)
         print ""Case #%d: %.9f"" % (_T+1, best)
",gcj/2013/2433487/kmod/2850486/1/extracted/a2.py,1434,50,164,Python,2433487,1,2850486,kmod,2013
142624,c.py,"import sys
 
 INF = 1000000000
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, M, P = map(int, f.readline().split())
         route_list = []
         routes = dict([(i, []) for i in xrange(N)])
         rev_routes = dict([(i, []) for i in xrange(N)])
         for i in xrange(M):
             u, v, a, b = map(int, f.readline().split())
             u -= 1
             v -= 1
             routes[u].append((v, a, b))
             rev_routes[v].append((u, a, b))
             route_list.append((u, v, a, b))
 
         minmax = []
         for start in xrange(N):
             mm = [INF] * N
             mm[start] = 0
 
             q = set(range(N))
             while q:
                 dist, idx = min([(mm[idx], idx) for idx in q])
                 q.remove(idx)
                 for v, a, b in routes[idx]:
                     mm[v] = min(mm[v], dist + b)
             minmax.append(mm)
 
         # print minmax
         minrest = []
         for dest in xrange(N):
             mr = [INF] * N
             mr[dest] = 0
             q = set(range(N))
             while q:
                 dist, idx = min([(mr[idx], idx) for idx in q])
                 q.remove(idx)
                 for u, a, b in rev_routes[idx]:
                     mr[u] = min(mr[u], dist + a)
             minrest.append(mr)
         # print minmax
         # print minrest
 
         suggested = map(int, f.readline().split())
         assert len(suggested) == P
 
         """"""
         def check(path):
             start = route_list[path[0] - 1][0]
             end = route_list[path[-1] - 1][1]
             print ""Checking %s from %s to %s"" % (path, start, end)
 
             best_case = 0
             loc = start
             max_best = minmax[start][end]
             for r in path:
                 r -= 1
                 u, v, a, b = route_list[r]
                 assert loc == u
                 best_case += a
                 print ""Went from %d to %d, could be there in %d"" % (u, v, best_case)
                 loc = v
                 if minrest[end][v] + best_case > max_best:
                     print ""Will take at least %d more to get to %s, but there's a guaranteed path <=%d"" % (minrest[end][v], end, max_best)
                     return r + 1
             return None
 
         for i in xrange(P):
             for j in xrange(i+1, P+1):
                 bad = check(suggested[i:j])
                 print i, j, bad
         print
         """"""
 
         """"""
         for i in xrange(1, P+1):
             bad = check(suggested[:i])
             if bad:
                 print ""Case #%d: %d"" % (_T+1, suggested[i-1])
                 break
         else:
             print ""Case #%d: Looks Good To Me"" % (_T+1)
         """"""
 
         loc = 0
         best_case = 0
         for r in suggested:
             u, v, a, b = route_list[r-1]
             assert loc == u
             loc = v
             best_case += a
             # print ""went from %d to %d, could be there in %d"" % (u, v, best_case)
             if best_case > minmax[0][loc]:
                 # print ""Know that I can be here faster""
                 print ""Case #%d: %d"" % (_T+1, r)
                 break
             elif best_case + minrest[1][loc] > minmax[0][1]:
                 # print ""Know that I could have finished faster""
                 print ""Case #%d: %d"" % (_T+1, r)
                 break
         else:
             print ""Case #%d: Looks Good To Me"" % (_T+1,)
         # print
",gcj/2013/2433487/kmod/2860486/0/extracted/c.py,3650,114,438,Python,2433487,0,2860486,kmod,2013
107865,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         naomi = map(float, f.readline().split())
         ken = map(float, f.readline().split())
         assert len(ken) == len(naomi) == N
 
         naomi = [(w, 1) for w in naomi]
         ken = [(w, 0) for w in ken]
 
         blocks = ken + naomi
         blocks.sort(reverse=True)
         blocks = [p[1] for p in blocks]
         # print blocks
 
         honest = 0
         adv = 0
         for b in blocks:
             if b == 1:
                 adv += 1
                 honest = max(honest, adv)
             else:
                 adv -= 1
 
         deceitful = 0
         kept = 0
         for b in blocks:
             if b == 1:
                 kept += 1
             else:
                 if kept:
                     kept -= 1
                     deceitful += 1
         print ""Case #%d: %d %d"" % (_T+1, deceitful, honest)
",gcj/2014/2974486/kmod/5644738749267968/1/extracted/d.py,1099,44,139,Python,2974486,1,5644738749267968,kmod,2014
107867,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         C, F, X = map(float, f.readline().split())
 
         cps = 2.0
         t = 0.0
         best_t = X / cps
 
         while True:
             t += C / cps
             if t >= best_t:
                 break
 
             cps += F
             best_t = min(best_t, t + X / cps)
 
         print ""Case #%d: %.7f"" % (_T+1, best_t)
",gcj/2014/2974486/kmod/5709773144064000/1/extracted/b.py,557,27,77,Python,2974486,1,5709773144064000,kmod,2014
107869,c2.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         R, C, M = map(int, f.readline().split())
 
         # print R, C, M
         print ""Case #%d:"" % (_T+1)
 
         left = R * C - M
 
         if R == 1:
             s = 'c'
             s += '.' * (left - 1)
             s += '*' * M
             print s
             continue
         if C == 1:
             print 'c'
             for i in xrange(left - 1):
                 print '.'
             for i in xrange(M):
                 print '*'
             continue
 
         if left == 1:
             print 'c' + '*' * (C-1)
             for i in xrange(R-1):
                 print '*' * C
             continue
 
         if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):
             print ""Impossible""
             continue
         if R == 2:
             assert left not in (2, 3, 5, 7)
             assert left >= 4
             print 'c' + '.' * (left/2 - 1) + '*' * (M/2)
             print '.' + '.' * (left/2 - 1) + '*' * (M/2)
             continue
         if C == 2:
             assert left >= 4
             assert left not in (2, 3, 5, 7)
             print 'c.'
             left -= 2
             R -= 1
             while left:
                 print '..'
                 left -= 2
                 R -= 1
             assert R >= 0
             while R:
                 print '**'
                 R -= 1
             continue
 
         assert R >= 3
         assert C >= 3
 
         if left == 4:
             print 'c.' + '*' * (C-2)
             print '..' + '*' * (C-2)
             for i in xrange(R-2):
                 print '*' * C
             continue
 
         if left in (2, 3, 5, 7):
             print ""Impossible""
             continue
 
         assert left >= 6
 
         cols = max(3, (left + R-1) // R)
 
         if left % cols == 1:
             assert left >= 10
 
             print 'c' + '.' * (cols - 1) + '*' * (C - cols)
             left -= cols
             R -= 1
 
             while left > cols + 1:
                 print '.' * cols + '*' * (C - cols)
                 left -= cols
                 R -= 1
             assert left == cols + 1
             print '.' * (cols - 1) + '*' * (C - cols + 1)
             print '.' * (2) + '*' * (C - 2)
             R -= 2
 
             assert R >= 0
 
             while R:
                 print '*' * C
                 R -= 1
             continue
         else:
             assert left >= 6
 
             print 'c' + '.' * (cols - 1) + '*' * (C - cols)
             left -= cols
             R -= 1
 
             while left > cols:
                 print '.' * cols + '*' * (C - cols)
                 left -= cols
                 R -= 1
             assert left >= 2
             print '.' * (left) + '*' * (C - left)
             R -= 1
 
             assert R >= 0
 
             while R:
                 print '*' * C
                 R -= 1
             continue
 
         1/0
",gcj/2014/2974486/kmod/5690574640250880/1/extracted/c2.py,3136,127,454,Python,2974486,1,5690574640250880,kmod,2014
107871,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         a1 = int(f.readline())
         l1 = [map(int, f.readline().split()) for _ in xrange(4)]
         a2 = int(f.readline())
         l2 = [map(int, f.readline().split()) for _ in xrange(4)]
 
         poss = list(set(l1[a1-1]) & set(l2[a2-1]))
 
         print ""Case #%d:"" % (_T + 1),
         if len(poss) == 0:
             print ""Volunteer cheated!""
         elif len(poss) == 1:
             print poss[0]
         else:
             print ""Bad magician!""
",gcj/2014/2974486/kmod/5756407898963968/0/extracted/a.py,684,26,81,Python,2974486,0,5756407898963968,kmod,2014
143580,c.py,"import sys
 
 def cando(n, m, k, s):
     assert n <= m
     assert n >= 1
     assert m >= 1
     assert k <= n * m
     if s <= 0:
         return False
     if s >= k:
         # print ""can do"", n, m, k, s
         return True
     if n >= 3 and m >= 3 and s >= 4:
         submin = findmin(n-2, m-2, k-s)
         if s >= submin + 4 or submin == 1 and s >= 4:
             # print ""can do"", n, m, k, s
             return True
 
     # assert n in (1, 2)
     assert s < k
     return False
 
 mins = {}
 def findmin(n, m, k):
     if k > n * m:
         return 10000000
     assert n <= m
 
     p = (n, m, k)
     if p in mins:
         return mins[p]
 
     for s in xrange(1, k+1):
         if cando(n, m, k, s):
             # print ""findmin(%d, %d, %d) = %d"" % (n, m, k, s)
             mins[p] = s
             return s
     assert 0
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, M, K = map(int, f.readline().split())
 
         if N > M:
             N, M = M, N
 
         r = findmin(N, M, K)
         print ""Case #%d: %d"" % (_T+1, r)
",gcj/2014/3004486/kmod/5658068650033152/1/extracted/c.py,1222,56,212,Python,3004486,1,5658068650033152,kmod,2014
143581,c_brute.py,"import sys
 
 def works():
     found = [[0] * M for _ in xrange(N)]
     q = []
     tot = 0
 
     for i in xrange(N):
         if grid[i][0] == 0:
             found[i][0] = 1
             tot += 1
             q.append((i, 0))
         if M > 1:
             if grid[i][M-1] == 0:
                 found[i][M-1] = 1
                 tot += 1
                 q.append((i, M-1))
 
     for j in xrange(1,M-1):
         if grid[0][j] == 0:
             found[0][j] = 1
             tot += 1
             q.append((0, j))
         if N > 1:
             if grid[N-1][j] == 0:
                 found[N-1][j] = 1
                 tot += 1
                 q.append((N-1, j))
 
     while q:
         r, c = q.pop()
 
         for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
             nr, nc = r + dr, c + dc
             if nr < 0 or nr >= N or nc < 0 or nc >= M:
                 continue
             if grid[nr][nc] == 0 and found[nr][nc] == 0:
                 found[nr][nc] = 1
                 tot += 1
                 q.append((nr, nc))
 
     return N * M - tot >= K
 
 def test(idx):
     if idx == N * M:
         if works():
             return sum(map(sum, grid))
         return 10000
 
     r, c = idx / M, idx % M
 
     grid[r][c] = 0
     a = test(idx + 1)
     grid[r][c] = 1
     b = test(idx + 1)
     return min(a, b)
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, M, K = map(int, f.readline().split())
 
         grid = [[0] * M for _ in xrange(N)]
 
         r = test(0)
         print ""Case #%d: %d"" % (_T+1, r)
",gcj/2014/3004486/kmod/5658068650033152/0/extracted/c_brute.py,1713,73,247,Python,3004486,0,5658068650033152,kmod,2014
143582,b.py,"import sys
 
 def compact(s):
     i = 0
     while i < len(s) - 1:
         if s[i] == s[i+1]:
             s = s[:i] + s[i+1:]
         else:
             i += 1
     return s
 
 class NotPossible(Exception):
     pass
 
 P = 1000000007
 
 def fact(n):
     t = 1
     for i in xrange(1, n+1):
         t = (t * i) % P
     return t
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         trains = f.readline().split()
         trains = map(compact, trains)
 
         try:
             for s in trains:
                 if s[0] in s[1:]:
                     raise NotPossible
                 if s[-1] in s[:-1]:
                     raise NotPossible
                 for c in s[1:-1]:
                     cnt = sum(s2.count(c) for s2 in trains)
                     assert cnt >= 1
                     if cnt != 1:
                         raise NotPossible()
 
             # print trains
             singles = {}
             chunks = []
             for i in xrange(N):
                 if len(trains[i]) == 1:
                     singles[trains[i]] = singles.get(trains[i], 0) + 1
                 else:
                     chunks.append(trains[i][0] + trains[i][-1])
             # print singles, chunks
 
             mult = 1
             left = 0
             while chunks:
                 # print mult, left, singles, chunks
                 first = chunks.pop()
                 assert len(set(first)) == len(first)
 
                 mult = (mult * fact(singles.pop(first[0], 0))) % P
                 mult = (mult * fact(singles.pop(first[-1], 0))) % P
 
                 for ch in chunks:
                     assert len(set(ch)) == len(ch)
                     if ch[0] in first:
                         if ch[0] in first[:-1]:
                             raise NotPossible()
                         assert not any(c == ch[0] for c in ch[1:])
                         if any(c in first for c in ch[1:]):
                             raise NotPossible()
                         assert ch[0] == first[-1]
                         chunks.remove(ch)
                         chunks.append(first + ch[1:])
                         break
                     if ch[-1] in first:
                         if ch[-1] in first[1:]:
                             raise NotPossible()
                         assert not any(c == ch[-1] for c in ch[:-1])
                         if any(c in first for c in ch[:-1]):
                             raise NotPossible()
                         assert ch[-1] == first[0]
                         chunks.remove(ch)
                         chunks.append(ch + first[1:])
                         break
                 else:
                     left += 1
                     continue
             # print mult, left, singles, chunks
 
             for k, v in singles.iteritems():
                 left += 1
                 mult = (mult * fact(v)) % P
 
             assert left >= 0
             while left:
                 mult = (mult * left) % P
                 left = left - 1
 
             print ""Case #%d: %d"" % (_T+1, mult)
         except NotPossible:
             print ""Case #%d: 0"" % (_T+1,)
",gcj/2014/3004486/kmod/5669245564223488/1/extracted/b.py,3361,107,340,Python,3004486,1,5669245564223488,kmod,2014
143584,a.py,"import sys
 
 def gcd(a, b):
     if a > b:
         a, b = b, a
     if a == 0:
         return b
     return gcd(b % a, a)
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         P, Q = map(int, f.readline().split('/'))
         g = gcd(P, Q)
         P /= g
         Q /= g
 
         n = 0
         first = 10000000
         while Q & 1 == 0:
             n += 1
             if P >= Q/2:
                 first = min(first, n)
             Q >>= 1
 
         if Q != 1:
             print ""Case #%d: impossible"" % (_T+1)
         else:
             assert n != 0
             assert 0 < first < 1000
             print ""Case #%d: %d"" % (_T+1, first)
",gcj/2014/3004486/kmod/5706278382862336/1/extracted/a.py,815,38,122,Python,3004486,1,5706278382862336,kmod,2014
145815,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         P, Q, N = map(int, f.readline().split())
 
         healths = []
         golds = []
 
         for i in xrange(N):
             h, g = map(int, f.readline().split())
             healths.append(h)
             golds.append(g)
 
         def num_hits_to_win(h):
             assert h > 0
 
             if P > Q:
                 return 1
 
             t = 1
             while True:
                 m = ((h - 1) % Q) + 1
                 if 1 <= m <= P:
                     return t
 
                 h -= P
                 t += 1
 
         # for h in healths:
             # print h, num_hits_to_win(h)
 
         cur = {1: 0}
 
         for i in xrange(N):
             next = {}
 
             hits_needed = num_hits_to_win(healths[i])
             would_win = golds[i]
 
             # print
             # print ""On creep %d"" % i
 
             for shots, money in cur.iteritems():
                 # print ""Could have %d shots and %d gold"" % (shots, money)
                 do_nothing = (healths[i] + Q-1) / Q + shots
 
                 # print ""do nothing and would have %d shots"" % do_nothing
                 next[do_nothing] = max(next.get(do_nothing, 0), money)
 
                 health = healths[i]
                 if shots == 0:
                     health -= Q
                     shots += 1
                     if health <= 0:
                         continue
 
                 # min_tower_shots = hits_needed - shots
                 # if min_tower_shots * Q + (hits_needed - 1) * P > health:
                     # continue
 
                 tower_shots = max((health - (hits_needed - 1) * P - 1) / Q, 0)
                 next_shots = shots - hits_needed + tower_shots
                 # print ""tower shoots %d times, we shoot %d times; we'd have %d shots"" % (tower_shots, hits_needed, next_shots)
                 if next_shots < 0:
                     # print ""we only have %d initial shots""
                     continue
 
                 next[next_shots] = max(next.get(next_shots, 0), money + would_win)
 
             cur = next
 
         # print cur
         best = max(cur.itervalues())
         print ""Case #%d: %d"" % (_T+1, best)
 
 
",gcj/2014/3024486/kmod/5724427840913408/1/extracted/b.py,2405,85,284,Python,3024486,1,5724427840913408,kmod,2014
145817,a.py,"import collections
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, p, q, r, s = map(int, f.readline().split())
 
         transistors = [(i * p + q) % r + s for i in xrange(N)]
         total = sum(transistors)
 
         sums = []
         t = 0
         for i in xrange(N):
             sums.append(t)
             t += transistors[i]
         sums.append(t)
         assert t == total
 
         def can3(p):
             needed = (1 - p) * total
             for i in xrange(N-1, 0, -1):
                 if sums[i] <= needed:
                     break
             else:
                 return False
 
             for j in xrange(N-1, i-1, -1):
                 if sums[j+1] - sums[i] <= needed:
                     break
             else:
                 return False
 
             if total - sums[j+1] <= needed:
                 return True
             return False
 
         def can2(p):
             needed = (1 - p) * total
             for i in xrange(N-1, 0, -1):
                 if sums[i] <= needed:
                     break
             else:
                 return False
 
             if total - sums[i] <= needed:
                 return True
             return False
 
 
         low = 0.0
         high = 1.0
         for i in xrange(40):
             g = (low + high) * 0.5
 
             if can3(g) or can2(g):
                 low = g
             else:
                 high = g
         print ""Case #%d: %.10f"" % (_T+1, low)
",gcj/2014/3024486/kmod/5645447150436352/1/extracted/a.py,1648,67,194,Python,3024486,1,5645447150436352,kmod,2014
156961,b.py,"import collections
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         nums = map(int, f.readline().split())
 
         r = 0
         while nums:
             m = min(nums)
             i = nums.index(m)
 
             r += min(i, len(nums)-1-i)
             del nums[i]
 
         print ""Case #%d: %d"" % (_T+1, r)
",gcj/2014/3014486/kmod/5721094409420800/1/extracted/b.py,523,25,63,Python,3014486,1,5721094409420800,kmod,2014
156963,d_brute.py,"import collections
 import sys
 
 P = 1000000007
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         M, N = map(int, f.readline().split())
 
         strings = []
         for i in xrange(M):
             strings.append(f.readline().strip())
 
         worst = 0
         nworst = 0
         for k in xrange(N ** M):
             servers = [[] for i in xrange(N)]
             for i in xrange(M):
                 servers[k % N].append(strings[i])
                 k /= N
 
             if any(not strset for strset in servers):
                 continue
 
             total = 0
             # print
             # print servers
             for strset in servers:
                 prefixes = set([""""])
                 for s in strset:
                     for i in xrange(len(s)):
                         prefixes.add(s[:i+1])
                 # print strset, prefixes
                 total += len(prefixes)
 
             if total > worst:
                 worst = total
                 nworst = 0
             if total == worst:
                 nworst += 1
 
         print ""Case #%d: %d %d"" % (_T+1, worst, nworst % P)
",gcj/2014/3014486/kmod/5649687893770240/0/extracted/d_brute.py,1293,50,144,Python,3014486,0,5649687893770240,kmod,2014
156964,c.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         W, H, B = map(int, f.readline().split())
 
         buildings = []
         for i in xrange(B):
             buildings.append(map(int, f.readline().split()))
 
         grid = [[1] * H for i in xrange(W)]
 
         for x0, y0, x1, y1 in buildings:
             for x in xrange(x0, x1+1):
                 for y in xrange(y0, y1+1):
                     grid[x][y] = 0
 
         r = 0
         for sx in xrange(W):
             if grid[sx][0] == 0:
                 continue
 
             cx, cy = sx, 0
             dx, dy = 0, 1
 
             visited = []
             while True:
                 # print ""at"", cx, cy
 
                 visited.append((cx, cy))
 
                 if cy == H-1:
                     for x, y in visited:
                         grid[x][y] = 0
                     r += 1
                     # print ""made it!""
                     break
 
                 dx, dy = -dy, dx
                 failed = False
                 while True:
                     nx, ny = cx + dx, cy + dy
                     if nx >= 0 and nx < W and ny >= 0 and ny < H and grid[nx][ny]:
                         cx, cy = nx, ny
                         break
                     else:
                         if (cx, cy) == (sx, 0) and (dx, dy) == (0, -1):
                             failed = True
                             break
 
                         dx, dy = dy, -dx
 
                 if failed:
                     for x, y in visited:
                         grid[x][y] = 0
                     # print ""failed""
                     break
 
                 # print ""moved"", dx, dy
 
         print ""Case #%d: %d"" % (_T+1, r)
",gcj/2014/3014486/kmod/5158144455999488/0/extracted/c.py,1891,69,219,Python,3014486,0,5158144455999488,kmod,2014
156965,a.py,"import collections
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, X = map(int, f.readline().split())
         disks = map(int, f.readline().split())
         assert len(disks) == N
 
         disks.sort()
         disks = collections.deque(disks)
 
         r = 0
         while disks:
             x1 = disks.pop()
             if disks and x1 + disks[0] <= X:
                 disks.popleft()
             r += 1
         print ""Case #%d: %d"" % (_T+1, r)
",gcj/2014/3014486/kmod/5737429512224768/1/extracted/a.py,641,27,76,Python,3014486,1,5737429512224768,kmod,2014
106204,d.py,"import sys
 
 def solve(_T, X, R, C):
     # 1xX doesn't fit
     if X > R and X > C:
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
 
     # X/2 x X/2 'L' doesn't fit
     if X > 2 * min(R, C):
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
 
     # not even
     if (R * C) % X != 0:
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
 
     # trap hole
     if X >= 7:
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
 
     # always fits
     if X <= 2:
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         return
 
     assert min(R, C) > 1
 
     if X % min(R, C) == 0 and X > min(R, C):
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
 
     if min(R, C) == 2:
         assert X <= 4
 
         if X == 3:
             assert R * C >= 6
             print ""Case #%d: GABRIEL"" % (_T + 1,)
             return
 
         assert R * C >= 8, (X, R, C)
 
         if X == 4 and (R * C == 8):
             print ""Case #%d: RICHARD"" % (_T + 1,)
             return
 
         if X == 4 and (R * C >= 12):
             print ""Case #%d: GABRIEL"" % (_T + 1,)
             return
 
         assert 0, (X, R, C)
 
     if max(R, C) >= X + 2 and min(R, C) >= (X + 1)//2 + 2:
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         return
 
     if X == 3 and R >= 3 and C >= 3:
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         return
 
     if X == 4 and min(R, C) >= 3 and max(R, C) >= 4:
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         return
 
     # 'w' shape needs (1 + 9) on one side and (3 + 12) on the other
     if X == 5 and min(R, C) == 3 and max(R, C) < 10:
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
 
     if X == 5 and min(R, C) == 3 and max(R, C) >= 10:
         print ""Case #%d: RICHARD"" % (_T + 1,)
         return
     if X == 5 and min(R, C) >= 4 and max(R, C) >= 5:
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         return
 
     if X == 6 and min(R, C) >= 4 and max(R, C) >= 6:
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         return
 
     print >>sys.stderr, ""not sure:"", X, R, C
     assert 0, (X, R, C)
 
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     # for x in xrange(1, 7):
         # for r in xrange(1, 21):
             # for c in xrange(r, 21):
                 # solve(0, x, r, c)
 
     T = int(f.readline())
     for _T in xrange(T):
         X, R, C = map(int, f.readline().split())
         solve(_T, X, R, C)
 
",gcj/2015/6224486/kmod/5658571765186560/1/extracted/d.py,2579,104,460,Python,6224486,1,5658571765186560,kmod,2015
106205,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         X, R, C = map(int, f.readline().split())
 
         # 1xX doesn't fit
         if X > R and X > C:
             print ""Case #%d: RICHARD"" % (_T + 1,)
             continue
 
         # X/2 x X/2 'L' doesn't fit
         if X > 2 * min(R, C):
             print ""Case #%d: RICHARD"" % (_T + 1,)
             continue
 
         # not even
         if (R * C) % X != 0:
             print ""Case #%d: RICHARD"" % (_T + 1,)
             continue
 
         # trap hole
         if X >= 7:
             print ""Case #%d: RICHARD"" % (_T + 1,)
             continue
 
         # always fits
         if X <= 2:
             print ""Case #%d: GABRIEL"" % (_T + 1,)
             continue
 
         assert min(R, C) > 1
 
         if X % min(R, C) == 0 and X > min(R, C):
             print ""Case #%d: RICHARD"" % (_T + 1,)
             continue
 
         if min(R, C) == 2:
             assert X <= 4
 
             if X == 3:
                 assert R * C >= 6
                 print ""Case #%d: GABRIEL"" % (_T + 1,)
                 continue
 
             assert R * C >= 8, (X, R, C)
 
             if X == 4 and (R * C == 8):
                 print ""Case #%d: RICHARD"" % (_T + 1,)
                 continue
 
             if X == 4 and (R * C >= 12):
                 print ""Case #%d: GABRIEL"" % (_T + 1,)
                 continue
 
             assert 0, (X, R, C)
 
         print >>sys.stderr, ""not sure:"", X, R, C
         print ""Case #%d: GABRIEL"" % (_T + 1,)
         continue
 
",gcj/2015/6224486/kmod/5658571765186560/0/extracted/d.py,1704,69,254,Python,6224486,0,5658571765186560,kmod,2015
106206,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         D = int(f.readline())
         P = map(int, f.readline().split())
 
         pmax = max(P)
 
         best = pmax
         for i in xrange(1, pmax+1):
             num_special = 0
             for p in P:
                 num_special += (p + i - 1) // i - 1
             best = min(best, i + num_special)
 
         print ""Case #%d: %d"" % (_T + 1, best)
",gcj/2015/6224486/kmod/5686275109552128/1/extracted/b.py,581,25,81,Python,6224486,1,5686275109552128,kmod,2015
106208,c.py,"import collections
 import sys
 
 Q = collections.namedtuple(""Q"", ""sign val"")
 def qmul(q1, q2):
     sign = q1.sign * q2.sign
     if q1.val == '1':
         return Q(sign, q2.val)
     if q2.val == '1':
         return Q(sign, q1.val)
     if q1.val == q2.val:
         return Q(-sign, '1')
     if q1.val == 'i' and q2.val == 'j':
         return Q(sign, 'k')
     if q1.val == 'i' and q2.val == 'k':
         return Q(-sign, 'j')
     if q1.val == 'j' and q2.val == 'i':
         return Q(-sign, 'k')
     if q1.val == 'j' and q2.val == 'k':
         return Q(sign, 'i')
     if q1.val == 'k' and q2.val == 'i':
         return Q(sign, 'j')
     if q1.val == 'k' and q2.val == 'j':
         return Q(-sign, 'i')
     assert 0, (q1, q2)
 
 def qpow(q, n):
     r = Q(1, '1')
     t = q
     while n:
         if n & 1:
             r = qmul(r, t)
         t = qmul(t, t)
         n = n >> 1
     return r
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         L, X = map(int, f.readline().split())
         assert X > 0
         assert L > 0
         s = f.readline().strip()
         assert len(s) == L
 
         q = Q(1, '1')
         for c in s:
             q = qmul(q, Q(1, c))
         q = qpow(q, X)
         if q != qmul(Q(1, 'i'), qmul(Q(1, 'j'), Q(1, 'k'))):
             print ""Case #%d: NO"" % (_T + 1,)
             continue
 
         q = Q(1, '1')
         I = Q(1, 'i')
         for i in xrange(L * 4):
             q = qmul(q, Q(1, s[i % L]))
             if q == I:
                 break
         else:
             assert q == Q(1, '1')
             print ""Case #%d: NO"" % (_T + 1,)
             continue
 
         q = Q(1, '1')
         K = Q(1, 'k')
         for k in xrange(L * X - 1, L * (X - 4) - 1, -1):
             q = qmul(Q(1, s[k % L]), q)
             if q == K:
                 break
         else:
             assert q == Q(1, '1')
             print ""Case #%d: NO"" % (_T + 1,)
             continue
 
         if k > i + 1:
             print ""Case #%d: YES"" % (_T + 1,)
         else:
             print ""Case #%d: NO"" % (_T + 1,)
",gcj/2015/6224486/kmod/5670465267826688/1/extracted/c.py,2234,86,337,Python,6224486,1,5670465267826688,kmod,2015
106210,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         smax, s = f.readline().split()
         smax = int(smax)
         assert smax + 1 == len(s)
 
         invited = 0
         num_standing = 0
 
         for i, c in enumerate(s):
             while num_standing < i:
                 invited += 1
                 num_standing += 1
 
             num_standing += int(c)
 
         print ""Case #%d: %d"" % (_T + 1, invited)
",gcj/2015/6224486/kmod/5639104758808576/1/extracted/a.py,597,27,76,Python,6224486,1,5639104758808576,kmod,2015
126877,c.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         coords = []
         for i in xrange(N):
             coords.append(map(int, f.readline().split()))
 
         print ""Case #%d:"" % (_T + 1,)
 
         if N <= 3:
             for i in xrange(N):
                 print 0
             continue
 
         for i in xrange(N):
             best = 1000000098098
             pi = coords[i]
             for j in xrange(N):
                 if i == j:
                     continue
 
                 pj = coords[j]
                 assert pj != pi
                 l1, l2 = 0, 0
 
                 for k in xrange(N):
                     if k == i or k == j:
                         l1 += 1
                         l2 += 1
                         continue
                     pk = coords[k]
 
                     x1 = pj[0] - pi[0]
                     y1 = pj[1] - pi[1]
                     x2 = pk[0] - pi[0]
                     y2 = pk[1] - pi[1]
                     r = x1 * y2 - x2 * y1
                     if r <= 0:
                         l1 += 1
                     if r >= 0:
                         l2 += 1
 
                 # print i, j, l1, l2
                 best = min(best, min(N - l1, N - l2))
 
             print best
",gcj/2015/4224486/kmod/6377668744314880/0/extracted/c.py,1456,56,173,Python,4224486,0,6377668744314880,kmod,2015
126878,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         L = int(f.readline())
         m = map(int, f.readline().split())
         assert L == len(m)
 
         def f1(m):
             n = 0
             c = m[0]
             for x in m:
                 if x < c:
                     n += c - x
                 c = x
             return n
 
         def f2(m):
             eat_per_period = 0
             for i in xrange(len(m) - 1):
                 eat_per_period = max(eat_per_period, m[i] - m[i + 1])
             n = 0
             for x in m[:-1]:
                 n += min(x, eat_per_period)
             return n
 
         print ""Case #%d: %d %d"" % (_T + 1, f1(m), f2(m))
",gcj/2015/4224486/kmod/6404600001200128/1/extracted/a.py,856,35,110,Python,4224486,1,6404600001200128,kmod,2015
126880,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         B, N = map(int, f.readline().split())
         M = map(int, f.readline().split())
 
         def started_at_end_of(n):
             t = len(M)
             for m in M:
                 t += n // m
             return t
 
         if N <= B:
             print ""Case #%d: %d"" % (_T + 1, N)
             continue
 
         low = 0
         high = max(M) * N
         while True:
             assert started_at_end_of(low) < N
             assert started_at_end_of(high) >= N
 
             if high == low + 1:
                 break
 
             g = (low + high + 1) // 2
             if started_at_end_of(g) >= N:
                 high = g
             else:
                 low = g
 
         # print low, high
         needed = N - started_at_end_of(low)
         # print low, high
         # print N, needed
         for i, m in enumerate(M):
             if high % m == 0:
                 # print i, ""done""
                 needed -= 1
                 if needed == 0:
                     print ""Case #%d: %d"" % (_T + 1, i + 1)
                     break
         else:
             assert 0
",gcj/2015/4224486/kmod/5765824346324992/1/extracted/b.py,1328,53,168,Python,4224486,1,5765824346324992,kmod,2015
162007,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
 
         if N == 0:
             ans = ""INSOMNIA""
         else:
             s = set()
 
             t = N
             i = 1
             while True:
                 s.update(set(str(t)))
                 if len(s) == 10:
                     break
 
                 i += 1
                 t += N
 
             ans = t
 
         print ""Case #%d: %s"" % (_T + 1, ans)
",gcj/2016/6254486/kmod/5652388522229760/1/extracted/a.py,625,32,76,Python,6254486,1,5652388522229760,kmod,2016
162009,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         K, C, S = map(int, f.readline().split())
 
         if K > C * S:
             ans = ""IMPOSSIBLE""
         else:
             s = set()
 
             def index(l):
                 assert len(l) == C
                 t = 0
                 for i in xrange(len(l)):
                     if l[i] >= K:
                         l[i] = 0
                     t += l[i] * (K ** i)
                 return t + 1
 
             num_needed = (K + C - 1) / C
             assert num_needed <= S
             ans = """"
             for i in xrange(num_needed):
                 if ans:
                     ans += "" ""
                 ans += str(index(range(i * C, (i + 1) * C)))
 
         print ""Case #%d: %s"" % (_T + 1, ans)
",gcj/2016/6254486/kmod/5636311922769920/1/extracted/d.py,945,37,125,Python,6254486,1,5636311922769920,kmod,2016
162011,c.py,"import sys
 
 def isprime(n):
     j = 3
     while j * j <= n and j < 100:
         if n % j == 0:
             return j
         j += 2
     return None
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, J = map(int, f.readline().split())
 
         print ""Case #%d:"" % (_T + 1,)
 
         t = (2**(N-1)) - 1
         while J:
             t += 2
             s = bin(t)[2:]
             assert len(s) == N
             # print s
 
             divisors = map(isprime, [int(s, b) for b in xrange(2, 11)])
             # print divisors
             if all(divisors):
                 J -= 1
                 print s, "" "".join(map(str, divisors))
",gcj/2016/6254486/kmod/5738606668808192/1/extracted/c.py,816,36,113,Python,6254486,1,5738606668808192,kmod,2016
162012,c.py,"import sys
 
 def isprime(n):
     j = 3
     while j * j <= n:
         if n % j == 0:
             return j
         j += 2
     return None
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, J = map(int, f.readline().split())
 
         print ""Case #%d:"" % (_T + 1,)
 
         t = (2**(N-1)) - 1
         while J:
             t += 2
             s = bin(t)[2:]
             assert len(s) == N
             # print s
 
             divisors = map(isprime, [int(s, b) for b in xrange(2, 11)])
             # print divisors
             if all(divisors):
                 J -= 1
                 print s, "" "".join(map(str, divisors))
",gcj/2016/6254486/kmod/5738606668808192/0/extracted/c.py,804,36,109,Python,6254486,0,5738606668808192,kmod,2016
162013,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s = f.readline().strip()
 
         cur = '+'
         ans = 0
         for c in reversed(s):
             if c != cur:
                 ans += 1
             cur = c
 
         print ""Case #%d: %s"" % (_T + 1, ans)
",gcj/2016/6254486/kmod/5634697451274240/1/extracted/b.py,442,22,62,Python,6254486,1,5634697451274240,kmod,2016
203367,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s = f.readline().strip()
 
         d = {}
         for c in s:
             d[c] = d.get(c, 0) + 1
 
         r = [0] * 10
 
         def find(c, n, s):
             while d.get(c, 0):
                 r[n] += 1
                 for _c in s:
                     d[_c] -= 1
                     if d[_c] == 0:
                         del d[_c]
 
         find('Z', 0, ""ZERO"")
         find('X', 6, ""SIX"")
         find('W', 2, ""TWO"")
         find('U', 4, ""FOUR"")
         find('F', 5, ""FIVE"")
         find('V', 7, ""SEVEN"")
         find('O', 1, ""ONE"")
         find('N', 9, ""NINE"")
         find('G', 8, ""EIGHT"")
         find('R', 3, ""THREE"")
         assert not d
 
         s = """"
         for i in xrange(10):
             for j in xrange(r[i]):
                 s += str(i)
 
         print ""Case #%d: %s"" % (_T + 1, s)
",gcj/2016/11254486/kmod/5648941810974720/1/extracted/a.py,1056,46,130,Python,11254486,1,5648941810974720,kmod,2016
203369,c.py,"import sys
 
 SOURCE = object()
 SINK = object()
 
 def maxflow(edges):
     r = 0
     while True:
         q = [SOURCE]
         seen = set(q)
         prev = {}
 
         while q and SINK not in seen:
             next = q.pop()
             d = edges.setdefault(next, {})
             for n, e in d.iteritems():
                 if not e:
                     continue
                 if n in seen:
                     continue
                 seen.add(n)
                 q.append(n)
                 prev[n] = next
         if SINK not in seen:
             break
 
         # print ""found a flow!""
         r += 1
         cur = SINK
         while cur != SOURCE:
             next = prev[cur]
             # print ""%s -> %s"" % (next, cur)
             edges[next][cur] -= 1
             d = edges.setdefault(cur, {})
             d[next] = d.get(next, 0) + 1
             cur = next
     return r
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N = int(f.readline())
         L = []
         for i in xrange(N):
             L.append(f.readline().split())
 
         c1 = {}
         c2 = {}
         for w1, w2 in L:
             c1[w1] = c1.get(w1, 0) + 1
             c2[w2] = c2.get(w2, 0) + 1
 
         left1 = set(c1.keys())
         left2 = set(c2.keys())
 
         new_l = []
         for w1, w2 in L:
             if c1[w1] == 1 or c2[w2] == 1:
                 left1.discard(w1)
                 left2.discard(w2)
             else:
                 new_l.append((w1, w2))
 
         # {source -> {dest -> capacity}}
         edges = {}
 
         e = edges.setdefault(SOURCE, {})
         for w1 in left1:
             e[(w1, 1)] = 1
         for w2 in left2:
             edges[(w2, 2)] = {SINK: 1}
         for w1, w2 in new_l:
             edges.setdefault((w1, 1), {})[(w2, 2)] = 1
 
         # print edges
 
         doubles = maxflow(edges)
         singles = len(left1) + len(left2) - 2 * doubles
         maxfake = len(new_l) - singles - doubles
 
         print ""Case #%d: %s"" % (_T + 1, maxfake)
",gcj/2016/11254486/kmod/5686313294495744/1/extracted/c.py,2199,88,268,Python,11254486,1,5686313294495744,kmod,2016
203371,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         C, J = f.readline().split()
 
         def score((c, j)):
             assert len(c) == len(j)
             c = int(c)
             j = int(j)
             return (abs(c - j), c, j)
 
         def tryall(c, j, totry):
             results = []
             for nc, nj, ne in totry:
                 bc, bj = run(c[1:], j[1:], ne)
                 results.append((nc + bc, nj + bj))
             return min(results, key=score)
 
         def run(c, j, larger):
             if not c:
                 return """", """"
             fc = c[0]
             fj = j[0]
             if fc != '?' and fj != '?':
                 new_larger = larger
                 if larger == 'e':
                     nc = int(fc)
                     nj = int(fj)
                     if nc > nj:
                         new_larger = 'c'
                     elif nc < nj:
                         new_larger = 'j'
                 bc, bj = run(c[1:], j[1:], new_larger)
                 return (fc + bc, fj + bj)
             if fc == '?' and fj == '?':
                 if larger == 'c':
                     bc, bj = run(c[1:], j[1:], larger)
                     return ('0' + bc, '9' + bj)
                 if larger == 'j':
                     bc, bj = run(c[1:], j[1:], larger)
                     return ('9' + bc, '0' + bj)
 
                 return tryall(c, j, [('0', '0', 'e'), ('1', '0', 'c'), ('0', '1', 'j')])
                 # bce, bje = run(c[1:], j[1:], 'e')
                 # bcc, bjc = run(c[1:], j[1:], 'c')
                 # bcj, bjj = run(c[1:], j[1:], 'j')
 # 
                 # return min([('0' + bce, '0' + bje), ('1' + bcc, '0' + bjc), ('0' + bcj, '1' + bjj)], key=score)
 
             if fc == '?':
                 assert fj != '?'
                 if larger == 'e':
                     totry = [(fj, fj, 'e')]
                     if fj != '9':
                         totry.append((chr(ord(fj) + 1), fj, 'c'))
                     if fj != '0':
                         totry.append((chr(ord(fj) - 1), fj, 'j'))
                     return tryall(c, j, totry)
                 if larger == 'j':
                     bc, bj = run(c[1:], j[1:], larger)
                     return ('9' + bc, fj + bj)
                 if larger == 'c':
                     bc, bj = run(c[1:], j[1:], larger)
                     return ('0' + bc, fj + bj)
                 assert 0, (c, j, larger)
             if fj == '?':
                 assert fc != '?'
                 if larger == 'e':
                     totry = [(fc, fc, 'e')]
                     if fc != '9':
                         totry.append((fc, chr(ord(fc) + 1), 'j'))
                     if fc != '0':
                         totry.append((fc, chr(ord(fc) - 1), 'c'))
                     return tryall(c, j, totry)
                 if larger == 'c':
                     bc, bj = run(c[1:], j[1:], larger)
                     return (fc + bc, '9' + bj)
                 if larger == 'j':
                     bc, bj = run(c[1:], j[1:], larger)
                     return (fc + bc, '0' + bj)
                 assert 0, (c, j, larger)
             assert 0, (c, j, larger)
 
         # _run = run
         # def run(*args):
             # r = _run(*args)
             # print ""%s: %s"" % (args, r)
             # return r
 
         best_c, best_j = run(C, J, 'e')
         print ""Case #%d: %s %s"" % (_T + 1, best_c, best_j)
",gcj/2016/11254486/kmod/5695413893988352/1/extracted/b.py,3627,100,441,Python,11254486,1,5695413893988352,kmod,2016
13885,c.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         Hd, Ad, Hk, Ak, B, D = map(int, f.readline().split())
 
         # if Ad >= Hk:
             # ans = 1
         # elif Ak - D >= Hd:
             # ans = ""IMPOSSIBLE""
         # elif max(Ad * 2, Ad + B) >= Hk:
             # ans = 2
         # elif (Ak - D) * 2 >= Hd:
             # ans = ""IMPOSSIBLE""
         # else:
         if 1:
             def turns(nd, nb):
                 hd = Hd
                 ad = Ad
                 ak = Ak
                 hk = Hk
                 n = 0
 
                 for i in xrange(nd):
                     if hd <= ak - D:
                         hd = Hd - ak
                         n += 1
                         # print 'C',
                     ak = max(0, ak - D)
                     hd -= ak
                     if hd <= 0:
                         return float('inf')
                     n += 1
                     # print 'D',
 
                 for i in xrange(nb):
                     if hd <= ak:
                         hd = Hd - ak
                         n += 1
                         # print 'C',
 
                     ad += B
                     hd -= ak
                     if hd <= 0:
                         return float('inf')
                     n += 1
                     # print 'B',
 
                 while hk > 0:
                     if hd <= ak and hk > ad:
                         hd = Hd - ak
                         n += 1
                         # print 'C',
 
                     hk -= ad
                     if hk > 0:
                         hd -= ak
                         if hd <= 0:
                             return float('inf')
                     n += 1
                     # print 'A',
                 # print
 
                 return n
 
             best = float('inf')
             for i in xrange(101):
                 for j in xrange(101):
                     r = turns(i, j)
                     best = min(r, best)
                     # print ""d=%d, b=%d: %s"" % (i, j, r)
             import math
             if math.isinf(best):
                 ans = ""IMPOSSIBLE""
             else:
                 ans = best
 
         print ""Case #%d: %s"" % (_T + 1, ans)
",gcj/2017/5304486/kmod/5719039502450688/0/extracted/c.py,2418,86,284,Python,5304486,0,5719039502450688,kmod,2017
13886,b.py,"import sys
 
 def num_servings(amount, recipe):
     # maximize n st amount >= recipe * 0.9 * n
     # n <= amount * 10 / (recipe * 9)
     upper_bound = amount * 10 / (recipe * 9)
     # minimize n st amount <= recipe * 1.1 * n
     # n >= amount * 10 / (recipe * 11)
     lower_bound = (amount * 10 + recipe * 11 - 1) / (recipe * 11)
     return lower_bound, upper_bound
 
 assert num_servings(100, 1) == (91, 111), num_servings(100, 1)
 assert num_servings(90, 1) == (82, 100), num_servings(90, 1)
 assert num_servings(110, 1) == (100, 122), num_servings(110, 1)
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, P = map(int, f.readline().split())
         recipe = map(int, f.readline().split())
 
         packages = [] # [ingredient][package_idx]
         for i in xrange(N):
             l = []
             for x in map(int, f.readline().split()):
                 l.append(num_servings(x, recipe[i]))
             l.sort()
             packages.append(l)
 
         made = 0
         while all(packages):
             highest_min = -1e9
             for l in packages:
                 highest_min = max(highest_min, l[0][0])
 
             changed = False
             for l in packages:
                 if l[0][1] < highest_min:
                     l.pop(0)
                     changed = True
             if changed:
                 continue
 
             # print packages
             for l in packages:
                 assert l[0][0] <= highest_min <= l[0][1]
                 l.pop(0)
             made += 1
 
         print ""Case #%d: %d"" % (_T + 1, made)
",gcj/2017/5304486/kmod/5697460110360576/1/extracted/b.py,1747,57,216,Python,5304486,1,5697460110360576,kmod,2017
13888,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         R, C = map(int, f.readline().split())
 
         grid = []
         for i in xrange(R):
             grid.append(list(f.readline().strip()))
 
 
         for l in grid:
             for i in xrange(1, C):
                 if l[i] == '?' and l[i - 1] != '?':
                     l[i] = l[i - 1]
             for i in xrange(C - 2, -1, -1):
                 if l[i] == '?' and l[i + 1] != '?':
                     l[i] = l[i + 1]
 
         for r in xrange(1, R):
             for c in xrange(C):
                 if grid[r][c] == '?' and grid[r - 1][c] != '?':
                     grid[r][c] = grid[r - 1][c]
         for r in xrange(R - 2, -1, -1):
             for c in xrange(C):
                 if grid[r][c] == '?' and grid[r + 1][c] != '?':
                     grid[r][c] = grid[r + 1][c]
 
         for r in xrange(R):
             for c in xrange(C):
                 assert grid[r][c] != '?'
 
         print ""Case #%d:"" % (_T + 1,)
         for g in grid:
             print ''.join(g)
",gcj/2017/5304486/kmod/5760761888505856/1/extracted/a.py,1227,43,166,Python,5304486,1,5760761888505856,kmod,2017
13889,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         R, C = map(int, f.readline().split())
 
         grid = []
         for i in xrange(R):
             grid.append(list(f.readline().strip()))
 
 
         for l in grid:
             for i in xrange(1, C):
                 if l[i] == '?' and l[i - 1] != '?':
                     l[i] = l[i - 1]
             for i in xrange(C - 2, -1, -1):
                 if l[i] == '?' and l[i + 1] != '?':
                     l[i] = l[i + 1]
 
         for r in xrange(1, R):
             for c in xrange(C):
                 if grid[r][c] == '?' and grid[r - 1][c] != '?':
                     grid[r][c] = grid[r - 1][c]
         for r in xrange(R - 2, -1, -1):
             for c in xrange(C):
                 if grid[r][c] == '?' and grid[r + 1][c] != '?':
                     grid[r][c] = grid[r + 1][c]
 
         print ""Case #%d:"" % (_T + 1,)
         for g in grid:
             print ''.join(g)
",gcj/2017/5304486/kmod/5760761888505856/0/extracted/a.py,1121,39,154,Python,5304486,0,5760761888505856,kmod,2017
15898,c.py,"import collections
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s = f.readline()
         if not s.strip():
             s = f.readline()
         C = int(s)
 
         trips = []
         tripsto = {}
         for i in xrange(2 * C):
             e, l, d = map(int, f.readline().split())
             trips.append((e - 1, l, d))
             tripsto.setdefault(e - 1, []).append(i)
         # print trips
 
         def wait(ti1, ti2):
             e1 = trips[ti2][1] - (trips[ti1][1] + trips[ti1][2])
             return e1 % 24
 
         thentrip = {}
         switch_penalty = {}
         total_wait = 0
         for i in xrange(C):
             # if i == 0:
                 # t1, t2 = i * 2, i * 2 + 1
                 # x1, x2 = tripsto[i]
                 # wait1 = wait(x1, t1) + trips[t2][1]
                 # wait2 = wait(x1, t2) + trips[t1][1]
             # else:
             t1, t2 = i * 2, i * 2 + 1
             x1, x2 = tripsto[i]
             wait1 = wait(x1, t1) + wait(x2, t2)
             wait2 = wait(x1, t2) + wait(x2, t1)
 
             if wait1 < wait2:
                 thentrip[x1] = t1
                 thentrip[x2] = t2
                 total_wait += wait1
             else:
                 thentrip[x1] = t2
                 thentrip[x2] = t1
                 total_wait += wait2
 
             # print i, wait1, wait2
             switch_penalty[i] = abs(wait1 - wait2)
             assert switch_penalty[i] in (0, 24)
 
         found = [False] * (2 * C)
         ncycles = 0
         cycle_idx = {}
         for i in xrange(2 * C):
             if found[i]:
                 continue
 
             ncycles += 1
             cur = i
             while not found[cur]:
                 found[cur] = True
                 cur = thentrip[cur]
                 cycle_idx[cur] = ncycles
 
         total_duration = 0
         for i in xrange(2 * C):
             total_duration += trips[i][2]
 
         while ncycles > 1:
             found = False
             for i in xrange(C):
                 c1 = cycle_idx[2 * i]
                 c2 = cycle_idx[2 * i + 1]
                 if c1 != c2 and switch_penalty[i] == 0:
                     found = True
                     ncycles -= 1
                     for i in xrange(2 * C):
                         if cycle_idx[i] == c2:
                             cycle_idx[i] = c1
             if not found:
                 break
 
         e1 = trips[tripsto[0][0]][1] + trips[tripsto[0][0]][2]
         e2 = trips[tripsto[0][1]][1] + trips[tripsto[0][1]][2]
         total_wait -= (24 - min(e1, e2)) % 24
         # print ncycles, total_duration, total_wait
         # total_wait -= min(trips_to[0][0]
 
         print ""Case #%d: %s"" % (_T + 1, total_duration + total_wait + 24 * (ncycles - 1))
",gcj/2017/8304486/kmod/5965456674390016/1/extracted/c.py,2963,97,356,Python,8304486,1,5965456674390016,kmod,2017
15899,c_brute.py,"import collections
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s = f.readline()
         if not s.strip():
             s = f.readline()
         C = int(s)
 
         # trips = [[] for i in xrange(C)]
         # for i in xrange(2 * C):
             # e, l, d = map(int, f.readline().split())
             # trips[i / 2].append((e - 1, l, d))
         trips = []
         for i in xrange(2 * C):
             e, l, d = map(int, f.readline().split())
             trips.append((e - 1, l, d))
         # print trips
 
         taken = [False] * (2 * C)
         def findbest(cidx, time):
             if cidx == 0 and all(taken):
                 return time
 
             # print cidx, time, taken
             best = 1e99
             for tidx in (cidx * 2, cidx * 2 + 1):
                 if taken[tidx]:
                     continue
                 taken[tidx] = True
 
                 newtime = time
                 while newtime % 24 != trips[tidx][1]:
                     newtime += 1
                 newtime += trips[tidx][2]
                 thisbest = findbest(trips[tidx][0], newtime)
                 best = min(thisbest, best)
 
                 taken[tidx] = False
             return best
 
         r = findbest(0, 0)
         print ""Case #%d: %s"" % (_T + 1, r)
",gcj/2017/8304486/kmod/5965456674390016/0/extracted/c_brute.py,1467,52,181,Python,8304486,0,5965456674390016,kmod,2017
15900,a.py,"import sys
 
 def _fact(n):
     if n <= 2:
         return n
     return n * _fact(n - 1)
 fact = map(_fact, range(20))
 fact[0] = 1
 
 def choose(n, r):
     return fact[n] / fact[r] / fact[n - r]
 
 def choices(counts):
     r = []
 
     for i in xrange(len(counts)):
         if counts[i] == 0:
             continue
         counts[i] -= 1
 
         t = choices(counts)
         for x in t:
             x.append(i)
             r.append(x)
         counts[i] += 1
     if not r:
         return [[]]
     return r
 
 def come_from(l):
     total = 0
     nexttotal = 0
     for i, c in enumerate(l):
         total += c
         nexttotal += (i + 1) * c
 
     # # print l, counts, total, nexttotal
 
     if total > len(l):
         # print l, ""->"", 1, ""(too big)""
         return 1
 
     if nexttotal > len(l):
         r = 1
         left = len(l)
         for i, c in enumerate(l):
             # # print l, r, left, x
             r *= choose(left, c)
             left -= c
         r += 1
         # print l, ""->"", r, ""(children too big)""
         return r
 
     counts = {0: len(l)}
     for i, c in enumerate(l):
         counts[i + 1] = c
         counts[0] -= c
 
     next = []
     for i in xrange(len(l) + 1):
         next.append(counts[i])
     # print l, choices(next)
 
     r = 1
     for l2 in choices(next):
         if l2 == l:
             continue
         # print l2, ""<-"", l
         r += come_from(l2)
     # print l, ""->"", r
     return r
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         l = f.readline().strip()
         l = [int(c) for c in l]
         r = come_from(l)
 
         print ""Case #%d: %d"" % (_T + 1, r)
",gcj/2017/8304486/kmod/5672542102618112/1/extracted/a.py,1823,87,263,Python,8304486,1,5672542102618112,kmod,2017
15902,b.py,"import collections
 import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s = f.readline()
         if not s.strip():
             s = f.readline()
         F, P = map(int, s.split())
 
         edges = []
         for i in xrange(P):
             a, b = map(int, f.readline().split())
             edges.append((a, b))
 
         def find_cycle(ei):
             start, target = edges[ei]
 
             got_to = {start: [(-1, ei)]}
             for i in xrange(P):
                 for i in xrange(P):
                     if i == ei:
                         continue
                     a, b = edges[i]
                     if a in got_to and b not in got_to:
                         got_to[b] = got_to[a] + [(1, i)]
                     if b in got_to and a not in got_to:
                         got_to[a] = got_to[b] + [(-1, i)]
 
                 if target in got_to:
                     return got_to[target]
             else:
                 raise EOFError()
 
             '''
             checked = set([start])
             q = collections.deque([start])
             while q:
                 next = q.popleft()
                 for i in xrange(P):
                     if i == ei:
                         continue
 
                     if next not in edges[i]:
                         continue
 
                     if next == edges[i][0]:
                         dest = edges[i][1]
                     else:
                         dest = edges[i][0]
             '''
 
         found_cycle = [False] * P
         cycles = []
         cycles_per_edge = {}
         try:
             for i in xrange(P):
                 if found_cycle[i]:
                     continue
                 c = find_cycle(i)
                 for dir, ei in c:
                     found_cycle[ei] = True
                     cycles_per_edge.setdefault(ei, []).append(len(cycles))
                 cycles.append(c)
         except EOFError:
             print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
             continue
 
         # print cycles
 
         news = [0] * P
         while True:
             works = True
             for i in xrange(P):
                 if news[i]:
                     continue
                 works = False
 
                 c = cycles[cycles_per_edge[i][0]]
                 for dir, ei in c:
                     news[ei] -= dir
                     assert abs(news[ei]) <= F * F
                 # print news
             if works:
                 break
 
         print ""Case #%d: %s"" % (_T + 1, ' '.join(map(str, news)))
",gcj/2017/8304486/kmod/6450220019744768/1/extracted/b.py,2740,95,267,Python,8304486,1,6450220019744768,kmod,2017
15904,d.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         R, C, N, D = map(int, f.readline().split())
 
         grid = [[0] * C for i in xrange(R)]
         candidates = []
         for i in xrange(N):
             r, c, b = map(int, f.readline().split())
             grid[r - 1][c - 1] = b
             candidates.append((r - 1, c - 1))
 
         possible = True
         while True:
             lowest = 1e99
             lr = None
             lc = None
             for r, c in candidates:
                 if grid[r][c] != 0 and grid[r][c] < lowest:
                     lowest = grid[r][c]
                     lr = r
                     lc = c
             if lr is None:
                 break
 
             for dr, dc in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                 nr = dr + lr
                 nc = dc + lc
                 if nr < 0 or nr >= R or nc < 0 or nc >= C:
                     continue
                 if grid[nr][nc]:
                     if grid[nr][nc] > lowest + D:
                         possible = False
                         break
                     continue
                 grid[nr][nc] = lowest + D
                 candidates.append((nr, nc))
 
             if not possible:
                 break
             candidates.remove((lr, lc))
 
         if not possible:
             print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
         else:
             total = sum(map(sum, grid))
             print ""Case #%d: %d"" % (_T + 1, total % 1000000007)
",gcj/2017/8304486/kmod/5683362198978560/0/extracted/d.py,1666,56,205,Python,8304486,0,5683362198978560,kmod,2017
24603,a.py,"import sys
 import numpy as np
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, P = map(int, f.readline().split())
         G = map(int, f.readline().split())
 
         dp = np.zeros((102, 102, 102), dtype=np.int32)
         counts = np.zeros(4, dtype=np.int32)
         for g in G:
             counts[g % P] += 1
         dp[tuple(counts[1:])] = counts[0]
         # print tuple(counts[1:]), counts[0]
 
         newcounts = np.zeros(4, dtype=np.int32)
         for newcounts[1] in xrange(counts[1], -1, -1):
             for newcounts[2] in xrange(counts[2], -1, -1):
                 for newcounts[3] in xrange(counts[3], -1, -1):
                     if (newcounts[1:] == counts[1:]).all():
                         continue
 
                     mod = ((counts - newcounts) * np.arange(4)).sum()
                     idx = tuple(newcounts[1:])
 
                     if (mod - 1) % P == 0:
                         dp[idx] = max(dp[idx], dp[newcounts[1] + 1, newcounts[2], newcounts[3]] + 1)
                     else:
                         dp[idx] = max(dp[idx], dp[newcounts[1] + 1, newcounts[2], newcounts[3]])
                     if (mod - 2) % P == 0:
                         dp[idx] = max(dp[idx], dp[newcounts[1], newcounts[2] + 1, newcounts[3]] + 1)
                     else:
                         dp[idx] = max(dp[idx], dp[newcounts[1], newcounts[2] + 1, newcounts[3]])
                     if (mod - 3) % P == 0:
                         dp[idx] = max(dp[idx], dp[newcounts[1], newcounts[2], newcounts[3] + 1] + 1)
                     else:
                         dp[idx] = max(dp[idx], dp[newcounts[1], newcounts[2], newcounts[3] + 1])
 
                     # print newcounts, mod, dp[idx]
 
         print ""Case #%d: %d"" % (_T + 1, dp[0,0,0])
",gcj/2017/5314486/kmod/5700919488413696/1/extracted/a.py,1946,49,201,Python,5314486,1,5700919488413696,kmod,2017
24605,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, C, M = map(int, f.readline().split())
 
         by_seat = [0] * N
         people = [[] for i in xrange(C)]
         tickets = []
         for i in xrange(M):
             p, b = map(int, f.readline().split())
             p -= 1
             b -= 1
             by_seat[p] += 1
             people[b].append(p)
 
         def can_do(rides):
             avail = 0
             promotions = 0
             for i in xrange(N):
                 needed = by_seat[i] - rides
                 if needed > 0:
                     if needed > avail:
                         return -1
                     avail -= needed
                     promotions += needed
                 else:
                     avail -= needed
             return promotions
 
         ans = 0
         for l in people:
             ans = max(ans, len(l))
 
         while True:
             r = can_do(ans)
             # print ans, r
             if r == -1:
                 ans += 1
                 continue
             break
 
         print ""Case #%d: %d %d"" % (_T + 1, ans, r)
",gcj/2017/5314486/kmod/5687148430753792/1/extracted/b.py,1290,51,149,Python,5314486,1,5687148430753792,kmod,2017
24607,c.py,"import sys
 import collections
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         R, C = map(int, f.readline().split())
 
         turrets = []
         soldiers = []
 
         themap = []
         for i in xrange(R):
             themap.append(f.readline().strip())
             assert len(themap[-1]) == C
 
         def shoot(r, c, dr, dc):
             r += dr
             c += dc
 
             l = []
             while r >= 0 and c >= 0 and r < R and c < C:
                 if themap[r][c] == '#':
                     return l
                 if themap[r][c] in '-|':
                     return None
 
                 if themap[r][c] == '.':
                     l.append((r, c))
                     r += dr
                     c += dc
                     continue
 
                 assert 0, themap[r][c]
             return l
 
         possible = True
         fixed = {}
         options = {}
         beams = []
         for r in xrange(R):
             for c in xrange(C):
                 if themap[r][c] in ""-|"":
                     beams.append((r, c))
                     v1 = shoot(r, c, 1, 0)
                     v2 = shoot(r, c, -1, 0)
                     h1 = shoot(r, c, 0, 1)
                     h2 = shoot(r, c, 0, -1)
 
                     h_works = not (h1 is None or h2 is None)
                     v_works = not (v1 is None or v2 is None)
 
                     # print r, c, h1, h2, v1, v2
                     if h_works:
                         for p in h1 + h2:
                             options.setdefault(p, []).append(((r, c), 'h'))
                     if v_works:
                         for p in v1 + v2:
                             options.setdefault(p, []).append(((r, c), 'v'))
 
                     if not (h_works or v_works):
                         possible = False
                     if not h_works:
                         fixed[(r, c)] = 'v'
                     if not v_works:
                         fixed[(r, c)] = 'h'
                     # if not h_works:
                         # fixed.append((r, c), 'v')
                         # fixed_hits.update(v1)
                         # fixed_hits.update(v2)
                     # if not v_works:
                         # fixed.append((r, c), 'h')
                         # fixed_hits.update(h1)
                         # fixed_hits.update(h2)
         # print options
 
         ifnot = {}
         for r in xrange(R):
             for c in xrange(C):
                 if themap[r][c] == '.':
                     o = options.get((r, c), [])
                     if not o:
                         possible = False
                         break
                     if len(o) == 1:
                         p, d = o[0]
                         if p not in fixed:
                             fixed[p] = d
                         elif fixed[p] != d:
                             possible = False
                     else:
                         assert len(o) == 2
                         x1, x2 = o
                         ifnot.setdefault(x1, set()).add(x2)
                         ifnot.setdefault(x2, set()).add(x1)
 
         # print fixed, ifnot
         q = list(fixed)
 
         def traverse(q):
             while q:
                 p = q.pop()
                 d = fixed[p]
 
                 od = {'h': 'v', 'v': 'h'}[d]
                 for then in ifnot.get((p, od), []):
                     if then[0] not in fixed:
                         fixed[then[0]] = then[1]
                         q.append(then[0])
                     elif fixed[then[0]] != then[1]:
                         return False
             return True
 
         possible = possible and traverse(list(fixed))
 
         for p in beams:
             if p in fixed:
                 continue
 
             orig_fixed = dict(fixed)
             fixed[p] = 'h'
             q = [p]
 
             this_possible = traverse(q)
             if not this_possible:
                 fixed = orig_fixed
                 fixed[p] = 'v'
                 q = [p]
                 possible = possible and traverse(q)
 
         assert len(fixed) == len(beams)
 
         if not possible:
             print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
         else:
             print ""Case #%d: POSSIBLE"" % (_T + 1,)
 
             for r in xrange(R):
                 l = []
                 for c in xrange(C):
                     if themap[r][c] in ""-|"":
                         l.append({'h': '-', 'v': '|'}[fixed[(r, c)]])
                     else:
                         l.append(themap[r][c])
                 print ''.join(l)
",gcj/2017/5314486/kmod/5715646612504576/0/extracted/c.py,4816,152,466,Python,5314486,0,5715646612504576,kmod,2017
24608,d.py,"import sys
 import collections
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         C, R, M = map(int, f.readline().split())
 
         turrets = []
         soldiers = []
 
         themap = []
         for i in xrange(R):
             themap.append(f.readline().strip())
             assert len(themap[-1]) == C
 
             for j in xrange(C):
                 if themap[-1][j] == 'S':
                     soldiers.append((i, j))
                 if themap[-1][j] == 'T':
                     turrets.append((i, j))
 
         visible_from = {} # pos => list of turrets
         def scan(ti, (r, c), dr, dc):
             while True:
                 if r < 0 or c < 0 or c >= C or r >= R or themap[r][c] == '#':
                     return
                 visible_from.setdefault((r, c), set()).add(ti)
                 r += dr
                 c += dc
 
         for ti in xrange(len(turrets)):
             scan(ti, turrets[ti], 1, 0)
             scan(ti, turrets[ti], -1, 0)
             scan(ti, turrets[ti], 0, 1)
             scan(ti, turrets[ti], 0, -1)
 
         # print visible_from
 
         can_kill = {}
         for si in xrange(len(soldiers)):
             for talive in xrange(2 ** len(turrets)):
                 q = collections.deque([(soldiers[si], 0)])
                 got_to = set([soldiers[si]])
                 killable = set()
 
                 while q:
                     pos, dist = q.popleft()
 
                     can_move = dist < M
                     for ti in visible_from.get(pos, ()):
                         if talive & (1 << ti):
                             killable.add(ti)
                             can_move = False
 
                     if can_move:
                         for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                             r = pos[0] + dr
                             c = pos[1] + dc
                             if r < 0 or c < 0 or r >= R or c >= C or themap[r][c] == '#' or (r, c) in got_to:
                                 continue
                             got_to.add((r, c))
                             q.append(((r, c), dist + 1))
                 can_kill[(si, talive)] = list(killable)
                 # print si, talive, killable
 
         tpow = 1 << len(turrets)
         spow = 1 << len(soldiers)
         reachable = [[None] * tpow for i in xrange(spow)]
         reachable[0][tpow - 1] = ""start""
 
         def nalive(n):
             t = 0
             while n:
                 if n & 1:
                     t += 1
                 n >>= 1
             return t
 
         best = 0, tpow - 1
         bestkill = 0
         for sused in xrange(spow):
             for talive in xrange(tpow - 1, -1, -1):
                 if not reachable[sused][talive]:
                     continue
 
                 for si in xrange(len(soldiers)):
                     if sused & (1 << si):
                         continue
                     new_sused = sused | (1 << si)
                     for killable in can_kill.get((si, talive)):
                         new_talive = talive & ~(1 << killable)
                         reachable[new_sused][new_talive] = (si, killable)
 
                         killed = len(turrets) - nalive(talive) + 1
                         if killed > bestkill:
                             bestkill = killed
                             best = new_sused, new_talive
 
         print ""Case #%d: %d"" % (_T + 1, bestkill)
 
         # print bestkill, best
         r = []
         while True:
             last = reachable[best[0]][best[1]]
             # print last
             if last == ""start"":
                 break
             r.append(last)
 
             best = list(best)
             best[0] &= ~(1 << last[0])
             best[1] |= (1 << last[1])
             # print best
 
         r.reverse()
         for last in r:
             print last[0] + 1, last[1] + 1
",gcj/2017/5314486/kmod/5756983256809472/0/extracted/d.py,4082,125,435,Python,5314486,0,5756983256809472,kmod,2017
139845,b.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s = list(f.readline().strip())
 
         first = 0
         for i in xrange(len(s) - 1):
             if s[i] < s[i+1]:
                 first = i+1
             if s[i] > s[i+1]:
                 s[first] = chr(ord(s[first]) - 1)
                 for j in xrange(first + 1, len(s)):
                     s[j] = '9'
                 break
 
         print ""Case #%d: %s"" % (_T + 1, int(''.join(s)))
",gcj/2017/3264486/kmod/5633382285312000/1/extracted/b.py,627,25,78,Python,3264486,1,5633382285312000,kmod,2017
139847,d.py,"import sys
 
 def solve(startwith, constraints, N):
     available = set([(i, j) for i in xrange(N) for j in xrange(N)])
     c_left = {}
     constraints_by = {}
     for c in constraints:
         c_left[c] = len(c)
         for el in c:
             constraints_by.setdefault(el, []).append(c)
 
     def use(p):
         assert p in available
         # print ""using"", p
         for c in constraints_by[p]:
             # print ""is in constraint"", c
             for el in c:
                 if el in available:
                     available.remove(el)
                     for c2 in constraints_by[el]:
                         c_left[c2] -= 1
 
     # print c_left, available
     for p in startwith:
         use(p)
         # print c_left, available
 
     rtn = []
     while available:
         best = None
         best_score = 100000
         for c, count in c_left.iteritems():
             if count > 0 and count < best_score:
                 best_score = count
                 best = c
         assert best
 
         for el in best:
             if el in available:
                 use(el)
                 rtn.append(el)
                 break
         else:
             assert 0
 
         """"""
         for c, count in c_left.iteritems():
             if count == 1:
                 for el in c:
                     if el in available:
                         use(el)
                         rtn.append(el)
                         break
                 else:
                     assert 0
                 break
         else:
             el = list(available)[0]
             use(el)
             rtn.append(el)
         """"""
 
     # print rtn
     return rtn
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, M = map(int, f.readline().split())
 
         grid = [['.'] * N for i in xrange(N)]
         pluses = []
         xs = []
         points = 0
         for i in xrange(M):
             m, r, c = f.readline().split()
             r = int(r) - 1
             c = int(c) - 1
             grid[r][c] = m
             if m in ""xo"":
                 xs.append((r, c))
             if m in ""+o"":
                 pluses.append((r, c))
             if m == 'o':
                 points += 2
             else:
                 points += 1
 
         # for g in grid:
             # print g
 
         rows_cols = []
         rows_cols += [tuple([(i, j) for i in xrange(N)]) for j in xrange(N)]
         rows_cols += [tuple([(j, i) for i in xrange(N)]) for j in xrange(N)]
         use_xs = set(solve(xs, rows_cols, N))
 
         diags = []
         diags += [tuple([(i, k - i) for i in xrange(k+1)]) for k in xrange(N)]
         diags += [tuple([(N - i - 1, N - k + i -1) for i in xrange(k+1)]) for k in xrange(N-1)]
         diags += [tuple([(N - i - 1, k - i) for i in xrange(k+1)]) for k in xrange(N)]
         diags += [tuple([(i, N - k + i -1) for i in xrange(k+1)]) for k in xrange(N-1)]
         use_ps = set(solve(pluses, diags, N))
 
         use_os = use_xs.intersection(use_ps)
         use_xs = use_xs - use_os
         use_ps = use_ps - use_os
 
         # print use_os, use_xs, use_ps
 
         print ""Case #%d: %d %d"" % (_T + 1, points + 2 * len(use_os) + len(use_xs) + len(use_ps), len(use_os) + len(use_xs) + len(use_ps))
         for i, j in use_os:
             print ""o %d %d"" % (i + 1, j + 1)
         for i, j in use_ps:
             assert grid[i][j] in "".x""
             if grid[i][j] == 'x':
                 print ""o %d %d"" % (i + 1, j + 1)
             else:
                 print ""+ %d %d"" % (i + 1, j + 1)
         for i, j in use_xs:
             assert grid[i][j] in "".+""
             if grid[i][j] == '+':
                 print ""o %d %d"" % (i + 1, j + 1)
             else:
                 print ""x %d %d"" % (i + 1, j + 1)
",gcj/2017/3264486/kmod/5719854539603968/1/extracted/d.py,3962,131,512,Python,3264486,1,5719854539603968,kmod,2017
139849,a.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         s, K = f.readline().split()
         K = int(K)
         l = [c == '+' for c in s]
 
         flips = 0
         for i in xrange(len(s) - K + 1):
             if not l[i]:
                 flips += 1
                 for j in xrange(i, i + K):
                     l[j] = not l[j]
 
         if not all(l):
             ans = ""IMPOSSIBLE""
         else:
             ans = flips
 
 
         print ""Case #%d: %s"" % (_T + 1, ans)
",gcj/2017/3264486/kmod/5736519012712448/1/extracted/a.py,656,30,93,Python,3264486,1,5736519012712448,kmod,2017
139851,c.py,"import sys
 
 if __name__ == ""__main__"":
     f = sys.stdin
     if len(sys.argv) >= 2:
         fn = sys.argv[1]
         if fn != '-':
             f = open(fn)
 
     T = int(f.readline())
     for _T in xrange(T):
         N, K = map(int, f.readline().split())
 
         amounts = {N: 1}
         K -= 1
 
         while K:
             next = max(amounts.keys())
             num = amounts[next]
             if num > K:
                 break
             del amounts[next]
             # print ""%d -> %d/%d"" % (next, (next-1)/2, next / 2)
             amounts[(next - 1) / 2] = amounts.get((next - 1) / 2, 0) + num
             amounts[next / 2] = amounts.get(next / 2, 0) + num
             K -= num
 
         next = max(amounts.keys())
 
         print ""Case #%d: %d %d"" % (_T + 1, next / 2, (next - 1) / 2)
",gcj/2017/3264486/kmod/5654742835396608/2/extracted/c.py,819,31,115,Python,3264486,2,5654742835396608,kmod,2017
9524,000000000004a3b2.PYTHON,"import sys

best = 100000
def findbest(grid, sofar):
    global best
    if sofar > best:
        return 10000

    rows = [{} for i in xrange(N)]
    cols = [{} for i in xrange(N)]
    for i in xrange(N):
        for j in xrange(N):
            c = grid[i][j]
            rows[i][c] = rows[i].get(c, 0) + 1
            cols[j][c] = cols[j].get(c, 0) + 1

    rowchanges = 0
    colchanges = 0
    for i in xrange(N):
        rowchanges += N - len(rows[i])
        colchanges += N - len(cols[i])

    if sofar + max(rowchanges, colchanges) >= best:
        return best + 1

    # print rowchanges, colchanges, sofar, best, grid

    bad = False
    r = 1000
    for i in xrange(N):
        if len(rows[i]) < N:
            bad = True
            idxs = range(N)
            idxs.sort(key=lambda j: len(cols[j]))
            for j in idxs:
                t = grid[i][j]
                if rows[i][t] <= 1:
                    continue
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    # print i, grid[i], 
                    grid[i][j] = k
                    # print grid[i], grid
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    for j in xrange(N):
        if len(cols[j]) < N:
            bad = True
            idxs = range(N)
            idxs.sort(key=lambda i: len(rows[i]))
            for i in idxs:
                t = grid[i][j]
                if cols[j][t] <= 1:
                    continue
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    grid[i][j] = k
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    if not bad:
        best = min(sofar, best)
        # print best
        return sofar
    return r

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N, = map(int, f.readline().split())

        grid = []
        for i in xrange(N):
            grid.append(map(int, f.readline().split()))

        best = N * N
        ans = findbest(grid, 0)

        print ""Case #%d: %s"" % (_T + 1, ans)
",,2267,83,276,Python,7706,000000000004a3b2,0000000000045875,kmod,2018
9525,000000000004a13c.PYTHON,"import sys

best = 100000
def findbest(grid, sofar):
    global best
    if sofar > best:
        return 10000

    rows = [{} for i in xrange(N)]
    cols = [{} for i in xrange(N)]
    for i in xrange(N):
        for j in xrange(N):
            c = grid[i][j]
            rows[i][c] = rows[i].get(c, 0) + 1
            cols[j][c] = cols[j].get(c, 0) + 1

    rowchanges = 0
    colchanges = 0
    for i in xrange(N):
        rowchanges += N - len(rows[i])
        colchanges += N - len(cols[i])

    if sofar + max(rowchanges, colchanges) >= best:
        return best + 1

    # print rowchanges, colchanges, sofar, best, grid

    bad = False
    r = 1000
    for i in xrange(N):
        if len(rows[i]) < N:
            bad = True
            for j in xrange(N):
                j = (i + j) % N
                t = grid[i][j]
                if rows[i][t] <= 1:
                    continue
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    # print i, grid[i], 
                    grid[i][j] = k
                    # print grid[i], grid
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    for j in xrange(N):
        if len(cols[j]) < N:
            bad = True
            for i in xrange(N):
                i = (i + j) % N
                t = grid[i][j]
                if cols[j][t] <= 1:
                    continue
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    grid[i][j] = k
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    if not bad:
        best = min(sofar, best)
        # print best
        return sofar
    return r

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N, = map(int, f.readline().split())

        grid = []
        for i in xrange(N):
            grid.append(map(int, f.readline().split()))

        best = N * N
        ans = findbest(grid, 0)

        print ""Case #%d: %s"" % (_T + 1, ans)
",,2185,81,278,Python,7706,000000000004a13c,0000000000045875,kmod,2018
9526,0000000000049d40.PYTHON,"import sys

best = 100000
def findbest(grid, sofar):
    global best
    if sofar > best:
        return 10000

    rows = [set() for i in xrange(N)]
    cols = [set() for i in xrange(N)]
    for i in xrange(N):
        for j in xrange(N):
            rows[i].add(grid[i][j])
            cols[j].add(grid[i][j])

    bad = False
    r = 1000
    for i in xrange(N):
        if len(rows[i]) < N:
            bad = True
            for j in xrange(N):
                t = grid[i][j]
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    grid[i][j] = k
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    for j in xrange(N):
        if len(cols[j]) < N:
            bad = True
            for i in xrange(N):
                t = grid[i][j]
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    grid[i][j] = k
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    if not bad:
        best = min(sofar, best)
        return sofar
    return r

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N, = map(int, f.readline().split())

        grid = []
        for i in xrange(N):
            grid.append(map(int, f.readline().split()))

        best = N * N
        ans = findbest(grid, 0)

        print ""Case #%d: %s"" % (_T + 1, ans)
",,1571,60,192,Python,7706,0000000000049d40,0000000000045875,kmod,2018
9527,0000000000049ca9.PYTHON,"import sys

best = 100000
def findbest(grid, sofar):
    rows = [set() for i in xrange(N)]
    cols = [set() for i in xrange(N)]
    for i in xrange(N):
        for j in xrange(N):
            rows[i].add(grid[i][j])
            cols[j].add(grid[i][j])

    bad = False
    r = 1000
    for i in xrange(N):
        if len(rows[i]) < N:
            bad = True
            for j in xrange(N):
                t = grid[i][j]
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    grid[i][j] = k
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    for j in xrange(N):
        if len(cols[j]) < N:
            bad = True
            for i in xrange(N):
                t = grid[i][j]
                for k in range(1,N+1) + range(-N, 0):
                    if k in rows[i] or k in cols[j]:
                        continue
                    grid[i][j] = k
                    r = min(r, findbest(grid, sofar+1))
                grid[i][j] = t
    if not bad:
        return sofar
    return r

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N, = map(int, f.readline().split())

        grid = []
        for i in xrange(N):
            grid.append(map(int, f.readline().split()))

        best = N * N
        ans = findbest(grid, 0)

        print ""Case #%d: %s"" % (_T + 1, ans)
",,1480,55,180,Python,7706,0000000000049ca9,0000000000045875,kmod,2018
9528,0000000000049808.PYTHON,"precalc = """"""
eJzt3euRHDmSRWFVRoD40ZlZ+ZJlbPVXY1mcru5iVDzwcADXHcesQQV2zb5zPZKc//73svznf/9d
v/67ffvv48//7j/+e2z999z577X/3/vwv8tfGe+S+a4F71b4PirevfI9DN7T6L0M39v2Xf9q8C6N
3rXhuzV+Hx3evdN7dHzPzu814L3HvNtfA99l/f5v+c9//4F5k+RTjLMYtgC4Jbw9wR0JrRKwyrB6
AtUzpJEAjQznTGD+wLLju67fv1CviD7AOZHlKpBbQNwD4BHwKoCrCK0HYD3CGgHUiJDOAKgMnB3f
7fv7BPtA6wOnE4U2obkFyT0oHkGwAL2S5Hqg1iOxEWgNSOoUlEoQ2vl9fL5/2S4GO5NqC6Jb0NyD
5BEUKxCsSK8Hcj1SG4HYiLTOQOpQSnu/bbo30W4ntoXULYTuIfMAkSUkVhTYg7wexQ0gbUhhZ5B1
iKq/3r3H+9Q7l+5UtBXAbgF1D6BHwKwAsiLEHgD2CG8EcCNCOwOwXXDdeA/r9y/ge3pb0l1Dtgeu
OzA9hGcFlhU59sCwQ35DsBuR2xmYNSc28T1L3zbhp37LwG0JdgSsRyCtgLMiyh4w9ohwBHwjojsD
tsXQVr7X0fsDcWvBS+RWVLuh1lNIrSC0oswORHYpcQSBI8o7g7iH2rZ6n4pv7nAtvy3c9mh2T6tx
WtNnDy579DiCwxH9ncHdt/X71/G9Kb6PuAXgCng3QDsk2COhBun+QHuC2TPIkSCODLA5vufv46/U
tw25oeLWgkeQu4fYM2qtpDRC6+rsWeVIGgdWOF1gq/eH5MWMeyDckO4QbI/gGqrbMg3P/niOwHJA
jrtTfKl9u5TbOz6L3y3dnsFsBatxWsNobI5rc0STqz3OfNfv79Py+9Z1fdvyXo4L+O3S7p5m47Wm
0xjty2dcxuWrxfvX8nrI1REfAfjscI8EG6z7Qw3QMYCOBLM7lDPe7fs7wryJ5NaKzyR4D7knVFtK
a6TWVRqd59J5mMql7w/NU3d5L8kbKo7eFXqPUBux22qN0v6UjqAzMte/j6+3q3kXyj0z7pHvCeiW
IBuuNaiG6LhER6T5o/bVcd5zkUO4Lt+wPZ5sqNam2jPR8DyI54x3/3yfnD++fTavnOYjJnmN4yMM
x+++dmN2e7M9WI3T/Z2O5HN3m0vev55vbvPRlqs7Ptpw7NayW8lsvJa1GqNPXjSji33OfYWeW1mu
5jiGz2E3brc1G6v9WR3B6HA+/3qPnPeH5+/9Y7sC5h4gB/A2gHvGG7THoO0Ja6AeD7Uk0LnvCPSU
da6OuVfIAwAO3oVPCW7A1gbbM9QgXfaeRy8F9Jp1noq5GuSzI+4BcOCOD7cHsMG6P9aRkD4EOvet
QTed5400dyH5aMUR3E5w5EZtT2IjdUCpD97r+/sU/fntF3HJ+9yb5l4lF1IcvROeit7B5UbsRs+z
1mGVznn/ip55cVfS3IvkKG4vuGe9kdu/3J7ERuvxWhdLnfqSRa/Z56ma99zlnvc4gvcXPIreqI3a
amIjdfp7n70/RG8y0Ftx3nKYRxjkLRn3QDh8y/EN2wYPsvuTLUF16ksjPXWhq3PukfLZGPdGOHTP
TTdsw3U3ro/f/a/PV0d67kJvybkHyqMzDuHtCYdu2IZtHbK7UZ36fpJ+dHSPxrlXymdkHL5j8D0T
3ZAN2eZk15OestDPON8i3YLykZxHohzG6wkPwjd0FzwvdEN2d7Jtud55l+/vk/TXH792b0F64kJ3
scytKI/OOIS3JTwi37AN25B9QvbZ+5f00w/p0T13avmUjnszHL/9+I3bmC1tdqHppRt9pOcjt3kk
y3HcveHYnfBmtRu3+5pt6vXOu35/K9Nbb3Q1zyNbPqvjGD7OcOzGbdxubPbZMzQdz/Mt97TJVQ0f
4Th+x/d7VrsxW9xsY9MNN3pTzz1s86ibnC1u6jh+bzzsns5uzD55t6+3Yfra8xTTW270Xp5jOY5j
uJ3h0f3Gbdzu6fYt9SWYnnt3n9FzVctndBzD8Xs2v3G7vdsyZhuabrTRXXmO5TiO4W0Mx27sxm3b
9/H5Pk3/At0CdTXQR45zMAdyC8hBvA3i4A3cbuE+et9Rv3xDfQ36RwLoJagrgq60zq0xnxFyEAfw
mQAH7+BoW6E+eqV7AX02zIEcxK0Qjw44eIO3Gdw5qF87ou4JdDDvizmQg3hvxCcCHLi9w/3r3fde
LuqAng36tJgDOYhbIw7gcQEH7gy4e6N+BvoW6i1BH3huNwPdGnPPq9wD4iMhjwK4IuLgDd4ScB+9
LdT3QLdCvWal9wIdzLUg74i5O8QVII8IuDDi4N3guYJ79R7fXw7qBad3QAdzD6vcHeQgPs0KnxZw
8D6A++hZo5670j2BrrTOPWEO5CBuhTiAjwUcvIXw3nslqKusdE+gg7k95kAO4r0RB3A9wKeE++h9
or75l9TXoqeo3nOmI3qd5q0kj6Q5kqO4quII7kPwlno/994fql8PVH/kqT7k8G6t+YnoUpq3EB3J
20uO4gjuXXD0HqT33qtS3XKn14peovrIfY7mTTRH8oOH4k0UR/DKh96Feu+9H6rfCr+pq17eI4vu
RfNIuxzJUVxVcQT3IbiZ3hvv9fkkVHciepeLO5oj+UjJUbyd4giuKbhbvffeoepr0R/nov9QvWSn
RxS95z5H83Gae1NcQfKIgisrPqveHgU/1HvvbaruZadHEV15n7fSPJLkIzT3rLiQ5OEF96A4elcI
vvWaqh5d9Mj73KvmSK4pOYqzwxHcWO+N9/n/4+8i1Vvt9FTR91T3JDqa+9R8FslRvI3iCK4nuFu9
914z1T3s9BlER3Mk9yI5ivdTHMF9CH6o997bVX0temvVEV1/nzfSPNQuR3KfkqP4WMURvFDwrfdb
9S/Rj1R/bqi+J/pa9ZKd7k30yPvcq+aRd/koyVG8jeIIrie4vN4/3+Ovz/eH6rcE1dV2egTRe+9z
NPe5yyeVHMVPHoJPJ/j/9N57zVVvudMRffw+96w5kiM5imsrjuAngiep/pGo+p7ouapb7/RIoqO5
b82RvK/kKN5XcQQXEDxb9bXoKaofXd9bi16genjRrTXPEF1K8siaj5J8tOJKkkcX3IPi0+m98y5Z
qr8yVc/d6RFEr9VcWfRW+5xdjuTeFFeUfCbBHSneTu+9t6n6PV1101/J1ageQXQ0n0NzJPcpOYqz
w+UEN1Ndbacjep7oaD7HLp9ZchTvpziCDxTcleqpou+pHkl04X2O5icPyeeTHMXHKj6V4MNU97DT
o4uO5mhuLPlwxZEcxT0p3kTwX++6fruq74n+EtrpiK4tumfNI0s+UnMUn0txBG8suInq6jtdQfRa
zVNEV9a8pehRNEfyOSVH8aGKxxN8V/Uv0RVUb7DTXYnec5+jeXzNZ5VcRXFFyVFcT/FiwU9V/0hX
vej6XrLTK0UvUh3Rda7tM2uO5D4lR/E4issL/u3dvl5T1Xvu9OiiW2meKDqaD5J8gOZIbvCiSj6T
4J4Uvx29H6rfv6m+Fr236ogeY5+juZzkQzUfLTmKu5R8WsFPFa9S/b2h+p7oa9U773TTb+mTiO5q
n6M5knuUHMVR3FTwrqpH2enKos+4z2fWHMmRHMXHKS4peLLqD+Nv6uo7fU/0I9Vbat5RdDRHcyRf
NCVHcRRPeR/rJ6m6uug1qtdqHkF0z5r3knwmzUdLrqK4ouQo7kBxU9VTRF+rXrLTE0XfVR3Ry0T3
tM+jaI7kc0mupriy5OqKDxG8SPWV6Nmqe9zpiqKzz9FcQXMkjyc5ijtXPFn1s53eS3VEn2efo7mm
5CM1R3IUR/G8dzdRfU/0teq9dzqijxVdYZ+jOZIjOYqHVnz9ilWfaaerim6learoaI7mqppHURzJ
4yjeRfBd1b9E76m6l50eXfRR+7yV5rmii0perPlMkitojuIoPlzxQ9XvDVXvudOtRD9SHdH1RG+9
z9nlSI7kKC6neJbqK9E3VS/Z6SNUtxS9RnVPoqM5mqtojuSaiitLPo3iq/f4ofpjX/WsX8opiV6i
ukPRQ+xzNNeTvEZzJI8nOYqLKb5+Rapflr6qp4putdNnFj3iPkfzeXY5kiO5iuJdBJdQ/Uz0GtVz
djqi64iO5jE0n3mXi0iO4sEkT1J8/TZVfyaqniJ6rupr0TdUH3J5R/S4+zyS5uxyJB8tOYp3Vnz9
mqt+X/pc3xHdl+gKmncQPazmSI7kHiSfQvHVe56qvha9RnWFnZ4r+pHqyqJbaT5SdDRHcwvNkVxb
chSvVHz9slW/LD9V3xO9VvWoO92L6BH3OZr31XzmXa4iuZriypK7VHz9dlU/u76nqH5f9lVvudMR
3a/oaG6vObscyUdLrqq4B8lPFV+/YtWvS9vru/VOR3Rb0aPuczT3J3mt5kg+l+ThFF8/L6rL7HRE
Z5+Xio7m7HIkR3FzxdfPVPU90deqe93piB5TdDTvqzmSI7knyeUV//Ve399v1b9EL1Hd607PFf1I
dWXRrTRPFR3N0VxN8wgX9oiKI7mR4uv3h+qPlep7ontSXXmnexF91D5vpXmm6KE07y35xJrL7HIl
yVG8geLrV6T6tUL1TNE3VUd0RI+yz6NqjuRIPpPkQxVfvx+qPwtV3xO9UnXznZ4r+pHqiD724o7m
aG6hOZLrSq6quJzki5XquTt9rbrnnY7oIfc5mhc+b5IraI7kviSXVfzv9/56XVX3ttP3RD9SHdHb
ij7TPkfzeLscyZG8ieTLmeovUdVb7HRL0StUDyc6+xzN0dxOcyRH8V3F1+9M9aTfv6eIvlbd6073
KLqV5qNEn0XzEtE9SF6j+cySK2mO5MKKr1+26tdC1SPs9JlFT9E8quiKmvcUfaJdjuQLkruUfJlN
9dY7HdHHiu55n6M5miP53JJXK/7ne/61q/q74Tf1XNG3VFcRvZXqnkRnn6N5jeaDJK/WHMm1JVdV
vInk35+p6nui16puvdMR3b/oKvsczd1p7n6XI7k/yZsqbq567k63UF1lpyN6LNHV9jma62g+WnIl
zZFcUPKhqkfZ6S1EP1Pdm+jWmmeIjuYJz4vm7HIkn1DydMWLVF+LPlL1Fjs9V/Qj1RE97j5vrXmJ
6Ggeb5cjOZJXvd+qf4m+Ur35N/Uz0a1VV97pNZf3Xpoj+pz7HM19aI7k7hS3k/zbu/yh+rOB6s8K
1VOu7713uproFqpbaT5QdDRH8yGaj5ZcSXMkH6T4+lWp/pGp+qtSdeWdjuhz73M07645u7zyIXkg
yQ9Vf41RPepOn0J09nmMb+dori25heZI7lPyQ8Wbq74n+lp11Z1uKHqV6oiuLzqaozm7HMklJDdX
vXKnm6leK3qJ6oiuK/pM+xzNtTRHciTvKvmp6u/Mv9VWqXrT6zuijxPdWHMJ0dU07yk6mutrriK5
lebRFTeT/O93/XzZqt8MVG+x04VUl/0bbI5Fd3dxR/P+mo+SHM11d7mi5JaK/yP591es+sdA1YVF
b7bTEd2H5j1ER3MNzZEcyWUkb6Z6iuivStFbqJ4reoudfiT6meqIriE6mqO5B82R3J/kh4qnqt7s
l3KBd7rbb+k9RbfWPEf0mfY5mmtpPlpyJc2RvIHkqG4v+qHqiM4+j7jP0VxfcySfRHIV1bv+bTaP
Ox3RER3N0Xx2zZE8/d0+X5Lqa9G3VE8RvVZ10Z2O6KKio/mcmo+SvFZzJNfWXFry769I9Y9C1d/G
qrfY6ZmiN7m8I3oM0VtrXiI6mrPLkTyg5MmqXzqqfia6teped3ow0cNe3Cfe52ie+NAcyc0k/6H6
l+i5qt/LVW9yfe+80xFdTHQFzXNFR/O5NB8tuYXmSC4o+a7qLwPV90S3Vl15p7cQ/Ux1RB8vuto+
R3M0D7jLkVxG9feB6hY7vVb1Hju9legWqs8gOvtcQ3Q096O5iOSSmktJ/u19/FD9XaD6I091dnqm
6oiuKzr7HM2tNR8tuZDmSJ4q+feH6oiO6B1En1nzUtG9Se5dcyR3LHmW6nuiW6meK/qW6i12eq7o
R6ojuv439Jn2ubrmI0QfJTma22o+reRnqif9XfX7huoJolerzk5HdPa5/j5H8/iaq0iuqHl3yUeq
bn59V9jpiI7o6qKjuYbm3iVX0hzJW6n+MFT9THRr1Vvv9Bain6mO6L4u7oL7HM133syaq0hupXk4
yWVUr93pW6qz0+tUR3T2eQ/R0RzN2eWGkv9696+3q/qlQvUd0c1Vn22nI3oM0dEczZUlN9AcyXtL
3kT13J2+Vv1M9B6qIzqiT7bP5a/taM4ujyC5peabkmervhZ9hOpr0bdUV9/ppaKfqR5NdGvNFUQX
05x9vvHQHM3d7XIz1e8Gql8Wreu7152O6Fzc0RzNB2iO5EqSy6sustNNfyHXQvQz1RHdl+iK+xzN
tTRnl9tqHkbyZNWvdr+UM72+R9rprUS3UH0G0RU0n32fo7m85qEkV9S8WvJv7zFE9aOdbqV6751e
InqN6ogeQ/SZ9zmao/nMu9xU8u/vt+pfopeqbnl9L1FdeacjOqKzz21ER3M/mqtIHlnzx977Q/X3
ANVb7PRK1V1f3hHdTvRWmueKPrvmI0RHc9+aR5X8UPMwqrPT01VH9PGiq+1zNPev+WjJo2nuUvIj
1Xf/tdi16Fuqp4gurnpY0Q1U7yq6teaI7kt0NNfXPJLkippnSZ6l+tlOz1X9spT/jba16Fuqq+90
RNfd5yqiozmao/mcu7xYchnV2ek2qiN6X9Fn2ue9NC8VHc39aK4ieVjNf73n59tU/ZKh+hPVh+50
RI9xcVfTnH2O5tE0jyr5P5o3VX1P9CPVc0XfUl1Z9CPVS0U/U71S9CTVET2e6GiO5miur/lz73VV
/bLYqd5jp+eKPttOR/Suok+/z9FcX3ILzZG8QPKlheqjr+8VopupjujxRG+luZroypqXio7m7PII
kidrvpypfh2o+pnoxqpnXd9zRT9SvVT0M9Vbi56iOqLHvbiraz5CdDRH8yG7fOslqb4W3Vr12p2+
pfqsOx3Rw4gup3lP0dE8tuYqkltpPlzypVb1R5rq3b6pz7TTj0Q/U72H6Cmqj9Ac0X3sczRHc3Z5
+Xt9virVnxuq5+50RdVH7vRWoluobiG6perWmueIrnJxn32f99a8RnQ0j6G5muT/aL6oqp4r+pbq
Cju9RPQa1RHdvejs88znZZ+juX/JFTV/7b1D1W8dfik3205HdD3RUzVHdA3RvWheIbprySNp7kby
ZTbVZ97piB5LdDQPrflQ0UdLjuaVmi+NVS/6pVyu6Fuqs9P7qo7o84reS/NS0dEczUdoPkTyZa36
a+d/Wz1X9dydXqt6yk6vVb3HTkd0XdEVNJ9ZdC/7HM3nllxC82VD9cP/vba16Baq3xZb1dnpiB5N
dDXNS0RHczSPqrmM5N/eu1j1Z2PVz0TvoTqij/876YiuI7ryPkdzNJ9Z8/f390P1y0r1j06q1+70
LdVTRR+legvRT1RH9ICis89diI7mhU9FcivNm0i+WKr++qn6kG/q1jt9T/XZd/qZ6CmqRxC9leZq
orPP0Xx2zaV3+dYbpvpt0Vbd4073ILql6tFEz9FcUXQ0txMdzdE8W/PlSPXrYNVzRd9S3etOLxX9
RHVEn1j02fe5J81Hio7mjq7sR89M9ffAb+rs9Lqdjuh+RGefS4uO5gUviuTDNV8mUz30Tq8R3UJ1
REd0NdHRHM2n2OU/3+uvpqrviZ6j+pnoW6qz0xF9gOhc3AU0LxUdzdHcveZfb1f121L0d9W7f1NP
2OnVqiM6orPP2edWoqM5mptLbqb6y0D1o51upLr8Tm8gusS3dESfW3Q0R3M076h5WNXZ6Ro7HdH7
ia6mubrovTWvER3N/UveTXNT1d9GqjfY6fKqRxQ9RXVEjym6subsczQPt8u7qr4nekvVrUXfU73H
Ti8Uvfnl3UJ0S9URHdHRHM3RPFX1jwaq3xY/qs+20xHdVvRWmueK3lrzEtHF9zmaZzw0N9O8XPJW
qpt+Uz8TPUH12Xb68Ms7orPPlUT3ss/RHM1NNP/1Lp/Prepr0a1Vj7bTER3RR4vOPkdzNG+oebbq
a9GtVb8v+tf3qDsd0WOJ3lpzZdGj73M0dy+5meaXvfdb9S/Rc1R/Jaq+J3pj1cPt9Fai91Ad0eOI
nqt5iehoriU6mutIfqj5puoXI9Vzd/pa9VzRe6g+UvQa1REd0UeJLrzP0TzhobkzzZNVvzf6/bul
6u+fT/ZXcjOJnqI6ovcXXXGfIzqao3mF5IeqXweofl98Xt8973QF0S1VVxe9leZqoqM5mqP5IM2t
VW/2S7kz0Xuozk7XvrzPKnqO5oiur3mN6GiO5rqqV+70quu72k4vFX30Tkd0RPesOfsczT1qfv16
m6rfjFRPEd1YdXY6oiO6sObqoqN5fM1VJDfXvJnqNTvdi+rKO/1I9DPVa0VPUR3R5xVdWXNPoqO5
b80tJN/UvEj1teitVc8U3d31fbadjuiIrii6F81rREfzCTTPUv1kp5up7mGn76muvtNHi56iOqL3
F7215iWiq+9zT5qPFB3NG17Zi1T/CKq6450ue3m3EN1SdUTXEJ19Pue1Hc0HaW6puuwv5djpGjsd
0fV+547oaI7mwTSXUP2+6H5Tj7LTET2+6DmaK4qurLkn0UdpXis6mhtp/ve7RVHd9Pqes9P3VDcU
vZnqCpd3RNcVnX3uQ3Ov+xzNjTX/eqaqXxadb+rednpv0c9UR/RYorPPY4ruUfNa0aNIbq55kup3
EdVPREf1AtVb7/Qz0VNUR3REZ5+juZLoKpJvat5N9T3Rj1Sv3elbqteIvqc6orv4lo7ofkWX3+e9
Na8RHc2Da56t+lr0WtXvDVUPstNdXt4R3aforTVXFp19HvbbeRjNTyU3Uf19oPo1U/WHQ9XZ6fLf
0hFdRPRMzeVFR3M0l9TcSnWT378fqZ4r+pbq7HRER3QXoktr7kl0NJ9Q8++q/yO6gurs9DGqK1ze
ZxG9leaIzj73KjqaG2j+9/v4Q/XrhuqPzr9/76F6quiDVGend1A9mug5mueK3ljzItHZ52iO5ivN
v15T1VNEb6269U7fU73HTi8VffROR3REZ5+juaHoaL6l+a7qt86qPw5UzxW9h+rRdjqizyN6juaI
Hlt0p5pLiC6reTPVrwNVX4u+pfpsO/1I9DPVa0VPUR3RER3N59jnaN5Yc0nVn8aqs9O1d3pP0VNV
R3REV9bc4z5H806aH6r+saP6SnRUP1B99p1+JnqK6ojeV3Q1zRF9/D5Hc0eaW6ie/Lfa9kQ/Ur1W
9C3Va0TfU33Gnd5DdEvVEd2f6Mqal4ruSfOBoqN5qeZZqj8LVM/d6daqj9zplqqrie7t8p4ieqrq
iI7oXvY5mk+ouanql0lVH7nTS0U/Ux3REd2T6Oxzru1o/u+7f75d1e+dVX8eqH4meorq7HQfl3dF
0VNVH615S9Fba64sOvucfe5C81Cqr0XvobrHnV4jushOlxW9heqtNFcTPVdzddHRHM2HaN5E9auR
6q9K1deie1S99053IHqIX8chen/R2edoPoXm3VRPEb216tai76kedacjegzRczRXFJ19Pu8+R/ME
zaVUf6arPsX1fbadjuiIjujsczSv1DxJ9Ueh6jdD1Wt3+pbqqaLnqO51pyM6oleIzsW94Hna56M0
rxV9Ss2zVd8T3Vr1g53eXfUt0VurrrTTW4ueoLr7v8HmSXT2OftcQXTv+3yY5maqX8RVX4teq/qW
6Huqs9N97XRER/Qo+xzNJ9T87/fwpHqzb+qed3qp6KN3OqIjupXoypp7En2U5rWio/nfmn89M9Wv
G6qniH6keu1O31K91063VF1tp3u6vKeInqo6oiN6RM297nM0X2kuo/qzoeopO71WdY87vUb0Djsd
0fVEn/pXcZFF96h5rehhNf9D9S/Rt1R/dlT9NUD1VNFHqd57pw8WPUn13qKnqo7out/Qe2leKrqj
fe5WcwXRm2q+qfrNQPVbG9VdXd+j7nQF0S1VtxS9heqIzj5nn6N5subyqvfY6bWqs9P9Xt4RHdFH
i84+R3NTzXdV/2ig+p7oo1VnpyM6oscUvZfmXkSfbZ9PqXmR6mvRa1V/dlSdne778o7omqK31lxZ
9BLNS0VH83lEL9bcRPXLgeofmaq/9lWX/KaeoTo7vVL03qojuobouZqri+5kn6O5V81/vefn21T9
7lz1tehbqteIvqc6Ox3REd2P6Or7HNHRPEvzLNVfnf9W29tY9YE73VR1tZ1eKbrc5R3RfYrOPkdz
j5pbiP7ceqhupPrInV4quvpO7yl6quqIjuiI7vvaHlbzJqrfTlTfEz1H9TPRU1SvEX2U6r13+mjR
U1RHdESPJLoXzdnnQtf2LNUfRqrn7vTXgeglO91a9S3Rd1SX3ulHop+pXim63E5PET1VdUSf+xs6
+xzNh2k+jepr0Vuozk73e3m3FL2F6ojOPlfQ3KvoU2neVPWPCtXfA1RvsNN3VZ98p0td3hEd0RE9
pua1orvU3KXquaJvqc5Ob7fTe4ieojqiI7qy5qWie9rnXjVXEL1Y81LVm/9d9d473avqaqJHvLwj
OqKzz/2IPr3mv97r8x2q/kz4F2iuiarviT5a9RrRd1QPudMRHdERHdHRXFjzLqrn7vTWqrPT/e50
REd0a9F7aV4quhfNvYo+WnML0V9bz0z1m4Hq7wPVc0UfpDo7vYHoKapbiZ6qOqLraK4sOvtcT3MF
0ZtovkRXfS36luo1oo9SXW2nK4jee6cjuo7ouZqri+5Fc6+ie9f8VPRFWPVQ1/dc0ZVUH73T1URP
VR3RET2q6GguqvnSSvWPeVUPt9MRXWenIzoX99Ga14g+SvNa0V1pvqSq/jJQPUX0HNXPRE9RvUZ0
NdVLRa9RvbXoKaojOqJ7F519zj4303z5rvqX6CNVfx+oXrvTrVXfEN3s+r4negvV2en639IRHdG9
io7mnTVftlT/CKr6WvQGqkte30tFH73TER3RR4jeS/NC0d1o7lV095r/ep//f/LOUT3r35W7l6s+
5Js6O91kp4e7vCM6orPPY2seQfT39/dD9XuG6tcBqp+JnqI6Oz32TrcSPVV1RNfRHNHZ59Nqvliq
fhNSfS26murs9FiXd0TXET1Xc3HR2ecnb2bNd0Vfequ+J/qR6pdl7ut7z51eIXoX1dVET1Ud0WOI
rr7PEb296NKaL0eqP1aqvwP9Um7kTrdUvfdOR3SZnY7olaKzz9Hco+inmi+iqmf9Uu5M9FGqT7bT
JS7vVqKnqo7oiI7oPjT3vs+TNV88ql6707dUrxB9mOrs9Cm/pSM6orv9RdyM+7y75ktL1e9Gqh/t
dAHVm/5Kjp2O6Ig+TvROmrsRvVTzGtG9aj5U9OVI9WdA1deit1Cdne7z8p4ieqrqiI7orTT3JLrH
fe5a8+U/778+XzfV90RXUz1RdDnV1URX2emIjuhRRPei+Yz7fLDm/4pepPpa9FrV34mq14q+pbr1
Tt9TPeBOdyG6peopoqeqjuhT/8210KKzzwftc1PVbweqP/JUb/pLuZSdXqs6O72f6l5Fb6E6ovf/
VVwvzUtFZ59PqHmu6kX/Ao031RNFz1LdSnQh1YeLnqI6oiO6d9HZ55qiy2qepPorQ/UPY9UvS1vV
rXd6a9X3RD9SfcROVxC9t+qI7lP0XM0RnX0uL7pb1XNF76H6luh7qrPT41zeER3RFUT3orlX0V1o
Pkz1HdGb/lJuLXqq6ux0rZ2uJnqq6oiO6IjuU/Na0btq3kz1+4bquTt9hOq9drql6ux0fdETVUd0
UdGVNUd09jmq5+z0Vqo73enyovdW3VD0JqojemzRvWheIzqal72LpOqXxf839Zl2emvR1XY6oiM6
orPP1TT/LXqS6u9C1R8iqq9F31K9107fU52djuiIjuitRGefT7DPvz951a+Lv+s7O13r8m4leqrq
iK6heQfR5b+hs89j7/PL1vut+pfoZ6rviY7qGqqr7fRa0T3udETXED1Xc2XRSzT3JLpHzStFb6P5
pur3QtU/ElVPET1H9TPRU1S3Fn1PdXY6l/dWoueojuiIrqK5V9El93lX1Wt2+lr12p3eQ3V2erzL
u6HoQ3c6ovMNXUV0j5pL7/ND1R8Vqt/FVV+LPlr1XNGVVGenIzqiI/ososvvczeqH13fW6leI/qe
6q13+pHqEXc6oiO6B9F7aT7DxR3NjVUf9nfVW6s+cqdbqu5pp9eKnqJ6T9ETVXfx6zhEZ5+zz51d
25NVf1aq/uigeq7oo1SPttNrRFfZ6YiO6IiuL7pDzceL/utdu6meIvqR6tY7fUv1GtFHqa600z2I
bql6gujJqiM6oke7uLPPO2v+9aRUvyx+Vd8SfU91dnob1b2K3kL1VNFzVEd0RGef24tupvn0qq9F
b6E6O11rpyM6orcQvZfmiC4nus4+T1L9taP6WvQj1Z8Vql+X4d/U3V7f1XZ6regOd3oo0XNUV9I8
kuglmpeK3lvzGtHZ5y1U/3Cg+lr0LdWtd/qe6uz08Jf3aUVvqXpjzcOJzj6fbJ+7U/22cH2fdaef
iZ6iekfRh/06DtERfRbR2edWql8Sv6mfqb4n+syq54qupDo73ddOR3R+FTdac4eiD93nyZrLqX5Z
ylQ/Ez1FdWvR91RvvdOPVI+40xEd0dVF76W5F9FLNa8R3avmRaKfqv4uUP2xoforU/Xr4vubes5O
t1Td006vFT1FdURH9BlEL9Hck+ge9/kQzadVfS16L9XZ6Xo73Uh0+W/piM43dAvRPe3zaUX/9W7y
qh9d3xup7vL6PtNOtxC9904fJXqO6ogeX3T2eWDNv14z1Z9OVO+x0/dUzxW9RHU10XuoriZ6quqI
juiIPp/oZpqHUD1X9FGqz7TTR4ueorqi6C1UR3REn0V0j5o3Eb276imiH6luvdM3VA91fWenj1dd
XfQc1RHdn+alonvR3KvoTTRPVX3z34Bfi26p+nXxq/qW6HuqW4mupDqiIzqi64jOPtfTvLno2aqf
7fQt1V/Cqr9/vhmu79P+Qq6n6KmqexA9R3VER3REH6S5C9VvS7rqZ6KXqp4quoXq7HR2umfRW6qO
6FzcK0V3u8+TNf9D9S/Ra1V/dFS9dqdvqO7u+s5Ojy96C9URHdE9is4+L1H9Iaz60U5XVT1np1uq
zk5HdETXEL2X5ogeS/QizUeqLvH79/fPN1R1dvo8Ox3REX30Pi8VvbfmFaK71Lxa9F/v44fqTwPV
nxuq5+50BdVrRN9TnZ0e9xdyiI7oiM4+H6b510tS/SKmeq3oG6pPfX2PutPVRE9V3Vr0HNURPbbo
JZo7Et2l5qaiS6t+W9qpnrLTW6jeWvQD1cPt9DPRU1S3Ej3KTkd0REd0p/v8VPUXqk9zfWenc3lH
dER3rHmV6F73+abmXVR/Gan+sTRVnV/JFajOTte/vKeKnqM6otuI3kvz4KKzz01UX4s+WvUz0VVU
V9zpR6q3Et3JTkd0RHcveonmiK4r+qnmZqrf81Q3//177k4vVT1VdDHVu+/0AKLLXt5Hip6jOqLP
JXpnzV1e3Jvv8yTV35mqPwxVvy1+v6lvib6nuupOH6V6regpqnsVvYXqLURvqDqiJz72eRzRszTv
qvpbV/XI13dXoovs9Gku74iO6Iiuq3mx6FmqXwf9/v1jmUv1XNG9qO5A9O47HdERHdG5uJtp/ve7
u1Y9V/QU1a1F31O98U5v8rfZPO90NdFTVUd0RFcS3Yvm04o+nervn09qpxuqzk7PU11S9JGqI3p/
0XtpHl30aTVPUb3q34B/NVD9vnB9Z6f73+mIjuie9jmi64p+33o9VR/+77+XqF4j+p7q7HRER3RE
R3QN0Udp3kR0SdVvS5nqZ6KnqD5yp/dQXW2n14puoLrk5X2U6DmqI3p80b1o7lH0Gs0PRZdX/WOZ
55u6kehSqrPT2+10REd0ROfibqf6WvQj1d+aqg/7pj5qpx+p7nGnn4muttMtRW+heqroOaojOqIr
iu5R82TRzVR/dFD9vvj6pp6z0/dUZ6eP3elWoqeqHkn0lqojupbovTWfTfRkzZNVvyzj/l25nqqz
0+PsdAvRe+90REd0RNe8uLvY581Ufyaqvid6qeqZok+nOjtdW/RU1RF9LtF7aR5d9Cn2uazqtyVN
deudvqV6jeg5qo/c6Ueqz7zTFUUfqTqixxW9RHNE1xX98fl6qe7ul3LWO32U6p52eq3oHnc6oiP6
BKJzcW+s+T+i/6P6l+hWqr+cqb4WvYXqW6LPpvrgnY7oiI7oFaKzzzVFf6zfH6o/RVW/L+NVTxU9
R/XWoh+pHm2nn4ju9vI+SvQc1REd0RFdRPQQqmeKnqS69U4fpTo7nZ3eeqcjOqJ7F92j5ruib6r+
2lD9Wqj6W0/1Id/Ut0TfUz1T9CLV2emIbiF6huqIPo/ofENvLPqu5hKq74l+pPpjifFNnZ3ua6db
iZ6qeiDRm6qO6HOLXqp5jeiS+3yo6rk7XUH1GtHVVJ9sp7u8vCM6oiM6+zxb80PV3weq74muoPqJ
6EO+qW+Jvqe6lehKqqvvdDXRU1W3Fj1HdUTvL3ovzRHdueimqj/3VeebushOP1Kdnc7lHdHnFr1A
82LRe2teI7obzVF9Q/RU1VNFV1Pd006vFN3lTkd0REd09nmV6L/e01z1V0PVH4uvb+pbou+pzk6P
u9NTRE9VfZToGaojenzRubirin6kevb/CmsE1VN2eq3q7PTmO73bL+R6i56qOqIjOqLPpfk/omep
fjNWfU/0UtVzRfegeq7o1qpH3ekWoluqbil6C9UTRc9SHdERHdEN93kX1d+Nf/9uvdO3VLcWfU/1
1jv9SHV2OqL3Fr2l6oiuJboXzcOILq/6fYmles5Ot1S9ZKe3Up2d7udbOqIj+gyih9Ec1U9EH606
Ox3Rc1S3Fj1DdURHdERXEf1U9YuQ6o9lvOqpoueozk7XUd2r6AN3OqIj+nSij9I8SfQeqnf5/Xuu
6CmqW+90NdXZ6fqqi4su8eu42UTvpHlX0Xtr7lH0JM2rVF+L7k31teg9VN8SfU91K9GVVGenIzqi
uxC96+/cvexzN6Kbqf7MVD1F9CPVn0uMb+qjdvqR6uz08aKnqu5B9BzVER3Ro4neVXN51e+Lluo1
oqup7mmn14rOTudbOqJrXdw9ie5mn397ryzVPxK/qXtXvcdO31Odnc7lHdERHdERvUj0JNWvRqpf
Fr6ps9P77vQz0VNU7yl6quqIjugzid5b8xrRR2n+j+jNVH87Un0teqrqqaIbqD78V3LsdH873Vh0
d7+OQ3Qt0dnnjfc5qmeqbr3T91RvvdOPVGenxxF95E5HdERH9IGiu1T92Vj1lJ1eq3rGTg97fY+w
061ET1VdXfQc1REd0SOILqV5D9VP/676nuilqp+J7lB1drqo6L13eiTRVVRHdEQPJ/o/qn+J3kP1
3J1uqfpa9FLVa0TfU52drqO6muipqhuLHvryjuh6ovfWPKToP1R/Car+OFD9Van6WvQt1Qfu9OGq
s9M1VFff6YjeV/RemkcWvVTzGtGba56l+m0S1VN2ekfVQ17f2emIjuj6opdoHl106X1+qPo7UfW1
6EeqX4xUfwZVnZ2uIXqK6j1FT1V9lOg5qiM6oiN6B9GLVD/b6SKqm3xTtxZdTXV2+jw7fXbRc1VH
dH4VVyt6d83DqV6703uoviX6juqyv5KLutMji95C9VTRc1RHdERX0tyj6J//t39vqf5b9FLV34mq
74meqvrBTnelOjv9VHWJf3Gmp+ipqkcSvaXqiI7ovTQfLvqiqPp9kOpr0bdUrxEd1dnpI3Y6oiO6
iuglms8iuonmywjVr5mqPwKpviX6jurhfiU3cqefia620y1FH6m6N9FzVUd0RJfa50sH1Uf+rTbJ
X8qx0+PudCvRU1VHdERHdETfFH05Uv2ylP1vq7dS/Xmgeu1O96B6ruglqrPT9Xe6uug5qiM6oiO6
segLqnN9Z6dr7PQU0VNV9yB6juoqoueqjuhxNa8RvZnmi2fVXwFUz9nplqrviX6kesSdbiE6O933
5R3RET3MPl96qn45UX1P9JGqr0UfrTo7vb/qiI7opaLnqq6qOaI7FH0ZpXruTs9Qvds39VTRM1SX
3OkDVB8ueorqPUVPVR3R/YneQ/VemiP6YM2XFNWvO6qvRR+puvVO31LdeqerqS4kuoTqgXf69L+O
Q3REDy36YqX6q7Hqz2Cqb4jO9V1EdLWdbij60J2O6HFFL9G8VPTemrsTffnP5a+/TFl/H7B+dcL6
mvROrEue3xnqZaxbkZ7KujrpOay3Ij2XdUiH9FLOa0iv4/zfP9zB/hKAvQZ1NdjZ6lzfVVBX2eqg
DuqeUc+X/a79t9ua/GKuw1xvfoVXmeveZXeqOhd4VJdQvUR0T6qXim6uOrSvWR9EO4PdAeuKtMM6
rMM6rJfafmtoe4rrR7a/jW1fu47tGpO91vWJJ7uLQ7yC67m24zqu17reyPROul82dK9Z7Qq618ie
o3tr2Y9077zam+veY7ULyp6sO7IjewTZe6suLTu8n/HeYbgP471kuDfiveooX0u7x+FuSXsL3lNp
z+Ed2uegPfpg70e7P99fGb6f2S7iu9xhnumuPd1ntL2l7zm25/qO7dhuZHuu6/GEH/azulTdc4Rv
rbuQ8Kx3e+HRHd3R/eT11r3jah9B/NUB8Wvet4g3HvCuDvQzDniHvLsgPjrvmcTDe+GD93Tjv3zP
MX7te2/j3/6NzzrS5/peYvxME/7M9xTje/oeZcLje3/j8X1a338i/95B/iMB+Xcm8inAj0R+Dbw3
5C1H/BHyjHiZES8PfA7yAA/wCrgPAN4M988/Lr//yGb+0ZH5ZyHzucSXMl9BvNytnh2vu+MTiOfv
xzVgHuLnJr6Udy3iN53/bXyF86b/6k2i8+Hv9XvO5xrvxfkIU97K+ChTHuMxfgbjC31vaXx/6G8V
0L8mhr71mD+CnjEvP+ZBHuRBfuOBPNJrfp3PmfOW0jPnNed8gvLDTvapyudIj/IoP5ny7YU/sf5i
YP2lofVvAesrnDexPtf5EutnW/QWzrPo/Tqfaz3O47wT52Ninwt9CvY9Rv0e9q1HvRL26qMe6Mef
7oEe6FWQ9wS9hvZ70vfSfi39KO1zZr2l9nvSH2lfKH2V9qOlt9LeSHr5830L6Vtqj/RI30F5S+mT
kS/g/l7I/bWQ+2ca91N+sWfYM+wth7019Tnce6M+k3uoz3xQ34r6Y++vDb3/yPT+Jea9tfV73itO
+xHej7Y+xXuv1o+c9liP9ZNYP+Z4j/gF4qut+9Hit9BeXXyP615d+xzxHWqfLT7ao31z7X2S/84g
/4x7j+RbcX9EvtLAPyOfga9zzG/BfQ75XrnvQT7cw/3//rgWmb/j/aH5tw7m1078UvMTvc8yn4kf
Z+IbeR9m4rfwvqX5eI/3A723of5/3puj3+Xf22mJ/hr8LfStR74a+ox8bvqAD/iRwO+MvTT45+rf
tNUP8fu9LfH31LcS31r9WWe+mvip6o8SP0d9xEd8h+ILnvPX5Ldz/5Lofor5I91fm9/L/VFL/8h9
lr6++1GWPuZjPua34N4R/K9C+M/Qt4K/Bn01+EvGfiv4Gftzop8Dfyv0M+EH/YwH+qM2fo38DwP5
P0TkX6ufIn+Pub8nP3NfR/0U+Xuqnyp/JPVF5j7qZzzUF1G/Pf1XY/rfB/RfFr7wM/gZ/LX0W7Of
Qz/swz7s92Af+3Mmfy/7t9xXtZ/JH8v9kZPfmfty/yYP7k/ufjL5Gfh/aOIv8RO/Gvgt8LeC/wh/
Rr//0a8Ofw7+wA/8wF8P/zz6n8mfon+P2b+nv+LsH6H/aPkjz34P8uforyJ/rv7I30f+weoL0N/P
/9uJ/3v2l/pfu/xH+Z+z/Hv4r2S/gv8Wy9/K/ijLv4X9Df13/6kf+4fbb8N+vf1jAyB3/B8FwNH4
jxoAVvh7CYAI+Pce/+AP/uAP/kd/3IoLYKV/qAJY679VANb67xXAqPl/VAAt9PdeAGr6pxbAKP1z
CgD90R/9TeH/n/6mCZD9z/vmJsA7eALkHAB6JIDSAeAsAUbzr5gAMx4A4B/+4T+HfxogtQHW/o9u
ACv/jRuAEwD+T/8BAP/x35H//0bA3wGwGwH3xeaf/f2wiYBpfgo46ghwFAEcAWL8BJAAIAAIgKkC
YG3/dgX8LoDZK2BdAFsVYF0AahVQcAaY9reAnAHaVAAFQAFQAB0KoG0GXMkA6a8BHAJ8HQJSEiDK
IcBbAuRmAAlAAugkwHYHXDp3QEoDHHXAZYn5qwBOAZwCWpwC1BsgpwNoABrAqAG0/O8cAX5K4C1e
AqkVELQEuAY4qYDUErCugMjXgJwKyC0BKmDCCrAJgLwK6JMCt40UuHdKgdwMaJ0CWxmQkwKtM+Ao
BTgImB8E+ChABgxNATKADDhrgatuC/AjAa2TwJAWGN0BnAT4MEAH0AGCHVCQAMSAdAxshcDIGFAK
AYUYUDoKWIZAagwQAoQAIRArBPJq4DFhDaxLILEGuv4VQqsS8FIDAUqA3wsWlkBODbQqgdwaoAQo
ARcl0DcHPhrkwGUZnwPWh4G9HBD8SjDlDwe9pUBqDkRKAZXDAClACrhJgY/ff+z2wC2hB9YtoNQD
uS2Q0gMJpwE+FFT2wFELnPXA6BZQ7AHL04B1C+T0AC1AC9ACTVugPAjOjgOpQZASA72CYB0DHoLA
Kga8BAHHgTm/E3iLgdwgIAaIAYUY8FEE78QiuC5xfz0w6jxwUAScB/KLgE8FBTWQUwTUADVADVTU
QLskuLZJArkfFFofCNSSgAMBBwIvOaCSBDk5kJsE5MCIHFAqgdY5MKYJ7k6bIOFEMMtHA04E+U3g
tgdGNgE90LcJ6AHlHrBJgZMeOI+CD+EouCzpUXAWBMpRMOpIoBQFHAnso4AgIAgIAoKgfxXcBlVB
7ZmgsAqm/3RQWgQ1VTC6CCKfCUYVQU4VKBRBbhVQBBSBzteC6ix4TpIF6yTYyoIeh4K9LOBQoJMF
FocCqyTgUEASkAQkQV0S6HTBXhOkdsF1oQtGnwpGdMHoJvB4KpiwCWQ+HtAENIGDJtAPg7dIGKyj
oFcYbEWBahi0iAL1MFA6FqREQWoYjIqCnDDwFgW5YUAUEAWjoqBfGXxslMEjrwzU/yLC8F8XWFXB
QRlInQvOyoBzQdxzAVVAFVAFDasgLQ3uztMgNwtS0qDHwWAvDRQPBkdpwMFAIwvUDwapWZCRBi6z
IDcNyAKywD4LPv+4u2yDyxL/14c5J4MObcDJwLgLPJ8MHHSBTBu07IIebUAXTNkFdXGwDgPiYFwc
WIWBlzgQPxqEDoORcUAYEAaEQZ8wsK2DS0Id3B3WwboMNuqg268NBp0Nuv8GkbMBnxMoA8pAuAyU
oqBNGbTJg2vnPLguvvNgKw3E8oDDQXoehD4cjEqDjDyQSIPcPCANSIOhVbCZBnp9sNMGxX2Q2wYp
ffD++fiwYNgGNX3g4XTgtQ04HdAGtMFUbVAWCK/+/85Bt7+ysI6DmQJhJw74tpAeCC6PB8SBn+8K
xAFx0PRzQnEhPJwUwm3p/nlhsxBq6mCvELbqoEMhhPm8wPmATwue6yC3EKgD6qC6Dv5NhK886JUI
j4pEuCxSiSD59xpz86AkETggcEAQOSCQBwMSgTyYIQ9+NsKlQSN8BGqElBNCz0ZofEKQagROCPRB
bSO06oPcRqAP6AMnfeA/Eq5LeiScBYJyJOQcEQwjoevPFGc/IlgFgmUkjAqEyEcEAoFA8BQI25Vw
DVIJtWeE0kqoKQSLSsgthJJK4IzAGUHgjEAhUAgUQutCIBNyDgkbmcDXBoFM4JAQ68eKiYkg8aUh
JxFyM4FEIBE0EqFvJ9xPOmGnEZI74bbE7IScU4JhJ8h8cKg5JZx1AqeEuk7w0Ag5nUAj0Ag0wuYf
j81QuHUKhdxjwshQeP98bkKBYwLHBOtIGBgKfG/oGAkloUAkxIqEvFJ4/iyF6v/FhtxSuCzapVBT
CTmloHhOOCqF0kpoWQqcE6gE75WgeE6YtRKUAsG8EuxT4SqaCrmZkJAKkX+hEOLLAweFub86kAlk
woyZYFMI60wob4W3QCtcl/i/ZtzqhJGtUHJSaNUKNSeFs1bo0QkprWDVCZwU+HUCnUAnVHTCcSx8
VMTC7SAWHsSCxN+O5KjQLhYsQqH3UWHGUFA5KhAKhIJGKGw2ArXArxU4K0jXQs9SSK2FQaXA5wfh
UiioBUrBYynEyYXb4jsXtlIhQi6UpkJNLkRIBQ4LpAKpQCpopUL7XvhI7IWUVrDqhbNWSOgFPkQk
tAKnBR+tIH5acPVrhZatkNsLtAKtYNwKvoLhsvT5KxHrWFAKBk/HhRHBoB4LisFgeVwwjoXQx4WW
sdAjGIiF+WLhvBjuDovh6LzQsxhqaiFCMbSoBe/FELkWRp4XqAXpWqgvBmJBIhbyi+FVWAz3jWJ4
VhTDdYnze8fUWtgrhta1cFQMSveFs2IYXQtei0G9FnKKgVqgFqiFilogGUiG/p8kODD4yYXUZDDO
heEHhla5kJsM5AK5oJULNENBM/Azhope4MSg0QtRTgwtekHlxDB9L1RHA73QoBc+/3i6j4bbovfb
x5pgsIgGq2DwEg0cGcIcGfgmURANBAPB0CsY+lfDw1k1vH8+Pk2cVANnBu0zg2UxpFYDxTDVmcH7
35AIFQvmxZCWDY/tbCj635Q4y4a9ZJg9G3IODT2ygUND7EODZTK0yIbUZMjJhlbJkJsNJMPQZBDp
BqVaWCdDm264ZXZD7qnhqBs+Fn7VYNUMM3QDpwZ/HydaNIPKqYFmoBkcNIPPcLgu2uFQEw054TDq
2HAUDr2j4SwcODbMe2wgGogGosG8FzqUw4dYOZxVg0I5bFWDWjlwboh7bohSDTnloFANueVANVAN
Q6thXDo8jdLhttilwzobUtJhnQ0t0mErG3LTITcbrNOBg0NZOlhlg2U6RMqGnHQgG/j3GaiGqnR4
O0mH+zLfjyNbXxyO0sHTxeEkHbg4OE6HFtnQMh1ysiE3HcgGsqFNNvRph3uMdij+gWRqN+S0Q87J
wbIdSk4OI9qBk8OcP4ykGxx9qaAbPHdDejw8HcTDxzI+HqyPDl7iQSkcPMRD5KPDqHDIiQfCgXAg
HOrCQase9spBtR5Szg619bBVDnv10LocvNSDejlwduDskFsPocqhOh8oB4ly+Ccf/kkHxXy4LPX5
kJsOyvmgdng4yocW6eA9HzweHkgH0oF0IB3O+uHasB8eG/3wyuyH69KnH94/H796yGyHEaeHs34Y
3Q5qp4eUdkjth1HtkNMP3tohtx9oB9qhYzt8/vEKGRD3Za5fPrSOBy8BwfGB44NFQHiMh9yA8BUP
1QVBPDSIh+2CuDkpiNsSuyC26mFUQezVw1FBcH7g/OCxHlQKomU9dC8I4iFkPNQXxLoeZimIdT30
KoitehhZENwf+t4frOphwP2BjxfUw4B6qE4I6uGoHuwT4jYoIT6W9IQ4y4eWCZGaDxYJYZUP1glR
mg81CTE6HzweIAzzYegBgnwgH3w3hHI+7DfEx0ZDvIwa4tm5ISpPEM1/R5naD3sNMeoEcdQQvU8Q
6g2hdIJI6YfUhlDvh5yGUOiH3IagH+iHwf1QHBEt/wnr4X+Z8ywgtiIi5QgRLSJKjhCtIuIoIE4i
giNEYUB4iIjIRwgCgoBQCAidisg9QxxVxH2JWRFbBbFXEVYFYV0RnCE4Q1AQ/A0MCiJQQbTPiHvA
jFgnROSM2EuIo4zgEMEhYnRC5GRE9IRwdYigIPwVxHFG3IUz4rZoZ4R1QuxlxFZC9MiIkkvEiIzg
EsG3DKuMaJUQuRlBQpAQWgkxtiNeAzoisyGSOkLtFLHTEV2+aCg1RG1HcIqgIdROETQEDSHYEP1C
4tEwJD6W+D+wzAmJ1scILyHBMYLvGZEiIjck3EREdUkQEaMjgpLwXBIZ54jhnzVaVIT3kuAc4eMc
QUVQEVQEKWGcEuuM2EoJ64zwkhJKB4mTlBieERwkfGSESkrkZERmSpARZIRBRpy3xGPVEm/xlrgv
8VpiqyP2WqJ1R3hpiRlOElYdMeIkYd0ROS1BR4i0RE1GVLcEGWGbEZ9/vLu2xPO4Jdz9BdB1R0Rv
ib2OOGoJbhL+bxKWHTHyJkFH0BF0RJOO0IiJmqNETkxkhoR0TGyFxMiY4Cjh8yiREhKJMSEfEjkx
oRASuTFBSHSpCUJiJyRsamJdEkFqwuyXlzUlYVATsp84SkuioiaGlwRnCc4SlITbkhDJCdGSqMuJ
s8NEj5z4WGL/+nIrJfZyYtRh4igneh8m1HOCwwQpYZ0SmTlBSpASjVKCnvDYExmnCT50ZPQEpwlf
v7xMbYmcngjeEn57gpRwkBJpPfEs7In7QU+8AvTEuiUEeyLcpw5uEz5bItptolVL5PYELUFLCLVE
rKC4L+lBcRITZkFRExM5QTHqOHEUFBwnwh8npowJleMEMUFMqMXEPEVRe54YURRbNaFWFCXniQFF
wXnCvibMi8K6JnKKwltNZBYFNUFN9KmJPknxSEuKpv/2RG1SrHNiKynWOdEiKbZyIjcpcnPCOila
5ETLpOBAwYGCnPD2K0xyYkxOFDVFq38b0/QvjT6W6ZuCjx6JTcGJIt6vMVv0hEpTZPREVVOQE+RE
fk7QFKVNse6J1KZI7Ymcpsi5UVg2RcmN4qgpFG8UPZqCG8W4pqAnBKOCnvDcE+Oj4m30WwrFqLA+
UniJCo4UoY8UYYIiJyoUgiIzKuYLiuqqICgsgiK9Kl4GVfEUqYrcokipipQzRW1VbBXFTlXw6SOh
KBSqwuJMYVUUllURqShyqoKioCimL4rff4TIivvCrzQVDhVHWcGhgkOFSla0SIqWWZGRFC5/STG0
KKqzgqJY/3H5i6xwnBUbScH3j4SkUMgKpUtFQlKEuVSQFPZdMW9SiHSFVFIs/3TFV1PQFXF/V2HV
FDN0BacK/l0KmiLjj1FhQVMoNsXyIyxumWGxjoqUsHidhMVeVKSGxWOJFxZbUbETFnwDSQgLjhUc
K4KFBVGR/QdR0SoqFvOy+GhYFrdFsyzWVdGrLHLOFT3KgnMF5wrlqgh8rqAqsv+gKppWxbKZFh8G
aXHPSwv+PsigtMjNCuu0KM2KmrTgYMEPNgNlxXQ/1qQqHFTFQlpkXixK06ImKzLSgm8hJ1lRmxZc
LGJnRU5atMoKDxeLUVlR3RZkRaes+P3H//3f/wNDBrau
""""""

import sys

best = 0
seen = {}

def run(R, B, rt, bt, cur):
    global best

    if cur + (R + B) / (rt + bt) <= best:
        # print R, B, rt, bt, cur, best, (""<="", (R + B) / (rt + bt))
        return (""<="", (R + B) / (rt + bt))

    if R == B == 0:
        return 0

    if R + B < rt + bt:
        return -1e9

    if rt + bt == R + B and rt > R:
        return -1e9

    if rt + bt <= R + B and (rt + bt) * 2 > R + B:
        return 1

    if bt == -1:
        return run(R, B, 0, rt + bt + 1, cur)

    if rt > R:
        return run(R, B, 0, rt + bt + 1, cur)
    if bt > B:
        return run(R, B, rt + bt - B, B, cur)

    key = (R, B, rt, bt)

    t = seen.get(key, (""<="", 10000))

    if isinstance(t, tuple) and t[1] + cur > best:
        x = run(R - rt, B - bt, rt + 1, bt - 1, cur + 1)
        if isinstance(x, (int, float)):
            x += 1
        else:
            x = (x[0], x[1] + 1)
        y = run(R, B, rt + 1, bt - 1, cur)

        if x < 0:
            t = y
        elif isinstance(x, (int, float)) and isinstance(y, (int, float)):
            t = max(x, y)
        elif isinstance(x, tuple) and isinstance(y, tuple):
            t = (""<="", max(x[1], y[1]))
        elif isinstance(x, int) and isinstance(y, tuple):
            if x >= y[1]:
                t = x
            else:
                t = y
        elif isinstance(x, tuple) and isinstance(y, int):
            if y >= x[1]:
                t = y
            else:
                t = x
                # assert 0, (x, y)
        else:
            assert 0, (x, y)

        # print key, t, (x, y), (cur, best)

        seen[key] = t

        # print key, t
        # if len(seen) % 10000 == 0:
            # print len(seen)

        # cache[ckey] = t
        # print len(cache)

    if isinstance(t, tuple):
        assert t[1] + cur <= best

    # print t
    if isinstance(t, int):
        best = max(best, cur + t)
        # print ""best"", best
    return t

if __name__ == ""__main__"":
    if 'gen' in sys.argv:
        d = {}
        for R in xrange(501):
            for B in xrange(501):
                if R == B == 0:
                    continue

                best = 0
                d[(R, B)] = run(R, B, 0, 1, 0)
                print R, B, d[(R, B)], len(seen)

        with open(""b6.py"", ""w"") as f:
            f.write(""precalc = %r\n\n"" % d)
            f.write(open(__file__).read())
        sys.exit()

    f = sys.stdin

    import zlib
    precalc = eval(zlib.decompress(precalc.decode(""base64"")))

    T = int(f.readline())
    for _T in xrange(T):
        R, B = map(int, f.readline().split())

        best = 1
        ans = precalc[R][B]
        print ""Case #%d: %s"" % (_T + 1, ans)
        # print len(seen)
",,26274,424,745,Python,7706,0000000000049808,00000000000459f3,kmod,2018
9529,0000000000046057.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        C, = map(int, f.readline().split())
        outputs = map(int, f.readline().split())

        if outputs[0] == 0 or outputs[-1] == 0:
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
            continue

        R = 0
        next = 0
        assignments = [-1] * C
        for i in xrange(C):
            for j in xrange(outputs[i]):
                R = max(R, abs(next - i))
                assignments[next] = i
                next += 1
        assert next == C

        # print R, assignments

        print ""Case #%d: %s"" % (_T + 1, R + 1)
        for i in xrange(R):
            for j in xrange(C):
                if j-i >= 0 and assignments[j-i] > j:
                    sys.stdout.write('\\')
                elif j+i < C and assignments[j+i] < j:
                    sys.stdout.write('/')
                else:
                    sys.stdout.write('.')
            sys.stdout.write('\n')
        print '.' * C
",,1043,38,124,Python,7706,0000000000046057,00000000000459f2,kmod,2018
9530,0000000000045df5.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        C, = map(int, f.readline().split())
        outputs = map(int, f.readline().split())

        if outputs[0] == 0 or outputs[-1] == 0:
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
            continue

        R = 0
        next = 0
        assignments = [-1] * C
        for i in xrange(C):
            for j in xrange(outputs[i]):
                R = max(R, abs(next - i))
                assignments[next] = i
                next += 1
        assert next == C

        print R, assignments

        print ""Case #%d: %s"" % (_T + 1, R + 1)
        for i in xrange(R):
            for j in xrange(C):
                if j-i >= 0 and assignments[j-i] > j:
                    sys.stdout.write('\\')
                elif j+i < C and assignments[j+i] < j:
                    sys.stdout.write('/')
                else:
                    sys.stdout.write('.')
            sys.stdout.write('\n')
        print '.' * C
",,1041,38,123,Python,7706,0000000000045df5,00000000000459f2,kmod,2018
45106,000000000003a9ae.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append([int(s) - 1 for s in f.readline().split()])
        G = map(int, f.readline().split())
        # print G

        while True:
            tomake = [0] * M
            q = {0: 1}

            done = False
            while q:
                x = iter(q).next()
                amnt = q[x]
                q.pop(x)

                tomake[x] += amnt
                a, b = R[x]
                tomake[a] -= amnt
                tomake[b] -= amnt
                if -tomake[a] > G[a]:
                    q[a] = -tomake[a] - G[a]
                if -tomake[b] > G[b]:
                    q[b] = -tomake[b] - G[b]
    
                if -sum(tomake) > sum(G):
                    done = True
                    break

            if done:
                break
            if tomake[0] < 0:
                break

            numtimes = 1e9
            for i in xrange(M):
                if tomake[i] >= 0:
                    continue
                numtimes = min(numtimes, G[i] / -tomake[i])

            # print ""%dx"" % numtimes, tomake
            for i in xrange(M):
                G[i] += tomake[i] * numtimes
                assert G[i] >= 0
            # print G

        print ""Case #%d: %s"" % (_T + 1, G[0])
",,1423,56,159,Python,7764,000000000003a9ae,000000000003675c,kmod,2018
45107,000000000003a7b1.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append([int(s) - 1 for s in f.readline().split()])
        G = map(int, f.readline().split())
        # print G

        while True:
            tomake = [0] * M
            q = {0: 1}

            done = False
            while q:
                x = iter(q).next()
                amnt = q[x]
                q.pop(x)

                tomake[x] += amnt
                a, b = R[x]
                tomake[a] -= amnt
                tomake[b] -= amnt
                if -tomake[a] > G[a]:
                    q[a] = -tomake[a] - G[a]
                if -tomake[b] > G[b]:
                    q[b] = -tomake[b] - G[b]
    
                if -sum(tomake) > sum(G):
                    done = True
                    break

            if done:
                break

            numtimes = 1e9
            for i in xrange(M):
                if tomake[i] >= 0:
                    continue
                numtimes = min(numtimes, G[i] / -tomake[i])

            # print ""%dx"" % numtimes, tomake
            for i in xrange(M):
                G[i] += tomake[i] * numtimes
                assert G[i] >= 0
            # print G

        print ""Case #%d: %s"" % (_T + 1, G[0])
",,1371,54,154,Python,7764,000000000003a7b1,000000000003675c,kmod,2018
45108,000000000003a6b8.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append([int(s) - 1 for s in f.readline().split()])
        G = map(int, f.readline().split())
        # print G

        while True:
            tomake = [0] * M
            q = {0: 1}

            done = False
            while q:
                if -sum(tomake) > sum(G):
                    done = True
                    break
                x = iter(q).next()
                amnt = q[x]
                q.pop(x)

                tomake[x] += amnt
                a, b = R[x]
                tomake[a] -= amnt
                tomake[b] -= amnt
                if -tomake[a] > G[a]:
                    q[a] = -tomake[a] - G[a]
                if -tomake[b] > G[b]:
                    q[b] = -tomake[b] - G[b]
    
            if done:
                break

            numtimes = 1e9
            for i in xrange(M):
                if tomake[i] >= 0:
                    continue
                numtimes = min(numtimes, G[i] / -tomake[i])

            # print ""%dx"" % numtimes, tomake
            for i in xrange(M):
                G[i] += tomake[i] * numtimes
            # print G

        print ""Case #%d: %s"" % (_T + 1, G[0])
",,1337,52,150,Python,7764,000000000003a6b8,000000000003675c,kmod,2018
45109,000000000003a44c.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append([int(s) - 1 for s in f.readline().split()])
        G = map(int, f.readline().split())
        # print G

        while True:
            tomake = [0] * M
            q = {0: 1}

            done = False
            while q:
                if sum(q.values()) > sum(G):
                    done = True
                    break
                x = iter(q).next()
                amnt = q[x]
                q.pop(x)

                tomake[x] += amnt
                a, b = R[x]
                tomake[a] -= amnt
                tomake[b] -= amnt
                if -tomake[a] > G[a]:
                    q[a] = -tomake[a] - G[a]
                if -tomake[b] > G[b]:
                    q[b] = -tomake[b] - G[b]
    
            if done:
                break

            numtimes = 1e9
            for i in xrange(M):
                if tomake[i] >= 0:
                    continue
                numtimes = min(numtimes, G[i] / -tomake[i])

            # print ""%dx"" % numtimes, tomake
            for i in xrange(M):
                G[i] += tomake[i] * numtimes
            # print G

        print ""Case #%d: %s"" % (_T + 1, G[0])
",,1340,52,150,Python,7764,000000000003a44c,000000000003675c,kmod,2018
45110,00000000000394b9.PYTHON,"import sys

def run(D, A, B):
    msets = {}
    nsets = {}
    asets = []
    bsets = []
    for i, (d, a, b) in enumerate(zip(D, A, B)):
        m = msets.setdefault(d + a, [])
        m.append(i)
        asets.append(m)
        n = nsets.setdefault(d - b, [])
        n.append(i)
        bsets.append(n)

    cur = 0
    best = [0]
    bestset = set()
    def rangeto(next):
        length = next - cur + 1
        if length > best[0]:
            best[0] = length
            bestset.clear()
            bestset.add(cur)
        elif length == best[0]:
            bestset.add(cur)

        # print ""Range found: [%d,%d]"" % (cur, next)

    # print
    for A, B, M, N in ((asets, bsets, msets, nsets), (bsets, asets, nsets, msets)):
        cur = 0
        dont_recheck = set()
        for cur in xrange(S):
            if cur in dont_recheck:
                continue

            a = A[cur]
            if cur > 0 and a is A[cur-1]:
                continue

            samea = []
            # print a
            for next in xrange(cur + 1, S):
                if next in a:
                    continue
                b = B[next]
                # print a, b
                for check in xrange(next + 1, S):
                    # print cur, next, check
                    if check in a:
                        samea.append(check)
                        continue
                    if check in b:
                        for x in samea:
                            dont_recheck.add(x)
                            del samea[:]
                        continue
                    # print ""Stopped: %d %d %d"" % (cur, next, check)
                    rangeto(check-1)
                    break
                else:
                    # print ""%d got to end case 2"" % cur, ""BA""[A is asets]
                    rangeto(S-1)

                break
            else:
                # print ""%d got to end"" % cur, ""BA""[A is asets]
                rangeto(S-1)


    return best[0], len(bestset)

def brute(D, A, B):
    msets = {}
    nsets = {}
    asets = []
    bsets = []
    for i, (d, a, b) in enumerate(zip(D, A, B)):
        m = msets.setdefault(d + a, [])
        m.append(i)
        asets.append(m)
        n = nsets.setdefault(d - b, [])
        n.append(i)
        bsets.append(n)

    best = 0
    numbest = 0
    for i in xrange(S):
        for j in xrange(i, S):
            if (j - i + 1) < best:
                continue

            a = asets[i]
            b = None
            works1 = True
            for x in xrange(i, j + 1):
                if x in a:
                    continue
                if b is None:
                    b = bsets[x]
                elif b is not bsets[x]:
                    works1 = False
                    break

            a = bsets[i]
            b = None
            works2 = True
            for x in xrange(i, j + 1):
                if x in a:
                    continue
                if b is None:
                    b = asets[x]
                elif b is not asets[x]:
                    works2 = False
                    break

            if works1 or works2:
                if j - i + 1 > best:
                    best = j - i + 1
                    numbest = 0
                numbest += 1
            else:
                break
                # print i, j, best, numbest, works1, works2
    return best, numbest

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        S = int(f.readline())

        l = [map(int, f.readline().split()) for i in xrange(S)]
        D, A, B = zip(*l)

        check = brute(D, A, B)
        ans = run(D, A, B)
        assert check == ans, (check, ans)
        print ""Case #%d: %s %s"" % (_T + 1, ans[0], ans[1])

    '''
    S = 10000
    for i in xrange(100000):
        print i
        import random
        random.seed(12345)
        D = [random.randint(0, 100) for i in xrange(S)]
        D.sort()
        A = [random.randint(0, 100) for i in xrange(S)]
        B = [random.randint(0, 100) for i in xrange(S)]

        import time
        start = time.time()
        print time.time()
        ans = run(D, A, B)
        print time.time()
        check = brute(D, A, B)
        print time.time()

        # print D
        # print A
        # print B
        assert check == ans, (check, ans)
    '''
",,4377,167,534,Python,7764,00000000000394b9,000000000003675b,kmod,2018
45111,0000000000038978.PYTHON,"import sys

def run(D, A, B):
    msets = {}
    nsets = {}
    asets = []
    bsets = []
    for i, (d, a, b) in enumerate(zip(D, A, B)):
        m = msets.setdefault(d + a, [])
        m.append(i)
        asets.append(m)
        n = nsets.setdefault(d - b, [])
        n.append(i)
        bsets.append(n)

    cur = 0
    best = [0]
    bestset = set()
    def rangeto(next):
        length = next - cur + 1
        if length > best[0]:
            best[0] = length
            bestset.clear()
            bestset.add(cur)
        elif length == best[0]:
            bestset.add(cur)

        # print ""Range found: [%d,%d]"" % (cur, next)

    # print
    for A, B, M, N in ((asets, bsets, msets, nsets), (bsets, asets, nsets, msets)):
        cur = 0
        while True:
            nextcur = -1
            a = A[cur]
            # print a
            for next in xrange(cur + 1, S):
                if next in a:
                    continue
                b = B[next]
                # print a, b
                for check in xrange(next + 1, S):
                    # print cur, next, check
                    if check in a or check in b:
                        continue
                    # print ""Stopped: %d %d %d"" % (cur, next, check)
                    rangeto(check-1)
                    nextcur = max(nextcur, check)
                    break
                else:
                    # print ""%d got to end case 2"" % cur, ""BA""[A is asets]
                    rangeto(S-1)
                    nextcur = max(nextcur, S)

                break
            else:
                # print ""%d got to end"" % cur, ""BA""[A is asets]
                rangeto(S-1)
                nextcur = max(nextcur, S)

            cur = nextcur
            if cur >= S:
                break

    return best[0], len(bestset)

def brute(D, A, B):
    msets = {}
    nsets = {}
    asets = []
    bsets = []
    for i, (d, a, b) in enumerate(zip(D, A, B)):
        m = msets.setdefault(d + a, [])
        m.append(i)
        asets.append(m)
        n = nsets.setdefault(d - b, [])
        n.append(i)
        bsets.append(n)

    best = 0
    numbest = 0
    for i in xrange(S):
        for j in xrange(i, S):
            if (j - i + 1) < best:
                continue

            a = asets[i]
            b = None
            works1 = True
            for x in xrange(i, j + 1):
                if x in a:
                    continue
                if b is None:
                    b = bsets[x]
                elif b is not bsets[x]:
                    works1 = False
                    break

            a = bsets[i]
            b = None
            works2 = True
            for x in xrange(i, j + 1):
                if x in a:
                    continue
                if b is None:
                    b = asets[x]
                elif b is not asets[x]:
                    works2 = False
                    break

            if works1 or works2:
                if j - i + 1 > best:
                    best = j - i + 1
                    numbest = 0
                numbest += 1
                # print i, j, best, numbest
    return best, numbest

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        S = int(f.readline())

        l = [map(int, f.readline().split()) for i in xrange(S)]
        D, A, B = zip(*l)

        check = brute(D, A, B)
        ans = run(D, A, B)
        assert check == ans, (check, ans)
        print ""Case #%d: %s %s"" % (_T + 1, ans[0], ans[1])
",,3546,133,447,Python,7764,0000000000038978,000000000003675b,kmod,2018
45112,00000000000384c3.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        S = int(f.readline())

        msets = {}
        nsets = {}
        asets = []
        bsets = []
        for i in xrange(S):
            d, a, b = map(int, f.readline().split())
            m = msets.setdefault(d + a, [])
            m.append(i)
            asets.append(m)
            n = nsets.setdefault(d - b, [])
            n.append(i)
            bsets.append(n)

        cur = 0
        best = [0]
        bestset = set()
        def rangeto(next):
            length = next - cur + 1
            if length > best[0]:
                best[0] = length
                bestset.clear()
                bestset.add(cur)
            elif length == best[0]:
                bestset.add(cur)

            # print ""Range found: [%d,%d]"" % (cur, next)

        # print
        for A, B, M, N in ((asets, bsets, msets, nsets), (bsets, asets, nsets, msets)):
            cur = 0
            while True:
                nextcur = -1
                a = A[cur]
                # print a
                for next in xrange(cur + 1, S):
                    if next in a:
                        continue
                    b = B[next]
                    # print a, b
                    for check in xrange(next + 1, S):
                        # print cur, next, check
                        if check in a or check in b:
                            continue
                        # print ""Stopped: %d %d %d"" % (cur, next, check)
                        rangeto(check-1)
                        nextcur = max(nextcur, check)
                        break
                    else:
                        # print ""%d got to end case 2"" % cur, ""BA""[A is asets]
                        rangeto(S-1)
                        nextcur = max(nextcur, S)

                    break
                else:
                    # print ""%d got to end"" % cur, ""BA""[A is asets]
                    rangeto(S-1)
                    nextcur = max(nextcur, S)

                cur = nextcur
                if cur >= S:
                    break

        print ""Case #%d: %s %s"" % (_T + 1, best[0], len(bestset))
",,2213,73,239,Python,7764,00000000000384c3,000000000003675b,kmod,2018
45113,0000000000037376.PYTHON,"import sys

def run(N, chosen):
    left = N - sum(chosen)

    frac = (100.0 / N)
    frac -= int(frac)
    if frac >= 0.5:
        for i in xrange(left):
            chosen.append(1)
        ans = sum([round(x * 100.0 / N) for x in chosen])
    else:
        fracs = [x * 100.0 / N - round(x * 100.0 / N) for x in chosen]
        for i in xrange(left):
            fracs.append(0.0)
        fracs.sort(reverse=True)
        assert fracs[0] < 0.5
        ans = None

        for i in xrange(len(fracs)):
            while True:
                assert fracs[i] >= 0
                assert fracs[i] <= 1
                fracs[i] += frac
                left -= 1
                if fracs[i] >= 0.5 or not left:
                    break
            if not left:
                break
        assert left == 0, left
        ans = 100 + sum([round(x + 1) - x - 1 for x in fracs])
    ans = int(round(ans))
    return ans

def brute(N, chosen, lastpicked):
    left = N - sum(chosen)

    if not left:
        return int(round(sum([round(x * 100.0 / N) for x in chosen])))

    best = 0
    for i in xrange(lastpicked, len(chosen)):
        if i and chosen[i] == chosen[i-1]:
            continue
        chosen[i] += 1
        best = max(best, brute(N, chosen, i))
        chosen[i] -= 1
    return best

def gen(cur, left):
    if not left:
        return

    max = left
    if cur:
        max = min(cur[-1], left)
    cur.append(0)
    for i in xrange(1, max + 1):
        cur[-1] = i
        yield tuple(cur)
        for x in gen(cur, left - i):
            yield x
    cur.pop()

if __name__ == ""__main__"":
    f = sys.stdin

    """"""
    for i in xrange(2, 260):
        run(i, [1])
        print i
        for t in gen([], i - 1):
            print i, t
            a = run(i, list(t))
            b = brute(i, list(t) + [0] * (i - sum(t)), 0)
            assert a == b, (a, b)
    """"""

    T = int(f.readline())
    for _T in xrange(T):
        N, _ = map(int, f.readline().split())
        chosen = map(int, f.readline().split())

        ans = run(N, chosen)
        print ""Case #%d: %s"" % (_T + 1, ans)
",,2111,86,294,Python,7764,0000000000037376,0000000000036601,kmod,2018
45114,00000000000370d7.PYTHON,"import sys

def run(N, chosen):
    left = N - sum(chosen)

    frac = (100.0 / N)
    frac -= int(frac)
    if frac >= 0.5:
        for i in xrange(left):
            chosen.append(1)
        ans = int(round(sum([round(x * 100.0 / N) for x in chosen])))
    else:
        fracs = [x * 100.0 / N - round(x * 100.0 / N) for x in chosen]
        for i in xrange(left):
            fracs.append(0.0)
        fracs.sort(reverse=True)
        assert fracs[0] < 0.5
        ans = None

        for i in xrange(len(fracs)):
            while True:
                assert fracs[i] >= 0
                assert fracs[i] <= 1
                fracs[i] += frac
                left -= 1
                if fracs[i] >= 0.5 or not left:
                    break
            if not left:
                break
        assert left == 0, left
        ans = 100 + sum([round(x) - x for x in fracs])
    ans = int(round(ans))
    return ans

def gen(cur, left):
    if not left:
        return

    max = left
    if cur:
        max = min(cur[-1], left)
    cur.append(0)
    for i in xrange(1, max + 1):
        cur[-1] = i
        yield tuple(cur)
        for x in gen(cur, left - i):
            yield x
    cur.pop()

if __name__ == ""__main__"":
    f = sys.stdin

    """"""
    for i in xrange(2, 260):
        run(i, [1])
        print i
        for t in gen([], i - 1):
            # print i, t
            run(i, list(t))
    """"""

    T = int(f.readline())
    for _T in xrange(T):
        N, _ = map(int, f.readline().split())
        chosen = map(int, f.readline().split())

        ans = run(N, chosen)
        print ""Case #%d: %s"" % (_T + 1, ans)
",,1638,69,221,Python,7764,00000000000370d7,0000000000036601,kmod,2018
45115,0000000000036dfc.PYTHON,"import sys

def run(N, chosen):
    left = N - sum(chosen)

    frac = (100.0 / N)
    frac -= int(frac)
    if frac >= 0.5:
        for i in xrange(left):
            chosen.append(1)
        ans = int(sum([round(x * 100.0 / N) for x in chosen]))
    else:
        fracs = [x * 100.0 / N - round(x * 100.0 / N) for x in chosen]
        for i in xrange(left):
            fracs.append(0.0)
        fracs.sort(reverse=True)
        assert fracs[0] < 0.5
        ans = None

        for i in xrange(len(fracs)):
            while True:
                assert fracs[i] >= 0
                assert fracs[i] <= 1
                fracs[i] += frac
                left -= 1
                if fracs[i] >= 0.5 or not left:
                    break
            if not left:
                break
        assert left == 0, left
        ans = 100 + sum([round(x) - x for x in fracs])
    ans = int(round(ans))
    return ans

if __name__ == ""__main__"":
    f = sys.stdin

    # for i in xrange(2, 100):
        # run(i, [1])

    T = int(f.readline())
    for _T in xrange(T):
        N, _ = map(int, f.readline().split())
        chosen = map(int, f.readline().split())

        ans = run(N, chosen)
        print ""Case #%d: %s"" % (_T + 1, ans)
",,1236,48,167,Python,7764,0000000000036dfc,0000000000036601,kmod,2018
45116,0000000000036e96.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N, _ = map(int, f.readline().split())
        chosen = map(int, f.readline().split())

        left = N - sum(chosen)

        frac = (100.0 / N)
        frac -= int(frac)
        if frac >= 0.5:
            for i in xrange(left):
                chosen.append(1)
            ans = int(sum([round(x * 100.0 / N) for x in chosen]))
        else:
            fracs = [x * 100.0 / N - round(x * 100.0 / N) for x in chosen]
            for i in xrange(left):
                fracs.append(0.0)
            fracs.sort(reverse=True)
            assert fracs[0] < 0.5
            ans = None

            for i in xrange(len(fracs)):
                while True:
                    assert fracs[i] >= 0
                    assert fracs[i] <= 1
                    fracs[i] += frac
                    left -= 1
                    if fracs[i] >= 0.5 or not left:
                        break
                if not left:
                    break
            assert left == 0, left
            ans = 100 + sum([round(x) - x for x in fracs])
        assert round(ans) == ans
        ans = int(ans)

        print ""Case #%d: %s"" % (_T + 1, ans)
",,1252,43,153,Python,7764,0000000000036e96,0000000000036601,kmod,2018
102776,0000000000029f52.PYTHON,"import sys
from math import cos, sin, atan2, pi

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        A = float(f.readline())

        r1 = 0.0
        r2 = 0.0

        def faces(r1, r2):
            v1 = [0.5, 0, 0]
            v2 = [0, 0.5, 0]
            v3 = [0, 0, 0.5]

            def rot1(v):
                c = cos(r1)
                s = sin(r1)
                return [c * v[0] + s * v[1], c * v[1] - s * v[0], v[2]]

            v1 = rot1(v1)
            v2 = rot1(v2)
            v3 = rot1(v3)

            def rot2(v):
                c = cos(r2)
                s = sin(r2)
                return [c * v[0] + s * v[2], v[1], c * v[2] - s * v[0]]

            v1 = rot2(v1)
            v2 = rot2(v2)
            v3 = rot2(v3)

            return v1, v2, v3

        def area(r1, r2):
            v1, v2, v3 = fcs = faces(r1, r2)
            # print v1
            # print v2
            # print v3

            verts = []
            mul = [(x1, x2, x3) for x1 in (-1, 1) for x2 in (-1, 1) for x3 in (-1, 1)]
            for m in mul:
                v = [0.0, 0.0, 0.0]
                for i in xrange(3):
                    for j in xrange(3):
                        v[i] += fcs[j][i] * m[j]
                verts.append(v[1:])
            '''
            verts = [(v1 * x1 + v2 * x2 + v3 * x3)[1:] for x1 in (1, -1) for x2 in (1, -1) for x3 in (1, -1)]
            # print verts
            '''

            hull = []

            for v in verts:
                for v2 in verts:
                    if v[0] * v2[0] < 0 or v[1] * v2[1] < 0:
                        continue
                    if abs(v[0]) < abs(v2[0]) and abs(v[1]) < abs(v2[1]):
                        break
                else:
                    hull.append(v)

            hull.sort(key=lambda x: atan2(*x))

            total = 0.0
            for i in xrange(0, len(hull)):
                total += hull[i - 1][1] * hull[i][0] - hull[i - 1][0] * hull[i][1]
            total *= 0.5
            # print hull
            # print total
            return total

        if A < area(pi/4, 0):
            l, h = 0, pi/4

            for i in xrange(100):
                g = 0.5 * (l + h)
                if area(g, 0) > A:
                    h = g
                else:
                    l = g
            r1, r2 = (l + h) * 0.5, 0
        else:
            l, h = 0, 0.61548

            for i in xrange(100):
                g = 0.5 * (l + h)
                if area(pi/4, g) > A:
                    h = g
                else:
                    l = g
            r1, r2 = pi/4, (l + h) * 0.5

        fcs = faces(r1, r2)
        print ""Case #%d:"" % (_T + 1,)
        for v in fcs:
            print ""%r %r %r"" % tuple(v)
",,2876,108,404,Python,00000000000000cb,0000000000029f52,00000000000079cc,kmod,2018
102777,000000000002994a.PYTHON,"import sys
from math import cos, sin, atan2, pi
import numpy as np

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        A = float(f.readline())

        r1 = 0.0
        r2 = 0.0

        def faces(r1, r2):
            v1 = np.array([0.5, 0, 0])
            v2 = np.array([0, 0.5, 0])
            v3 = np.array([0, 0, 0.5])

            rot1 = np.array([
                [cos(r1), sin(r1), 0],
                [-sin(r1), cos(r1), 0],
                [0, 0, 1]
                ])

            v1 = v1.dot(rot1)
            v2 = v2.dot(rot1)
            v3 = v3.dot(rot1)

            rot2 = np.array([
                [cos(r2), 0, sin(r2)],
                [0, 1, 0],
                [-sin(r2), 0, cos(r2)],
                ])

            v1 = v1.dot(rot2)
            v2 = v2.dot(rot2)
            v3 = v3.dot(rot2)

            return v1, v2, v3

        def area(r1, r2):
            v1, v2, v3 = faces(r1, r2)
            # print v1
            # print v2
            # print v3

            verts = [(v1 * x1 + v2 * x2 + v3 * x3)[1:] for x1 in (1, -1) for x2 in (1, -1) for x3 in (1, -1)]
            # print verts

            hull = []

            for v in verts:
                for v2 in verts:
                    if any(v * v2 < 0):
                        continue
                    if abs(v[0]) < abs(v2[0]) and abs(v[1]) < abs(v2[1]):
                        break
                else:
                    hull.append(v)

            hull.sort(key=lambda x: atan2(*x))

            total = 0.0
            for i in xrange(0, len(hull)):
                total += hull[i - 1][1] * hull[i][0] - hull[i - 1][0] * hull[i][1]
            total *= 0.5
            # print hull
            # print total
            return total

        if A < area(pi/4, 0):
            l, h = 0, pi/4

            for i in xrange(100):
                g = 0.5 * (l + h)
                if area(g, 0) > A:
                    h = g
                else:
                    l = g
            r1, r2 = (l + h) * 0.5, 0
        else:
            l, h = 0, 0.61548

            for i in xrange(100):
                g = 0.5 * (l + h)
                if area(pi/4, g) > A:
                    h = g
                else:
                    l = g
            r1, r2 = pi/4, (l + h) * 0.5

        fcs = faces(r1, r2)
        print ""Case #%d:"" % (_T + 1,)
        for v in fcs:
            print ""%r %r %r"" % tuple(v)
",,2560,101,330,Python,00000000000000cb,000000000002994a,00000000000079cc,kmod,2018
102778,0000000000028d1e.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        A = int(f.readline())

        hit = set()

        target = 2

        def hitall(targets):
            while any(t not in hit for t in targets):
                print target, 2
                sys.stdout.flush()
                i, j = map(int, f.readline().split())
                hit.add((i, j))
                # print >>sys.stderr, (target, 2), (i, j)
                if i == 0:
                    break

        while True:
            hitall([(target - 1, i) for i in [1, 2, 3]])

            if (target + 1) * 3 >= A:
                break

            target += 1
            # print >>sys.stderr, target

        # print >>sys.stderr, target
        if (0, 0) not in hit:
            hitall([(target, i) for i in [1, 2, 3]])
        if (0, 0) not in hit:
            hitall([(target + 1, i) for i in [1, 2, 3]])
        assert (0, 0) in hit
",,1069,43,140,Python,00000000000000cb,0000000000028d1e,0000000000007a30,kmod,2018
102779,0000000000028213.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())
        A = map(int, f.readline().split())

        s1 = A[::2]
        s2 = A[1::2]
        s1.sort()
        s2.sort()
        A[::2] = s1
        A[1::2] = s2

        ans = ""OK""
        for i in xrange(len(A) - 1):
            if A[i] > A[i+1]:
                ans = i
                break

        print ""Case #%d: %s"" % (_T + 1, ans)
",,579,29,77,Python,00000000000000cb,0000000000028213,00000000000079cb,kmod,2018
102780,0000000000028075.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        D, P = f.readline().split()
        D = int(D)
        N = len(P)

        def damage():
            power = 1
            damage = 0
            for c in P:
                if c == ""S"":
                    damage += power
                else:
                    power *= 2
            return damage

        swaps = 0

        # print D, P, damage()

        while damage() > D:
            for i in xrange(N-2, -1, -1):
                if P[i:i+2] == ""CS"":
                    # print P, damage(), ""->"",
                    P = P[:i] + ""SC"" + P[i+2:]
                    swaps += 1
                    # print P, damage()
                    break
            else:
                break

        if damage() > D:
            ans = ""IMPOSSIBLE""
        else:
            ans = swaps


        print ""Case #%d: %s"" % (_T + 1, ans)
",,1050,48,129,Python,00000000000000cb,0000000000028075,0000000000007966,kmod,2018
263118,00000000000015f7.PYTHON,"import sys

f = sys.stdin
T = int(f.readline())

for _t in xrange(T):
    a, b = map(int, f.readline().split())
    n, = map(int, f.readline().split())
    
    while True:
        g = (a + b + 1) / 2
        print g
        sys.stdout.flush()
        resp = f.readline().strip()
        if resp == ""TOO_SMALL"":
            a = g
        elif resp == ""TOO_BIG"":
            b = g - 1
        elif resp == ""CORRECT"":
            break
        else:
            raise Exception(resp)",,481,22,62,Python,130,00000000000015f7,0000000000000523,kmod,2018
263119,000000000000151b.PYTHON,"import sys

f = sys.stdin
T = int(f.readline())

for _t in xrange(T):
    D, N = map(int, f.readline().split())
    maxt = 0
    for i in xrange(N):
        start, speed = map(int, f.readline().split())
        maxt = max(maxt, (D-start)*1.0/speed)
    print ""Case #%d: %f"" % (_t+1, D / maxt)",,292,12,42,Python,130,000000000000151b,0000000000000524,kmod,2018
16228,000000000014d13c.PYPY2,"import math
import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append(map(int, f.readline().split()))
        G = map(int, f.readline().split())

        maxes = [0] * M
        maxes[0] = 1
        for i in xrange(10000):
            for i in xrange(M):
                a, b = R[i]
                a -= 1
                b -= 1
                maxes[i] = max(maxes[i], maxes[a] + maxes[b])

        total = 0
        for i in xrange(M):
            if G[i]:
                total += maxes[i] * G[i]

        if total > 1e300:
            print ""Case #%d: UNBOUNDED"" % (_T + 1,)
        else:
            print ""Case #%d: %d"" % (_T + 1, total % 1000000007)

",,803,34,104,Python,0000000000051679,000000000014d13c,0000000000146185,kmod,2019
16229,000000000014ccef.PYPY2,"import math
import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append(map(int, f.readline().split()))
        G = map(int, f.readline().split())

        maxes = [0] * M
        maxes[0] = 1
        for i in xrange(10000):
            for i in xrange(M):
                a, b = R[i]
                a -= 1
                b -= 1
                maxes[i] = max(maxes[i], maxes[a] + maxes[b])

        total = 0
        for i in xrange(M):
            if G[i]:
                total += maxes[i] * G[i]

        if total > 1e300:
            print ""Case #%d: UNBOUNDED"" % (_T + 1,)
        else:
            print ""Case #%d: %d"" % (_T + 1, int(total) % 1000000007)

",,808,34,104,Python,0000000000051679,000000000014ccef,0000000000146185,kmod,2019
16230,000000000014ca5a.PYPY2,"import math
import sys

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        M = int(f.readline())
        R = []
        for i in xrange(M):
            R.append(map(int, f.readline().split()))
        G = map(int, f.readline().split())

        maxes = [0.0] * M
        maxes[0] = 1.0
        for i in xrange(10000):
            for i in xrange(M):
                a, b = R[i]
                a -= 1
                b -= 1
                maxes[i] = max(maxes[i], maxes[a] + maxes[b])

        total = 0
        for i in xrange(M):
            if G[i]:
                total += maxes[i] * G[i]

        if math.isinf(total):
            print ""Case #%d: UNBOUNDED"" % (_T + 1,)
        else:
            print ""Case #%d: %d"" % (_T + 1, int(total) % 1000000007)

",,816,34,102,Python,0000000000051679,000000000014ca5a,0000000000146185,kmod,2019
16231,000000000014befe.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        token_last = [0] * 21
        token_last[0] = None
        token_last[20] = 1
        token_uncertainty = [0] * 21
        contents = [None] * 21
        for d in xrange(1, 101):
            _ = f.readline()
            assert _

            if d <= 99:
                for i in xrange(1, 21):
                    token_uncertainty[i] += 1

            X = _T
            def add(g, d):
                g = (g + X - 1) % 20 + 1
                print g, d

            def read(g):
                add(g, 0)
                sys.stdout.flush()
                A = map(int, f.readline().split())
                assert A
                contents[g] = A[1:]
                if g == 20:
                    contents[g].append(100)
                # if V:
                    # print len(contents[g])
                token_last[g] = len(contents[g])
                token_uncertainty[g] = 0

            def guessbest():
                if V:
                    print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                l = range(1, 21)
                l.sort(key=lambda x: token_last[x] + 0.01 * token_uncertainty[x])
                g = l[1]
                add(g, d)
                token_last[g] += 1

            if d <= 19:
                add(d, 100)
                token_last[d] += 1
            elif d == 100:
                add(20, 100)
                token_last[20] += 1
            else:
                if d < 50:
                    add((d % 19) + 1, d)
                elif d < 70:
                    g = (d % 20) + 1
                    read(g)
                else:
                    guessat = sorted(set(token_last[1:]))[-1]
                    g = None
                    g_uncertainty = -1
                    for x in xrange(1, 21):
                        if token_last[x] != guessat:
                            continue
                        if token_uncertainty[x] > g_uncertainty:
                            g_uncertainty = token_uncertainty[x]
                            g = x
                    if V:
                        print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                    if g_uncertainty < 30:
                        guessbest()
                    else:
                        read(g)
            sys.stdout.flush()

",,2452,80,229,Python,0000000000051679,000000000014befe,00000000001461c8,kmod,2019
16232,000000000014bc59.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        token_last = [0] * 21
        token_last[0] = None
        token_last[20] = 1
        token_uncertainty = [0] * 21
        contents = [None] * 21
        for d in xrange(1, 101):
            _ = f.readline()
            assert _

            if d <= 99:
                for i in xrange(1, 21):
                    token_uncertainty[i] += 1

            X = _T
            def add(g, d):
                g = (g + X - 1) % 20 + 1
                print g, d

            def read(g):
                add(g, 0)
                sys.stdout.flush()
                A = map(int, f.readline().split())
                assert A
                contents[g] = A[1:]
                if g == 20:
                    contents[g].append(100)
                # if V:
                    # print len(contents[g])
                token_last[g] = len(contents[g])
                token_uncertainty[g] = 0

            def guessbest():
                if V:
                    print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                l = range(1, 21)
                l.sort(key=lambda x: token_last[x] + 0.01 * token_uncertainty[x])
                g = l[1]
                add(g, d)
                token_last[g] += 1

            if d <= 19:
                add(d, 100)
                token_last[d] += 1
            elif d == 100:
                add(20, 100)
                token_last[20] += 1
            else:
                if d < 50:
                    add((d % 19) + 1, d)
                elif d < 70:
                    g = (d % 20) + 1
                    read(g)
                else:
                    guessat = sorted(set(token_last[1:-1]))
                    g = None
                    g_uncertainty = -1
                    for x in xrange(1, 20):
                        if token_last[x] != guessat:
                            continue
                        if token_uncertainty[x] > g_uncertainty:
                            g_uncertainty = token_uncertainty[x]
                            g = x
                    if V:
                        print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                    if g_uncertainty < 30:
                        guessbest()
                    else:
                        read(g)
            sys.stdout.flush()

",,2450,80,229,Python,0000000000051679,000000000014bc59,00000000001461c8,kmod,2019
16233,000000000014b43c.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        token_last = [0] * 21
        token_last[0] = None
        token_last[20] = 1
        token_uncertainty = [0] * 21
        contents = [None] * 21
        for d in xrange(1, 101):
            _ = f.readline()
            assert _

            if d <= 99:
                for i in xrange(1, 21):
                    token_uncertainty[i] += 1

            def read(g):
                print g, 0
                sys.stdout.flush()
                A = map(int, f.readline().split())
                assert A
                contents[g] = A[1:]
                if g == 20:
                    contents[g].append(100)
                # if V:
                    # print len(contents[g])
                token_last[g] = len(contents[g])
                token_uncertainty[g] = 0

            def guessbest():
                if V:
                    print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                l = range(1, 21)
                l.sort(key=lambda x: token_last[x] + 0.01 * token_uncertainty[x])
                g = l[1]
                print g, d
                token_last[g] += 1

            if d <= 19:
                print d, 100
                token_last[d] += 1
            elif d == 100:
                print 20, 100
                token_last[20] += 1
            else:
                if d < 60:
                    print (d % 19) + 1, d
                elif d < 80:
                    g = (d % 20) + 1
                    read(g)
                elif 78 <= d < 192:
                    guessat = sorted(set(token_last[1:]))[1]
                    g = None
                    g_uncertainty = -1
                    for x in xrange(1, 20):
                        if token_last[x] != guessat:
                            continue
                        if token_uncertainty[x] > g_uncertainty:
                            g_uncertainty = token_uncertainty[x]
                            g = x
                    if V:
                        print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                    if g_uncertainty < 20:
                        guessbest()
                    else:
                        read(g)
                else:
                    guessbest()
            sys.stdout.flush()

",,2409,77,221,Python,0000000000051679,000000000014b43c,00000000001461c8,kmod,2019
16234,000000000014b1f2.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())
        M = []
        for i in xrange(N):
            M.append(map(int, f.readline().split()))

        best = None
        for C in xrange(1, 1000):
            for J in xrange(1, 1000):
                works = True
                for i in xrange(N - 1):
                    if C * M[i][0] + J * M[i][1] >= C * M[i+1][0] + J * M[i+1][1]:
                        works = False
                if works:
                    best = C, J
                    break
            if best:
                break

        if best:
            print ""Case #%d: %d %d"" % (_T + 1, best[0], best[1])
        else:
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)

",,818,33,106,Python,0000000000051679,000000000014b1f2,0000000000146184,kmod,2019
16235,000000000014b215.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())
        M = []
        for i in xrange(N):
            M.append(map(int, f.readline().split()))

        best = None
        for C in xrange(1, 100):
            for J in xrange(1, 100):
                works = True
                for i in xrange(N - 1):
                    if C * M[i][0] + J * M[i][1] >= C * M[i+1][0] + J * M[i+1][1]:
                        works = False
                if works:
                    best = C, J
                    break
            if best:
                break

        if best:
            print ""Case #%d: %d %d"" % (_T + 1, best[0], best[1])
        else:
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)

",,816,33,106,Python,0000000000051679,000000000014b215,0000000000146184,kmod,2019
16236,000000000014aff1.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        token_last = [0] * 21
        token_last[0] = None
        token_last[20] = 1
        token_uncertainty = [0] * 21
        contents = [None] * 21
        for d in xrange(1, 101):
            _ = f.readline()
            assert _

            if d <= 99:
                for i in xrange(1, 21):
                    token_uncertainty[i] += 1

            def read(g):
                print g, 0
                sys.stdout.flush()
                A = map(int, f.readline().split())
                assert A
                contents[g] = A[1:]
                if g == 20:
                    contents[g].append(100)
                # if V:
                    # print len(contents[g])
                token_last[g] = len(contents[g])
                token_uncertainty[g] = 0

            def guessbest():
                if V:
                    print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                l = range(1, 21)
                l.sort(key=lambda x: token_last[x] + 0.01 * token_uncertainty[x])
                g = l[1]
                print g, d
                token_last[g] += 1

            if d <= 19:
                print d, 100
                token_last[d] += 1
            elif d == 100:
                print 20, 100
                token_last[20] += 1
            else:
                if d < 60:
                    print (d % 19) + 1, d
                elif d < 80:
                    g = (d % 20) + 1
                    read(g)
                elif 78 <= d < 192:
                    guessat = sorted(set(token_last[1:-1]))
                    g = None
                    g_uncertainty = -1
                    for x in xrange(1, 20):
                        if token_last[x] != guessat:
                            continue
                        if token_uncertainty[x] > g_uncertainty:
                            g_uncertainty = token_uncertainty[x]
                            g = x
                    if V:
                        print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                    if g_uncertainty < 20:
                        guessbest()
                    else:
                        read(g)
                else:
                    guessbest()
            sys.stdout.flush()

",,2408,77,221,Python,0000000000051679,000000000014aff1,00000000001461c8,kmod,2019
16237,000000000014ad43.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        token_last = [0] * 21
        token_last[0] = None
        token_last[20] = 1
        token_uncertainty = [0] * 21
        contents = [None] * 21
        for d in xrange(1, 101):
            _ = f.readline()
            assert _

            if d <= 99:
                for i in xrange(1, 21):
                    token_uncertainty[i] += 1

            def read(g):
                print g, 0
                sys.stdout.flush()
                A = map(int, f.readline().split())
                assert A
                contents[g] = A[1:]
                if g == 20:
                    contents[g].append(100)
                # if V:
                    # print len(contents[g])
                token_last[g] = len(contents[g])
                token_uncertainty[g] = 0

            def guessbest():
                if V:
                    print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                l = range(1, 21)
                l.sort(key=lambda x: token_last[x] + 0.01 * token_uncertainty[x])
                g = l[1]
                print g, d
                token_last[g] += 1

            if d <= 19:
                print d, 100
                token_last[d] += 1
            elif d == 100:
                print 20, 100
                token_last[20] += 1
            else:
                if d < 60:
                    print (d % 19) + 1, d
                elif d < 80:
                    g = (d % 20) + 1
                    read(g)
                elif 88 <= d < 92:
                    guessat = sorted(set(token_last[1:-1]))
                    g = None
                    g_uncertainty = -1
                    for x in xrange(1, 20):
                        if token_last[x] != guessat:
                            continue
                        if token_uncertainty[x] > g_uncertainty:
                            g_uncertainty = token_uncertainty[x]
                            g = x
                    if V:
                        print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                    if g_uncertainty < 30:
                        guessbest()
                    else:
                        read(g)
                else:
                    guessbest()
            sys.stdout.flush()

",,2407,77,221,Python,0000000000051679,000000000014ad43,00000000001461c8,kmod,2019
16238,000000000014ac31.PYPY2,"import sys

V = '-v' in sys.argv

if __name__ == ""__main__"":
    f = sys.stdin

    T = int(f.readline())
    for _T in xrange(T):
        token_last = [0] * 21
        token_last[0] = None
        token_last[20] = 1
        token_uncertainty = [0] * 21
        contents = [None] * 21
        for d in xrange(1, 101):
            _ = f.readline()
            assert _

            if d <= 99:
                for i in xrange(1, 21):
                    token_uncertainty[i] += 1

            def read(g):
                print g, 0
                sys.stdout.flush()
                A = map(int, f.readline().split())
                assert A
                contents[g] = A[1:]
                if g == 20:
                    contents[g].append(100)
                # if V:
                    # print len(contents[g])
                token_last[g] = len(contents[g])
                token_uncertainty[g] = 0

            def guessbest():
                if V:
                    print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                l = range(1, 21)
                l.sort(key=lambda x: token_last[x] + 0.01 * token_uncertainty[x])
                g = l[1]
                print g, d
                token_last[g] += 1

            if d <= 19:
                print d, 100
                token_last[d] += 1
            elif d == 100:
                print 20, 100
                token_last[20] += 1
            else:
                if d < 60:
                    print (d % 19) + 1, d
                elif d < 80:
                    g = (d % 20) + 1
                    read(g)
                elif 86 <= d < 94:
                    guessat = sorted(set(token_last[1:-1]))
                    g = None
                    g_uncertainty = -1
                    for x in xrange(1, 20):
                        if token_last[x] != guessat:
                            continue
                        if token_uncertainty[x] > g_uncertainty:
                            g_uncertainty = token_uncertainty[x]
                            g = x
                    if V:
                        print zip(range(1, 21), token_last[1:], token_uncertainty[1:])
                    if g_uncertainty < 30:
                        guessbest()
                    else:
                        read(g)
                else:
                    guessbest()
            sys.stdout.flush()

",,2407,77,221,Python,0000000000051679,000000000014ac31,00000000001461c8,kmod,2019
16239,00000000001478bf.PYPY2,"import sys

class Fraction(object):
    def __init__(self, n, d):
        self.n = n
        self.d = d

    def __repr__(self):
        return ""<Frac %d/%d>"" % (self.n, self.d)

    def __cmp__(self, rhs):
        r = self.n * rhs.d - rhs.n * self.d
        if rhs.d < 0:
            r *= -1
        if self.d < 0:
            r *= -1
        return r

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        N, = map(int, f.readline().split())

        M = []
        for i in xrange(N):
            M.append(map(int, f.readline().split()))

        M.sort()
        # print M

        ans = 1

        C = 1000000000000000
        J = 1

        while True:
            nc = None
            nj = None
            frac = None
            found = False
            for i in xrange(N - 1):
                dc = M[i+1][0] - M[i][0]
                dj = M[i+1][1] - M[i][1]

                if dc >= 0 and dj >= 0:
                    continue

                if dc <= 0:
                    continue

                assert dj < 0

                # C * dc + dj < 0
                # C = -dj / dc
                this_frac = Fraction(-dj, dc)
                # print this_frac
                if not found or this_frac > frac:
                    found = True
                    frac = this_frac

            # print found, frac

            if not found:
                break

            def key(a):
                X = 1000000000000
                return (frac.n * X - 1) * a[0] + (frac.d * X) * a[1]
            M.sort(key=key)
            # print M
            ans += 1

        print ""Case #%d: %d"" % (_T + 1, ans)

",,1774,81,229,Python,0000000000051679,00000000001478bf,0000000000146183,kmod,2019
96250,000000000010ac64.PYPY2,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T, N, M = map(int, f.readline().split())
    for _T in xrange(T):
        blades = [7, 11, 13, 15, 16, 17, 18]
        for b in blades:
            print ' '.join(map(str, [b]*18))
        sys.stdout.flush()

        mods = []
        for b in blades:
            mods.append(sum(map(int, f.readline().split())) % b)

        def works(g):
            for i in xrange(7):
                if g % blades[i] != mods[i]:
                    return False
            return True

        g = mods[-1]
        while not works(g):
            g += blades[-1]

        print g
        sys.stdout.flush()
        if int(f.readline()) == -1:
            break

",,812,36,95,Python,51635,000000000010ac64,0000000000104f1a,kmod,2019
96254,0000000000106246.PYPY2,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T, N, M = map(int, f.readline().split())
    for _T in xrange(T):
        blades = [7, 11, 13, 15, 16, 17, 18]
        for b in blades:
            print ' '.join(map(str, [b]*18))
        sys.stdout.flush()

        mods = []
        for b in blades:
            mods.append(sum(map(int, f.readline().split())))

        def works(g):
            for i in xrange(7):
                if g % blades[i] != mods[i]:
                    return False
            return True

        g = mods[-1]
        while not works(g):
            g += blades[-1]

        print g
        sys.stdout.flush()
        if int(f.readline()) == -1:
            break

",,808,36,93,Python,51635,0000000000106246,0000000000104f1a,kmod,2019
96255,0000000000106187.PYPY2,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T, N, M = map(int, f.readline().split())
    for _T in xrange(T):
        blades = [7, 11, 13, 15, 16, 17, 18]
        for b in blades:
            print ' '.join(map(str, [b]*18))
        sys.stdout.flush()

        mods = []
        for b in blades:
            mods.append(sum(map(int, f.readline().split())))

        def works(g):
            for i in xrange(7):
                if g % blades[i] != mods[i]:
                    return False
            return True

        g = mods[-1]
        while not works(g):
            g += blades[-1]

        print g
        sys.stdout.flush()
        f.readline()

",,775,35,89,Python,51635,0000000000106187,0000000000104f1a,kmod,2019
96256,0000000000105896.PYPY2,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        R, C = map(int, f.readline().split())
        _R, _C = R, C

        reverse = False
        if R < C:
            reverse = True
            R, C = C, R

        c_offset = 0

        squares = []
        def emit(i, j):
            j += c_offset
            if reverse:
                squares.append((j, i))
            else:
                squares.append((i, j))

        while R >= 5 and C >= 4:
            y = 1
            emit(y, 1)
            while True:
                emit(y+3, 2)
                emit(y+1, 1)
                y += 1
                if y == R - 2:
                    break
            emit(1, 2)
            emit(R - 1, 1)
            emit(2, 2)
            emit(R, 1)
            emit(3, 2)

            C -= 2
            c_offset += 2

        hit = {}
        for x in xrange(1, R+1):
            for y in xrange(1, C+1):
                hit[(x, y)] = False

        def search(x, y):
            hit[(x, y)] = True
            emit(x, y)

            if all(hit.values()):
                raise IOError()

            for i in xrange(1, R+1):
                for j in xrange(1, C+1):
                    if hit[(i, j)]:
                        continue
                    if i == x:
                        continue
                    if j == y:
                        continue
                    if i + j == x + y:
                        continue
                    if i - j == x - y:
                        continue

                    search(i, j)
            hit[(x, y)] = False
            squares.pop()

        try:
            search(2, 2)
        except IOError:
            assert len(squares) == _R * _C, len(squares)
            assert len(set(squares)) == len(squares)
            for r, c in squares:
                assert 1 <= r <= _R, (r, c)
                assert 1 <= c <= _C, (r, c)
            for i in xrange(len(squares) - 1):
                r, c = squares[i]
                x, y = squares[i + 1]
                assert r != x
                assert c != y
                assert r + c != x + y
                assert r - c != x - y

            print ""Case #%d: POSSIBLE"" % (_T + 1,)
            for x, y in squares:
                print x, y
        else:
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)

",,2499,99,302,Python,51635,0000000000105896,0000000000104e03,kmod,2019
130761,000000000008a4dc.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        N, B, F = map(int, f.readline().split())

        responses = []

        for round in range(4):
            msg = []
            for i in xrange(N):
                msg.append(chr(ord('0') + ((i & (1 << round)) >> round)))
            msg = ''.join(msg)
            print msg
            sys.stdout.flush()
            responses.append(f.readline().strip())

        prev = -1
        missed = []
        for i in xrange(N - B):
            idx = 0
            for round in range(4):
                idx += (ord(responses[round][i]) - ord('0')) << round

            while idx != (prev + 1) % 16:
                prev += 1
                missed.append(prev)
            prev += 1
        while N % 16 != (prev + 1) % 16:
            prev += 1
            missed.append(prev)

        print ' '.join(map(str, missed))
        sys.stdout.flush()
        f.readline()
",,1083,43,127,Python,51705,000000000008a4dc,00000000000881de,kmod,2019
130762,000000000008900c.PYTHON,"import sys

def gcd(a, b):
    if a > b:
        a, b = b, a
    if a == 0:
        return b
    return gcd(b % a, a)

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        N, L = map(int, f.readline().split())
        X = map(int, f.readline().split())

        P = [None] * (L + 1)

        for i in xrange(L - 1):
            if X[i] != X[i + 1]:
                break
        else:
            raise Exception(1)

        P[i + 1] = gcd(X[i], X[i + 1])
        P[i] = X[i] / P[i + 1]
        P[i + 2] = X[i + 1] / P[i + 1]

        for j in xrange(i - 1, -1, -1):
            P[j] = X[j] / P[j + 1]
        for j in xrange(i + 1, L):
            P[j + 1] = X[j] / P[j]

        assert all(P)

        primeset = sorted(set(P))

        ans = []
        for p in P:
            ans.append(chr(ord('A') + primeset.index(p)))
        ans = ''.join(ans)

        print ""Case #%d: %s"" % (_T + 1, ans)
",,1050,49,167,Python,51705,000000000008900c,000000000008830b,kmod,2019
130763,00000000000886c2.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())
        S = f.readline().strip()

        ans = []
        for c in S:
            if c == 'S':
                ans.append('E')
            else:
                ans.append('S')

        ans = ''.join(ans)
        print ""Case #%d: %s"" % (_T + 1, ans)
",,489,24,62,Python,51705,00000000000886c2,00000000000881da,kmod,2019
130764,000000000008869c.PYTHON,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    if len(sys.argv) >= 2:
        fn = sys.argv[1]
        if fn != '-':
            f = open(fn)

    T = int(f.readline())
    for _T in xrange(T):
        S = f.readline().strip()

        A = list(S)
        B = ['0'] * len(A)

        for i in xrange(len(A)):
            if A[i] == '4':
                A[i] = '3'
                B[i] = '1'

        A = ''.join(A)
        B = ''.join(B).lstrip('0')
        print ""Case #%d: %s %s"" % (_T + 1, A, B)
",,513,25,72,Python,51705,000000000008869c,0000000000088231,kmod,2019
131,0000000000222da5,"import sys

def bruteForce(N, K):
    M = [[None] * N for i in range(N)]
    _K = K
    for i in range(N):
        left = N - i - 1
        t = i + 1
        # if K >= left + N:
            # M[i][i] = N
        # elif K <= left * N + 1:
            # M[i][i] = 1
        # else:
        if K >= left + t and K <= left * N + t:
            M[i][i] = t
            if i == 0 and K == left * N + t:
                M[i][i] += 1
        else:
            M[i][i] = K / (N - i)
        K -= M[i][i]

    def avoid(i, j):
        if M[i][j] is not None:
            return []

        used = [False] * N
        for k in range(N):
            for c in M[i][k], M[k][j]:
                if c is None:
                    continue
                used[c - 1] = True

        return used

    def recurse():
        # print M
        best = 0
        besti = None
        bestj = None
        besta = None
        for i in range(N):
            for j in range(N):
                a = avoid(i, j)
                if sum(a) > best:
                    best = sum(a)
                    besti = i
                    bestj = j
                    besta = a

        if besta is None:
            return True

        # if len(besta) == N:
            # print ""Stuck at"", besti, bestj

        assert not M[besti][bestj]
        for i in range(1, N + 1):
            if besta[i-1]:
                continue
            M[besti][bestj] = i
            done = recurse()
            if done:
                return True
        M[besti][bestj] = None
        return False
    assert recurse(), (N, _K)
    return M

def swapNumbers(M, i, j):
    N = len(M)
    if i == j:
        return

    for x in range(N):
        for y in range(N):
            if M[x][y] == i:
                M[x][y] = j
            elif M[x][y] == j:
                M[x][y] = i


def solve(N, K):
    M = [[None for j in range(N)] for i in range(N)]

    if N <= 4:
        M = bruteForce(N, K)
    elif K == N + 2 or K == N * N - 2:
        for i in range(N - 2):
            M[i][i] = 1
        M[N - 2][N - 1] = 1
        M[N - 1][N - 2] = 1

        M[N - 2][N - 2] = 2
        M[N - 1][N - 1] = 2

        for i in range(N - 2):
            for j in range(N - 4):
                M[i][(i + j + 1) % (N - 2)] = (2 * i + j) % (N - 2) + 3
            M[i][(i - 1) % (N - 2)] = 2

        for i in range(N - 2):
            x1, x2 = N-2, N-1
            if N % 2 == 0 and i >= (N - 2) / 2:
                x1, x2 = x2, x1
            M[x1][i] = (i * 2) % (N - 2) + 3
            M[x2][i] = (i * 2 - 1) % (N - 2) + 3

            M[i][x2] = (-2 + i * 2) % (N - 2) + 3
            M[i][x1] = (-1 + i * 2) % (N - 2) + 3

        if K == N * N - 2:
            swapNumbers(M, 1, N)
            swapNumbers(M, 2, N - 1)

        # for i in range(N - 2):
            # used = M[N - 2][:i]
            # for j in range(N - 2):
                # used.append(M[
    else:
        for i in range(N):
            for j in range(N):
                M[i][j] = (j - i) % N + 1

        if K == N:
            pass
        elif K == N * N:
            swapNumbers(M, 1, N)
        else:
            for i in range(N):
                M[N-1][i], M[N-2][i] = M[N-2][i], M[N-1][i]

            found = False
            for k1 in range(1, N + 1):
                for k2 in range(1, N + 1):
                    if k1 == k2:
                        continue
                    for k3 in range(1, N + 1):
                        if k3 == k1 or k3 == k2:
                            continue

                        if k1 + k2 + (N - 2) * k3 == K:
                            found = True
                            break
                    if found == True:
                        break
                if found == True:
                    break

            assert found, (N, K)
            # print k1, k2, k3

            swapNumbers(M, M[N-2][N-2], k1)
            swapNumbers(M, M[N-1][N-1], k2)
            swapNumbers(M, M[0][0], k3)

    # for i in range(N):
        # print "" "".join([str(i or 0) for i in M[i]])
    # print

    for i in range(N):
        assert sorted(M[i]) == range(1, N+1), i
        assert sorted([M[j][i] for j in xrange(N)]) == range(1,N+1)
    assert sum([M[i][i] for i in range(N)]) == K, K

    return M

'''
for N in range(2, 51):
    for K in range(N, N * N + 1):
        if K == N + 1 or K == N * N - 1:
            continue
        if N == 3 and K in (5, 7):
            continue

        print N, K
        solve(N, K)
1/0
'''

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        N, K = map(int, f.readline().split())

        if K == N + 1 or K == N * N - 1:
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
            continue
        if N == 3 and K in (5, 7):
            print ""Case #%d: IMPOSSIBLE"" % (_T + 1,)
            continue


        M = solve(N, K)

        print ""Case #%d: POSSIBLE"" % (_T + 1,)
        for i in range(N):
            print "" "".join(map(str, M[i]))
",0000000000222da5.PYPY2,5025,199,798,Python,000000000019fd27,0000000000222da5,0000000000209aa0,kmod,2020
132,0000000000213302,"
import sys

def p(s):
    print s
    # print >>sys.stderr, "">"", s
    sys.stdout.flush()
    r = sys.stdin.readline().strip()
    # print >>sys.stderr, ""<"", r
    return r

if __name__ == ""__main__"":
    f = sys.stdin
    T, B = map(int, f.readline().split())
    # print >>sys.stderr, T, B
    for _T in xrange(T):
        # print >>sys.stderr, ""test case"", _T
        A = [None] * B

        for i in range(5):
            A[i] = int(p(i + 1))
            A[B - i - 1] = int(p(B - i))

        while True:
            if all([a is not None for a in A]):
                r = p(''.join(map(str, A)))
                assert r == ""Y""
                break

            switch_same = None
            switch_diff = None

            # print >>sys.stderr, A
            for i in range(B / 2):
                x, y = A[i], A[B - i - 1]
                if x is None:
                    continue

                if x == y and switch_same is None:
                    nx = int(p(i + 1))
                    switch_same = (nx != x)
                elif x != y and switch_diff is None:
                    nx = int(p(i + 1))
                    switch_diff = (nx != x)

            if switch_same is None:
                p(1)
            if switch_diff is None:
                p(1)

            # print >>sys.stderr, switch_same, switch_diff

            for i in range(B / 2):
                x, y = A[i], A[B - i - 1]
                if x is None:
                    continue

                if x == y:
                    if switch_same:
                        A[i] = 1 ^ x
                        A[B - i - 1] = 1 ^ y
                else:
                    if switch_diff:
                        A[i] = 1 ^ x
                        A[B - i - 1] = 1 ^ y
            # print >>sys.stderr, A

            asked = 0
            for i in range(B / 2):
                if A[i] is not None:
                    continue

                A[i] = int(p(i + 1))
                A[B - i - 1] = int(p(B - i))
                asked += 1
                if asked >= 4:
                    break
",0000000000213302.PYTHON,2088,78,271,Python,000000000019fd27,0000000000213302,0000000000209a9e,kmod,2020
133,0000000000210e42,"
import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())

        A = []
        for i in xrange(N):
            A.append(map(int, f.readline().split()) + [i])

        A.sort()

        C = 0
        J = 0

        r = [None] * N
        for s, e, i in A:
            if s >= C:
                r[i] = ""C""
                C = e
            elif s >= J:
                r[i] = ""J""
                J = e

        if not all(r):
            ans = ""IMPOSSIBLE""
        else:
            ans = ''.join(r)

        print ""Case #%d: %s"" % (_T + 1, ans)

",0000000000210e42.PYPY2,630,35,87,Python,000000000019fd27,0000000000210e42,000000000020bdf9,kmod,2020
134,0000000000210cc6,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        S = f.readline().strip()

        r = """"

        cur = 0
        for c in S:
            d = int(c)
            while cur < d:
                r += ""(""
                cur += 1
            while cur > d:
                r += "")""
                cur -= 1
            r += c
        while cur > 0:
            r += "")""
            cur -= 1

        print ""Case #%d: %s"" % (_T + 1, r)

",0000000000210cc6.PYPY2,500,27,74,Python,000000000019fd27,0000000000210cc6,0000000000209a9f,kmod,2020
135,0000000000210aa2,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())

        M = []
        for i in range(N):
            M.append(map(int, f.readline().split()))

        k = 0
        for i in range(N):
            k += M[i][i]

        r = 0
        c = 0
        for i in range(N):
            if len(set(M[i])) < N:
                r += 1
            s = set()
            for j in range(N):
                s.add(M[j][i])
            if len(s) < N:
                c += 1

        print ""Case #%d: %s %s %s"" % (_T + 1, k, r, c)
",0000000000210aa2.PYPY2,605,29,83,Python,000000000019fd27,0000000000210aa2,000000000020993c,kmod,2020
386043,0000000000306b3e,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        R, S = map(int, f.readline().split())
        # print
        # print R, S
        
        cards = tuple([(r, s) for s in range(S) for r in range(R)])

        def score(cards):
            used = [False] * R
            tofix = 0
            for i in xrange(len(cards) - 1):
                x = cards[i][0]
                y = cards[i + 1][0]
                if x == y:
                    continue
                elif y == x + 1:
                    if used[x]:
                        tofix += 1
                    else:
                        used[x] = True
                else:
                    tofix += 1
            return tofix

        s = score(cards)
        k = (s + 1) / 2
        # print ""initial score"", s
        print ""Case #%d: %d"" % (_T + 1, k)

        while True:
            # for a in xrange(1, R * S):
                # for c in range(a + 1, R * S - 1):
            try:
                for c in xrange(R * S):
                    if cards[c-1][0] == cards[c][0]:
                        continue
                    if cards[c-1][0] != cards[0][0]:
                        continue
                    for a in xrange(1, c):
                        if cards[a-1][0] == cards[a][0]:
                            continue
                        if cards[c][0] == cards[a-1][0]:
                            newcards = cards[a:c] + cards[:a] + cards[c:]
                            newscore = score(newcards)
                            # newscore = s - 2
                            # print
                            print a, c - a
                            k -= 1
                            # print cards, ""->"", newcards
                            # print s, ""->"", newscore
                            assert newscore == s - 2

                            s = newscore
                            cards = newcards
                            raise EOFError()
                else:
                    1/0
            except EOFError:
                pass

            if s == 1:
                # for (a, b) in [(a, b) for a in xrange(1, R * S) for b in xrange(1, R * S - a + 1)]:
                for a in xrange(1, R * S):
                    b = R * S - a
                    newcards = cards[a:a+b] + cards[:a] + cards[a+b:]
                    newscore = score(newcards)
                    if newscore < s:
                        assert newscore == 0
                        print a, b
                        k -= 1
                        # print cards, ""->"", newcards
                        s = newscore
                        cards = newcards
                        break
                else:
                    1/0
                assert s == 0

            if s == 0:
                break
        assert k == 0

        # print cards
",0000000000306b3e.PYPY2,2905,89,318,Python,000000000019fef2,0000000000306b3e,00000000002d5b64,kmod,2020
386044,0000000000306a17,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        R, S = map(int, f.readline().split())
        # print
        # print R, S
        
        cards = tuple([(r, s) for s in range(S) for r in range(R)])

        def score(cards):
            used = [False] * R
            tofix = 0
            for i in xrange(len(cards) - 1):
                x = cards[i][0]
                y = cards[i + 1][0]
                if x == y:
                    continue
                elif y == x + 1:
                    if used[x]:
                        tofix += 1
                    else:
                        used[x] = True
                else:
                    tofix += 1
            return tofix

        s = score(cards)
        k = (s + 1) / 2
        # print ""initial score"", s
        print ""Case %d: %d"" % (_T + 1, k)

        while True:
            # for a in xrange(1, R * S):
                # for c in range(a + 1, R * S - 1):
            try:
                for c in xrange(R * S):
                    if cards[c-1][0] == cards[c][0]:
                        continue
                    if cards[c-1][0] != cards[0][0]:
                        continue
                    for a in xrange(1, c):
                        if cards[a-1][0] == cards[a][0]:
                            continue
                        if cards[c][0] == cards[a-1][0]:
                            newcards = cards[a:c] + cards[:a] + cards[c:]
                            newscore = score(newcards)
                            # newscore = s - 2
                            # print
                            print a, c - a
                            k -= 1
                            # print cards, ""->"", newcards
                            # print s, ""->"", newscore
                            assert newscore == s - 2

                            s = newscore
                            cards = newcards
                            raise EOFError()
                else:
                    1/0
            except EOFError:
                pass

            if s == 1:
                # for (a, b) in [(a, b) for a in xrange(1, R * S) for b in xrange(1, R * S - a + 1)]:
                for a in xrange(1, R * S):
                    b = R * S - a
                    newcards = cards[a:a+b] + cards[:a] + cards[a+b:]
                    newscore = score(newcards)
                    if newscore < s:
                        assert newscore == 0
                        print a, b
                        k -= 1
                        # print cards, ""->"", newcards
                        s = newscore
                        cards = newcards
                        break
                else:
                    1/0
                assert s == 0

            if s == 0:
                break
        assert k == 0

        # print cards
",0000000000306a17.PYPY2,2904,89,318,Python,000000000019fef2,0000000000306a17,00000000002d5b64,kmod,2020
386046,00000000002fc635,"import sys

def p(x, y):
    print x, y
    # print >>sys.stderr, "">"", x, y
    sys.stdout.flush()
    ans = sys.stdin.readline().strip()
    # print >>sys.stderr, ""<"", ans
    return ans

def search(hit, miss, tocoord):
    ""Returns the last hit""
    while abs(hit - miss) > 1:
        g = int((hit + miss) / 2)

        x, y = tocoord(g)
        ans = p(x, y)
        if ans == ""CENTER"":
            raise EOFError()
        elif ans == ""HIT"":
            hit = g
        else:
            miss = g
    return hit

if __name__ == ""__main__"":
    f = sys.stdin
    T, A, B = map(int, f.readline().split())

    M = 10 ** 9
    M2 = M // 2
    for _T in xrange(T):
        try:
            for x, y in [(x, y) for x in (-M2, 0, M2) for y in (-M2, 0, M2)]:
                ans = p(x, y)
                if ans == ""CENTER"":
                    raise EOFError()
                if ans == ""HIT"":
                    break
            else:
                raise Exception(""not found"")

            x1 = search(x, -M - 1, lambda g: (g, y))
            x2 = search(x, M + 1, lambda g: (g, y))
            y1 = search(y, -M - 1, lambda g: (x, g))
            y2 = search(y, M + 1, lambda g: (x, g))

            mx = int((x1 + x2) / 2)
            my = int((y1 + y2) / 2)

            for x in [mx, mx-1, mx+1, mx+2]:
                for y in [my, my-1, my+1, my+2]:
                    ans = p(x, y)
                    if ans == ""CENTER"":
                        raise EOFError()
        except EOFError as e:
            # print >>sys.stderr, ""done""
            pass

",00000000002fc635.PYTHON,1564,60,225,Python,000000000019fef2,00000000002fc635,00000000002d5b63,kmod,2020
386047,00000000002fa07a,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        X, Y = map(int, f.readline().split())

        def solve(x, y):
            if x == 0 and y == 0:
                return """"
            if (x & 1) + (y & 1) != 1:
                return None
            if abs(x) == 1 and y == 0:
                return ""_EW""[x]
            if abs(y) == 1 and x == 0:
                return ""_NS""[y]
            if x & 1:
                s1 = solve((x - 1) >> 1, y >> 1)
                s2 = solve((x + 1) >> 1, y >> 1)
                if s1 is None and s2 is None:
                    return None
                elif s1 is not None and (s2 is None or len(s2) > len(s1)):
                    return ""E"" + s1
                else:
                    return ""W"" + s2
            else:
                s1 = solve(x >> 1, (y - 1) >> 1)
                s2 = solve(x >> 1, (y + 1) >> 1)
                if s1 is None and s2 is None:
                    return None
                elif s1 is not None and (s2 is None or len(s2) > len(s1)):
                    return ""N"" + s1
                else:
                    return ""S"" + s2

        s = solve(X, Y)
        if s is None:
            s = ""IMPOSSIBLE""
        print ""Case #%d: %s"" % (_T + 1, s)
",00000000002fa07a.PYPY2,1298,41,195,Python,000000000019fef2,00000000002fa07a,00000000002d5b62,kmod,2020
386048,00000000002f9b42,"import sys

class ImpossibleException(Exception):
    pass

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        X, Y = map(int, f.readline().split())

        def solve(x, y):
            if x == 0 and y == 0:
                return """"
            if (x & 1) + (y & 1) != 1:
                return None
            if x & 1:
                s1 = solve((x - 1) >> 1, y >> 1) if x != -1 else None
                s2 = solve((x + 1) >> 1, y >> 1) if x != 1 else None
                if s1 is None and s2 is None:
                    return None
                elif s1 is not None and (s2 is None or len(s2) > len(s1)):
                    return ""E"" + s1
                else:
                    return ""W"" + s2
            else:
                s1 = solve(x >> 1, (y - 1) >> 1) if y != -1 else None
                s2 = solve(x >> 1, (y + 1) >> 1) if y != 1 else None
                if s1 is None and s2 is None:
                    return None
                elif s1 is not None and (s2 is None or len(s2) > len(s1)):
                    return ""N"" + s1
                else:
                    return ""S"" + s2

        s = solve(X, Y)
        if s is None:
            s = ""IMPOSSIBLE""
        print ""Case #%d: %s"" % (_T + 1, s)
",00000000002f9b42.PYPY2,1286,40,202,Python,000000000019fef2,00000000002f9b42,00000000002d5b62,kmod,2020
485561,000000000033d0e6,"import sys

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        C, D = map(int, f.readline().split())

        X = [None] + map(int, f.readline().split())
        assert len(X) == C
        E = []
        for _ in xrange(D):
            u, v = map(int, f.readline().split())
            E.append((u - 1, v - 1))

        # print C, D
        # print X
        # print E

        order = [None] * C
        times = [None] * C
        order[0] = 0
        times[0] = 0

        seen = 1
        lasttime = 0
        lastguessed = []
        while seen < C:
            # print
            # print order
            # print times
            # print ""seen %d lasttime %d"" % (seen, lasttime)
            found = [i for i in xrange(C) if X[i] == -seen]
            if found:
                # print ""order implies these next:"", found
                newtime = lasttime + 1
                lastguessed = found
                for x in found:
                    times[x] = newtime
                    order[x] = seen
                lasttime = newtime
                seen += len(found)
                continue

            earliest = 1e6
            found = []
            for i in xrange(C):
                if order[i] is not None:
                    continue
                k = X[i]
                if k < 0:
                    continue
                if k > earliest:
                    continue
                if k < earliest:
                    earliest = k
                    found = []
                found.append(i)

            # print ""missing from order, so this must be next:"", found

            for x in found:
                # order[x] = seen - len(lastguessed)
                order[x] = seen
                times[x] = earliest
            seen += len(found)

            # for x in lastguessed:
                # times[x] = earliest
            lastguessed = []
            lasttime = earliest


        # print ""order"", order
        # print ""times"", times

        latencies = []
        for i in xrange(D):
            latencies.append(max(1, abs(times[E[i][0]] - times[E[i][1]])))

        print ""Case #%d: %s"" % (_T + 1, ' '.join(map(str, latencies)))
",000000000033d0e6.PYPY2,2234,82,265,Python,000000000019ffb9,000000000033d0e6,000000000033871f,kmod,2020
485562,000000000033b796,"import collections
import sys

class Direction(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, rhs):
        return self.x * rhs.y == rhs.x * self.y

    def __hash__(self):
        if self.y == 0:
            return -1
        return int(1000000007 * self.x / self.y)

    def __repr__(self):
        return ""<%s, %s>"" % (self.x, self.y)

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        N = int(f.readline())

        W = []
        for i in xrange(N):
            W.append(map(int, f.readline().split()))

        directions = set()
        edges = collections.defaultdict(lambda: collections.defaultdict(list))

        for i in range(N):
            for j in range(i):
                d = Direction(W[i][0] - W[j][0], W[i][1] - W[j][1])
                edges[i][d].append(j)
                edges[j][d].append(i)
                directions.add(d)

        # print W

        best = min(N, 2)
        for d in directions:
            # print
            # print ""examining"", d
            used = [False] * N
            total_found = 0
            nodd = 0
            for i in range(N):
                if used[i]:
                    continue
                l = edges[i].get(d)
                if not l:
                    continue

                total_found += 1 + len(l)
                if len(l) % 2 == 0:
                    nodd += 1
                used[i] = True
                for j in l:
                    used[j] = True

            if nodd % 2 == 1:
                total_found -= 1
            t = min(N, total_found + 2)
            # print d, t
            best = max(t, best)

        print ""Case #%d: %d"" % (_T + 1, best)


        # To test:
        # - all in a line
        # - random
        # - grid
",000000000033b796.PYPY2,1840,76,214,Python,000000000019ffb9,000000000033b796,00000000003386d0,kmod,2020
485563,000000000033a73c,"import sys

def brute(L, R):
    i = 1
    while True:
        if L < i and R < i:
            return i - 1, L, R
        if L >= R:
            L -= i
        else:
            R -= i
        i += 1

def solve(L, R):
    flipped = False
    if R > L:
        flipped = True
        L, R = R, L

    x = int(((8 * (L - R) + 1) ** 0.5 - 1) * 0.5)
    t = x

    L -= x * (x + 1) / 2
    assert L >= R
    assert L - (x + 1) < R

    if L == R:
        flipped = False

    y = int(0.5 * (((x+1)**2 + 4 * R) ** 0.5 - (x + 1)))
    t += 2 * y

    L -= y * x + y ** 2
    if L >= x + 2 * y + 1:
        L -= x + 2 * y + 1
        t += 1
        assert L < x + 2 * y + 3
    R -= y * x + y * (y + 1)
    assert R < x + 2 * y + 2, (x, y, L, R)

    if flipped:
        L, R = R, L

    return t, L, R

def check():
    import numpy as np
    np.random.seed(12346)
    for i in range(100):
        for j in range(100):
            print i, j
            a1 = brute(i, j)
            a2 = solve(i, j)
            assert a1 == a2, (a1, a2)
    for i, j in np.random.randint(1, 1000000000, (100000, 2)):
        print i, j
        a1 = brute(i, j)
        a2 = solve(i, j)
        assert a1 == a2, (a1, a2)

if __name__ == ""__main__"":
    f = sys.stdin
    T = int(f.readline())
    for _T in xrange(T):
        L, R = map(int, f.readline().split())

        print ""Case #%d:"" % (_T + 1), ""%d %d %d"" % solve(L, R)
",000000000033a73c.PYPY2,1405,68,288,Python,000000000019ffb9,000000000033a73c,00000000003384ea,kmod,2020
12606,problem_c.py,"import time
 
 print (time.ctime())
 
 N_LIMIT = 30
 MODULO = 100003
 
 # pre-processing
 
 
 def factorial (n):
     s = 1
     for i in range(1,n+1):
         s *= i
     return s
 
 def binomial (n,k):
     if k > n:
         return 0
     return factorial (n)// (factorial(k)*factorial (n-k))
 
 
 
 intermediate_results = [[None]*(N_LIMIT) for i in range(N_LIMIT)]
 for set_maximal_value in range(2,N_LIMIT):
     intermediate_results[set_maximal_value][1] = 1
 
 
 for set_length in range(2,N_LIMIT):
     for set_maximal_value in range(2,N_LIMIT):
         # calculate intermediate_results[set_maximal_value][set_length]
         intermediate_results[set_maximal_value][set_length] = 0
         for next_subset_length in range(1,set_length):
             diff_values = set_maximal_value - set_length
             diff_lengths = set_length - next_subset_length
             binom = binomial (diff_values-1, diff_lengths-1)
             subset_poss = intermediate_results[set_length][next_subset_length]
             all_possibilities = (binom*subset_poss) % MODULO
             intermediate_results[set_maximal_value][set_length] += all_possibilities
             intermediate_results[set_maximal_value][set_length] %= MODULO
                 
 
 results = [0]*N_LIMIT
 for value in range(2,N_LIMIT):
     for set_length in range(1,N_LIMIT):
         results[value] += intermediate_results[value][set_length]
         results[value] %= MODULO
 
 
 
 
 
 
 
 # processing
 
 f_in = open('c:/temp/codejam/round1b/problem_c/C-small-attempt1.in')
 f_out = open('c:/temp/codejam/round1b/problem_c/C-small-attempt1.out','w')
 
 T = int(f_in.readline())
 for case in range(1,T+1):
     n = int (f_in.readline())
     f_out.write('Case #' + str(case) + ': ' + str(results[n]) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
",gcj/2010/635101/bigOnion/598111/0/extracted/problem_c.py,1839,70,153,Python,635101,0,598111,bigOnion,2010
12607,problem_a.py,"import time
 
 print (time.ctime())
 
 f_in = open('c:/temp/codejam/round1b/A-large.in')
 f_out = open('c:/temp/codejam/round1b/A-large.out','w')
 
 T = int(f_in.readline())
 for case in range(1,T+1):
     
     N, M = [int(x) for x in f_in.readline().split()]
     
     existing_directories = {():1}
     for i in range(N):
         path = ''.join(f_in.readline().split())
         if path[-1] == '/':
             path = path[:-1]
         path_list = tuple(path.split('/'))[1:]
         for p in range(len(path_list)+1):
             existing_directories [path_list[:p]] = 1
 
     mkdir_commands = 0
 
     for i in range(M):
         path = ''.join(f_in.readline().split())
         if path[-1] == '/':
             path = path[:-1]
         path_list = tuple(path.split('/'))[1:]
         p = len(path_list)
         while path_list[:p] not in existing_directories:
             p -= 1
             mkdir_commands += 1
         for p in range(len(path_list)+1):
             existing_directories [path_list[:p]] = 1
 
     res = mkdir_commands       
 
     f_out.write('Case #' + str(case) + ': ' + str(res) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
 
",gcj/2010/635101/bigOnion/563117/1/extracted/problem_a.py,1183,46,113,Python,635101,1,563117,bigOnion,2010
12608,problem_a.py,"import time
 
 print (time.ctime())
 
 f_in = open('c:/temp/codejam/round1b/A-small-attempt0.in')
 f_out = open('c:/temp/codejam/round1b/A-small-attempt0.out','w')
 
 T = int(f_in.readline())
 for case in range(1,T+1):
     
     N, M = [int(x) for x in f_in.readline().split()]
     
     existing_directories = {():1}
     for i in range(N):
         path = ''.join(f_in.readline().split())
         if path[-1] == '/':
             path = path[:-1]
         path_list = tuple(path.split('/'))[1:]
         for p in range(len(path_list)+1):
             existing_directories [path_list[:p]] = 1
 
     mkdir_commands = 0
 
     for i in range(M):
         path = ''.join(f_in.readline().split())
         if path[-1] == '/':
             path = path[:-1]
         path_list = tuple(path.split('/'))[1:]
         p = len(path_list)
         while path_list[:p] not in existing_directories:
             p -= 1
             mkdir_commands += 1
         for p in range(len(path_list)+1):
             existing_directories [path_list[:p]] = 1
 
     res = mkdir_commands       
 
     f_out.write('Case #' + str(case) + ': ' + str(res) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
 
",gcj/2010/635101/bigOnion/563117/0/extracted/problem_a.py,1201,46,113,Python,635101,0,563117,bigOnion,2010
12609,problem_b.py,"import time
 from fractions import Fraction
 
 print (time.ctime())
 
 f_in = open('c:/temp/codejam/round1b/B-large.in')
 f_out = open('c:/temp/codejam/round1b/B-large.out','w')
 
 C = int(f_in.readline())
 for case in range(1,C+1):
     N, K, B, T = [int(x) for x in f_in.readline().split()]
     init_places = [int(x) for x in f_in.readline().split()]
     velocities = [int(v) for v in f_in.readline().split()]
     is_able_to_reach = [None]*N
     for i in range(N):
         time_to_reach = Fraction(B - init_places[i] , velocities[i])
         if time_to_reach <= T:
             is_able_to_reach[i] = True
         else:
             is_able_to_reach[i] = False
 
     n_can_reach = is_able_to_reach.count (True)
     
     if n_can_reach >= K:
         total_must_skip = 0
         is_able_to_reach.reverse()
         for i in range(K):
             must_skip = is_able_to_reach.index(True)
             total_must_skip += must_skip
             del is_able_to_reach[must_skip]
         res = total_must_skip
     else:
         res = 'IMPOSSIBLE'
     
     f_out.write('Case #' + str(case) + ': ' + str(res) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
",gcj/2010/635101/bigOnion/542118/1/extracted/problem_b.py,1183,42,116,Python,635101,1,542118,bigOnion,2010
12610,problem_b.py,"import time
 from fractions import Fraction
 
 print (time.ctime())
 
 f_in = open('c:/temp/codejam/round1b/B-small-attempt0.in')
 f_out = open('c:/temp/codejam/round1b/B-small-attempt0.out','w')
 
 C = int(f_in.readline())
 for case in range(1,C+1):
     N, K, B, T = [int(x) for x in f_in.readline().split()]
     init_places = [int(x) for x in f_in.readline().split()]
     velocities = [int(v) for v in f_in.readline().split()]
     is_able_to_reach = [None]*N
     for i in range(N):
         time_to_reach = Fraction(B - init_places[i] , velocities[i])
         if time_to_reach <= T:
             is_able_to_reach[i] = True
         else:
             is_able_to_reach[i] = False
 
     n_can_reach = is_able_to_reach.count (True)
     
     if n_can_reach >= K:
         total_must_skip = 0
         is_able_to_reach.reverse()
         for i in range(K):
             must_skip = is_able_to_reach.index(True)
             total_must_skip += must_skip
             del is_able_to_reach[must_skip]
         res = total_must_skip
     else:
         res = 'IMPOSSIBLE'
     
     f_out.write('Case #' + str(case) + ': ' + str(res) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
",gcj/2010/635101/bigOnion/542118/0/extracted/problem_b.py,1201,42,116,Python,635101,0,542118,bigOnion,2010
37033,problem_c.py,"
 def apply_one_round (k, list_of_group_sizes):
     # apply just one round on the rollercoaster and
     # returns the money earned and new state of queue
     s1= sum (list_of_group_sizes)
     if s1 <= k:
         return s1, list_of_group_sizes
     s = 0
     i = 0
     while s+list_of_group_sizes[i] <= k:
         s += list_of_group_sizes[i]
         i += 1
     return s, list_of_group_sizes[i:] + list_of_group_sizes[:i]
 
 def apply_N_rounds (k, list_of_group_sizes):
     # applies enough number of rounds on the roller coaster
     # until state of queue must repeat itself
     # returns a list of queue state and money earned after every round applied
     N = len(list_of_group_sizes)
     states = []
     money_earned_so_far = 0
     current_round = 0
 
     for curr_round in range(N+10):
         states.append((money_earned_so_far, tuple(list_of_group_sizes)))
         curr_money, list_of_group_sizes = apply_one_round (k, list_of_group_sizes)
         money_earned_so_far += curr_money
 
     return states
 
 
 def simulate_all_rounds (R, k, list_of_group_sizes):
     # make an efficient simulation of running the coaster R times
     N = len(list_of_group_sizes)
     states = apply_N_rounds (k, list_of_group_sizes)
     if R <= len(states)-1:
         return states[R][0]
     else:
         last_reached_queue_state =states[-1][1]
         i = len(states)-2
         while states[i][1] != last_reached_queue_state:
             i -=1
         len_of_repeating_cycle = len(states)-1-i
         money_through_cycle = states[-1][0] - states[i][0]
         n_cycles = (R-i) // len_of_repeating_cycle
         money_earned_so_far = states[i][0] + n_cycles*money_through_cycle
         last_round_reached = i + n_cycles*len_of_repeating_cycle
         more_rounds_needed = R - last_round_reached
         assert more_rounds_needed >=0
         list_of_group_sizes = states[-1][1]
         for i in range (more_rounds_needed):
             curr_money, list_of_group_sizes = apply_one_round (k, list_of_group_sizes)
             money_earned_so_far += curr_money
         return money_earned_so_far
     
 
 
     
 f_in = open('c:/temp/codejam/qualification/C-large.in')
 f_out = open('c:/temp/codejam/qualification/C-large.out','w')
 
 T = int(f_in.readline())
 for case in range(T):
     R, k, N = [int(x) for x in f_in.readline().split()]
     list_of_group_sizes = [int(x) for x in f_in.readline().split()]
     res = simulate_all_rounds (R,k, list_of_group_sizes)
     f_out.write('Case #' + str(case+1) + ': ' + str(res) + '\n')
 
 f_in.close()
 f_out.close()
 
",gcj/2010/433101/bigOnion/509101/1/extracted/problem_c.py,2589,72,258,Python,433101,1,509101,bigOnion,2010
37034,problem_c.py,"
 def apply_one_round (k, list_of_group_sizes):
     # apply just one round on the rollercoaster and
     # returns the money earned and new state of queue
     s1= sum (list_of_group_sizes)
     if s1 <= k:
         return s1, list_of_group_sizes
     s = 0
     i = 0
     while s+list_of_group_sizes[i] <= k:
         s += list_of_group_sizes[i]
         i += 1
     return s, list_of_group_sizes[i:] + list_of_group_sizes[:i]
 
 def apply_N_rounds (k, list_of_group_sizes):
     # applies enough number of rounds on the roller coaster
     # until state of queue must repeat itself
     # returns a list of queue state and money earned after every round applied
     N = len(list_of_group_sizes)
     states = []
     money_earned_so_far = 0
     current_round = 0
 
     for curr_round in range(N+10):
         states.append((money_earned_so_far, tuple(list_of_group_sizes)))
         curr_money, list_of_group_sizes = apply_one_round (k, list_of_group_sizes)
         money_earned_so_far += curr_money
 
     return states
 
 
 def simulate_all_rounds (R, k, list_of_group_sizes):
     # make an efficient simulation of running the coaster R times
     N = len(list_of_group_sizes)
     states = apply_N_rounds (k, list_of_group_sizes)
     if R <= len(states)-1:
         return states[R][0]
     else:
         last_reached_queue_state =states[-1][1]
         i = len(states)-2
         while states[i][1] != last_reached_queue_state:
             i -=1
         len_of_repeating_cycle = len(states)-1-i
         money_through_cycle = states[-1][0] - states[i][0]
         n_cycles = (R-i) // len_of_repeating_cycle
         money_earned_so_far = states[i][0] + n_cycles*money_through_cycle
         last_round_reached = i + n_cycles*len_of_repeating_cycle
         more_rounds_needed = R - last_round_reached
         assert more_rounds_needed >=0
         list_of_group_sizes = states[-1][1]
         for i in range (more_rounds_needed):
             curr_money, list_of_group_sizes = apply_one_round (k, list_of_group_sizes)
             money_earned_so_far += curr_money
         return money_earned_so_far
     
 
 
     
 f_in = open('c:/temp/codejam/qualification/C-small-attempt0.in')
 f_out = open('c:/temp/codejam/qualification/C-small-attempt0.out','w')
 
 T = int(f_in.readline())
 for case in range(T):
     R, k, N = [int(x) for x in f_in.readline().split()]
     list_of_group_sizes = [int(x) for x in f_in.readline().split()]
     res = simulate_all_rounds (R,k, list_of_group_sizes)
     f_out.write('Case #' + str(case+1) + ': ' + str(res) + '\n')
 
 f_in.close()
 f_out.close()
 
",gcj/2010/433101/bigOnion/509101/0/extracted/problem_c.py,2607,72,258,Python,433101,0,509101,bigOnion,2010
37035,problem_b.py,"
 def gcd (a,b):
     ""gcd (a, b)  -  claculate greatest common divisor of a and b""
     if a==0:
         return b
     if b==0:
         return a
     while b != 0:
         a,b = b, a %b
     return a
 
 def gcd_list (l):
     ""gcd_list (l)  -  claculate greatest common divisor of all numbers in list l""
     g = l[0]
     for i in l[1:]:
         g = gcd(g,i)
     return g
 
 
 
 f_in = open('c:/temp/codejam/qualification/B-large.in')
 f_out = open('c:/temp/codejam/qualification/B-large.out','w')
 
 C = int(f_in.readline())
 print (C)
 for case in range(C):
     line = f_in.readline()
     list_of_event_times = [int(x) for x in line.split()][1:]
     max_time= max(list_of_event_times)
     time_differences = [max_time - x for x in list_of_event_times]
     g = gcd_list (time_differences)
     #print (list_of_event_times, time_differences, g)
     t_i = list_of_event_times[-1]
     if t_i % g == 0:
         res = 0
     else:
         res = (t_i// g +1)*g - t_i
 
     f_out.write('Case #' + str(case+1) + ': ' + str(res) + '\n')
 
 
 f_in.close()
 f_out.close()
 
",gcj/2010/433101/bigOnion/506101/1/extracted/problem_b.py,1081,45,139,Python,433101,1,506101,bigOnion,2010
37036,problem_b.py,"
 def gcd (a,b):
     ""gcd (a, b)  -  claculate greatest common divisor of a and b""
     if a==0:
         return b
     if b==0:
         return a
     while b != 0:
         a,b = b, a %b
     return a
 
 def gcd_list (l):
     ""gcd_list (l)  -  claculate greatest common divisor of all numbers in list l""
     g = l[0]
     for i in l[1:]:
         g = gcd(g,i)
     return g
 
 
 
 f_in = open('c:/temp/codejam/qualification/B-small-attempt0.in')
 f_out = open('c:/temp/codejam/qualification/B-small-attempt0.out','w')
 
 C = int(f_in.readline())
 print (C)
 for case in range(C):
     line = f_in.readline()
     list_of_event_times = [int(x) for x in line.split()][1:]
     max_time= max(list_of_event_times)
     time_differences = [max_time - x for x in list_of_event_times]
     g = gcd_list (time_differences)
     #print (list_of_event_times, time_differences, g)
     t_i = list_of_event_times[-1]
     if t_i % g == 0:
         res = 0
     else:
         res = (t_i// g +1)*g - t_i
 
     f_out.write('Case #' + str(case+1) + ': ' + str(res) + '\n')
 
 
 f_in.close()
 f_out.close()
 
",gcj/2010/433101/bigOnion/506101/0/extracted/problem_b.py,1099,45,139,Python,433101,0,506101,bigOnion,2010
37037,problem_a.py,"f_in = open ('c:/temp/codejam/qualification/A-large.in')
 f_out = open ('c:/temp/codejam/qualification/A-large.out','w')
 
 T = int(f_in.readline())
 for case in range(T):
     N,K = [int(x) for x in f_in.readline().split()]
     if (K+1) % (2**N) == 0:
         f_out.write ('Case #' + str(case+1) + ': ON\n')
     else:
         f_out.write ('Case #' + str(case+1) + ': OFF\n')
 
 f_in.close()
 f_out.close()
",gcj/2010/433101/bigOnion/502103/1/extracted/problem_a.py,411,14,47,Python,433101,1,502103,bigOnion,2010
37038,problem_a.py,"f_in = open ('c:/temp/codejam/qualification/A-small-attempt0.in')
 f_out = open ('c:/temp/codejam/qualification/A-small-attempt0.out','w')
 
 T = int(f_in.readline())
 for case in range(T):
     N,K = [int(x) for x in f_in.readline().split()]
     if (K+1) % (2**N) == 0:
         f_out.write ('Case #' + str(case+1) + ': ON\n')
     else:
         f_out.write ('Case #' + str(case+1) + ': OFF\n')
 
 f_in.close()
 f_out.close()
",gcj/2010/433101/bigOnion/502103/0/extracted/problem_a.py,429,14,47,Python,433101,0,502103,bigOnion,2010
67540,problem_c.py,"import time
 #from copy import deepcopy
 
 SMALL_LIMIT = 102
 print (time.ctime())
 
 f_in = open('c:/temp/codejam/round2/c/C-small-attempt1.in')
 f_out = open('c:/temp/codejam/round2/c/C-small-attempt1.out','w')
 
 def is_bacteria_in_mat (mat):
     for line in mat:
         if True in line:
             return True
     return False
 
 T = int(f_in.readline())
 for case in range(1,T+1):
 
     print (case,end ='  ')
     R  = int(f_in.readline())
     mat = [[False]*SMALL_LIMIT for i in range(SMALL_LIMIT)]
     start_diagonal = 2
     for rect in range(R):
         x1,y1,x2,y2 = [int(x) for x in f_in.readline().split()]
         for x in range(x1,x2+1):
             for y in range(y1,y2+1):
                 mat[x][y] = True
 
     print ('*')
     
     # simulate
 
     count_time = 0
     while is_bacteria_in_mat(mat):
         #mat2 = deepcopy(mat)
         for x in range(SMALL_LIMIT-1,0,-1):
             for y in range(SMALL_LIMIT-1,0,-1):
                 if mat[x-1][y] and mat[x][y-1]:
                     mat[x][y] = True
                 if (not mat[x-1][y]) and (not mat[x][y-1]):
                     mat[x][y] = False
 ##        for x in range(SMALL_LIMIT):
 ##            mat2[x][0] = False
 ##            mat2[0][x] = False
 
         count_time +=1
         
         
     f_out.write('Case #' + str(case) + ': ' + str(count_time) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
",gcj/2010/635102/bigOnion/706485/0/extracted/problem_c.py,1429,56,144,Python,635102,0,706485,bigOnion,2010
67541,problem_b.py,"import time
 from copy import deepcopy
 
 
 print (time.ctime())
 
 f_in = open('c:/temp/codejam/round2/b/B-small-attempt0.in')
 f_out = open('c:/temp/codejam/round2/b/B-small-attempt0.out','w')
 
 T = int(f_in.readline())
 for case in range(1,T+1):
 
     P = int(f_in.readline())
     M_arr = [int(x) for x in f_in.readline().split()]
     prices = []
     for i in range(P):
         prices.append([int(x) for x in f_in.readline().split()])
     game_price = prices[0][0]
     must_buy = [[False for i in range(2**j)] for j in range(P-1,-1,-1)]
     for i in range(2**P):
         for j in range(P-M_arr[i]):
             k = i//(2**(P-j))
             must_buy[-1-j][k] = True
     count = 0
     for l in must_buy:
         count += l.count(True)
     
     res = count * game_price
     
     f_out.write('Case #' + str(case) + ': ' + str(res) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
",gcj/2010/635102/bigOnion/698485/0/extracted/problem_b.py,915,37,101,Python,635102,0,698485,bigOnion,2010
67542,problem_a.py,"import time
 print (time.ctime())
 
 def is_elegant (d):
     l = len(d)
     for i in range(l//2+1):
         for j in range(l//2+1):
             tmp = [d[i][j], d[j][i], d[l-1-i][l-1-j],d[l-1-j][l-1-i]]
             while None in tmp:
                 tmp.remove(None)
             tmp.sort()
             if tmp and tmp[0] != tmp[-1]:
                 return False
     return True
 
             
 f_in = open('c:/temp/codejam/round2/a/A-small-attempt2.in')
 f_out = open('c:/temp/codejam/round2/a/A-small-attempt2.out','w')
 #f_in = open('c:/temp/codejam/round2/a/sample.in')
 #f_out = open('c:/temp/codejam/round2/a/sample.out','w')
 
 T = int(f_in.readline())
 for case in range(1,T+1):
 
     k = int(f_in.readline())
     diamond = [[None]*k for i in range(k)]
     for line in range(k):
         digits = [int(x) for x in f_in.readline().split()]
         for i in range(len(digits)):
             diamond[line-i][i] = digits[i]
         #print (diamond)
     for diag in range(k-1):
         digits = [int(x) for x in f_in.readline().split()]
         line = k + diag
         for i in range(len(digits)):
             diamond[k-i-1][line-(k-i-1)] = digits[i]
         #print (diamond)
 
     #print (diamond)
     #print ('**********************')
 
     res = None
     for good_size in range(k,2*k+2):
         if res != None:
             break
         for t1 in range(good_size-k+1):
             if res != None:
                 break
             for t2 in range(good_size-k+1):
                 diamond2 = [[None]*good_size for i in range(good_size)]
                 if res != None:
                     break
                 zevel = False
                 for line in range(k):
                     diamond2[line+t1][t2:t2+k] = diamond[line]
                     if len(diamond2[line+t1]) != good_size:
                         zevel = True
                 #print (k, good_size,diamond2)
                 if (not zevel) and is_elegant(diamond2):
                     res = (good_size) **2 - k**2
                     
         
     print (res)
     f_out.write('Case #' + str(case) + ': ' + str(res) + '\n')
 
 f_out.close()
 f_in.close()
 
 print (time.ctime())
 
",gcj/2010/635102/bigOnion/694485/0/extracted/problem_a.py,2191,71,202,Python,635102,0,694485,bigOnion,2010
32639,c.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/C/C-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/C/C-large.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     fin.readline()
     
     values = [int(x) for x in fin.readline().split()]
 
     xor_sum = 0
     for i in values:
         xor_sum ^= i
 
     if xor_sum == 0:
         # splitting possible
         best_split = sum(values) - min(values)
         outputline = 'Case #' + str(testcase)+': ' + str(best_split)
     else:
         # splitting impossible
         outputline = 'Case #' + str(testcase)+': ' + 'NO'
 
     fout.write (outputline+ '\n')
     
     
 
 
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/1059486/1/extracted/c.py,743,31,78,Python,975485,1,1059486,bigOnion,2011
32640,c.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/C/C-small-attempt0.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/C/C-small-attempt0.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     fin.readline()
     
     values = [int(x) for x in fin.readline().split()]
 
     xor_sum = 0
     for i in values:
         xor_sum ^= i
 
     if xor_sum == 0:
         # splitting possible
         best_split = sum(values) - min(values)
         outputline = 'Case #' + str(testcase)+': ' + str(best_split)
     else:
         # splitting impossible
         outputline = 'Case #' + str(testcase)+': ' + 'NO'
 
     fout.write (outputline+ '\n')
     
     
 
 
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/1059486/0/extracted/c.py,761,31,78,Python,975485,0,1059486,bigOnion,2011
32641,a.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/A/A-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/A/A-large.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     
     l = fin.readline().split()
     N= int(l[0])
     l = l[1:]
     buttons = []
     for i in range(N):
         buttons.append((l[0],int(l[1])))
         del l[:2]
 
     pos_o = 1
     pos_b = 1
     time_o = 0
     time_b = 0
 
     min_times = []
     for btn in buttons:
         if btn[0] == 'B':
             time_b += abs(pos_b-btn[1])+1
             min_times.append(['B', time_b])
             pos_b = btn[1]
         if btn[0] == 'O':
             time_o += abs(pos_o-btn[1])+1
             min_times.append(['O', time_o])
             pos_o = btn[1]
 
 
     for i in range(1,len(min_times)):
         if min_times[i][1] <= min_times[i-1][1]:
             if min_times[i][0] == 'O':
                 delay_o = min_times[i-1][1] - min_times[i][1] + 1
                 for j in range(i, len(min_times)):
                     if min_times[j][0] == 'O':
                         min_times[j][1] += delay_o
             elif min_times[i][0] == 'B':
                 delay_b = min_times[i-1][1] - min_times[i][1] + 1
                 for j in range(i, len(min_times)):
                     if min_times[j][0] == 'B':
                         min_times[j][1] += delay_b
             else:
                 assert ValueError
 
     all_time_o = max([0] + [x[1] for x in min_times if x[0] == 'O'])
     all_time_b = max([0] + [x[1] for x in min_times if x[0] == 'B'])
     all_time = max([all_time_o, all_time_b])
 
 
     outputline = 'Case #' + str(testcase)+': ' + str(all_time)
     fout.write (outputline+ '\n')
     
     
 
 
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/1080487/1/extracted/a.py,1817,62,183,Python,975485,1,1080487,bigOnion,2011
32642,a.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/A/A-small-attempt0.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/A/A-small-attempt0.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     
     l = fin.readline().split()
     N= int(l[0])
     l = l[1:]
     buttons = []
     for i in range(N):
         buttons.append((l[0],int(l[1])))
         del l[:2]
 
     pos_o = 1
     pos_b = 1
     time_o = 0
     time_b = 0
 
     min_times = []
     for btn in buttons:
         if btn[0] == 'B':
             time_b += abs(pos_b-btn[1])+1
             min_times.append(['B', time_b])
             pos_b = btn[1]
         if btn[0] == 'O':
             time_o += abs(pos_o-btn[1])+1
             min_times.append(['O', time_o])
             pos_o = btn[1]
 
 
     for i in range(1,len(min_times)):
         if min_times[i][1] <= min_times[i-1][1]:
             if min_times[i][0] == 'O':
                 delay_o = min_times[i-1][1] - min_times[i][1] + 1
                 for j in range(i, len(min_times)):
                     if min_times[j][0] == 'O':
                         min_times[j][1] += delay_o
             elif min_times[i][0] == 'B':
                 delay_b = min_times[i-1][1] - min_times[i][1] + 1
                 for j in range(i, len(min_times)):
                     if min_times[j][0] == 'B':
                         min_times[j][1] += delay_b
             else:
                 assert ValueError
 
     all_time_o = max([0] + [x[1] for x in min_times if x[0] == 'O'])
     all_time_b = max([0] + [x[1] for x in min_times if x[0] == 'B'])
     all_time = max([all_time_o, all_time_b])
 
 
     outputline = 'Case #' + str(testcase)+': ' + str(all_time)
     fout.write (outputline+ '\n')
     
     
 
 
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/1080487/0/extracted/a.py,1835,62,183,Python,975485,0,1080487,bigOnion,2011
32643,d.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/D/D-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/D/D-large.out','w')
 T = int(fin.readline())
 for testcase in range(1,T+1):
     fin.readline()
     array = [int(x) for x in fin.readline().split()]
     sorted_array = list(sorted(array))
     count_unsorted = 0
     for i in range(len(array)):
         if array[i] != sorted_array[i]:
             count_unsorted +=1
     fout.write ('Case #' + str(testcase) + ': ' + str(count_unsorted) + '\n')
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/992486/1/extracted/d.py,591,16,59,Python,975485,1,992486,bigOnion,2011
32644,d.py,"##
 ##
 ##N=300
 ##from fractions import Fraction
 ##    
 ##        
 ##def pre_process():
 ##    global solution
 ##
 ##    print ('factorials')
 ##    factorial = [1]
 ##    for i in range(1,N+1):
 ##        factorial.append(factorial[-1]*i)
 ##
 ##    print ('binoms')
 ##    n_choose_k = []
 ##    for n in range(N+1):
 ##        tmp = []
 ##        for k in range (N+1):
 ##            tmp.append(factorial[n]//(factorial[k]*factorial[n-k]))
 ##        n_choose_k.append(tmp)
 ##
 ##    print ('derangements')
 ##    derangements = [None]*(N+1)
 ##    derangements[0] = 1
 ##    derangements[1] = 0
 ##    for i in range(2,N+1):
 ##        derangements[i] = (i-1)*(derangements[i-1]+derangements[i-2])
 ##
 ##    print ('solution')
 ##    solution = [None]*(N+1)
 ##    solution[0] = Fraction(0,1)
 ##    solution[1] = Fraction(0,1)
 ##    solution[2] = Fraction(2,1)
 ##    for n in range(3,N+1):
 ##        tmp = [n_choose_k[n][k] * derangements[k] for k in range(n+1)]
 ##        assert sum(tmp) == factorial[n]
 ##        tmp2 = factorial[n]
 ##        for k in range(n):
 ##            tmp2 += tmp[k]*solution[k]
 ##        solution[n] = tmp2 / (factorial[n]-tmp[n])
 ##
 ##    return
 ##
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/D/D-small-attempt0.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/D/D-small-attempt0.out','w')
 T = int(fin.readline())
 for testcase in range(1,T+1):
     fin.readline()
     array = [int(x) for x in fin.readline().split()]
     sorted_array = list(sorted(array))
     count_unsorted = 0
     for i in range(len(array)):
         if array[i] != sorted_array[i]:
             count_unsorted +=1
     fout.write ('Case #' + str(testcase) + ': ' + str(count_unsorted) + '\n')
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/992486/0/extracted/d.py,1810,60,203,Python,975485,0,992486,bigOnion,2011
32645,b.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/b/B-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/b/B-large.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     
     l = fin.readline().split()
     
     C = int(l[0])
     combinations_dict = {}
     for s in l[1:1+C]:
         c1,c2,c3= s
         combinations_dict[(c1,c2)] = c3
         combinations_dict[(c2,c1)] = c3
 
     D = int(l[C+1])
     oppose_dict = {}
     for s in l[C+2:C+2+D]:
         c1,c2 = s
         oppose_dict[(c1,c2)] = 1
         oppose_dict[(c2,c1)] = 1
 
     N = int(l[C+2+D])
     S = l[C+D+3]
 
     invoke = []
     for c in S:
         if len(invoke)==0:
             invoke.append(c)
         else:
             last = invoke[-1]
             if (last,c) in combinations_dict:
                 invoke = invoke[:-1]
                 invoke.append(combinations_dict[last,c])
             else:
                 found_oppose = False
                 for c2 in invoke:
                     if (c2,c) in oppose_dict:
                         found_oppose = True
                         break
                 if found_oppose:
                     invoke = []
                 else:
                     invoke.append(c)
 
 
     # output
     l_out = 'Case #' + str (testcase) + ': ['
     if len(invoke)==0:
         pass
     else:
         for i in invoke[:-1]:
             l_out += i + ', '
         l_out += invoke[-1]
     l_out += ']\n'
     fout.write(l_out)
     
 
 
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/1026487/1/extracted/b.py,1577,64,147,Python,975485,1,1026487,bigOnion,2011
32646,b.py,"
 fin = open ('c:/users/hai/my projects/google code jam/2011/qualification/b/B-small-attempt0.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/qualification/b/B-small-attempt0.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     
     l = fin.readline().split()
     
     C = int(l[0])
     combinations_dict = {}
     for s in l[1:1+C]:
         c1,c2,c3= s
         combinations_dict[(c1,c2)] = c3
         combinations_dict[(c2,c1)] = c3
 
     D = int(l[C+1])
     oppose_dict = {}
     for s in l[C+2:C+2+D]:
         c1,c2 = s
         oppose_dict[(c1,c2)] = 1
         oppose_dict[(c2,c1)] = 1
 
     N = int(l[C+2+D])
     S = l[C+D+3]
 
     invoke = []
     for c in S:
         if len(invoke)==0:
             invoke.append(c)
         else:
             last = invoke[-1]
             if (last,c) in combinations_dict:
                 invoke = invoke[:-1]
                 invoke.append(combinations_dict[last,c])
             else:
                 found_oppose = False
                 for c2 in invoke:
                     if (c2,c) in oppose_dict:
                         found_oppose = True
                         break
                 if found_oppose:
                     invoke = []
                 else:
                     invoke.append(c)
 
 
     # output
     l_out = 'Case #' + str (testcase) + ': ['
     if len(invoke)==0:
         pass
     else:
         for i in invoke[:-1]:
             l_out += i + ', '
         l_out += invoke[-1]
     l_out += ']\n'
     fout.write(l_out)
     
 
 
 fin.close()
 fout.close()
",gcj/2011/975485/bigOnion/1026487/0/extracted/b.py,1595,64,147,Python,975485,0,1026487,bigOnion,2011
83900,d.py,"
 from copy import copy
 
 class Planet :
     def __init__ (self, val):
         self.v = val
         self.threatened = False
         self.threat = set([])
         self.step = 10000000000000000
 
 
 def relax (planet1, planet2):
     if planet1.step < 100000:
         if planet2.step > planet1.step + 1:
             planet2.step = planet1.step +1
             planet2.parent = planet1.value
             planet2.threat = planet1.threat.union(planet2.neighbors)
             planet2.conquer = copy(planet1.conquer)
             planet2.conquer.add(planet2.value)
             planet2.threat = planet2.threat.difference(planet2.conquer)
             #print ('relaxed :', planet2.value, planet2.parent, planet2.conquer, planet2.threat)
             planet2.step = planet1.step+1
         if planet2.step == planet1.step + 1:
             tmp_conquer = copy(planet1.conquer)
             tmp_conquer.add(planet2.value)
             tmp_threat = copy(planet1.threat)
             tmp_threat = tmp_threat.union(planet2.neighbors)
             tmp_threat = tmp_threat.difference(tmp_conquer)
             if len(tmp_threat) > len(planet2.threat):
                 planet2.step = planet1.step +1
                 planet2.parent = planet1.value
                 planet2.threat = planet1.threat.union(planet2.neighbors)
                 planet2.conquer = copy(planet1.conquer)
                 planet2.conquer.add(planet2.value)
                 planet2.threat = planet2.threat.difference(planet2.conquer)
                 planet2.step = planet1.step+1
                 #print ('relaxed! :', planet2.value, planet2.parent, planet2.conquer, planet2.threat)
     return
 
 
 
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/2/D/D-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/2/D/D-large.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     P,W = [int(x) for x in fin.readline().split()]
     l = fin.readline().split()
     #print ('l:',l)
     l2= []
     for i in l:
         pair = [int(x) for x in i.split(',')]
         l2.append(pair)
     #print (l2)
     d={}
     for i in range(500):
         d[i] = []
     for i,j in l2:
         d[i].append(j)
         d[j].append(i)
 
     planets = []
     for i in range(P):
         planets.append(Planet(i))
     for i in range(P):
         planets[i].neighbors = set(d[i][:])
         planets[i].parent = None
         planets[i].conquer = set([])
         planets[i].threat = set([])
         planets[i].step = 10000000000000000000000000
         planets[i].value = i
     
         
     conquered = [Planet(0)]
     step = 0
     planets[0].parent = None
     planets[0].threat = set(d[0][:])
     planets[0].step = 0
     planets[0].conquer = set([0])
 
     stopit = False
     for step in range(5000):
         #print ('step: ',step)
         for p in planets:
             if 1 in p.threat:
                 stopit = True
         if stopit:
             break
         for i in d:
             for j in d[i]:
                 #planets i,j are connected
                 if planets[i].step == step:
                     relax(planets[i],planets[j])
                 if planets[j].step == step:
                     relax(planets[j],planets[i])
 
     best = planets[0]
     for p in planets:
         if len(p.conquer) > len(best.conquer) or (len(p.conquer)==len(best.conquer) and len(p.threat) > len(best.threat)):
             if 1 in p.threat:
                 best = p
         
     #print (step, len(best.conquer),len(best.threat))  
 
     fout.write('Case #' + str(testcase) + ': ' + str(len(best.conquer)-1) + ' ' + str(len(best.threat))+'\n')
 fin.close()
 fout.close()
",gcj/2011/1150486/bigOnion/1201485/1/extracted/d.py,3697,110,315,Python,1150486,1,1201485,bigOnion,2011
83901,d.py,"
 from copy import copy
 
 class Planet :
     def __init__ (self, val):
         self.v = val
         self.threatened = False
         self.threat = set([])
         self.step = 10000000000000000
 
 
 def relax (planet1, planet2):
     if planet1.step < 100000:
         if planet2.step > planet1.step + 1:
             planet2.step = planet1.step +1
             planet2.parent = planet1.value
             planet2.threat = planet1.threat.union(planet2.neighbors)
             planet2.conquer = copy(planet1.conquer)
             planet2.conquer.add(planet2.value)
             planet2.threat = planet2.threat.difference(planet2.conquer)
             #print ('relaxed :', planet2.value, planet2.parent, planet2.conquer, planet2.threat)
             planet2.step = planet1.step+1
         if planet2.step == planet1.step + 1:
             tmp_conquer = copy(planet1.conquer)
             tmp_conquer.add(planet2.value)
             tmp_threat = copy(planet1.threat)
             tmp_threat = tmp_threat.union(planet2.neighbors)
             tmp_threat = tmp_threat.difference(tmp_conquer)
             if len(tmp_threat) > len(planet2.threat):
                 planet2.step = planet1.step +1
                 planet2.parent = planet1.value
                 planet2.threat = planet1.threat.union(planet2.neighbors)
                 planet2.conquer = copy(planet1.conquer)
                 planet2.conquer.add(planet2.value)
                 planet2.threat = planet2.threat.difference(planet2.conquer)
                 planet2.step = planet1.step+1
                 #print ('relaxed! :', planet2.value, planet2.parent, planet2.conquer, planet2.threat)
     return
 
 
 
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/2/D/D-small-attempt2.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/2/D/D-small-attempt2.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     P,W = [int(x) for x in fin.readline().split()]
     l = fin.readline().split()
     #print ('l:',l)
     l2= []
     for i in l:
         pair = [int(x) for x in i.split(',')]
         l2.append(pair)
     #print (l2)
     d={}
     for i in range(500):
         d[i] = []
     for i,j in l2:
         d[i].append(j)
         d[j].append(i)
 
     planets = []
     for i in range(P):
         planets.append(Planet(i))
     for i in range(P):
         planets[i].neighbors = set(d[i][:])
         planets[i].parent = None
         planets[i].conquer = set([])
         planets[i].threat = set([])
         planets[i].step = 10000000000000000000000000
         planets[i].value = i
     
         
     conquered = [Planet(0)]
     step = 0
     planets[0].parent = None
     planets[0].threat = set(d[0][:])
     planets[0].step = 0
     planets[0].conquer = set([0])
 
     stopit = False
     for step in range(5000):
         #print ('step: ',step)
         for p in planets:
             if 1 in p.threat:
                 stopit = True
         if stopit:
             break
         for i in d:
             for j in d[i]:
                 #planets i,j are connected
                 if planets[i].step == step:
                     relax(planets[i],planets[j])
                 if planets[j].step == step:
                     relax(planets[j],planets[i])
 
     best = planets[0]
     for p in planets:
         if len(p.conquer) > len(best.conquer) or (len(p.conquer)==len(best.conquer) and len(p.threat) > len(best.threat)):
             if 1 in p.threat:
                 best = p
         
     print (step, len(best.conquer),len(best.threat))  
 
     fout.write('Case #' + str(testcase) + ': ' + str(len(best.conquer)-1) + ' ' + str(len(best.threat))+'\n')
 fin.close()
 fout.close()
",gcj/2011/1150486/bigOnion/1201485/0/extracted/d.py,3714,110,315,Python,1150486,0,1201485,bigOnion,2011
83902,a2.py,"from fractions import Fraction
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/2/A/A-small-attempt3.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/2/A/A-small-attempt3.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     X,S,R,t,N = [int(x) for x in fin.readline().split()]
     l = []
     for i in range(N):
         B,E,w = [int(x) for x in fin.readline().split()]
         l.append((B,E,w))
 
     l2 = []
     location = 0
     while location != X:
         if l:
             i = l[0]
             if i[0] != location:
                 l2.append((location,i[0],0))
             l2.append(i)
             del l[0]
             location = i[1]
         else:
             break
     if location != X:
         l2.append((location,X,0))
     l2.sort()
 
     print (l2)
     
     stime = 0
     location = 0
     runn = True
     running_time = 0
     speed = R
     for i in l2:
         path_speed = speed + i[2]
         if runn:
             if running_time + Fraction(i[1]-location,path_speed) <=t:
                 running_time += Fraction(i[1]-location,path_speed)
                 #print (i[1], location)
                 stime += Fraction(i[1]-location,path_speed)
                 location = i[1]
             else:
                 stime += (t-running_time)
                 location += (t-running_time)*path_speed
                 runn = False
                 speed = S
             if running_time >=t:
                 runn = False
                 speed = S
         if not runn:
             path_speed = speed + i[2]
             stime += Fraction(i[1]-location,path_speed)
             location = i[1]
 
     print (stime)
 
 
         
 
     fout.write('Case #'+str(testcase) + ': ' + str(float(stime)) +'\n')
     print('*****************')
             
     
 
 fin.close()
 fout.close()
",gcj/2011/1150486/bigOnion/1163489/0/extracted/a2.py,1871,71,175,Python,1150486,0,1163489,bigOnion,2011
102724,b.py,"
 
 
 ##def is_legal (lst, D):
 ##    for i in range(len(lst)-1):
 ##        if lst[i][1] > lst[i+1][0]-D:
 ##            return False
 ##    return True
 
 
 def fix_problem (lst, D):
     for i in range(len(lst)-1):
         if lst[i][1] > lst[i+1][0]-D:
             leftmost = lst[i][0]
             rightmost = lst[i+1][1]
             max_time = max(lst[i][2],lst[i+1][2])
             if lst[i][2] > lst[i+1][2]:
                 rng = lst[i+1][1]-lst[i+1][0]
                 time_diff = lst[i][2] - lst[i+1][2]
                 rightmost = min(lst[i+1][1]-lst[i+1][0]+lst[i][1]+D,  lst[i+1][1]+time_diff)               
                 lst[i+1] = rightmost-rng, rightmost, lst[i][2]
             elif lst[i][2] < lst[i+1][2]:
                 rng = lst[i][1]-lst[i][0]
                 time_diff = lst[i+1][2] - lst[i][2]
                 leftmost = max( lst[i+1][0]-D-(lst[i][1]-lst[i][0]), lst[i][0]-time_diff)
                 lst[i] = leftmost, leftmost+rng, lst[i+1][2]
             if lst[i][1] > lst[i+1][0]-D:
                 x = (lst[i][1]+D-lst[i+1][0])/2
                 lst[i] = (lst[i][0]-x, lst[i+1][1]+x, lst[i][2]+x)
                 del lst[i+1]
             return True
     return False
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/1B/B/B-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/1B/B/B-large.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     C,D = map(int, fin.readline().split())
     print(C,D)
     l = []
     for i in range(C):
         P,V = map(int,fin.readline().split())
         l.append((P,V))
     l.sort()
     l2 =[]
     for i in range(len(l)):
         P,V = l[i]
         l2.append((P-(V-1)*D/2, P+(V-1)*D/2, (V-1)*D/2))
 
     #print(l2)
     while fix_problem(l2,D):
         #print(l2)
         pass
     #print(l2)
   
     t = max([x[2] for x in l2])
 
     otpt = 'Case #'+str(testcase) +': ' + str(t)
     print(otpt)
     #print()
     #print()
     #print()
     fout.write(otpt+'\n')
     
     
         
 
 fin.close()
 fout.close()
",gcj/2011/1150485/bigOnion/1058489/1/extracted/b.py,2067,72,180,Python,1150485,1,1058489,bigOnion,2011
102725,b.py,"
 
 
 ##def is_legal (lst, D):
 ##    for i in range(len(lst)-1):
 ##        if lst[i][1] > lst[i+1][0]-D:
 ##            return False
 ##    return True
 
 
 def fix_problem (lst, D):
     for i in range(len(lst)-1):
         if lst[i][1] > lst[i+1][0]-D:
             leftmost = lst[i][0]
             rightmost = lst[i+1][1]
             max_time = max(lst[i][2],lst[i+1][2])
             if lst[i][2] > lst[i+1][2]:
                 rng = lst[i+1][1]-lst[i+1][0]
                 time_diff = lst[i][2] - lst[i+1][2]
                 rightmost = min(lst[i+1][1]-lst[i+1][0]+lst[i][1]+D,  lst[i+1][1]+time_diff)               
                 lst[i+1] = rightmost-rng, rightmost, lst[i][2]
             elif lst[i][2] < lst[i+1][2]:
                 rng = lst[i][1]-lst[i][0]
                 time_diff = lst[i+1][2] - lst[i][2]
                 leftmost = max( lst[i+1][0]-D-(lst[i][1]-lst[i][0]), lst[i][0]-time_diff)
                 lst[i] = leftmost, leftmost+rng, lst[i+1][2]
             if lst[i][1] > lst[i+1][0]-D:
                 x = (lst[i][1]+D-lst[i+1][0])/2
                 lst[i] = (lst[i][0]-x, lst[i+1][1]+x, lst[i][2]+x)
                 del lst[i+1]
             return True
     return False
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/1B/B/B-small-attempt2.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/1B/B/B-small-attempt2.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     C,D = map(int, fin.readline().split())
     print(C,D)
     l = []
     for i in range(C):
         P,V = map(int,fin.readline().split())
         l.append((P,V))
     l.sort()
     l2 =[]
     for i in range(len(l)):
         P,V = l[i]
         l2.append((P-(V-1)*D/2, P+(V-1)*D/2, (V-1)*D/2))
 
     #print(l2)
     while fix_problem(l2,D):
         #print(l2)
         pass
     #print(l2)
   
     t = max([x[2] for x in l2])
 
     otpt = 'Case #'+str(testcase) +': ' + str(t)
     print(otpt)
     #print()
     #print()
     #print()
     fout.write(otpt+'\n')
     
     
         
 
 fin.close()
 fout.close()
",gcj/2011/1150485/bigOnion/1058489/0/extracted/b.py,2085,72,180,Python,1150485,0,1058489,bigOnion,2011
102726,a.py,"from fractions import Fraction
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/1B/A/A-large.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/1B/A/A-large.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     N = int(fin.readline())
     l = []
     for i in range(N):
         l.append(fin.readline())
 
     losses = [x.count('0') for x in l]
     wins = [x.count('1') for x in l]
     played = [losses[i] + wins[i] for i in range(N)]
     
     WP = [None]*N
     for i in range(N):
         WP[i] = Fraction (wins[i], played[i])
 
     OWP = []
     for j in range(N):
         tmp = 0
         c=0
         for i in range(N):
             if l[i][j] != '.':
                 c+=1
                 if l[i][j] == '1':
                     tmp += Fraction(wins[i]-1, played[i]-1)
                 else:
                     tmp += Fraction(wins[i], played[i]-1)
         #print ('*********', tmp, c)
         OWP.append(tmp/c)
 
     OOWP = []
     for j in range(N):
         tmp = 0
         c = 0
         for i in range(N):
             if l[i][j] != '.':
                 c += 1
                 tmp += OWP[i]
         #print ('########', tmp, c)
         OOWP.append(tmp/c)
 
     #print ('WP : ', WP)
     #print ('OWP : ', OWP)
     #print ('OOWP : ', OOWP)
     fout.write('Case #' + str(testcase) +':\n')
     for i in range(N):
         RPI = WP[i]/4 + OWP[i]/2 + OOWP[i]/4
         #print (RPI)
         fout.write (str(float(RPI))+'\n')
     
 
 fin.close()
 fout.close()
",gcj/2011/1150485/bigOnion/1048486/1/extracted/a.py,1538,59,178,Python,1150485,1,1048486,bigOnion,2011
102727,a.py,"from fractions import Fraction
 
 fin = open ('c:/users/hai/my projects/google code jam/2011/1B/A/A-small-attempt0.in')
 fout = open ('c:/users/hai/my projects/google code jam/2011/1B/A/A-small-attempt0.out','w')
 
 T = int(fin.readline())
 
 for testcase in range(1,T+1):
     N = int(fin.readline())
     l = []
     for i in range(N):
         l.append(fin.readline())
 
     losses = [x.count('0') for x in l]
     wins = [x.count('1') for x in l]
     played = [losses[i] + wins[i] for i in range(N)]
     
     WP = [None]*N
     for i in range(N):
         WP[i] = Fraction (wins[i], played[i])
 
     OWP = []
     for j in range(N):
         tmp = 0
         c=0
         for i in range(N):
             if l[i][j] != '.':
                 c+=1
                 if l[i][j] == '1':
                     tmp += Fraction(wins[i]-1, played[i]-1)
                 else:
                     tmp += Fraction(wins[i], played[i]-1)
         #print ('*********', tmp, c)
         OWP.append(tmp/c)
 
     OOWP = []
     for j in range(N):
         tmp = 0
         c = 0
         for i in range(N):
             if l[i][j] != '.':
                 c += 1
                 tmp += OWP[i]
         #print ('########', tmp, c)
         OOWP.append(tmp/c)
 
     #print ('WP : ', WP)
     #print ('OWP : ', OWP)
     #print ('OOWP : ', OOWP)
     fout.write('Case #' + str(testcase) +':\n')
     for i in range(N):
         RPI = WP[i]/4 + OWP[i]/2 + OOWP[i]/4
         #print (RPI)
         fout.write (str(float(RPI))+'\n')
     
 
 fin.close()
 fout.close()
",gcj/2011/1150485/bigOnion/1048486/0/extracted/a.py,1556,59,178,Python,1150485,0,1048486,bigOnion,2011
3662,A.py,"directory = 'C:/users/hai/my projects/google code jam/2012/2/A/'
 
 
 
 def solve_one_testcase (f_in, f_out, testcase):
     N  = int(f_in.readline())
     lst = []
     for i in range(N):
         d, l = [int(x) for x in f_in.readline().split()]
         lst.append((i,d,l))
         #print ('input:   ',i,d,l)
     D = int(f_in.readline())
     lst.append((len(lst),D,0))
     #print ('input : ', D)
     
 
     visited = [False]*len(lst)
     visited[0] = True
 
     visited_details = {}
 
     S = [(0,lst[0][1],lst[0][1])]
     while S:
         #print ('visiting : ', S[0])
         w, place, length = S[0]
         S = S[1:]
         neighbors = find_next_vines (lst, w, place, length)
         for u in neighbors:
             if not visited[u[0]] or visited_details[u[0]] < u[2]:
                 visited[u[0]] = True
                 visited_details[u[0]] = u[2]
                 S = S + [u]
 
     if visited[-1]:
         f_out.write ('Case #' + str(testcase) + ': YES\n')
         #print ('out : yes')
     else:
         f_out.write ('Case #' + str(testcase) + ': NO\n')
         #print ('out : no')
         
 
 
 def find_next_vines (lst, vine, place, length):
     l = []
     for i in range (vine+1, len(lst)):
         if lst[i][1] <= place + length:
             l.append((i,lst[i][1],min(lst[i][2],lst[i][1]-place)))
         else:
             break
     return l
 
 
 
 
 def solve_all_testcases (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print ('*****  Testcase ', testcase)
         solve_one_testcase(f_in, f_out, testcase)
    
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve_all_testcases(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
",gcj/2012/1842485/bigOnion/1481486/1/extracted/A.py,2301,92,239,Python,1842485,1,1481486,bigOnion,2012
3664,B.py,"directory = 'C:/users/hai/my projects/google code jam/2012/2/B/'
 
 
 
 def solve_one_testcase (f_in, f_out, testcase):
     line = f_in.readline()
     print (line)
     N,W,L = [int(x) for x in line.split()]
     r = [int(x) for x in f_in.readline().split()]
     assert len(r) == N
 
     print ('TESTCASE ', testcase)
     #print ('input : ', N,W,L)
     #print ('input : ',r)
     
     ordd = order_r (r)
     curr_row = 0
     next_col = 0
     next_row = 0
     positions = {}
     
     while len(ordd) != 0:
         arms, idd = ordd[0]
         ordd = ordd[1:]
         next_row = max (next_row, curr_row + arms)
         if next_col +arms > W:
             curr_row = next_row + arms
             next_col = 0
             next_row = curr_row+arms
         if next_col == 0:
             next_col = -arms
         assert curr_row >=0
         assert curr_row <=L
         assert next_col+arms >= 0
         assert next_col+arms <=W
         positions[idd] = (next_col+arms, curr_row)
         next_col = next_col + 2*arms
 
     f_out.write ('Case #' + str(testcase) + ': ')
     for k in sorted(positions):
         x,y = positions[k]
         #print (k, ' : ', x,y)
         f_out.write (str(x) +' ' + str(y) + ' ')
     f_out.write('\n')
 
     
     
 
 
 def order_r (r):
     r2 = r[:]
     o = []
     while (sum(r2)):
         arms = max(r2)
         index = r2.index(arms)
         r2[index] = 0
         o.append((arms,index))
     return o
 
 ##    skyline = [(0,W,0)]
 ##    positions = []
 ##    while sum(r) != 0:
 ##        place_next (W, L, skyline, positions, r)
 ##
 ##
 ##
 ##
 ##    f_out.write('Case #' + str(testcase) + ' :')
 ##    
 ##
 ##def place_next (W,L, skyline, positions, r):
 ##    arms = max(r)
 ##    index = r.find(arms)
 ##    r[index] = 0
 ##    for next_location in sorted_skyline(skyline):
 ##        if next_location[1] == 0:
 ##            next_location[1] == -arms
 ##            
 ##
 ##
 ##def is_valid_location (W,L,skyline,arms,x,y):
 ##    left_x = max(0,x-arms)
 ##    right_x = min(W,x+arms)
 ##    for t i in skyline:
 ##        if t[0]<=left_x and t[1] >=right_x
 ##def sorted_skyline (skyline):
 ##    c = []
 ##    for s in skyline:
 ##        ttt = [s[2],s[0],s[1]]
 ##        c.append(ttt)
 ##    c.sort()
 ##    return c
 ##
 ##    
 def solve_all_testcases (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print ('*****  Testcase ', testcase)
         solve_one_testcase(f_in, f_out, testcase)
    
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve_all_testcases(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
",gcj/2012/1842485/bigOnion/1484495/1/extracted/B.py,3207,132,385,Python,1842485,1,1484495,bigOnion,2012
3665,B.py,"directory = 'C:/users/hai/my projects/google code jam/2012/2/B/'
 
 
 
 def solve_one_testcase (f_in, f_out, testcase):
     line = f_in.readline()
     print (line)
     N,W,L = [int(x) for x in line.split()]
     r = [int(x) for x in f_in.readline().split()]
     assert len(r) == N
 
     print ('TESTCASE ', testcase)
     print ('input : ', N,W,L)
     print ('input : ',r)
     
     ordd = order_r (r)
     curr_row = 0
     next_col = 0
     next_row = 0
     positions = {}
     
     while len(ordd) != 0:
         arms, idd = ordd[0]
         ordd = ordd[1:]
         next_row = max (next_row, curr_row + arms)
         if next_col +arms > W:
             curr_row = next_row + arms
             next_col = 0
             next_row = curr_row+arms
         if next_col == 0:
             next_col = -arms
         assert curr_row >=0
         assert curr_row <=L
         assert next_col+arms >= 0
         assert next_col+arms <=W
         positions[idd] = (next_col+arms, curr_row)
         next_col = next_col + 2*arms
 
     f_out.write ('Case #' + str(testcase) + ': ')
     for k in sorted(positions):
         x,y = positions[k]
         print (k, ' : ', x,y)
         f_out.write (str(x) +' ' + str(y) + ' ')
     f_out.write('\n')
 
     
     
 
 
 def order_r (r):
     r2 = r[:]
     o = []
     while (sum(r2)):
         arms = max(r2)
         index = r2.index(arms)
         r2[index] = 0
         o.append((arms,index))
     return o
 
 ##    skyline = [(0,W,0)]
 ##    positions = []
 ##    while sum(r) != 0:
 ##        place_next (W, L, skyline, positions, r)
 ##
 ##
 ##
 ##
 ##    f_out.write('Case #' + str(testcase) + ' :')
 ##    
 ##
 ##def place_next (W,L, skyline, positions, r):
 ##    arms = max(r)
 ##    index = r.find(arms)
 ##    r[index] = 0
 ##    for next_location in sorted_skyline(skyline):
 ##        if next_location[1] == 0:
 ##            next_location[1] == -arms
 ##            
 ##
 ##
 ##def is_valid_location (W,L,skyline,arms,x,y):
 ##    left_x = max(0,x-arms)
 ##    right_x = min(W,x+arms)
 ##    for t i in skyline:
 ##        if t[0]<=left_x and t[1] >=right_x
 ##def sorted_skyline (skyline):
 ##    c = []
 ##    for s in skyline:
 ##        ttt = [s[2],s[0],s[1]]
 ##        c.append(ttt)
 ##    c.sort()
 ##    return c
 ##
 ##    
 def solve_all_testcases (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print ('*****  Testcase ', testcase)
         solve_one_testcase(f_in, f_out, testcase)
    
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve_all_testcases(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
",gcj/2012/1842485/bigOnion/1484495/0/extracted/B.py,3204,132,385,Python,1842485,0,1484495,bigOnion,2012
50675,B.py,"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     print ('Test cases : ',T)
     for i in range(1,T+1):
         line = f_in.readline()
         nnn = [int(x) for x in line.split()]
         S = nnn[1]
         p = nnn[2]
         t = nnn[3:]
         if p > 1:
             A = 0
             B = 0
             for t_i in t:
                 if t_i >=3*p-2:
                     A += 1
                 elif t_i >= 3*p-4:
                     B += 1
             result = A + min(B,S)
         if p == 1:
             result = len([x for x in t if x>=1])
         if p == 0:
             result=  len(t)
         f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')
 
 
 
 
 
 
 
 
 
 
 def main_run():
     import os
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 
 
 main_run()
",gcj/2012/1460488/bigOnion/1595491/1/extracted/B.py,1336,57,157,Python,1460488,1,1595491,bigOnion,2012
50677,C.py,"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'
 
 
 def solve (f_in, f_out):
     pre_calc = prepare()
     T = int(f_in.readline())
     for i in range(1,T+1):
         A,B = [int(x) for x in f_in.readline().split()]
         c = 0
         for m in range(A,B+1):
             c += len ([n for n in pre_calc[m] if n >=A])
         f_out.write('Case #' + str(i) + ': ' + str(c) + '\n')
 
 
 
 
 
 
 def prepare ():
     l = [None]* 2000001
     for n in range(1,2000001):
         recycled = []
         s = str(n)
         for c in range(1, len(s)):
             s2 = s[c:] + s[:c]
             if s2[0] != '0':
                 n2 = int(s2)
                 if n2 < n and n2 not in recycled:
                     recycled.append(n2)
         #recycled.sort()
         l [n] = recycled
     return l
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2012/1460488/bigOnion/1483488/1/extracted/C.py,1507,60,176,Python,1460488,1,1483488,bigOnion,2012
50679,D_small.py,"import time
 
 directory = 'C:/users/hai/my projects/google code jam/2012/qualification/D/'
 
 from math import sqrt
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for i in range(1,T+1):
         print ('Test Case : ',i)
         H, W, D = [int(x) for x in f_in.readline().split()]
         mat = []
         for line in range(H):
             mat.append(list(f_in.readline().replace('\n','')))
         res = solve_for_one_matrix(mat, D)
         f_out.write('Case #' + str(i) + ': ' + str(res) + '\n')
 
 
 
 
 
 
 def gcd (v_speed, h_speed):
     assert v_speed != 0
     assert h_speed != 0
     a = abs(v_speed)
     b = abs(h_speed)
     while a != 0:
         a,b = b%a,a
     return b
 
 
 
 def enlarge_matrix (mat, scale):
     assert scale %2 == 0
     height = len(mat)
     width = len(mat[0])
     #mat2 = [['.'] * (width*scale) for x in range(height*scale)]
     for i in range(height):
         for j in range(width):
             p = mat[i][j]
             if p == 'X':
                 location_y = i*scale+scale//2
                 location_x = j*scale+scale//2
             #elif p == '#':
             #    for t in range(scale):
             #        for s in range(scale):
             #            mat2[i*scale+t][j*scale+s] = '#'
     return len(mat[0])*scale, len(mat)*scale, location_x, location_y
 
 def make_n_moves (n, width, height, scale, location_x, location_y, x_speed, y_speed):
     for i in range(n):
         assert x_speed !=0 
         assert location_x >=scale
         assert location_x <=width-scale
         
         if x_speed < 0 and location_x == scale:
             x_speed = -x_speed
         elif location_x == width-scale and x_speed > 0:
             x_speed = -x_speed
 
         location_x += x_speed
 
     for i in range(n):
         assert y_speed != 0
         assert location_y >=scale
         assert location_y <=height-scale
         
         if location_y == scale and y_speed < 0:
             y_speed = -y_speed
         elif location_y == height-scale and y_speed > 0:
             y_speed = -y_speed
 
         location_y += y_speed
 
     return location_x, location_y, x_speed, y_speed
          
     
 def make_one_move (width, height, scale, location_x, location_y, x_speed, y_speed):
     assert x_speed !=0 and y_speed != 0
     assert location_x >=scale
     assert location_y >=scale
     assert location_x <=width-scale
     assert location_y <=height-scale
     
     if x_speed < 0 and location_x == scale:
         x_speed = -x_speed
     elif location_x == width-scale and x_speed > 0:
         x_speed = -x_speed
     if location_y == scale and y_speed < 0:
         y_speed = -y_speed
     elif location_y == height-scale and y_speed > 0:
         y_speed = -y_speed
         
             
     return location_x+x_speed, location_y+y_speed, x_speed, y_speed
 
 
 
 def solve_for_one_matrix (mat, D):
     print (time.ctime())
     count = 0
     print_matrix(mat)
     print ('D = ', D)
     print ('Rays : ')
 
     good_directions = []
     width, height, location_x, location_y = enlarge_matrix(mat,2)
 
     # direction down
     if (height-2) - location_y <= D:
         good_directions.append ((0,1))
 
     # direction up
     if location_y-2 <=D:
         good_directions.append ((0,-1))
 
     #direction right
     if (width-2) - location_x <= D:
         good_directions.append((1,0))
 
     #direction left
     if location_x-2 <=D:
         good_directions.append((-1,0))
 
     print (good_directions)
 
     # diagonal directions
     for p in range(1, D*2+1):
         for q in range(1, p+1):
             if gcd (p,q) !=1:
                 continue
             scale = p*q*2
 
             move_distance = sqrt(p**2 + q**2)
             if move_distance == round(move_distance):
                 allowed_moves = D*scale // int(move_distance)
             else:
                 allowed_moves = int(D*scale / move_distance)
 
             if allowed_moves < scale:
                 continue
 
             width, height, original_location_x, original_location_y = enlarge_matrix(mat,scale)
 
 
             #print ('DEBUG: ',p,q,D,allowed_moves)
             
             arr = [(p,q),(-p,q),(p,-q),(-p,-q),(q,p),(-q,p),(q,-p),(-q,-p)]
             arr = unique(arr)
             for direction in arr:
 
                 #print ('DEBUG:',direction)
                 count_moves = 0
                 x_speed, y_speed = direction
                 continue_in_this_direction = True
                 location_x = original_location_x
                 location_y = original_location_y
                 for i in range(allowed_moves//(scale//2)):
                     retval = make_n_moves(scale//2, width, height, scale, location_x, location_y, x_speed, y_speed)
                     count_moves += scale//2
                     location_x, location_y, x_speed, y_speed = retval
                     if location_x == original_location_x and location_y == original_location_y:
                         good_directions.append((direction[0],direction[1], count_moves, allowed_moves, allowed_moves//(scale//2)*(scale//2)))
                         #print (good_directions[-1], end= ', ')
                         break
 
 
     print()
     #print(good_directions)
     count = len(good_directions)
     print (count)
     return count
 
 
 def unique(arr):
     arr2 = []
     for i in arr:
         if i not in arr2:
             arr2.append(i)
     return arr2
 
 def print_matrix (mat):
     for line in mat:
         print (''.join(line))
 
 
 
 def main_run():
     import os
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
 
 #test_loop_speed()
 
",gcj/2012/1460488/bigOnion/1285485/0/extracted/D_small.py,6243,218,615,Python,1460488,0,1285485,bigOnion,2012
50680,skeleton.py,"directory = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'
 
 
 t= '''ay
 bh
 ce
 ds
 eo
 fc
 gv
 hx
 id
 ju
 ki
 lg
 ml
 nb
 ok
 pr
 qz
 rt
 sn
 tw
 uj
 vp
 wf
 xm
 ya
 zq'''
 
 table = {}
 for line in t.split():
     table[line[0]] = line[1]
 
 def translate (line):
     l = list(line)
     for i in range(len(l)):
         if l[i] in table:
             l[i] = table[l[i]]
     return ''.join(l)
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for i in range(1,T+1):
         line = f_in.readline()
         out_line = translate(line)
         f_out.write('Case #' + str(i) + ': ' + out_line)
 
 
 
 
 
 
 
 
 
 
 def main_run():
     import os
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 
 
 main_run()
",gcj/2012/1460488/bigOnion/1483485/0/extracted/skeleton.py,1200,78,142,Python,1460488,0,1483485,bigOnion,2012
99047,B.py,"directory = 'C:/users/hai/my projects/google code jam/2012/1C/B/'
 
 from math import sqrt
 from fractions import Fraction
 
 def strfloat_to_fraction (s):
     try:
         if s[0] == '-':
             s = s[1:]
             is_negative = True
         else:
             is_negative= False
         
         a = s.split('.')
         if len(a) == 1:
             return int(a[0])
         assert len(a)==2
         if a[1] == '':
             return int(a[0])
         
         if a[0] == '':
             first = 0
         else:
             first = int(a[0])
         f = first + Fraction(int(a[1]),10**len(a[1]))
         if is_negative:
             f = -f
         return f
 
     except:
         raise ValueError('could not convert string to Fraction: ' + repr(s))
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         line = f_in.readline().split()
         D = strfloat_to_fraction(line[0])
         N = int(line[1])
         f_out.write ('Case #' + str(testcase) + ':\n')
         
         if N == 2:
             t0, x0 = [strfloat_to_fraction(x) for x in f_in.readline().split()]
             t1, x1 = [strfloat_to_fraction(x) for x in f_in.readline().split()]
             accs = [strfloat_to_fraction(x) for x in f_in.readline().split()]
             assert t0 == 0
             assert x1 >= D
             assert x1 >= x0
             for a in accs:
                 if x1 == x0 or x0 >=D:
                     assert x0 >=D
                     res = sqrt (2*D/a)
                 else:
                     velocity = (x1-x0)/t1
                     t_end = (D-x0)/velocity
                     #print (testcase, float(t0),float(x0),float(t1),float(x1),float(D),float(a))
                     if D <= a*t_end**2/2:
                         res = float(t_end)
                     else:
                         res = sqrt (2*D/a)
                     #print (res)
                 f_out.write(str(res) + '\n')
                 
         else:
             assert N==1
             t0, x0 = [strfloat_to_fraction(x) for x in f_in.readline().split()]
             accs = [strfloat_to_fraction(x) for x in f_in.readline().split()]
             assert t0 == 0
             assert x0 >= D
             for a in accs:
                 #print (testcase, float(t0),float(x0),float(D),float(a))
                 res = sqrt (2*D/a)
                 #print (res)
                 f_out.write(str(res) + '\n')
             
 
         print ()
 
         
 
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
",gcj/2012/1781488/bigOnion/1482492/0/extracted/B.py,3212,116,306,Python,1781488,0,1482492,bigOnion,2012
99048,A.py,"directory = 'C:/users/hai/my projects/google code jam/2012/1C/A/'
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         N  = int(f_in.readline())
         nodes_parents = [None for i in range(N+1)]
         nodes_reaches = [[] for i in range(N+1)]
         for i in range(1,N+1):
             nodes_parents[i] = [int(x) for x in f_in.readline().split()[1:]]
 
         try:
             answer = 'No'
             for i in range(1,N+1):
                 walk (nodes_parents, nodes_reaches, i, i)
         except ValueError:
             answer = 'Yes'
 
         f_out.write('Case #' + str(testcase) + ': ' + answer + '\n')
         
 
 
 def walk (nodes_parents, nodes_reaches, initiating_node, curr):
     if initiating_node != curr:
         if initiating_node in nodes_reaches[curr]:
             raise ValueError
         nodes_reaches[curr].append(initiating_node)
     for nextnode in nodes_parents[curr]:
         walk (nodes_parents, nodes_reaches, initiating_node, nextnode)
 
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
",gcj/2012/1781488/bigOnion/1674486/0/extracted/A.py,1727,66,169,Python,1781488,0,1674486,bigOnion,2012
99049,C.py,"directory = 'C:/users/hai/my projects/google code jam/2012/1C/C/'
 
 q1 = []
 q2 = []
 memo = {}
 
 def solve (f_in, f_out):
     global q1
     global q2
     global memo
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         N,M = [int(x) for x in f_in.readline().split()]
         l1 = [int(x) for x in f_in.readline().split()]
         l2 = [int(x) for x in f_in.readline().split()]
         assert len(l1) == N*2
         assert len(l2) == M*2
         q1 = []
         q2 = []
         memo = {}
         for i in range(N):
             q1.append((l1[i*2],l1[i*2+1]))
         for i in range(M):
             q2.append((l2[i*2],l2[i*2+1]))
 
         res = memo_search (q1[0][0],q2[0][0],0,0)
 
         f_out.write('Case #' + str(testcase) + ': ' + str(res) + '\n')
 
 
 def memo_search (remain_q1, remain_q2, loc_q1, loc_q2):
     global q1
     global q2
     global memo
     
     if (remain_q1, remain_q2, loc_q1, loc_q2) in memo:
         return memo[(remain_q1, remain_q2, loc_q1, loc_q2)]
     
     if loc_q1 >= len(q1):
         return 0
     if loc_q2 >= len(q2):
         return 0
     
     if remain_q1 == 0:
         if loc_q1 == len(q1)-1:
             memo[(remain_q1, remain_q2, loc_q1, loc_q2)] = 0
             return 0
         else:
             result = memo_search(q1[loc_q1+1][0], remain_q2,loc_q1+1,loc_q2)
             memo[(remain_q1, remain_q2, loc_q1, loc_q2)] = result
             return result
 
     if remain_q2 == 0:
         if loc_q2 == len(q2)-1:
             memo[(remain_q1, remain_q2, loc_q1, loc_q2)] = 0
             return 0
         else:
             result = memo_search(remain_q1, q2[loc_q2+1][0],loc_q1,loc_q2+1)
             memo[(remain_q1, remain_q2, loc_q1, loc_q2)] = result
             return result
 
     
     item1 = q1[loc_q1][1]
     item2 = q2[loc_q2][1]
     if item1 == item2:
         addition = min (remain_q1, remain_q2)
         result = addition + memo_search(remain_q1-addition, remain_q2-addition,loc_q1,loc_q2)
         memo[(remain_q1, remain_q2, loc_q1, loc_q2)] = result
         return result
 
     tmp1 = 0
     tmp2 = 0
     if loc_q1 < len(q1)-1:
         # throw from queue1
         tmp1 = memo_search (q1[loc_q1+1][0], remain_q2,loc_q1+1,loc_q2)
         
     if loc_q2 < len(q2)-1:
         # throw from queue1
         tmp2 = memo_search (remain_q1, q2[loc_q2+1][0],loc_q1,loc_q2+1)
 
     result = max(tmp1,tmp2)
     memo[(remain_q1, remain_q2, loc_q1, loc_q2)] = result
     return result
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 
",gcj/2012/1781488/bigOnion/1485490/1/extracted/C.py,3196,118,330,Python,1781488,1,1485490,bigOnion,2012
16604,B.py,"directory = 'C:/users/hai/my projects/google code jam/2013/round1b/B/'
 
 
 from decimal import Decimal
 from fractions import Fraction
 
 
 def factorial (n):
     s = 1
     for i in range(1,n+1):
         s *= i
     return s
 
 def binomial (n,k):
     if k > n:
         print ('oh no!')
         return 0
     return factorial (n) // (factorial(k)*factorial(n-k))
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         #print ('\ntestcase = ' , testcase)
         N, X, Y = [int(x) for x in f_in.readline().split()]
         result = calc (N,X,Y)
         f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\n')
 
 
 def calc (N, X, Y, debug=0):
     if debug:
         print ('N = ', N)
         print ('X,Y = ',X,Y)
     
     if Y < 0:
         return 0
     if (X+Y) % 2 == 1:
         return 0
 
     l = 1
     while sum(range(1,l+1)) <= N:
         l += 2
 
     if debug:
         print ('l = ',l)
     
     if abs(X) + abs(Y) +1 < l:
         return 1
 
     if abs(X) + abs(Y)  + 1 > l :
         return 0
 
     if X == 0:
         if sum(range(1,Y+2)) <= N:
             return 1
         else:
             return 0
         
     n0 = N - sum(range(1,l-1))
     if debug:
         print ('n0 = ',n0)
 ##    if n0 > (l-1):
 ##        print ('kuku1')
 ##        leftovers = n0 - 2 * (n0 - (l-1))
 ##        height = Y - (n0 - (l-1))
 ##    else:
 ##        print ('kuku2')
 ##        leftovers = n0
 ##        height = Y
 
 ##    print ('leftovers = ', leftovers)
 ##    print ('height =', height)
 ##    s = 0
 ##    for i in range(height+1, leftovers+1):
 ##        s += binomial (leftovers, i)
 
 ##    print ('s = ',s)
 
     if (Y+1) + (l-1) <= n0:
         if debug:
             print ('here')
         return 1
 
     if debug:
         print ('kuku')
     s = 0
     for i in range(Y+1, n0+1):
         s += binomial (n0, i)
     if debug:
         print ('s = ',s)
     
     #return  make_decimal_string(Fraction(s, 2**n0))
     return  float(Fraction(s, 2**n0))
     #return Decimal(s) / Decimal(2**leftovers)
 
 
 
 def make_decimal_string(frac):
     nom_high = 999999999
     nom_low = 1
 
     while nom_high - nom_low > 1:
         #print (nom_high, nom_low)
         nom_mid = (nom_high + nom_low)//2
         if Fraction(nom_mid, 1000000000) > frac:
             nom_high = nom_mid
         else:
             nom_low = nom_mid
 
     assert Fraction (nom_mid,1000000000) - frac < Fraction(1,1000000)
 
     return '0.' + ('0'*10 + str(nom_mid))[-9:]
 
         
         
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2434486/bigOnion/2700486/1/extracted/B.py,3244,142,410,Python,2434486,1,2700486,bigOnion,2013
16606,A.py,"directory = 'C:/users/hai/my projects/google code jam/2013/round1b/A/'
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         #print (testcase)
         A,N = [int(x) for x in f_in.readline().split()]
         s = [int(x) for x in f_in.readline().split()]
         s.sort()
         sugg = [len(s)]
         if A == 1 and s[0] >=1:
             pass
         else:
             moves = 0
             while s:
                 while A <= s[0]:
                     moves += 1
                     A = A*2-1
                 A += s[0]
                 s = s[1:]
                 sugg.append(moves + len(s))
         result = min(sugg)
         f_out.write('Case #' + str(testcase) + ': '+ str(min(sugg)) + '\n')
 
 
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2434486/bigOnion/2692487/1/extracted/A.py,1452,60,152,Python,2434486,1,2692487,bigOnion,2013
16607,A.py,"directory = 'C:/users/hai/my projects/google code jam/2013/round1b/A/'
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print (testcase)
         A,N = [int(x) for x in f_in.readline().split()]
         s = [int(x) for x in f_in.readline().split()]
         s.sort()
         sugg = [len(s)]
         if A == 1 and s[0] >=1:
             pass
         else:
             moves = 0
             while s:
                 while A <= s[0]:
                     moves += 1
                     A = A*2-1
                 A += s[0]
                 s = s[1:]
                 sugg.append(moves + len(s))
         result = min(sugg)
         f_out.write('Case #' + str(testcase) + ': '+ str(min(sugg)) + '\n')
 
 
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2434486/bigOnion/2692487/0/extracted/A.py,1451,60,152,Python,2434486,0,2692487,bigOnion,2013
93523,A.py,"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'
 
 
 def solve (f_in, f_out):
     N = int(f_in.readline())
     for testcase in range(1,N+1):
         sqr = []
         for i in range(4):
             sqr.append(list(f_in.readline().split()[0]))
         assert len(f_in.readline().split()) == 0
 
         f_out.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'\n')
     
 
 def get_all_lines(sqr):
     lines = []
     for line in sqr:
         lines.append(list(line))
     for column in range(4):
         line = []
         for row in range(4):
             line.append(sqr[row][column])
         lines.append(list(line))
 
     diag1 = []
     diag2 = []
     for  i in range(4):
         diag1.append(sqr[i][i])
         diag2.append(sqr[i][3-i])
     lines.append(diag1)
     lines.append(diag2)
 
     return lines
     
 def get_square_winner (sqr):
     for line in get_all_lines(sqr):
         if get_line_winner (line):
             return get_line_winner (line)
 
     for row in sqr:
         if '.' in row:
             return ""Game has not completed""
     return ""Draw""
 
 
 
 
 def get_line_winner (line):
     if line.count('X') == 4:
         return ""X won""
     if line.count('X') == 3 and 'T' in line:
         return ""X won""
     
     if line.count('O') == 4:
         return ""O won""
     if line.count('O') == 3 and 'T' in line:
         return ""O won""
 
 
     return None
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2270488/bigOnion/2453486/1/extracted/A.py,2131,93,216,Python,2270488,1,2453486,bigOnion,2013
93525,C_2.py,"
 # as part of the solution the function pre_process() must be run in advance!!
 # before downloading the input and running main_run()
 
 
 directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'
 
 
 import itertools
 import time
 
 
 def pre_process():
     fairs = set([1,2,3])
     for length in range(1,27):
         print(time.ctime(), length)
         digits = [[0,1] for i in range(length)]
         for comb in itertools.product(*digits):
             if sum(comb) > 5:
                 continue
             comb1 = list(comb) + list(reversed(comb))
             comb2 = list(comb) + list(reversed(comb))[1:]
 
             fairs.add(int(''.join([str(x) for x in comb1])))
             fairs.add(int(''.join([str(x) for x in comb2])))
 
             for i in range(len(comb1)):
                 c1 = list(comb1)
                 c1[i] = 2
                 c1[-i-1] = 2
                 fairs.add(int(''.join([str(x) for x in c1])))
             
             for i in range(len(comb2)):
                 c2 = list(comb2)
                 c2[i] = 2
                 c2[-i-1] = 2
                 fairs.add(int(''.join([str(x) for x in c2])))
 
     fairs.remove(0)
     fairs = list(sorted(fairs))
     
     print (' len of fairs = ', len(fairs))
     f = open(directory + 'pre_process_fair_and_squares.txt', 'w')
     for n in fairs:
         if is_palindrome(n) and is_palindrome(n**2):
             f.write(str(n**2)+'\n')
 
     f.close()
     return
 
 
 def is_palindrome (n):
     l = list(str(n))
     return list(reversed(l)) == l
 
   
 def solve (f_in, f_out):
     print(time.ctime())
     global fair_and_squares
     f = open(directory + 'pre_process_fair_and_squares.txt')
     fair_and_squares = [int(x) for x in f.readlines()]
     f.close()
     print(time.ctime())
     print(len(fair_and_squares))
     
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         A,B = [int(x) for x in f_in.readline().split()]
         count = len([x for x in fair_and_squares if (x>=A and x<=B)])
         f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 #pre_process()
 main_run()
 
 
",gcj/2013/2270488/bigOnion/2463486/2/extracted/C_2.py,2820,102,282,Python,2270488,2,2463486,bigOnion,2013
93526,C.py,"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'
 
 
 def is_palindrome (n):
     l = list(str(n))
     return list(reversed(l)) == l
 
 def prepare ():
     global fair_and_squares
     fair_and_squares = []
     
     for i in range(1,10**7):
         if is_palindrome(i):
             sqr = i**2
             if is_palindrome(sqr):
                 fair_and_squares.append(sqr)
     return
 
         
 def solve (f_in, f_out):
     prepare()
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         A,B = [int(x) for x in f_in.readline().split()]
         count = len([x for x in fair_and_squares if (x>=A and x<=B)])
         f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2270488/bigOnion/2463486/1/extracted/C.py,1419,55,147,Python,2270488,1,2463486,bigOnion,2013
93528,B.py,"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'
 
 
 from copy import deepcopy
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         #print (testcase)
         N,M = [int(x) for x in f_in.readline().split()]
         sqr = []
         for i in range(N):
             sqr.append([int(x) for x in f_in.readline().split()])
         res = get_result(sqr)
         f_out.write('Case #' + str(testcase) + ': ' + res + '\n')
 
 
 def get_result (sqr):
     while len(sqr) > 1 and len(sqr[0]) > 1:
         #print (sqr)
         r,c = 0,0
         for row in range(len(sqr)):
             for col in range(len(sqr[0])):
                 if sqr[row][col] < sqr[r][c]:
                     r,c = row, col
         min_val = sqr[r][c]
         whole_row = list(sqr[r])
         whole_col = []
         for row in range(len(sqr)):
             whole_col.append(sqr[row][c])
         assert min(whole_row) == min_val
         assert min(whole_col) == min_val
         if max(whole_row) == min_val:
             sqr = remove_row(sqr,r)
         elif max(whole_col) == min_val:
             sqr = remove_col(sqr,c)
         else:
             return 'NO'
 
     return 'YES'
     
 
 
 
 
 
 def remove_row (sqr, row):
     cpy = deepcopy(sqr)
     del cpy[row]
     return cpy
 
 def remove_col (sqr,col):
     cpy = deepcopy(sqr)
     for row in cpy:
         del row[col]
     return cpy
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2270488/bigOnion/2449486/1/extracted/B.py,2136,87,223,Python,2270488,1,2449486,bigOnion,2013
93529,B.py,"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'
 
 
 from copy import deepcopy
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print (testcase)
         N,M = [int(x) for x in f_in.readline().split()]
         sqr = []
         for i in range(N):
             sqr.append([int(x) for x in f_in.readline().split()])
         res = get_result(sqr)
         f_out.write('Case #' + str(testcase) + ': ' + res + '\n')
 
 
 def get_result (sqr):
     while len(sqr) > 1 and len(sqr[0]) > 1:
         print (sqr)
         r,c = 0,0
         for row in range(len(sqr)):
             for col in range(len(sqr[0])):
                 if sqr[row][col] < sqr[r][c]:
                     r,c = row, col
         min_val = sqr[r][c]
         whole_row = list(sqr[r])
         whole_col = []
         for row in range(len(sqr)):
             whole_col.append(sqr[row][c])
         assert min(whole_row) == min_val
         assert min(whole_col) == min_val
         if max(whole_row) == min_val:
             sqr = remove_row(sqr,r)
         elif max(whole_col) == min_val:
             sqr = remove_col(sqr,c)
         else:
             return 'NO'
 
     return 'YES'
     
 
 
 
 
 
 def remove_row (sqr, row):
     cpy = deepcopy(sqr)
     del cpy[row]
     return cpy
 
 def remove_col (sqr,col):
     cpy = deepcopy(sqr)
     for row in cpy:
         del row[col]
     return cpy
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2270488/bigOnion/2449486/0/extracted/B.py,2134,87,223,Python,2270488,0,2449486,bigOnion,2013
93530,D.py,"directory = 'C:/users/hai/my projects/google code jam/2013/qualification/D/'
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print('\n******************** Testcase ', testcase)
         K,N = [int(x) for x in f_in.readline().split()]
         keys = [int(x) for x in f_in.readline().split()]
         assert len(keys) == K
         chests = []
         for i in range(N):
             a = [int(x) for x in f_in.readline().split()]
             T_i = a[0]
             K_i = a[1]
             chests.append([False, a[0],a[2:]])
 
         solution =  find_way (keys, chests)
 
         if solution != None:
             f_out.write('Case #' + str(testcase) + ': ' + ' '.join([str(x+1) for x in solution]) + '\n')
         else:
             f_out.write('Case #' + str(testcase) + ': IMPOSSIBLE\n')
 
 
 
 
 def is_there_still_a_way (keys, chests):
     all_keys = list(keys)
     closed_chests = [chst for chst in chests if chst[0] == False]
     for chst in closed_chests:
         all_keys.extend(chst[2])
     chst_types = [chst[1] for chst in closed_chests]
     for chst_type in chst_types:
         if chst_types.count(chst_type) > all_keys.count(chst_type):
             #print ('Not enough keys to open chests of types ', chst_type)
             return False
 
     #print ('keys = ', sorted(all_keys))
     #print ('chest_types = ', sorted(chst_types))
     
     return True
 
 
 
     
 def find_way (keys, chests):
 
 
     if not is_there_still_a_way(keys,chests):
         print ('Not enough keys to open chests of specific type')
         return None
 
 
     states_reached = set()
     
     maximal_opened_chest = [-1] * (len(chests)+2)
     trail = []
 
     # get first chest that can be opened
     found = None
     for c in range(len(chests)):
         if chests[c][1] in keys:
             found = c
             break
 
     if found == None:
         return None
 
     trail.append(c)
 
     while trail:
         #print ('Trail :', trail)
 
         if len(trail) == len(chests):
             # finished!!!!
             return trail
 
         
         step = len(trail)
         current_chest = trail[-1]
         chests[current_chest][0] = True
         keys.remove(chests[current_chest][1])
         keys.extend(chests[current_chest][2])
         maximal_opened_chest[step] = current_chest
         maximal_opened_chest[step+1] = -1
 
         states_reached.add(tuple(sorted(trail)))
 
         next_try = None
         if is_there_still_a_way(keys,chests):
             for c in range(maximal_opened_chest[step+1]+1, len(chests)):
                 if (not chests[c][0]) and chests[c][1] in keys:
                     if tuple(sorted(trail+[c])) not in states_reached:
                         next_try = c
                         break
 
         while next_try == None and len(trail) > 0:
             last_opened_chest = trail.pop()
             chests[last_opened_chest][0] = False
             key_to_reappend = chests[last_opened_chest][1]
             keys_to_remove = chests[last_opened_chest][2]
             
             for ky in keys_to_remove:
                 keys.remove(ky)
             keys.append(key_to_reappend)
 
             step = len(trail)
 
             next_try = None
             for c in range(maximal_opened_chest[step+1]+1, len(chests)):
                 if (not chests[c][0]) and chests[c][1] in keys:
                     if tuple(sorted(trail+[c])) not in states_reached:
                         next_try = c
                         break
 
         if next_try != None:
             trail.append(next_try)
 
 
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2013/2270488/bigOnion/2458486/0/extracted/D.py,4321,151,402,Python,2270488,0,2458486,bigOnion,2013
63287,D.py,"directory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'
 
 from copy import deepcopy
 import itertools
 
 
 from random import choice
 
 INCREASING = 501
 DECREASING = 502
 NO_ORDER = 503
 
 def play_war (l_n, l_k, inc_val):
     assert inc_val in [INCREASING, DECREASING, NO_ORDER]
     assert len(l_n) == len(l_k)
     if inc_val == INCREASING:
         l_n = list(sorted(l_n))
     if inc_val == DECREASING:
         l_n = list(reversed(sorted(l_n)))
     l_k = list(sorted(l_k))
     naomi_wins = 0
     for i in range(len(l_n)):
         val = l_n[0]
         l_n = l_n[1:]
         if l_k[-1] < val:
             l_k = l_k[1:]
             naomi_wins += 1
         else:
             for j in range(len(l_k)):
                 if l_k[j] > val:
                     del l_k[j]
                     break
 
     return naomi_wins
 
 
 def play_deceitful (l_n, l_k):
     l_n = list(sorted(l_n))
     l_k = list(sorted(l_k))
     naomi_wins = 0
     assert len(l_n) == len(l_k)
     while len(l_n):
         if l_n[-1] < l_k[-1]:
             l_n = l_n[1:]
             l_k = l_k[:-1]
         else:
             l_n = l_n[:-1]
             l_k = l_k[:-1]
             naomi_wins += 1
     return naomi_wins
             
             
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         N = int(f_in.readline())
         l_n = [float(x) for x in f_in.readline().split()]
         l_k = [float(x) for x in f_in.readline().split()]
 
         a1 = play_war (l_n, l_k, INCREASING)
         a2 = play_war (l_n, l_k, DECREASING)
         a3 = play_war (l_n, l_k, NO_ORDER)
         assert a1 == a2
         assert a2 == a3
         b = play_deceitful (l_n, l_k)
 
         f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '\n')
 
 
         
         
 
     
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 def randomize_arrs (n):
     l = []
     for i in range(2*n):
         r = choice(range(2**30))
         while r in l:
             r = choice(range(2**30))
         l.append(r)
     return l[:n], l[n:]
 
",gcj/2014/2974486/bigOnion/5644738749267968/1/extracted/D.py,2725,109,302,Python,2974486,1,5644738749267968,bigOnion,2014
63289,B.py,"directory = 'C:/users/me/desktop/google code jam/2014/qualification/B/'
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         line = f_in.readline()
         C,F,X = [float(q) for q in line.split()]
         result = compute (C,F,X)
         f_out.write('Case #' + str(testcase) + ': ' + str(result) + '\n')
 
 
 def compute(C,F,X):
     cps = 2
     farms = 0
     timespent = 0
     while X / cps > C/cps + X/(cps+F):
         farms += 1
         timespent += C/cps
         cps += F
 
     return timespent + X/cps
 
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2014/2974486/bigOnion/5709773144064000/1/extracted/B.py,1252,54,142,Python,2974486,1,5709773144064000,bigOnion,2014
63291,C2.py,"directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'
 
 from copy import deepcopy
 import itertools
 
 
 def solve_one_case (R,C,M):
         l = []
         for i in range(R):
             for j in range(C):
                 l.append((i,j))
 
         empty_mat = []
         for i in range(R):
             empty_mat.append(['.']*C)
 
         found = False
 
         assert (0,0) in l
         l = l[1:]
         l = l[::-1]
         assert (0,0) not in l
         
         output = ''
         
         for mine_placement in itertools.combinations(l,M):
             mat = deepcopy(empty_mat)
             for cell in mine_placement:
                 mat[cell[0]][cell[1]] = '*'
             if isOneClick(mat, R, C, M):
                 mat[0][0] = 'c'
                 for line in mat:
                     output += ''.join(line) + '\n'
                 found = True
                 return output
             
         if not found:
             return 'Impossible\n'
         
         assert ValueError()
         
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         line = f_in.readline()
         R,C,M = [int(q) for q in line.split()]
         print (testcase,R,C,M)
 
         output = solve_one_case (R,C,M)
         f_out.write('Case #' + str(testcase) + ':\n')
         f_out.write(output)
 
         
 
 
 def isOneClick (mat, R, C, M):
 ##    if mat[0][0] != '.':
 ##        return False
 ##    assert len(mat) == R
 ##    lens = [len(l) for l in mat]
 ##    assert min(lens) == C
 ##    assert max(lens) == C
 ##    assert sum([l.count('*') for l in mat]) == M
 
     mat_cpy = deepcopy(mat)
     oneclickcells = [(0,0)]
     while oneclickcells:
         node = oneclickcells.pop()
         mat_cpy[node[0]][node[1]] = 'v'
         if noNearbyMines(mat_cpy,node):
             oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))
 
     #print (mat_cpy)
     return sum([l.count('.') for l in mat_cpy]) == 0
     
 
 def getNearbyUnvisited(mat, node):
     R = len(mat)
     C = len(mat[0])
     deltas_r = [0]
     deltas_c = [0]
     if node[0] > 0:
         deltas_r.append(-1)
     if node[1] > 0:
         deltas_c.append(-1)
     if node[0] < R-1:
         deltas_r.append(1)
     if node[1] < C-1:
         deltas_c.append(1)
 
     ret_list = []
     for delta_r in deltas_r:
         for delta_c in deltas_c:
             next_node = (node[0]+delta_r, node[1] + delta_c)
             if mat[next_node[0]][next_node[1]] not in ['*','v']:
                 ret_list.append((next_node[0],next_node[1]))
 
     return ret_list
 
 def noNearbyMines(mat,node):
     R = len(mat)
     C = len(mat[0])
     deltas_r = [0]
     deltas_c = [0]
     if node[0] > 0:
         deltas_r.append(-1)
     if node[1] > 0:
         deltas_c.append(-1)
     if node[0] < R-1:
         deltas_r.append(1)
     if node[1] < C-1:
         deltas_c.append(1)
 
     for delta_r in deltas_r:
         for delta_c in deltas_c:
             if mat[node[0] + delta_r][node[1] + delta_c] == '*':
                 return False
     return True
     
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
 
 ##bads = []
 ##goods = []
 ##
 ##for R in range(1,6):
 ##    for C in range(1,6):
 ##        for M in range(1,R*C+1):
 ##            print (R,C,M)
 ##            output = solve_one_case (R,C,M)
 ##            if output[0] == 'I':
 ##                bads.append((R,C,M))
 ##            else:
 ##                goods.append((R,C,M))
 ##
",gcj/2014/2974486/bigOnion/5690574640250880/0/extracted/C2.py,4135,159,430,Python,2974486,0,5690574640250880,bigOnion,2014
63292,A.py,"directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'
 
 
 
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         
         c1 = int(f_in.readline())
         l1 = []
         for i in range(4):
             l1.append(f_in.readline())
         
         c2 = int(f_in.readline())
         l2 = []
         for i in range(4):
             l2.append(f_in.readline())
 
         d1 = l1[c1-1].split()
         d2 = l2[c2-1].split()
 
         foundFlag = False
         chosenCard = None
         badMagician = False
         for card in d1:
             if card in d2:
                 if not foundFlag:
                     foundFlag = True
                     chosenCard = card
                 else:
                     badMagician = True
 
         f_out.write('Case #' + str(testcase) + ': ')
         if badMagician:
             f_out.write('Bad magician!\n')
         elif not foundFlag:
             f_out.write('Volunteer cheated!\n')
         else:
             f_out.write(chosenCard + '\n')
 
 
 
 
 def main_run():
     import os
     import time
     filenames = [x for x in os.listdir (directory)]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
     chosen_filename =  sorted(l1)[-1][1][:-3]
 
     print ('Directory : ', directory)
     print ('Chosen Filename : ',chosen_filename)
     print()
     print ('Start : ', time.ctime())
     print()
     
     f_in = open(directory+chosen_filename+'.in')
     f_out = open(directory+chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
     print ()
     print ('End : ', time.ctime())
 
 
 main_run()
",gcj/2014/2974486/bigOnion/5756407898963968/0/extracted/A.py,1748,69,163,Python,2974486,0,5756407898963968,bigOnion,2014
122463,fegla.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 def memoize_it(inner_func):
     # a decorator for memoizing function outputs
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 def reset_memoization ():
     # clear all previous memoization. For use in the beginning of a new test-case
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 def time_it(inner_func):
     # a decorator for adding printing of timing for a function
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 def count_it (inner_func):
     # a decorator for counting the number of calls to the wrapped function
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 def pre_process_it (inner_func):
     # a decorator for pre-processing the function and automatically save the result 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
         
 
 ###########################################
 # write code here
 ###########################################
 
 @time_it
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print('****************testcase ', testcase)
         f_out.write('Case #' + str(testcase) + ': ')
         N = int(f_in.readline())
         l = []
         for i in range(N):
             l.append(f_in.readline().replace('\n',''))
         l2 = [no_repeat(x) for x in l]
         if l2 != [l2[0]] * N:
             f_out.write('Fegla Won\n')
         else:
             unique_letters = l2[0]
             #print ('unique', unique_letters)
             n_unique = len(unique_letters)
             l3 = [count_reps(s, unique_letters) for s in l]
             #print ('l3',l3)
             moves = 0
             for j in range(n_unique):
                 ttt = [x[j] for x in l3]
                 #print ('ttt',ttt)
                 med = median(ttt)
                 #print('med', med)
                 moves += sum([abs(t-med) for t in ttt])
                 #print('moves', med)
             f_out.write(str(moves) + '\n') 
                 
 
 def median (lst):
     lst2 = list(sorted(lst))
     n = len(lst2)
     #print ('??????', lst2, n)
     if n %2 == 1:
         return lst2[(n-1)//2]
     else:
         return (lst2[n//2] + lst2[n//2-1])//2
     
 def no_repeat(s):
     s2 = s[0]
     for i in range(1,len(s)):
         if s2[-1] != s[i]:
             s2 += s[i]
     return s2
 
 
 def count_reps (s, unique_letters):
     l = []
     i = 0
     n = len(s)
     for c in unique_letters:
         rep = 0
         while i <n and s[i] == c:
             rep += 1
             i += 1
         l.append(rep)
     assert i == n
     return tuple(l)
 
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 @time_it
 def main_run():
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames]
     if not l1:
         raise ValueError('No input file found')
     chosen_filename =  sorted(l1)[-1][1][:-3]
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(chosen_filename+'.in')
     f_out = open(chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 main_run()
",gcj/2014/2994486/bigOnion/5751500831719424/1/extracted/fegla.py,5856,184,596,Python,2994486,1,5751500831719424,bigOnion,2014
122465,salesman_small.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 def memoize_it(inner_func):
     # a decorator for memoizing function outputs
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 def reset_memoization ():
     # clear all previous memoization. For use in the beginning of a new test-case
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 def time_it(inner_func):
     # a decorator for adding printing of timing for a function
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 def count_it (inner_func):
     # a decorator for counting the number of calls to the wrapped function
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 def pre_process_it (inner_func):
     # a decorator for pre-processing the function and automatically save the result 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
         
 
 ###########################################
 # write code here
 ###########################################
 
 import itertools
 
 @time_it
 def solve (f_in, f_out):
     T = int(f_in.readline())
     
     for testcase in range(1,T+1):
         N,M = [int(x) for x in f_in.readline().split()]
         zipcodes = [None]
         for l in range(N):
             zipcodes.append(f_in.readline().replace('\n',''))
         neighbors = {}
         for l in range(1,N+1):
             neighbors[l] = []
         for l in range(M):
             i,j = [int(x) for x in f_in.readline().split()]
             neighbors[i].append(j)
             neighbors[j].append(i)
         
         minimal_code_found = 10**1000
         
         for prm in itertools.permutations(range(1,N+1)):
             travelcode = ''.join([zipcodes[i] for i in prm])
             if int(travelcode) > minimal_code_found:
                 continue
             
             if is_prm_possible(prm, neighbors):
                 minimal_code_found = int(travelcode)
         
         f_out.write('Case #' + str(testcase) + ': ' + str(minimal_code_found) + '\n')
     
         
     
 def is_prm_possible (prm, neighbors):
     root = prm[0]
     backtrack = [root]
     for next_node in prm[1:]:
         while backtrack and next_node not in neighbors[backtrack[-1]]:
             backtrack.pop()
         if len(backtrack) == 0:
             return False
         else:
             assert next_node in neighbors[backtrack[-1]]
             backtrack.append(next_node)
     return True
 
         
     
 
 
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 @time_it
 def main_run():
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames]
     if not l1:
         raise ValueError('No input file found')
     chosen_filename =  sorted(l1)[-1][1][:-3]
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(chosen_filename+'.in')
     f_out = open(chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 main_run()
",gcj/2014/2994486/bigOnion/5731331665297408/0/extracted/salesman_small.py,5654,174,536,Python,2994486,0,5731331665297408,bigOnion,2014
122466,lotytery_small.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 def memoize_it(inner_func):
     # a decorator for memoizing function outputs
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 def reset_memoization ():
     # clear all previous memoization. For use in the beginning of a new test-case
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 def time_it(inner_func):
     # a decorator for adding printing of timing for a function
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 def count_it (inner_func):
     # a decorator for counting the number of calls to the wrapped function
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 def pre_process_it (inner_func):
     # a decorator for pre-processing the function and automatically save the result 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
         
 
 ###########################################
 # write code here
 ###########################################
 
 @time_it
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         A,B,K = [int(x) for x in f_in.readline().split()]
         w = 0
         for i in range(A):
             for j in range(B):
                 if i&j < K:
                     w += 1
         f_out.write('Case #' + str(testcase) + ': '+ str(w) + '\n')
         
 
 
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 @time_it
 def main_run():
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames]
     if not l1:
         raise ValueError('No input file found')
     chosen_filename =  sorted(l1)[-1][1][:-3]
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(chosen_filename+'.in')
     f_out = open(chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 main_run()
",gcj/2014/2994486/bigOnion/5658282861527040/0/extracted/lotytery_small.py,4558,138,459,Python,2994486,0,5658282861527040,bigOnion,2014
151771,up_down_seq_small.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 def memoize_it(inner_func):
     # a decorator for memoizing function outputs
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 def reset_memoization ():
     # clear all previous memoization. For use in the beginning of a new test-case
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 def time_it(inner_func):
     # a decorator for adding printing of timing for a function
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 def count_it (inner_func):
     # a decorator for counting the number of calls to the wrapped function
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 def pre_process_it (inner_func):
     # a decorator for pre-processing the function and automatically save the result 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
         
 
 ###########################################
 # write code here
 ###########################################
 import itertools
 
 
 
 def count_moves(A, p):
     copy_A = A[:]
     res = 0
     for i in p:
         res += copy_A.index(i)
         copy_A.remove(i)
     return res
         
     
 def is_legal (p):
     mx = max(p)
     ind = p.index(mx)
     for i in range(ind):
         if p[i] > p[i+1]:
             return False
     for i in range(ind, len(p)-1):
         if p[i] < p[i+1]:
             return False
     return True
 
 
 def powerset(iterable):
     ""powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)""
     s = list(iterable)
     return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s)+1))
 
 
 @time_it
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1, T+1):
         print (testcase)
         N = int(f_in.readline())
         A = [int(x) for x in f_in.readline().split()]
         #mx = max(A)
         assert N  == len(A)
         best_choice = 10**80
         for subset1 in powerset(A):
             subset2 = set(A).difference(subset1)
             arranged = list(sorted(subset1)) + list(sorted(subset2,reverse=True))
             assert len(arranged) == len(A)
             if is_legal(arranged):
                 m  =  count_moves(A, arranged)
                 #print(A, p, m)
                 best_choice = min(best_choice, m)
         
         f_out.write('Case #' + str(testcase) + ': ' + str(best_choice) + '\n')
         print()
 
 
 
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 @time_it
 def main_run():
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames]
     if not l1:
         raise ValueError('No input file found')
     chosen_filename =  sorted(l1)[-1][1][:-3]
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(chosen_filename+'.in')
     f_out = open(chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 main_run()
",gcj/2014/3014486/bigOnion/5721094409420800/0/extracted/up_down_seq_small.py,5632,178,563,Python,3014486,0,5721094409420800,bigOnion,2014
151772,trie.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 def memoize_it(inner_func):
     # a decorator for memoizing function outputs
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 def reset_memoization ():
     # clear all previous memoization. For use in the beginning of a new test-case
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 def time_it(inner_func):
     # a decorator for adding printing of timing for a function
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 def count_it (inner_func):
     # a decorator for counting the number of calls to the wrapped function
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 def pre_process_it (inner_func):
     # a decorator for pre-processing the function and automatically save the result 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
         
 
 ###########################################
 # write code here
 ###########################################
 
 from itertools import  *
 
 def count_nodes_on_server (subset):
     a = set()
     for word in subset:
         for i in range(len(word)+1):
             a.add(word[:i])
     return len(a)
 
 @time_it
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1,T+1):
         print(testcase)
         scores = {}
         M,N = [int(x) for x in f_in.readline().split()]
         S = []
         for i in range(M):
             S.append(f_in.readline().replace('\n',''))
         for prdct in product (range(N), repeat=M):
             nodes = 0
             for server in range(N):
                 subset = [S[i] for i in range(M) if prdct[i] == server]
                 nodes += count_nodes_on_server(subset)
             scores[tuple(prdct)] = nodes
         
         worst_case = max(scores.values())
         counter = len([x for x in scores.items() if x[1] == worst_case])
         f_out.write('Case #' + str(testcase) + ': ' + str(worst_case) + ' '+ str(counter) + '\n')
         
             
 
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 @time_it
 def main_run():
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames]
     if not l1:
         raise ValueError('No input file found')
     chosen_filename =  sorted(l1)[-1][1][:-3]
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(chosen_filename+'.in')
     f_out = open(chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 main_run()
",gcj/2014/3014486/bigOnion/5649687893770240/0/extracted/trie.py,5215,156,523,Python,3014486,0,5649687893770240,bigOnion,2014
151773,discs.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 def memoize_it(inner_func):
     # a decorator for memoizing function outputs
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 def reset_memoization ():
     # clear all previous memoization. For use in the beginning of a new test-case
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 def time_it(inner_func):
     # a decorator for adding printing of timing for a function
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 def count_it (inner_func):
     # a decorator for counting the number of calls to the wrapped function
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 def pre_process_it (inner_func):
     # a decorator for pre-processing the function and automatically save the result 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
         
 
 ###########################################
 # write code here
 ###########################################
 
 from bisect import *
 
 def index(a, x):
     'Locate the leftmost value exactly equal to x'
     i = bisect_left(a, x)
     if i != len(a) and a[i] == x:
         return i
     raise ValueError
 
 def find_lt(a, x):
     'Find rightmost value less than x'
     i = bisect_left(a, x)
     if i:
         return a[i-1]
     raise ValueError
 
 def find_le(a, x):
     'Find rightmost value less than or equal to x'
     i = bisect_right(a, x)
     if i:
         return a[i-1]
     raise ValueError
 
 def find_gt(a, x):
     'Find leftmost value greater than x'
     i = bisect_right(a, x)
     if i != len(a):
         return a[i]
     raise ValueError
 
 def find_ge(a, x):
     'Find leftmost item greater than or equal to x'
     i = bisect_left(a, x)
     if i != len(a):
         return a[i]
     raise ValueError
 
 @time_it
 def solve (f_in, f_out):
     T = int(f_in.readline())
     for testcase in range(1, T+1):
         N, X = [int(x) for x in f_in.readline().split()]
         S = [int(x) for x in f_in.readline().split()]
         S.sort()
         cds_needed = 0
         while S:
             mx_val = S[-1]
             del S[-1]
             if S and S[0] + mx_val <= X:
                 other_val = find_le(S, X-mx_val)
                 i = index(S, other_val)
                 del S[i]
             cds_needed += 1
         f_out.write('Case #' + str(testcase) + ': ' + str(cds_needed) + '\n')
 
 
             
 
 
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 @time_it
 def main_run():
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     filenames = [x for x in filenames if x.endswith('.in')]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames]
     if not l1:
         raise ValueError('No input file found')
     chosen_filename =  sorted(l1)[-1][1][:-3]
     print ('Chosen Filename : ',chosen_filename)
     print()
     f_in = open(chosen_filename+'.in')
     f_out = open(chosen_filename+'.out', 'w')
     solve(f_in,f_out)
     f_in.close()
     f_out.close()
 
 
 main_run()
",gcj/2014/3014486/bigOnion/5737429512224768/1/extracted/discs.py,5621,183,600,Python,3014486,1,5737429512224768,bigOnion,2014
4810,pool.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def calc (V, X, N, R, C):
     if N == 1:
         if C[0] != X:
             return 'IMPOSSIBLE'
         else:
             return V / R[0]
     
     if N == 2:
         if C[0] > C[1]:
             R[1], R[0] = R[0], R[1]
             C[1], C[0] = C[0], C[1]
         
         if X < C[0] or X > C[1]:
             return 'IMPOSSIBLE'
         
         if X == C[0] and X < C[1]:
             return V / R[0]
         if X == C[1] and X > C[0]:
             return V / R[1]
         
         if X == C[0] == C[1]:
             return V / (R[0] + R[1])
         
         assert C[0] < X < C[1]
         
         V1 = V*(X-C[0]) / (C[1]-C[0])
         #V1 = int(V1 * (10**8)) / (10**8)
         assert V1 >= -(10**(-6))
         V0 = V - V1
         print (V, X, V0, V1)
         #V0 = int(V0 * (10**8)) / (10**8)
         assert V0 >= -(10**(-6))
         
         return max (V1/R[1], V0/R[0])
         
     
     raise NotImplementedError
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     N, V, X = [float(x) for x in ioWrapper.readline().split()]
     N = int(N)
     
     R = []
     C = []
     for i in range(N):
         R_i, C_i = [float(x) for x in ioWrapper.readline().split()]
         R.append(R_i)
         C.append(C_i)
 
     result = calc (V, X, N, R, C)
     if type(result) == float:
         result = '%.8f' % result
 
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(result) + '\n')
 
 
 
 main_run()
",gcj/2015/8234486/bigOnion/5750872826970112/0/extracted/pool.py,9173,269,986,Python,8234486,0,5750872826970112,bigOnion,2015
4811,language.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 from itertools import *
 import random
 import operator
 import collections
 
 def powerset(iterable):
     ""powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)""
     s = list(iterable)
     return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))
 
 def calc (sentences):
 
     best_found = 2**100
     
     #a = ' '.join(sentences)
     #words  = collections.Counter(a.split())
     #for word in words:
     #    if words[word] == 1:
     #        for i in range(len(sentences)):
     #            sentences[i] = sentences[i].replace(' ' + word + ' ',' ')
     #            sentences[i] = sentences[i].replace(word + ' ','')
     #            sentences[i] = sentences[i].replace(' ' + word,'')
     
     sentences2 = []
     for snt in sentences:
         sentences2.append(set(snt.split()))
         
     del sentences
     
     assert len(sentences2) >= 2
     
     
     
     e1 = []
     f1 = []
     
     a = set(list(range(2, min(11,len(sentences2)))))
     for subset in powerset (list(range(2,min(11,len(sentences2))))):
         english_sentences = set(subset)
         french_sentences = a.difference(english_sentences)
         
         eng_dict = set(sentences2[0])
         for i in english_sentences:
             eng_dict.update(sentences2[i])
             
         frn_dict = set(sentences2[1])
         for i in french_sentences:
             frn_dict.update(sentences2[i])
         
         e1.append(eng_dict)
         f1.append(frn_dict)
     
     
     if len(sentences2) > 11:
             
         e2 = []
         f2 = []
         b = set(list(range(11, len(sentences2))))
         for subset in powerset (list(range(11,len(sentences2)))):
             english_sentences = set(subset)
             french_sentences = b.difference(english_sentences)
             
             eng_dict = set()
             for i in english_sentences:
                 eng_dict.update(sentences2[i])
                 
             frn_dict = set()
             for i in french_sentences:
                 frn_dict.update(sentences2[i])
             
             e2.append(eng_dict)
             f2.append(frn_dict)
         
         best_found = min(best_found, len(eng_dict.intersection(frn_dict)))
 
     else:
         e2 = []
         f2 = []
     
     assert len(e1) == len(f1)
     assert len(e2) == len(f2)
     
     if not e2:
         for i in range(len(e1)):
             eng_dict = e1[i]
             frn_dict = f1[i]
             best_found = min(best_found, len(eng_dict.intersection(frn_dict)))
     
     else:
         for i in range(len(e1)):
             for j in range(len(e2)):
                 eng_dict = e1[i].intersection(e2[j])
                 frn_dict = f1[i].intersection(f2[j])
                 best_found = min(best_found, len(eng_dict.intersection(frn_dict)))
                 
         
     assert best_found >= 0
     assert best_found < 2**50
     
     return best_found
 
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     N = int(ioWrapper.readline())
     print ('*****', ioWrapper.getTestcase(), N)
     sentences = []
     for i in range(N):
         sentences.append(ioWrapper.readline().replace('\n',''))
     
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(calc(sentences)) + '\n')
 
 
 
 
 main_run()
",gcj/2015/8234486/bigOnion/5759940174020608/0/extracted/language.py,11041,326,1062,Python,8234486,0,5759940174020608,bigOnion,2015
4812,pegman.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 EMPTY = '.'
 UP = '^'
 DOWN = 'v'
 RIGHT = '>'
 LEFT = '<'
 
 def get_row (matrix, i):
     return matrix[i]
 
 def get_column(matrix, j):
     return [row[j] for row in matrix]
 
 def calc (matrix, n_rows, n_columns):
     count = 0
     rows = [get_row(matrix, r) for r in range(n_rows)]
     cols = [get_column(matrix, c) for c in range(n_columns)]
     
     for r in range(n_rows):
         for c in range(n_columns):
             if matrix[r][c] != EMPTY:
                 if rows[r].count(EMPTY) == n_columns-1 and cols[c].count(EMPTY) == n_rows-1:
                     return 'IMPOSSIBLE'
     
     counted = set()
     
     for r in range(n_rows):
         row = rows[r]
         if row.count(EMPTY) == len(row):
             continue
         
         if row.count(EMPTY) == len(row)-1:
             c = 0
             while row[c] == EMPTY:
                 c += 1
             arrow = row[c]
             if arrow == LEFT or arrow == RIGHT:
                 if (r,c) not in counted:
                     count += 1
                     counted.add((r,c))
         
         else:
             assert row.count(EMPTY) <= len(row)-2
             
             c = 0
             while row[c] == EMPTY:
                 c += 1
             if row[c] == LEFT:
                 if (r,c) not in counted:
                     counted.add((r,c))
                     count += 1
             
             c = len(row)-1
             while row[c] == EMPTY:
                 c -= 1
             if row[c] == RIGHT:
                 if (r,c) not in counted:
                     counted.add((r,c))
                     count += 1
 
 
 
     del r
     del row
     
 
     for c in range(n_columns):
         col = cols[c]
         if col.count(EMPTY) == len(col):
             continue
         
         if col.count(EMPTY) == len(col)-1:
             r = 0
             while col[r] == EMPTY:
                 r += 1
             arrow = col[r]
             if arrow == UP or arrow == DOWN:
                 if (r,c) not in counted:
                     count += 1
                     counted.add((r,c))
         
         else:
             assert col.count(EMPTY) <= len(col)-2
             
             r = 0
             while col[r] == EMPTY:
                 r += 1
             if col[r] == UP:
                 if (r,c) not in counted:
                     count += 1
                     counted.add((r,c))
             
             r = len(col)-1
             while col[r] == EMPTY:
                 r -= 1
             if col[r] == DOWN:
                 if (r,c) not in counted:
                     count += 1
                     counted.add((r,c))
     
 
     assert len(counted) == count
     print (counted)
     return count
 
         
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     
     print (ioWrapper.getTestcase(),'********************')
     
     R, C = [int(x) for x in ioWrapper.readline().split()]
     matrix = []
     for r in range(R):
         matrix.append(list(ioWrapper.readline().replace('\n','')))
     
     assert len(matrix[0]) == len(matrix[-1]) == C
     
     result = calc (matrix, R, C)
     
     ioWrapper.write ('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(result) + '\n')
 
 
 
 
 main_run()
",gcj/2015/8234486/bigOnion/5708208098246656/1/extracted/pegman.py,10981,336,1118,Python,8234486,1,5708208098246656,bigOnion,2015
13705,count.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator for adding printing of timing for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically wrap the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 @memoize_it
 def count (n):
     assert n >= 0
     if n == 1:
         return 1
     else:
         if n % 10 == 0:
             return count(n-1) + 1        
         else:
             a = count(n-1)
             rev_n = int(''.join(str(n)[::-1]))
             b = count(rev_n)
             return min(a,b) + 1
 
 
 def count2 (n):
     start = int('1' + '0' * (len(str(n))-1))
     if start == n and start not in d:
         res = count2(n-1) + 1
         d[n] = res
         return res
     print (n)
     assert start in d
     s = [n]
     used = set()
     cnt = d[start]
     while start not in s:
         s2 = []
         used = used.union(s)
         for i in s:
             if i-1 not in used:
                 s2.append(i-1)
             if i % 10 != 0:
                 rev_i = int(''.join(str(i)[::-1]))
                 if rev_i not in used and rev_i < i:
                     s2.append(rev_i)
         s = list(set(s2))
         cnt += 1
     
     return cnt
     
 def reverse(n):
     return int(str(n)[::-1])
 
 @memoize_it
 def count3 (n):
     if n < 20:
         return n
     start = int('1' + '0' * (len(str(n))-1))
     if n%10 == 0:
         res = count3(n-1) + 1
         return res
     simple = n - start
     l = len(str(n))
     first_half = int(str(n)[:l//2][::-1])
     second_half = int(str(n)[l//2:])
     return count3(start) + min(simple, first_half + second_half)
     
 
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     n = int(ioWrapper.readline())
     print (ioWrapper.getTestcase(), n)
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(count3(n)) + '\n')
 
 
 
 
 
 main_run()
",gcj/2015/8224486/bigOnion/5688567749672960/1/extracted/count.py,8629,265,926,Python,8224486,1,5688567749672960,bigOnion,2015
65457,pancakes.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator for adding printing of timing for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically wrap the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     D = int (ioWrapper.readline())
     P = [int(x) for x in ioWrapper.readline().split()]
     assert len(P) == D
     best = 2000
     for mx_allowed_on_plate in range(1,1001):
         if max(P) <= mx_allowed_on_plate:
             time_needed = max(P)
         else:
             time_needed = 0
             for p in P:
                 if p > mx_allowed_on_plate:
                     time_needed += (p-1) // mx_allowed_on_plate
             time_needed += mx_allowed_on_plate
         if time_needed < best:
             best = time_needed
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': '+ str(best) + '\n')
 
         
 
 
 main_run()
",gcj/2015/6224486/bigOnion/5686275109552128/1/extracted/pancakes.py,7685,217,791,Python,6224486,1,5686275109552128,bigOnion,2015
65459,not_dijkstra.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator for adding printing of timing for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically wrap the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 _mult = {
     ('1','1') : (1,'1'),
     ('1','i') : (1,'i'),
     ('1','j') : (1,'j'),
     ('1','k') : (1,'k'),
 
     ('i','1') : (1,'i'),
     ('i','i') : (-1,'1'),
     ('i','j') : (1,'k'),
     ('i','k') : (-1,'j'),
     
     ('j','1') : (1,'j'),
     ('j','i') : (-1,'k'),
     ('j','j') : (-1,'1'),
     ('j','k') : (1,'i'),
 
     ('k','1') : (1,'k'),
     ('k','i') : (1,'j'),
     ('k','j') : (-1,'i'),
     ('k','k') : (-1,'1')
 }
 
 @memoize_it
 def multiply(a, b):
     sign_a, type_a = a
     sign_b, type_b = b
     sign_res, type_res = _mult[(type_a,type_b)]
     return (sign_a * sign_b * sign_res, type_res)
 
 def solveOneCase__ (ioWrapper):
     # fill details here
     #reset_memoization()
     L, X = [int(x) for x in ioWrapper.readline().split()]
     seq = ioWrapper.readline()
     assert len(seq) == L+1
     seq = seq[:L]
     
     res = 'MAYBE'
     
     cummulative_product_single_seq = (1,'1')
     for c in seq:
         cummulative_product_single_seq = multiply(cummulative_product_single_seq, (1,c))
     cummulative_product_rep = (1,'1')
     for rep in range(X%16):
         cummulative_product_rep = multiply(cummulative_product_rep, cummulative_product_single_seq)
     
     if cummulative_product_rep != (-1,'1'):
         res = 'NO'
     
 
     if X <= 4:
         XXX = X
     else:
         XXX = (X%4) + 4
     
     if res != 'NO':
         # get first i
         found_i = False
         cummulative_product = (1,'1')
         seq_left = seq * XXX
         for index_left in range(1,len(seq_left)+1):
             letter = seq_left[index_left-1]
             cummulative_product = multiply(cummulative_product, (1,letter))
             if cummulative_product == (1,'i'):
                 # found the first index whose product is i
                 found_i = True
                 break
         
         if not found_i:
             res = 'NO'
             
     if res != 'NO':
         # get last k
         found_k = False
         cummulative_product = (1,'1')
         seq_right = seq * XXX
         for index_right in range(1, len(seq_right)+1):
             letter = seq_right[-index_right]
             cummulative_product = multiply((1,letter), cummulative_product)
             if cummulative_product == (1,'k'):
                 # found the last index from which product is k
                 found_k = True
                 break
         
         if not found_k:
             res = 'NO'
     
     # final check
     if res != 'NO':
         total_index_left = index_left
         assert total_index_left > 0
         assert total_index_left <= X * L
         
         total_index_right = X*L - index_right
         assert total_index_right >= 0
         assert total_index_right < X * L
         
         if index_left + index_right > X * L :
             res = 'NO'
         assert index_left + index_right != X * L
         
         res = 'YES'
     
     
     #output
     assert res in ['YES', 'NO']
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + res + '\n')
     
 
 
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     L, X = [int(x) for x in ioWrapper.readline().split()]
     if X > 16:
         X = (X % 16) + 16
     else:
         pass
     
     seq = ioWrapper.readline()
     assert len(seq) == L+1
     seq = seq[:L] * X
     
     res = 'MAYBE'
     
     cummulative_product_single_seq = (1,'1')
     first_location = len(seq)
     
     for index in range(len(seq)):
         c = seq[index]
         cummulative_product_single_seq = multiply(cummulative_product_single_seq, (1,c))
         if cummulative_product_single_seq == (1,'i'):
             first_location = index
             break
     
     if first_location >= len(seq):
         res = 'NO'
     
     if res != 'NO':
         cummulative_product_single_seq = (1,'1')
         second_location = len(seq)
         for index in range(first_location+1, len(seq)):
             c = seq[index]
             cummulative_product_single_seq = multiply(cummulative_product_single_seq, (1,c))
             if cummulative_product_single_seq == (1,'j'):
                 second_location = index
                 break
     
         if second_location >= len(seq):
             res = 'NO'
 
     if res != 'NO':
         cummulative_product_single_seq = (1,'1')
         for index in range(second_location+1, len(seq)):
             c = seq[index]
             cummulative_product_single_seq = multiply(cummulative_product_single_seq, (1,c))
         
         if cummulative_product_single_seq != (1,'k'):
             res = 'NO'
         else:
             res = 'YES'
 
 
     #output
     assert res in ['YES', 'NO']
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + res + '\n')
     
 
 main_run()
",gcj/2015/6224486/bigOnion/5670465267826688/1/extracted/not_dijkstra.py,11763,363,1206,Python,6224486,1,5670465267826688,bigOnion,2015
65461,A.py,"from functools import wraps
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrap(*args):
         if args not in cache:
             cache[args] = inner_func(*args)
         return cache[args]
     return wrap
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator for adding printing of timing for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrap(*args):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrap
     
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrap(*args):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args)
     return wrap
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrap (*args):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrap
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically wrap the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     l = ioWrapper.readline()
     mx = int(l.split()[0])
     cntrs = [int(x) for x in l.split()[1]]
     assert len(cntrs) == mx + 1
     assert cntrs[-1]
     people_needed = 0
     for shyness in range(1,mx+1):
         if cntrs[shyness]:
             people_standing = sum(cntrs[:shyness])
             if people_standing < shyness:
                 people_needed = max(people_needed, shyness-people_standing)
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(people_needed) + '\n')
 
 
 
 main_run()
",gcj/2015/6224486/bigOnion/5639104758808576/1/extracted/A.py,7552,212,777,Python,6224486,1,5639104758808576,bigOnion,2015
135269,coins.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def can_pay (next_val, C, d_arr):
     target_val = next_val
     copy_d = list(d_arr)
     while copy_d:
         t = copy_d.pop()
         if t <= target_val:
             target_val -= t * min(C, target_val//t)
         assert target_val >= 0
         if target_val == 0:
             break
     
     assert len(d_arr) > 0
 
     if target_val == 0:
         return True
     
     assert target_val == 1
     return False
 
 
             
         
     
     
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     C, D, V = [int(x) for x in ioWrapper.readline().split()]
     d_arr = [int(x) for x in ioWrapper.readline().split()]
     assert len(d_arr) == D
     
     need_add = 0
     if 1 not in d_arr:
         d_arr.append(1)
         need_add += 1
     
     d_arr.sort()
     
     i = 1
     while True:
         basic_coins = d_arr[:i]
         next_val = sum(basic_coins)*C+1
         if next_val > V:
             break
         if not can_pay(next_val, C, d_arr):
             d_arr.append(next_val)
             d_arr.sort()
             need_add += 1
         i += 1
 
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(need_add) + '\n')
 
 main_run()
",gcj/2015/4244486/bigOnion/5646553574277120/1/extracted/coins.py,8907,262,915,Python,4244486,1,5646553574277120,bigOnion,2015
135271,monkeys.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 from fractions import Fraction
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     K, L, S = [int(x) for x in ioWrapper.readline().split()]
     keyboard = ioWrapper.readline().replace('\n','')
     assert len(keyboard) == K
     target_str = ioWrapper.readline().replace('\n','')
     assert len(target_str) == L
     
     prob = 1
     for c in target_str:
         prob = prob * Fraction(keyboard.count(c), K)
     if prob == 0 or prob == 1 or S < L:
         ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': 0.0\n')
         return
     
     exp = prob * (S-(L-1))
     
     start_again = L
     for i in range(1,L):
         if target_str.startswith(target_str[-i:]):
             start_again = L-i
 
     cnt_max = 0
     i = 0
     while i + L <= S:
         cnt_max += 1
         i += start_again
     
     
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(float(cnt_max - exp)) + '\n')
 
 
 
 
 
 main_run()
",gcj/2015/4244486/bigOnion/5708284669460480/1/extracted/monkeys.py,8670,247,899,Python,4244486,1,5708284669460480,bigOnion,2015
135273,battleships.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solveOneCase (ioWrapper):
     # fill details here
     #reset_memoization()
     R, C, W = [int(x) for x in ioWrapper.readline().split()]
     
     score = (R-1) * (C//W)
     if C % W == 0:
         score += (C//W)-1 + W
     else:
         assert C % W != 0
         score += (C//W) + W
     
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': '+ str(score) + '\n')
 
 
 
 
 main_run()
",gcj/2015/4244486/bigOnion/5640146288377856/1/extracted/battleships.py,8086,227,838,Python,4244486,1,5640146288377856,bigOnion,2015
102901,sheep.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solveOneCase (ioWrapper):
     N = int(ioWrapper.readline())
     lastN = 0
     s = set()
     for i in range(1,201):
         lastN += N
         s.update(list(str(lastN)))
         if len(s) == 10:
             break
     
     if len(s) == 10:
         ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': ' + str(lastN) + '\n')
     else:
         ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': INSOMNIA\n')
 
 
 
 main_run()
",gcj/2016/6254486/bigOnion/5652388522229760/1/extracted/sheep.py,8134,227,831,Python,6254486,1,5652388522229760,bigOnion,2016
102903,fractiles.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solveOneCase (ioWrapper):
     K, C, S = [int(x) for x in ioWrapper.readline().split()]
     assert S <= K 
     checksNeeded = K // C
     if K % C != 0:
         checksNeeded += 1
     if checksNeeded > S:
         ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': IMPOSSIBLE\n')
     else:
         ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ':')
         for i in range(checksNeeded):
             indexDigits = list(range(C*i, C*(i+1)))
             for i in range(C):
                 if indexDigits[i] >= K:
                     indexDigits[i] = 0
             ind = convertToIndex(indexDigits, K, C) + 1
             ioWrapper.write(' ' + str(ind))
         ioWrapper.write('\n')
         
 
 
 def convertToIndex(indexDigits, K, C):
     assert max(indexDigits) < K
     assert len(indexDigits) == C
     n = 0
     for digit in indexDigits:
         n *= K
         n += digit
     return n
 
     
 
 main_run()
",gcj/2016/6254486/bigOnion/5636311922769920/1/extracted/fractiles.py,8630,242,889,Python,6254486,1,5636311922769920,bigOnion,2016
102905,jamcoin.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solveOneCase (ioWrapper):
     assert ioWrapper.getTestcase() == 1
     ioWrapper.write('Case #1:\n')
     
     N, J = [int(x) for x in ioWrapper.readline().split()]
     assert (N == 16 and J == 50) or (N == 32 and J == 500) or (N == 6 and J == 3)
     
     proofDict = generateCoins (N,J)
     assert len(proofDict) == J
     for s,proof in proofDict.items():
         ioWrapper.write(s)
         for pBase in proof:
             ioWrapper.write(' ' + str(pBase))
         ioWrapper.write('\n')
         
     
 
 def simpleIsPrime (n):
     if n in [0,1,4,6,8,9,10]:
         return False
     if n in [2,3,5,7,11]:
         return True
     for d in range(2,int(n**0.5)+5):
         if n %d == 0:
             return False
     return True
 
 
 def findPrimesUpTo2Exp16 ():
     primes = [x for x in range(2**16) if simpleIsPrime(x)]
     return primes
 
 print('finding small primes')
 PRIMES_UP_TO_2_EXP_16_LIST = findPrimesUpTo2Exp16()
 PRIMES_UP_TO_2_EXP_16_SET = set(PRIMES_UP_TO_2_EXP_16_LIST)
 print('finished')
 
 def getDivisor(n):
     if n < 2**16:
         if n in PRIMES_UP_TO_2_EXP_16_SET:
             return None
         else:
             for p in PRIMES_UP_TO_2_EXP_16_LIST:
                 if n%p == 0:
                     return p
             assert False # cannot get here
     else:
         for p in PRIMES_UP_TO_2_EXP_16_LIST:
             if n%p == 0:
                 return p
         return None
     
 
 def proveCoinJam (s):
     proofs = [None]*9
     for base in range(2,11):
         n = int(s, base)
         d = getDivisor(n)
         if d == None:
             return None
         else:
             proofs[base-2] = d
     return proofs
 
 from random import choice
 
 def randomizeCoin (N):
     while True:
         s = '1' + ''.join(choice('01') for _ in range(N-2)) + '1'
         proof = proveCoinJam(s)
         if proof != None:
             return s, proof
 
 def generateCoins (N, J):
     proofDict = {}
     while len(proofDict) < J:
         coin, proof = randomizeCoin(N)
         proofDict[coin] = proof
     return proofDict
 
 main_run()
",gcj/2016/6254486/bigOnion/5738606668808192/1/extracted/jamcoin.py,9783,290,1019,Python,6254486,1,5738606668808192,bigOnion,2016
102907,happy_pancake.py,"from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 ##      useful decorators
 ###############################
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     try:
         __memoization_registry
     except NameError:
         __memoization_registry = []
     cache = {}
     __memoization_registry.append(cache)
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         if args not in cache:
             cache[args] = inner_func(*args, **kwds)
         return cache[args]
     return wrapper
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization ():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
         
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         print ('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         starttime = time.time()
         res = inner_func(*args, **kwds)
         endtime = time.time()
         print ('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print ('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', endtime-starttime)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it (arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwds):
             if arguments:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwds=', kwds)
             result = user_function(*args, **kwds)
             if output:
                 print (time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it (inner_func):
     global _CALL_FUNC_COUNTERS
     if '_CALL_FUNC_COUNTERS' not in globals():
         _CALL_FUNC_COUNTERS = {}
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
     @wraps(inner_func)
     def wrapper(*args, **kwds):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwds)
     return wrapper
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it (inner_func): 
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError ('A pre process function must not have arguments')        
     
     @time_it
     @wraps(inner_func)
     def wrapper (*args, **kwds):
         filename = 'preprocess_' + inner_func.__qualname__ + '.pickle'
         if not filename in os.listdir():
             print ('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             preProcessData = inner_func()
             print ('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print ('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(preProcessData, f_pp, pickle.HIGHEST_PROTOCOL)
             print ('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print ('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print ('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
     
     def __init__ (self, inputfilename, parsedfilename, outputfilename):
         self.__inputfilename = inputfilename
         self.__parsedfilename = parsedfilename
         self.__outputfilename = outputfilename
         self.__indextestcase = 0
     
     def __enter__ (self):
         # open the IO files
         self.__inputfile = open (self.__inputfilename, 'r')
         self.__parsedfile = open (self.__parsedfilename, 'w')
         self.__outputfile = open (self.__outputfilename, 'w')
     
     def __exit__ (self, typeE, value, tb):
         # close the IO files
         self.__inputfile.close()
         self.__parsedfile.close()
         self.__outputfile.close()
     
     def readline (self):
         # read one line from the input. write it as is to the parsed file
         l = self.__inputfile.readline()
         self.__parsedfile.write(l)
         return l
     
     def newTestcase (self):
         # mark a new testcase to the parsed file
         self.__indextestcase += 1
         self.__parsedfile.write('\n## _BigOnion Testcase: ' + str(self.__indextestcase) + ' ##\n')
     
     def write (self, s):
         # write to the output file
         self.__outputfile.write(s)
     
     def getTestcase (self):
         # return the index of the current testcase
         return self.__indextestcase
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print ('Directory : ', os.getcwd())
     filenames = [x for x in os.listdir ()]
     l1 = [(os.stat(x).st_mtime, x) for x in filenames if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix =  sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix+'.in'
     print ('Chosen Input : ',input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix+'.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in filenames if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print ('Chosen Output : ',output_filename)
     print()
     
     #with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #    solve(f_in,f_out)
     ioWrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with ioWrapper:
         solveAllCases(ioWrapper)
 
     # print the chosen files once again for easy checking of correctness
     print ()
     print ('Conclusion :')
     print ('Directory : ', os.getcwd())
     print ('Chosen Input : ',input_filename)
     print ('Chosen Output : ',output_filename)
 
 
 # the automatic solver. Handles the testcase mechanism
 @time_it
 def solveAllCases (ioWrapper):
     T = int(ioWrapper.readline())
     for testcase in range(1, T+1):
         ioWrapper.newTestcase()
         assert ioWrapper.getTestcase() == testcase
         solveOneCase (ioWrapper)
 
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solveOneCase (ioWrapper):
     S = ioWrapper.readline().replace('\n','')
     assert len(S) == S.count('+') + S.count('-')
     S += '+'
     c = 0
     for i in range(1,len(S)):
         if S[i-1] != S[i]:
             c += 1
             
     ioWrapper.write('Case #' + str(ioWrapper.getTestcase()) + ': '+ str(c) + '\n')
     
 
 
 
 
 main_run()
",gcj/2016/6254486/bigOnion/5634697451274240/1/extracted/happy_pancake.py,8032,225,822,Python,6254486,1,5634697451274240,bigOnion,2016
174826,rps.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 __memoization_registry = []
 _CALL_FUNC_COUNTERS = {}
 
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     cache = {}
     __memoization_registry.append(cache)
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         if args not in cache:
             cache[args] = inner_func(*args, **kwargs)
         return cache[args]
     return wrapper
 
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     global _CALL_FUNC_COUNTERS
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
     
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 ROCK = 'R'
 PAPER = 'P'
 SCISSORS = 'S'
 
 def solve_one_case(io_wrapper):
     # fill details here
     N, R, P, S = [int(x) for x in io_wrapper.readline().split()]
     assert R+P+S == 2**N
     solution = find_solution(N, R, P, S)
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + solution + '\n')
 
 
 def find_solution (N, R, P, S):
     a = try_winner(ROCK, N, R, P, S)
     print(a)
     if a is not None:
         a = alphabetically_first_solution(a)
     else:
         a = 'Z'
     b = try_winner(PAPER, N, R, P, S)
     print(b)
     if b is not None:
         b = alphabetically_first_solution(b)
     else:
         b = 'Z'
     c = try_winner(SCISSORS, N, R, P, S)
     print(c)
     if c is not None:
         c = alphabetically_first_solution(c)
     else:
         c = 'Z'
     print()
     if a == b == c == 'Z':
         return 'IMPOSSIBLE'
     return min(a, b, c)
 
 
 def try_winner(winner, N, R, P, S):
     l = [winner]
     for _round in range(N):
         l2 = []
         for i in l:
             if i == ROCK:
                 l2.extend([ROCK, SCISSORS])
             elif i == PAPER:
                 l2.extend([PAPER, ROCK])
             else:
                 assert i == SCISSORS
                 l2.extend([SCISSORS, PAPER])
         l = l2
     if l.count(ROCK) == R and l.count(PAPER) == P and l.count(SCISSORS) == S:
         return l
     return None
 
 
 def alphabetically_first_solution(l):
     jump = 1
     while jump < len(l):
         for s in range(0, len(l), 2*jump):
             t1 = l[s:s+jump]
             t2 = l[s+jump:s+2*jump]
             if t2 < t1:
                 l[s+jump:s+2*jump] = t1
                 l[s:s+jump] = t2
         jump *= 2
     assert jump == len(l)
     return ''.join(l)
 
 
 
 main_run()
",gcj/2016/10224486/bigOnion/5718606851604480/1/extracted/rps.py,9614,287,981,Python,10224486,1,5718606851604480,bigOnion,2016
192423,phone.py,"from collections import OrderedDict
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 __memoization_registry = []
 _CALL_FUNC_COUNTERS = {}
 
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     cache = {}
     __memoization_registry.append(cache)
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         if args not in cache:
             cache[args] = inner_func(*args, **kwargs)
         return cache[args]
     return wrapper
 
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
 
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     global _CALL_FUNC_COUNTERS
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError('A pre process function must not have arguments')
 
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
 
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
 
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
 
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
 
 
 # This is the automatic runner
 @time_it
 def main_run():
 
     # find the most current input file (.in) which is in the working directory
     print('Directory : ', os.getcwd())
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
 
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix,
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
 
     # with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #     solve(f_in,f_out)
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solve_one_case(io_wrapper):
     # fill details here
     # reset_memoization()
     S = io_wrapper.readline().replace('\n','')
     d = OrderedDict()
     for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
         d[c] = 0
     for c in S:
         d[c] += 1
     phone_number = ''
 
     for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
         assert d[c] >= 0
 
     a = d['Z']
     phone_number += '0' * a
     d['Z'] -= a
     d['E'] -= a
     d['R'] -= a
     d['O'] -= a
 
     a = d['X']
     phone_number += '6' * a
     d['S'] -= a
     d['I'] -= a
     d['X'] -= a
 
     a = d['W']
     phone_number += '2' * a
     d['T'] -= a
     d['W'] -= a
     d['O'] -= a
 
     a = d['G']
     phone_number += '8' * a
     d['E'] -= a
     d['I'] -= a
     d['G'] -= a
     d['H'] -= a
     d['T'] -= a
 
     a = d['U']
     phone_number += '4' * a
     d['F'] -= a
     d['O'] -= a
     d['U'] -= a
     d['R'] -= a
 
     a = d['F']
     phone_number += '5' * a
     d['F'] -= a
     d['I'] -= a
     d['V'] -= a
     d['E'] -= a
 
     a = d['T']
     phone_number += '3' * a
     d['T'] -= a
     d['H'] -= a
     d['R'] -= a
     d['E'] -= a
     d['E'] -= a
 
     a = d['V']
     phone_number += '7' * a
     d['S'] -= a
     d['E'] -= a
     d['V'] -= a
     d['E'] -= a
     d['N'] -= a
 
     a = d['O']
     phone_number += '1' * a
     d['O'] -= a
     d['N'] -= a
     d['E'] -= a
 
     a = d['I']
     phone_number += '9' * a
     d['N'] -= a
     d['I'] -= a
     d['N'] -= a
     d['E'] -= a
 
     for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
         assert d[c] == 0
 
     phone_number = ''.join(sorted(phone_number))
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + phone_number + '\n')
 
 
 main_run()
",gcj/2016/11254486/bigOnion/5648941810974720/1/extracted/phone.py,9409,307,1023,Python,11254486,1,5648941810974720,bigOnion,2016
192425,fake_subjects.py,"
 _INFINITY_CAPACITY = float('Infinity')
 _SUPERSOURCE = '_SUPERSOURCE'
 _SUPERSINK = '_SUPERSINK'
 
 
 # this algorithm is a one time run on each instance.
 # after one execution a new instance of the graph should be created
 # in order to run max_flow()
 
 class Edge(object):
     def __init__(self, u, v, w):
         self.source = u
         self.sink = v
         self.capacity = w
         assert w >= 0
 
     def __repr__(self):
         return ""%s->%s:%s"" % (self.source, self.sink, self.capacity)
 
 
 class FlowNetwork(object):
     def __init__(self):
         self.adj = {}
         self.flow = {}
 
     def add_vertex(self, vertex):
         self.adj[vertex] = []
 
     def get_edges(self, v):
         return self.adj[v]
 
     def add_edge(self, u, v, w=0):
         if u == v:
             raise ValueError(""u == v"")
         edge = Edge(u, v, w)
         redge = Edge(v, u, 0)
         edge.redge = redge
         redge.redge = edge
         self.adj[u].append(edge)
         self.adj[v].append(redge)
         self.flow[edge] = 0
         self.flow[redge] = 0
 
 #    def find_path_recursive_dfs(self, source, sink, path=[]):
 #        if source == sink:
 #            return path
 #        else:
 #            for edge in self.get_edges(source):
 #                residual = edge.capacity - self.flow[edge]
 #                if residual > 0 and edge not in path:
 #                    result = self.find_path_recursive_dfs( edge.sink, sink, path + [edge])
 #                    if result != None:
 #                        return result
 
     def find_path_bfs(self, source, sink):
         if source == sink:
             return []
         parent = {vertex:None for vertex in self.adj}
         parent[source] = source
         Q = [source]
         foundPath = False
         while Q and not foundPath:
             u = Q.pop(0)
             for edge in self.get_edges(u):
                 residual = edge.capacity - self.flow[edge]
                 v = edge.sink
                 # If there is available capacity, and v is not seen before in search
                 if residual > 0 and parent[v] == None:
                     parent[v] = edge
                     Q.append(v)
                     if v == sink:
                         foundPath = True
                         break
 
         if foundPath:
             path = []
             u = sink
             while u != source:
                 edge = parent[u]
                 path.append(edge)
                 u = edge.source
             path.reverse()
             return path
         else:
             return None
 
     def find_path(self, source, sink):
         # choose the bfs method, so it runs in Edmonds-Karp time.
         # you can choose the 'simpler' find_path_recursive_dfs,
         # but it does not guarantee good running times
         return self.find_path_bfs(source, sink)
 
     def max_flow(self, source, sink):
 
         # handle multiple sources
         if type(source) == list:
             assert _SUPERSOURCE not in self.adj
             self.add_vertex(_SUPERSOURCE)
             for v in source:
                 self.add_edge(_SUPERSOURCE, v, _INFINITY_CAPACITY)
             source = _SUPERSOURCE
 
         # handle multiple sinks
         if type(sink) == list:
             assert _SUPERSINK not in self.adj
             self.add_vertex(_SUPERSINK)
             for v in sink:
                 self.add_edge(v, _SUPERSINK, _INFINITY_CAPACITY)
             sink = _SUPERSINK
 
         path = self.find_path(source, sink)
         while path != None:
             residuals = [edge.capacity - self.flow[edge] for edge in path]
             flow = min(residuals)
             for edge in path:
                 self.flow[edge] += flow
                 self.flow[edge.redge] -= flow
             path = self.find_path(source, sink)
         return sum(self.flow[edge] for edge in self.get_edges(source))
 
 
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 __memoization_registry = []
 _CALL_FUNC_COUNTERS = {}
 
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     cache = {}
     __memoization_registry.append(cache)
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         if args not in cache:
             cache[args] = inner_func(*args, **kwargs)
         return cache[args]
     return wrapper
 
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
 
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     global _CALL_FUNC_COUNTERS
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError('A pre process function must not have arguments')
 
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
 
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
 
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
 
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
 
 
 # This is the automatic runner
 @time_it
 def main_run():
 
     # find the most current input file (.in) which is in the working directory
     print('Directory : ', os.getcwd())
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
 
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix,
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
 
     # with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #     solve(f_in,f_out)
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 from collections import Counter
 
 source_name = 'source_igfvfjsdv;clksaivhwes;fdhesfdhlahdwefgl'
 target_name = 'target_igfvfjsdv;clksaivhwes;fdhesfdhlahdwefgl'
 def solve_one_case(io_wrapper):
     # fill details here
     # reset_memoization()
     N = int(io_wrapper.readline())
     subject_list = []
     for i in range(N):
         subject = io_wrapper.readline().split()
         subject_list.append(subject)
     first_list = [x[0] for x in subject_list]
     second_list = [x[1] for x in subject_list]
     first_counters = Counter(first_list)
     second_counters = Counter(second_list)
 
     g = FlowNetwork()
     g.add_vertex(source_name)
     g.add_vertex(target_name)
 
     for v in first_counters:
         g.add_vertex(v + '_1')
 
     for v in second_counters:
         g.add_vertex(v + '_2')
 
     for f in first_counters:
         g.add_edge(source_name, f + '_1', first_counters[f]-1)
 
     for s in second_counters:
         g.add_edge(s + '_2', target_name, second_counters[s] - 1)
     for subject in subject_list:
         f, s = subject
         g.add_edge(f + '_1', s + '_2', 1)
 
     most_fakes = g.max_flow(source_name, target_name)
 
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(most_fakes) + '\n')
 
 
 main_run()
",gcj/2016/11254486/bigOnion/5686313294495744/1/extracted/fake_subjects.py,12860,378,1289,Python,11254486,1,5686313294495744,bigOnion,2016
192427,close_match.py,"from collections import OrderedDict
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 __memoization_registry = []
 _CALL_FUNC_COUNTERS = {}
 
 
 # a decorator for memoizing function outputs
 def memoize_it(inner_func):
     global __memoization_registry
     cache = {}
     __memoization_registry.append(cache)
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         if args not in cache:
             cache[args] = inner_func(*args, **kwargs)
         return cache[args]
     return wrapper
 
 
 # clear all previous memoization. For use in the beginning of a new test-case
 def reset_memoization():
     global __memoization_registry
     try:
         for cache_d in __memoization_registry:
             cache_d.clear()
     except NameError:
         pass
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
 
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     global _CALL_FUNC_COUNTERS
     assert type(_CALL_FUNC_COUNTERS) == dict
     assert inner_func.__qualname__ not in _CALL_FUNC_COUNTERS
     _CALL_FUNC_COUNTERS[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global _CALL_FUNC_COUNTERS
         _CALL_FUNC_COUNTERS[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.getargspec(inner_func)
     if a.args or a.keywords or a.varargs or a.defaults:
         raise ValueError('A pre process function must not have arguments')
 
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
 
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
 
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
 
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
 
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
 
 
 # This is the automatic runner
 @time_it
 def main_run():
 
     # find the most current input file (.in) which is in the working directory
     print('Directory : ', os.getcwd())
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
 
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix,
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
 
     # with open(input_filename) as f_in, open(output_filename, 'w') as f_out:
     #     solve(f_in,f_out)
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 UNDECIDED = 0
 C_WINNING = 1
 J_WINNING = 2
 
 def solve_one_case(io_wrapper):
     # fill details here
     # reset_memoization()
     C, J = io_wrapper.readline().split()
     assert len(C) == len(J)
 
     c_res, j_res = get_best (C, J, UNDECIDED)
 
     io_wrapper.write ('Case #' + str(io_wrapper.get_test_case()) + ': ' + c_res +' '+ j_res + '\n')
 
 
 
 
 @memoize_it
 def get_best (C, J, winning):
     if len(C) == len(J) == 0:
         return '',''
 
     if winning == C_WINNING:
         c_res = C.replace('?','0')
         j_res = J.replace('?', '9')
         return c_res, j_res
     elif winning == J_WINNING:
         c_res = C.replace('?', '9')
         j_res = J.replace('?', '0')
         return c_res, j_res
     else:
         assert winning == UNDECIDED
         if C[0] != '?' and J[0] != '?':
             if C[0] > J[0]:
                 c_tmp, j_tmp = get_best(C[1:], J[1:], C_WINNING)
             elif C[0] < J[0]:
                 c_tmp, j_tmp = get_best(C[1:], J[1:], J_WINNING)
             else:
                 c_tmp, j_tmp = get_best (C[1:], J[1:], UNDECIDED)
             return C[0] + c_tmp, J[0] + j_tmp
 
         elif C[0] == J[0] == '?':
             c1,j1 = get_best (C[1:], J[1:], UNDECIDED)
             c1 = '0' + c1
             j1 = '0' + j1
             diff1 = get_diff(c1,j1)
 
             c2,j2 = get_best (C[1:], J[1:], C_WINNING)
             c2 = '1' + c2
             j2 = '0' + j2
             diff2 = get_diff(c2,j2)
 
             c3, j3 = get_best(C[1:], J[1:], J_WINNING)
             c3 = '0' + c3
             j3 = '1' + j3
             diff3 = get_diff(c3,j3)
 
             best_diff = min(diff1, diff2, diff3)
             l = []
             if diff1 == best_diff:
                 l.append((c1,j1))
             if diff2 == best_diff:
                 l.append((c2, j2))
             if diff3 == best_diff:
                 l.append((c3,j3))
 
             return min(l)
 
         elif C[0] == '?' and J[0] != '?':
             d = int(J[0])
             c1 = j1 = None
             if d > 0:
                 c1, j1 = get_best (C[1:], J[1:], J_WINNING)
                 c1 = str(d-1) + c1
                 j1 = str(d) + j1
                 diff1 = get_diff(c1,j1)
             else:
                 diff1 = 2**100
 
             c2,j2 = get_best (C[1:], J[1:], UNDECIDED)
             c2 = str(d) + c2
             j2 = str(d) + j2
             diff2 = get_diff(c2,j2)
 
             c3 = j3 = None
             if d < 9:
                 c3, j3 = get_best(C[1:], J[1:], C_WINNING)
                 c3 = str(d + 1) + c3
                 j3 = str(d) + j3
                 diff3 = get_diff(c3, j3)
             else:
                 diff3 = 2**100
 
             best_diff = min(diff1, diff2, diff3)
             l = []
             if diff1 == best_diff:
                 l.append((c1, j1))
             if diff2 == best_diff:
                 l.append((c2, j2))
             if diff3 == best_diff:
                 l.append((c3, j3))
 
             return min(l)
 
         else:
             assert C[0] != '?' and J[0] == '?'
             d = int(C[0])
             c1 = j1 = None
             if d > 0:
                 c1, j1 = get_best(C[1:], J[1:], C_WINNING)
                 c1 = str(d) + c1
                 j1 = str(d - 1) + j1
                 diff1 = get_diff(c1, j1)
             else:
                 diff1 = 2 ** 100
 
             c2, j2 = get_best(C[1:], J[1:], UNDECIDED)
             c2 = str(d) + c2
             j2 = str(d) + j2
             diff2 = get_diff(c2, j2)
 
             c3 = j3 = None
             if d < 9:
                 c3, j3 = get_best(C[1:], J[1:], J_WINNING)
                 c3 = str(d) + c3
                 j3 = str(d + 1) + j3
                 diff3 = get_diff(c3, j3)
             else:
                 diff3 = 2 ** 100
 
             best_diff = min(diff1, diff2, diff3)
             l = []
             if diff1 == best_diff:
                 l.append((c1, j1))
             if diff2 == best_diff:
                 l.append((c2, j2))
             if diff3 == best_diff:
                 l.append((c3, j3))
 
             return min(l)
 
 
 def get_diff (c,j):
     return abs(int(c)-int(j))
 
 main_run()
",gcj/2016/11254486/bigOnion/5695413893988352/1/extracted/close_match.py,11902,360,1254,Python,11254486,1,5695413893988352,bigOnion,2016
20636,chocolate_tour.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solve2(G):
     remainders = [x % 2 for x in G]
     a = remainders.count(0)
     a += remainders.count(1) // 2
     if remainders.count(1) % 2 == 1:
         a += 1
     return a
 
 
 def solve3(G):
     remainders = [x % 3 for x in G]
     a = remainders.count(0)
     c1 = remainders.count(1)
     c2 = remainders.count(2)
     m = min(c1, c2)
     a += m
     c = max(c1, c2) - m
     a += c // 3
     if c % 3 != 0:
         a += 1
     return a
 
 
 def solve4(G):
     remainders = [x % 4 for x in G]
     c0 = remainders.count(0)
     c1 = remainders.count(1)
     c2 = remainders.count(2)
     c3 = remainders.count(3)
 
     a = c0
     a += c2 // 2
     a += min(c1, c3)
     b = max(c1, c3) - min(c1, c3)
 
     if c2 % 2 == 0:
         a += (b // 4)
         if b % 4 != 0:
             a += 1
         return a
 
     else:
         a += 1
         if b >= 2:
             b -= 2
             a += (b // 4)
             if b % 4 != 0:
                 a += 1
             return a
 
 
 def solve_one_case(io_wrapper):
     N, P = [int(x) for x in io_wrapper.readline().split()]
     G = [int(x) for x in io_wrapper.readline().split()]
     assert len(G) == N
 
     if P == 2:
         sol = solve2(G)
     if P == 3:
         sol = solve3(G)
     if P == 4:
         sol = solve4(G)
 
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(sol) + '\n')
 
 
 main_run()
",gcj/2017/5314486/bigOnion/5700919488413696/1/extracted/chocolate_tour.py,9813,296,994,Python,5314486,1,5700919488413696,bigOnion,2017
20637,chocolate_tour.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def solve2(G):
     remainders = [x % 2 for x in G]
     a = remainders.count(0)
     a += remainders.count(1) // 2
     if remainders.count(1) % 2 == 1:
         a += 1
     return a
 
 
 def solve3(G):
     remainders = [x % 3 for x in G]
     a = remainders.count(0)
     c1 = remainders.count(1)
     c2 = remainders.count(2)
     m = min(c1, c2)
     a += m
     c = max(c1, c2) - m
     a += c // 3
     if c % 3 != 0:
         a += 1
     return a
 
 
 def solve_one_case(io_wrapper):
     N, P = [int(x) for x in io_wrapper.readline().split()]
     G = [int(x) for x in io_wrapper.readline().split()]
     assert len(G) == N
 
     if P == 2:
         sol = solve2(G)
     if P == 3:
         sol = solve3(G)
     #if P == 4:
     #    sol = solve4(G)
 
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(sol) + '\n')
 
 
 main_run()
",gcj/2017/5314486/bigOnion/5700919488413696/0/extracted/chocolate_tour.py,9271,268,904,Python,5314486,0,5700919488413696,bigOnion,2017
20638,rollercoaster.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 from collections import Counter
 
 
 def is_enough(travels, N, M, C, sorted_tickets):
     rides = []
     for i in range(travels):
         rides.append([0] + ([None] * N))
     promotions = 0
     assert M == len(sorted_tickets)
     for p, b in sorted_tickets:
         assert p <= N
         assert b <= C
         r = 0
         while r < travels and (b in rides[r] or None not in rides[r][:p+1]):
             r += 1
         if r == travels:
             return None
         if rides[r][p] is None:
             rides[r][p] = b
             continue
         else:
             possible_ride = r
             r += 1
             while r < travels and (b in rides[r] or None is not rides[r][p]):
                 r += 1
             if r == travels:
                 # put client in possible_ride
                 i = rides[possible_ride].index(None)
                 assert 1 <= i <= p-1
                 rides[possible_ride][i] = b
                 promotions += 1
             else:
                 rides[r][p] = b
     return travels, promotions
 
 
 def solve_one_case(io_wrapper):
     #print('Case ', io_wrapper.get_test_case())
     N, C, M = [int(x) for x in io_wrapper.readline().split()]
     tickets = []
     #print ('****************', N, C, M, io_wrapper.get_test_case())
     for _ in range(M):
         t = [int(x) for x in io_wrapper.readline().split()]
         #print(t, end =' ')
         p, b = t
         assert p>=1 and p <= N
         assert b>=1 and b <= C
         tickets.append(t)
 
     p1_tickets = 0
     for p,b in tickets:
         if p == 1:
             p1_tickets += 1
 
     best_buyer = max(Counter([x[1] for x in tickets]).values())
 
     min_rollers = max(p1_tickets, best_buyer)
 
     max_rollers = M
 
 
     max_seat_ticket = max([x[0] for x in tickets])
 
     sorted_tickets = sorted(tickets)
     promotions = None
     while max_rollers > min_rollers:
         mid = (max_rollers + min_rollers) // 2
         t = is_enough(mid, max_seat_ticket, M, C, sorted_tickets)
         if t:
             max_rollers = mid
             promotions = t[1]
         else:
             min_rollers = mid + 1
 
     assert min_rollers == max_rollers
     travels = min_rollers
     if promotions is None:
         promotions = is_enough(travels, max_seat_ticket, M, C, sorted_tickets)[1]
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(travels) + ' ' + str(promotions) + '\n')
 
 
 
 
 
 main_run()
",gcj/2017/5314486/bigOnion/5687148430753792/0/extracted/rollercoaster.py,10872,313,1062,Python,5314486,0,5687148430753792,bigOnion,2017
86892,tidy_numbers.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def is_tidy(n):
     l = [int(x) for x in str(n)]
     for i in range(len(l)-1):
         if l[i] > l[i+1]:
             return False
     return True
 
 tidy_till_1000 = [x for x in range(1, 1001) if is_tidy(x)]
 
 
 def last_counted(n):
     while not is_tidy(n):
         l = [int(x) for x in str(n)]
         for i in range(len(l)-1):
             if l[i] > l[i+1]:
                 l[i] -= 1
                 for j in range(i+1, len(l)):
                     l[j] = 9
         n = int(''.join([str(x) for x in l]))
     return n
 
 
 def solve_one_case(io_wrapper):
     N = int(io_wrapper.readline())
     last = last_counted(N)
     if N <= 1000:
         assert last == max([x for x in tidy_till_1000 if x <= N])
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(last) + '\n')
 
 
 main_run()
",gcj/2017/3264486/bigOnion/5633382285312000/1/extracted/tidy_numbers.py,9231,260,877,Python,3264486,1,5633382285312000,bigOnion,2017
86894,fashion_show.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def add_rooks(chessboard):
     N = len(chessboard)
     good_rows = []
     for row_index in range(N):
         row = chessboard[row_index]
         if True not in row:
             good_rows.append(row_index)
     good_cols = []
     for col_index in range(N):
         col = [chessboard[r][col_index] for r in range(N)]
         if True not in col:
             good_cols.append(col_index)
     assert len(good_rows) == len(good_cols)
     for row_index, col_index in zip(good_rows, good_cols):
         chessboard[row_index][col_index] = True
 
 
 from copy import deepcopy
 
 FREE = 0
 THREATENED = 1
 BISHOP = 2
 
 
 def place_bishop(chessboard, r, c):
     N = len(chessboard)
     chessboard[r][c] = BISHOP
     for i in range(1, N+1):
         if r - i >= 0 and c - i >= 0:
             chessboard[r - i][c - i] = THREATENED
         if r + i < N and c + i < N:
             chessboard[r + i][c + i] = THREATENED
         if r - i >= 0 and c + i < N:
             chessboard[r - i][c + i] = THREATENED
         if r + i < N and c - i >= 0:
             chessboard[r + i][c - i] = THREATENED
 
 
 def add_bishops(chessboard):
     original = deepcopy(chessboard)
     N = len(chessboard)
     for r in range(N):
         for c in range(N):
             if chessboard[r][c] == BISHOP:
                 place_bishop(chessboard, r, c)
     if chessboard[0][0] == FREE:
         place_bishop(chessboard, 0, 0)
     if chessboard[0][N-1] == FREE:
         place_bishop(chessboard, 0, N-1)
     for i in range(1, N-1):
         if chessboard[0][i] == FREE and chessboard[N-1][N-1-i] == FREE:
             place_bishop(chessboard, 0, i)
             place_bishop(chessboard, N-1, N-1-i)
         if chessboard[i][0] == FREE and chessboard[N-1-i][N-1] == FREE:
             place_bishop(chessboard, i, 0)
             place_bishop(chessboard, N - 1 - i, N - 1)
         if chessboard[0][i] == FREE:
             place_bishop(chessboard, 0, i)
         if chessboard[i][0] == FREE:
             place_bishop(chessboard, i, 0)
         if chessboard[N-1][N-1-i] == FREE:
             place_bishop(chessboard, N-1, N-1-i)
         if chessboard[N-1-i][N-1] == FREE:
             place_bishop(chessboard, N-1-i, N-1)
     for r in range(N):
         for c in range(N):
             if original[r][c] == BISHOP:
                 assert chessboard[r][c] == BISHOP
 
 
 def translate_fashion_to_chessboards(N, fashion_grid):
     chessboard_rooks = [[False] * N for _ in range(N)]
     chessboard_bishops = [[FREE] * N for _ in range(N)]
     for r in range(N):
         for c in range(N):
             if fashion_grid[r][c] == 'o':
                 chessboard_rooks[r][c] = True
                 chessboard_bishops[r][c] = BISHOP
             elif fashion_grid[r][c] == '+':
                 chessboard_bishops[r][c] = BISHOP
             elif fashion_grid[r][c] == 'x':
                 chessboard_rooks[r][c] = True
             else:
                 assert fashion_grid[r][c] == '.'
     return chessboard_rooks, chessboard_bishops
 
 
 def translate_chessboards_to_fashion(N, chessboard_rooks, chessboard_bishops):
     fashion_grid = [['.'] * N for _ in range(N)]
     for r in range(N):
         for c in range(N):
             if chessboard_rooks[r][c] == True and chessboard_bishops[r][c] == BISHOP:
                 fashion_grid[r][c] = 'o'
             elif chessboard_rooks[r][c] == True and chessboard_bishops[r][c] != BISHOP:
                 fashion_grid[r][c] = 'x'
             elif chessboard_rooks[r][c] == False and chessboard_bishops[r][c] == BISHOP:
                 fashion_grid[r][c] = '+'
             else:
                 pass
     return fashion_grid
 
 
 def calc_score(fashion_grid):
     N = len(fashion_grid)
     score = 0
     for r in range(N):
         for c in range(N):
             if fashion_grid[r][c] == 'o':
                 score +=2
             elif fashion_grid[r][c] == '+':
                 score +=1
             elif fashion_grid[r][c] == 'x':
                 score += 1
             else:
                 assert fashion_grid[r][c] == '.'
     return score
 
 
 def solve_one_case(io_wrapper):
     N, M = [int(x) for x in io_wrapper.readline().split()]
     fashion_grid = [['.'] * N for _ in range(N)]
     for i in range(M):
         l = io_wrapper.readline().split()
         assert len(l) == 3
         assert l[0] in '.x+o'
         r = int(l[1])
         c = int(l[2])
         fashion_grid[r-1][c-1] = l[0]
 
     chessboard_rooks, chessboard_bishops = translate_fashion_to_chessboards(N, fashion_grid)
     add_rooks(chessboard_rooks)
     add_bishops(chessboard_bishops)
     new_fashion_grid = translate_chessboards_to_fashion(N, chessboard_rooks, chessboard_bishops)
 
     diffs = []
     for r in range(N):
         for c in range(N):
             if fashion_grid[r][c] != new_fashion_grid[r][c]:
                 assert new_fashion_grid[r][c] != '.'
                 if new_fashion_grid[r][c] == 'x' or new_fashion_grid == '+':
                     assert fashion_grid[r][c] == '.'
                 if new_fashion_grid[r][c] == 'o':
                     assert fashion_grid[r][c] in '.+x'
                 diffs.append((new_fashion_grid[r][c], r+1, c+1))
 
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(calc_score(new_fashion_grid)) + ' ' + str(len(diffs)) + '\n')
     for line in diffs:
         io_wrapper.write(line[0] + ' ' + str(line[1]) + ' ' + str(line[2]) + '\n')
 
 
 
 main_run()
",gcj/2017/3264486/bigOnion/5719854539603968/1/extracted/fashion_show.py,13888,381,1340,Python,3264486,1,5719854539603968,bigOnion,2017
86896,pancake_flip.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 def flip(S, K, ind):
     for i in range(ind, ind+K):
         if S[i] == '-':
             S[i] = '+'
         elif S[i] == '+':
             S[i] = '-'
         else:
             raise ValueError()
 
 
 def solve_one_case(io_wrapper):
     d = io_wrapper.readline().split()
     assert len(d) == 2
     S = list(d[0])
     K = int(d[1])
     assert K <= len(S)
 
     count = 0
     for ind in range(len(S) - K +1):
         if S[ind] == '-':
             flip(S, K, ind)
             count +=1
 
     if S.count('-') == 0:
         io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) +': ' + str(count) + '\n')
     else:
         io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': IMPOSSIBLE\n')
 
 
 
 main_run()
",gcj/2017/3264486/bigOnion/5736519012712448/1/extracted/pancake_flip.py,9143,260,857,Python,3264486,1,5736519012712448,bigOnion,2017
86898,stalls.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 def simulate(N, K):
     intervals = {N:1}
     moves_made = 0
     while moves_made < K:
         assert len(intervals) < 5
         largest_interval = max(intervals)
         count_largest_interval = intervals[largest_interval]
         if largest_interval % 2 == 1:
             maxx, minn = (largest_interval-1)//2, (largest_interval-1)//2
         else:
             maxx, minn = largest_interval//2, (largest_interval-1)//2
         del intervals[largest_interval]
         if maxx not in intervals:
             intervals[maxx] = count_largest_interval
         else:
             intervals[maxx] += count_largest_interval
         if minn not in intervals:
             intervals[minn] = count_largest_interval
         else:
             intervals[minn] += count_largest_interval
         moves_made += count_largest_interval
 
     return maxx, minn
 
 
 def solve_one_case(io_wrapper):
     N, K = [int(x) for x in io_wrapper.readline().split()]
     maxx, minn = simulate(N,K)
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(maxx) + ' ' + str(minn) + '\n')
 
 
 main_run()
",gcj/2017/3264486/bigOnion/5654742835396608/2/extracted/stalls.py,9515,260,873,Python,3264486,2,5654742835396608,bigOnion,2017
159484,horses.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 from decimal import Decimal
 
 
 def solve_one_case(io_wrapper):
     D, N = [int(x) for x in io_wrapper.readline().split()]
     last_time = 0
     for i in range(N):
         K, S = [int(x) for x in io_wrapper.readline().split()]
         ti = Decimal(D-K) / S
         last_time = max(last_time, ti)
     horse_speed = D/last_time
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': %0.8f\n' % horse_speed)
 
 
 main_run()
",gcj/2017/8294486/bigOnion/5630967708385280/1/extracted/horses.py,8846,244,821,Python,8294486,1,5630967708385280,bigOnion,2017
159486,unicorns.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 IMPOSSIBLE = 'IMPOSSIBLE'
 
 
 def solve_small(R, B, Y):
     if R > B + Y:
         return IMPOSSIBLE
     if B > R + Y:
         return IMPOSSIBLE
     if Y > B + R:
         return IMPOSSIBLE
 
     s = ''
     a = [R, B, Y]
     a.sort()
     while a[1] > a[0]:
         s += '21'
         a[1] -= 1
         a[2] -= 1
         assert min(a) >= 0
         assert a == sorted(a)
     assert a[1] == a[0]
     while a[2] > a[0]:
         s += '2120'
         a[0] -= 1
         a[1] -= 1
         a[2] -= 2
         assert min(a) >= 0
         assert a == sorted(a)
     assert a.count(a[0]) == 3
     if a[0] != 0:
         s += '210' * a[0]
 
     if R >= B >= Y:
         return s.replace('2', 'R').replace('1', 'B').replace('0', 'Y')
     if B >= R >= Y:
         return s.replace('2', 'B').replace('1', 'R').replace('0', 'Y')
     if B >= Y >= R:
         return s.replace('2', 'B').replace('1', 'Y').replace('0', 'R')
     if R >= Y >= B:
         return s.replace('2', 'R').replace('1', 'Y').replace('0', 'B')
     if Y >= R >= B:
         return s.replace('2', 'Y').replace('1', 'R').replace('0', 'B')
     if Y >= B >= R:
         return s.replace('2', 'Y').replace('1', 'B').replace('0', 'R')
 
 
 def get_stall(R, O, Y, G, B, V):
     l = [R, O, Y, G, B, V]
     if l.count(0) == 5:
         return IMPOSSIBLE
     if B == O == Y == V == 0:
         if R != G:
             print('ERROR')
             return IMPOSSIBLE
         else:
             return 'RG' * R
     if R == G == Y == V == 0:
         if B != O:
             print('ERROR')
             return IMPOSSIBLE
         else:
             return 'BO' * B
     if B == O == R == G == 0:
         if Y != V:
             print('ERROR')
             return IMPOSSIBLE
         else:
             return 'YV' * Y
 
     if O and B < O + 1:
         print('ERROR')
         return IMPOSSIBLE
     if G and R < G + 1:
         print('ERROR')
         return IMPOSSIBLE
     if V and Y < V + 1:
         print('ERROR')
         return IMPOSSIBLE
 
     small_solution = solve_small (R - G, B - O, Y - V)
     if small_solution == IMPOSSIBLE:
         return IMPOSSIBLE
     else:
         assert small_solution.count('B') == B - O
         assert small_solution.count('R') == R - G
         assert small_solution.count('Y') == Y - V
         s = small_solution
         if O > 0:
             i = s.find('B')
             s = s[:i] + 'BO' * O + 'B' + s[i+1:]
         if G > 0:
             i = s.find('R')
             s = s[:i] + 'RG' * G + 'R' + s[i+1:]
         if V > 0:
             i = s.find('Y')
             s = s[:i] + 'YV' * V + 'Y' + s[i+1:]
         return s
 
 
 def solve_one_case(io_wrapper):
     N, R, O, Y, G, B, V = [int(x) for x in io_wrapper.readline().split()]
     assert N == R + O + Y + G + B + V
     assert N >= 3
 
     solution = get_stall(R, O, Y, G, B, V)
     if solution != IMPOSSIBLE:
         assert solution.count('R') == R
         assert solution.count('O') == O
         assert solution.count('Y') == Y
         assert solution.count('G') == G
         assert solution.count('B') == B
         assert solution.count('V') == V
         assert len(solution) == N
         validate_solution(solution)
 
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + solution + '\n')
 
 
 def validate_solution(solution):
     sol = solution + solution[0]
     for i in range(1, len(sol)):
         if sol[i] == 'R':
             assert sol[i-1] in 'BYG'
         if sol[i] == 'B':
             assert sol[i - 1] in 'RYO'
         if sol[i] == 'Y':
             assert sol[i - 1] in 'VBR'
         if sol[i] == 'O':
             assert sol[i - 1] in 'B'
         if sol[i] == 'G':
             assert sol[i - 1] in 'R'
         if sol[i] == 'V':
             assert sol[i - 1] in 'Y'
 
 
 main_run()
",gcj/2017/8294486/bigOnion/5654117850546176/1/extracted/unicorns.py,12219,365,1310,Python,8294486,1,5654117850546176,bigOnion,2017
159488,pony.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 import sys
 from itertools import permutations, combinations
 from enum import Enum, unique
 
 
 class DisjointSet(object):
 
     def __init__(self):
         self.leader = {}  # maps a member to the group's leader
         self.group = {}  # maps a group leader to the group (which is a set)
 
     def make_set(self, a):
         if a is None:
             raise ValueError()
         self.leader[a] = a
         self.group[a] = {a}
 
     def union(self, a, b):
         leader_a = self.leader[a]
         leader_b = self.leader[b]
         if leader_a != leader_b:
             group_a = self.group[leader_a]
             group_b = self.group[leader_b]
             if len(group_a) < len(group_b):
                 group_b |= group_a
                 del self.group[leader_a]
                 for k in group_a:
                     self.leader[k] = leader_b
             else:
                 group_a |= group_b
                 del self.group[leader_b]
                 for k in group_b:
                     self.leader[k] = leader_a
 
     def same_set(self, a, b):
         return self.leader[a] == self.leader[b]
 
 
 class DirectedEdge:
     def __init__(self, source, target):
         self.source_vertex = source
         self.target_vertex = target
 
     def __repr__(self):
         return ""%s->%s"" % (self.source_vertex, self.target_vertex)
 
     def __eq__(self, other):
         if type(other) != type(self):
             return False
         return self.source_vertex == other.source and self.target_vertex == other.target
 
     def get_vertices(self):
         return self.source_vertex, self.target_vertex
 
     def reverse(self):
         return self.__class__(self.target_vertex, self.source_vertex)
 
 
 class WeightedDirectedEdge(DirectedEdge):
     def __init__(self, source, target, w):
         super().__init__(source, target)
         self.weight = w
 
     def __repr__(self):
         return '%s->%s:%s' % (self.source_vertex, self.target_vertex, self.weight)
 
     def reverse(self):
         return self.__class__(self.target_vertex, self.source_vertex, self.weight)
 
     def set_weight(self, w):
         self.weight = w
 
     def get_weight(self):
         return self.weight
 
 
 class UndirectedEdge:
     def __init__(self, u, v):
         self.vertices = {u, v}
 
     def __repr__(self):
         l = list(self.vertices)
         return ""%s<->%s"" % (l[0], l[1])
 
     def __eq__(self, other):
         if type(other) != type(self):
             return False
         return self.vertices == other.vertices
 
     def get_vertices(self):
         return self.vertices
 
     def get_other_vertex(self, u):
         a, b = self.vertices
         if u == a:
             return b
         elif u == b:
             return a
         else:
             raise ValueError('%s is not an end of the edge %s' % (str(u), str(self)))
 
     def add_direction(self, u):
         a, b = self.vertices
         if u == a:
             return DirectedEdge(u, b)
         elif u == b:
             return DirectedEdge(u, a)
         else:
             raise ValueError('%s is not an end of the edge %s' % (str(u), str(self)))
 
 
 class WeightedUndirectedEdge(UndirectedEdge):
     def __init__(self, u, v, w):
         super().__init__(u, v)
         self.weight = w
 
     def __repr__(self):
         l = list(self.vertices)
         return '%s<->%s:%s' % (l[0], l[1], self.weight)
 
     def set_weight(self, w):
         self.weight = w
 
     def get_weight(self):
         return self.weight
 
     def add_direction(self, u):
         a, b = self.vertices
         if u == a:
             return WeightedDirectedEdge(u, b, self.weight)
         elif u == b:
             return WeightedDirectedEdge(u, a, self.weight)
         else:
             raise ValueError('%s is not an end of the edge %s' % (str(u), str(self)))
 
 
 class DirectedGraph:
     def __init__(self):
         self.forward_edges = {}
         self.backward_edges = {}
 
     def add_vertex(self, v):
         self.forward_edges[v] = []
         self.backward_edges[v] = []
 
     def get_all_vertices(self):
         return list(self.forward_edges)
 
     def get_forward_edges(self, v):
         return self.forward_edges[v]
 
     def get_forward_neighbors(self, v):
         return list({e.target_vertex for e in self.forward_edges[v]})
 
     def get_backward_edges(self, v):
         return self.backward_edges[v]
 
     def get_next_neighbors(self, v):
         return self.get_forward_neighbors(v)
 
     def get_backward_neighbors(self, v):
         return list({e.source_vertex for e in self.backward_edges[v]})
 
     def add_edge(self, source, target, weight=None):
         if weight is None:
             edge = DirectedEdge(source, target)
         else:
             edge = WeightedDirectedEdge(source, target, weight)
         self.forward_edges[source].append(edge)
         self.backward_edges[target].append(edge)
 
     def get_all_edges(self):
         for l in self.forward_edges.values():
             for edge in l:
                 yield edge
 
     # in DirectedGraph get_all_edges() and get_directed_edges() are the same
     def get_directed_edges(self):
         for l in self.forward_edges.values():
             for edge in l:
                 yield edge
 
     # a graph with the reversed edges
     def reverse(self):
         r = self.__class__()
         [r.add_vertex(v) for v in self.get_all_vertices()]
         for edge in self.get_all_edges():
             if edge.__class__ == WeightedDirectedEdge:
                 r.add_edge(edge.target_vertex, edge.source_vertex, edge.weight)
             else:
                 assert edge.__class__ == DirectedEdge
                 r.add_edge(edge.target_vertex, edge.source_vertex)
         return r
 
     # the complement graph. can be applied on multi graphs and on weighted graphs, although not clearly defined
     def complement(self):
         c = self.__class__()
         vertices = self.get_all_vertices()
         [c.add_vertex(v) for v in vertices]
         if WeightedDirectedEdge in [edge.__class__ for edge in self.get_all_edges()]:
             print('A complement of a weighted graph is not so clearly defined', file=sys.stderr)
         edge_tuples = {(edge.source_vertex, edge.target_vertex) for edge in self.get_all_edges()}
         for u, v in permutations(vertices, 2):
             if (u, v) not in edge_tuples:
                 c.add_edge(u, v)
         return c
 
     # un-weight the graph
     def remove_weights(self):
         new_g = self.__class__()
         vertices = self.get_all_vertices()
         [new_g.add_vertex(v) for v in vertices]
         for edge in self.get_all_edges():
             new_g.add_edge(edge.source_vertex, edge.target_vertex)
         return new_g
 
     def remove_directions_and_weights(self):
         new_g = UndirectedGraph()
         vertices = self.get_all_vertices()
         [new_g.add_vertex(v) for v in vertices]
         for edge in self.get_all_edges():
             new_g.add_edge(edge.source_vertex, edge.target_vertex)
         return new_g
 
 
 class UndirectedGraph:
     def __init__(self):
         self.adj = {}
 
     def add_vertex(self, v):
         self.adj[v] = []
 
     def get_all_vertices(self):
         return list(self.adj)
 
     def get_edges(self, v):
         return self.adj[v]
 
     def get_forward_edges(self, v):
         return [edge.add_direction(v) for edge in self.get_edges(v)]
 
     def get_neighbors(self, v):
         return list({e.get_other_vertex(v) for e in self.adj[v]})
 
     def get_next_neighbors(self, v):
         return self.get_neighbors(v)
 
     def add_edge(self, u, v, weight=None):
         if weight is None:
             edge = UndirectedEdge(u, v)
         else:
             edge = WeightedUndirectedEdge(u, v, weight)
         self.adj[u].append(edge)
         self.adj[v].append(edge)
 
     def get_all_edges(self):
         for l in self.adj.values():
             for edge in l:
                 yield edge
 
     def get_directed_edges(self):
         for u, u_edges in self.adj.items():
             for edge in u_edges:
                 yield edge.add_direction(u)
 
     # the complement graph. can be applied on multi graphs and on weighted graphs, although not clearly defined
     def complement(self):
         c = self.__class__()
         vertices = self.get_all_vertices()
         [c.add_vertex(v) for v in vertices]
         if WeightedUndirectedEdge in [edge.__class__ for edge in self.get_all_edges()]:
             print('A complement of a weighted graph is not so clearly defined', file=sys.stderr)
         edge_tuples = {tuple(edge.vertices) for edge in self.get_all_edges()}
         for u, v in combinations(vertices, 2):
             if (u, v) not in edge_tuples and (v, u) not in edge_tuples:
                 c.add_edge(u, v)
         return c
 
     # un-weight the graph
     def remove_weights(self):
         new_g = self.__class__()
         vertices = self.get_all_vertices()
         [new_g.add_vertex(v) for v in vertices]
         for edge in self.get_all_edges():
             u, v = edge.vertices
             new_g.add_edge(u, v)
         return new_g
 
 
 # TODO: method: sub-graph
 
 
 @unique
 class Color(Enum):
     white = 0
     gray = 1
     black = 2
 
 
 class DFS:
     def __init__(self, graph):
         self.graph = graph
         self.vertices = graph.get_all_vertices()
         self.color = {}
         self.parent = {}
         self.discovered_time = {}
         self.finished_time = {}
         self.discover_vertex_execution_function = None
         self.finish_vertex_execution_function = None
         self.found_cycles_longer_than_2 = None
         self.found_cycles_of_size_2 = None
         self.found_loops = None
         self.topological_sort = None
         self.discovered_trees = []
 
     def set_discover_vertex_execution_function(self, f):
         self.discover_vertex_execution_function = f
 
     def set_finish_vertex_execution_function(self, f):
         self.finish_vertex_execution_function = f
 
     def iterative_traverse(self, source_vertex=None):
 
         # initialize. All vertices are bleached
         self.color = {u: Color.white for u in self.vertices}
         self.parent = {u: None for u in self.vertices}
         timestamp = 0
         self.discovered_time = {}
         self.finished_time = {}
         self.found_cycles_longer_than_2 = False
         self.discovered_trees = []
 
         # initialize a stack of vertices from which we start traversing the graph
         if source_vertex is None:
             stack = list(self.vertices)
         elif source_vertex in self.vertices:
             stack = [source_vertex]
         else:
             stack = list(reversed(source_vertex))
 
         # the actual DFS traverse
         while stack:
             u = stack[-1]
             u_color = self.color[u]
             if u_color == Color.black:
                 # already finished with this vertex before
                 stack.pop()
             elif u_color == Color.gray:
                 # u has been visited already, now we finish with it
                 if self.finish_vertex_execution_function is not None:
                     self.finish_vertex_execution_function(u)
                 self.color[u] = Color.black
                 timestamp += 1
                 self.finished_time[u] = timestamp
                 stack.pop()
             elif u_color == Color.white:
                 # u was not visited before. visit it now
                 timestamp += 1
                 self.discovered_time[u] = timestamp
                 self.color[u] = Color.gray
                 if self.discover_vertex_execution_function is not None:
                     self.discover_vertex_execution_function(u)
                 for v in self.graph.get_next_neighbors(u):
                     v_color = self.color[v]
                     if v_color == Color.white:
                         self.parent[v] = u
                         stack.append(v)
                     elif v_color == Color.gray:
                         if v == u:
                             self.found_loops = True
                         elif v == self.parent[u]:
                             self.found_cycles_of_size_2 = True
                         else:
                             self.found_cycles_longer_than_2 = True
             else:
                 assert False
 
         # save a topological sort of the graph
         if self.found_cycles_of_size_2 or self.found_cycles_longer_than_2:
             self.topological_sort = None
         else:
             self.topological_sort = [x[0] for x in sorted(self.finished_time.items(), key=lambda x:x[1], reverse=True)]
 
         # compute the discovered tree components.
         # (Please note this does not make much sense by itself on a DirectedGraph).
         discovered_vertices = sorted(self.discovered_time.items(), key=lambda x: x[1])
         while discovered_vertices:
             root, root_discovered_time = discovered_vertices[0]
             root_finish_time = self.finished_time[root]
             index = 1
             while index < len(discovered_vertices) and discovered_vertices[index][1] < root_finish_time:
                 index += 1
             self.discovered_trees.append(tuple(x[0] for x in discovered_vertices[:index]))
             del discovered_vertices[:index]
 
 
 class BFS:
     def __init__(self, graph):
         self.graph = graph
         self.vertices = graph.get_all_vertices()
         self.root = None
         self.color = {}
         self.parent = {}
         self.distance_from_root = {}
         self.discover_vertex_execution_function = None
         self.finish_vertex_execution_function = None
 
     def set_discover_vertex_execution_function(self, f):
         self.discover_vertex_execution_function = f
 
     def set_finish_vertex_execution_function(self, f):
         self.finish_vertex_execution_function = f
 
     def iterative_traverse(self, root_vertex):
         inf = float('infinity')
 
         # initialize. All vertices are bleached
         self.distance_from_root = {u: inf for u in self.vertices}
         self.parent = {u: None for u in self.vertices}
         self.color = {u: Color.white for u in self.vertices}
 
         # initialize a a queue with the chosen root vertex
         self.color[root_vertex] = Color.gray
         self.distance_from_root[root_vertex] = 0
         self.root = root_vertex
         queue = [root_vertex]
 
         # the actual BFS traverse
         while queue:
             u = queue.pop(0)
             if self.discover_vertex_execution_function is not None:
                 self.discover_vertex_execution_function(u)
             distance_v = self.distance_from_root[u] + 1
             for v in self.graph.get_next_neighbors(u):
                 if self.color[v] == Color.white:
                     self.color[v] = Color.gray
                     self.distance_from_root[v] = distance_v
                     self.parent[v] = u
                     queue.append(v)
             if self.finish_vertex_execution_function is not None:
                 self.finish_vertex_execution_function(u)
             self.color[u] = Color.black
 
     def reconstruct_path(self, v):
         if self.color[v] is Color.white:
             return None
         path = [v]
         while v != self.root:
             v = self.parent[v]
             path.append(v)
         return list(reversed(path))
 
 
 # return a list of the connected components in a graph
 def connected_components(graph):
     assert isinstance(graph, (UndirectedGraph, DirectedGraph))
     ds = DisjointSet()
     for u in graph.get_all_vertices():
         ds.make_set(u)
     for e in graph.get_all_edges():
         u, v = e.get_vertices()
         if not ds.same_set(u, v):
             ds.union(u, v)
     return list(ds.group.values())
 
 
 # return a tuple (strongly-connected-components, SCC graph).
 # If the boolean parameter flag is False then the second part of the returned tuple is None (saves time)
 def strongly_connected_components(graph, build_component_graph=False):
     if isinstance(graph, UndirectedGraph):
         raise NotImplementedError(
             ""Use connected_components instead. It is meant to do the same thing for undirected graphs."")
     assert isinstance(graph, DirectedGraph)
     dfs_object1 = DFS(graph)
     dfs_object1.iterative_traverse()
     dfs_object2 = DFS(graph.reverse())
     ordered_vertices = [x[0] for x in sorted(dfs_object1.finished_time.items(), key=lambda x:x[1], reverse=True)]
     dfs_object2.iterative_traverse(ordered_vertices)
     scc = [tuple(x) for x in dfs_object2.discovered_trees]
     if not build_component_graph:
         return scc, None
     graph_scc = DirectedGraph()
     component_dict = {}
     for comp in scc:
         graph_scc.add_vertex(comp)
         for v in comp:
             component_dict[v] = comp
     for u in graph.get_all_vertices():
         comp_u = component_dict[u]
         for v in graph.get_forward_neighbors(u):
             comp_v = component_dict[v]
             if comp_u != comp_v and comp_v not in graph_scc.get_forward_neighbors(comp_u):
                 graph_scc.add_edge(comp_u, comp_v)
     return scc, graph_scc
 
 
 # Kruskal
 def minimum_spanning_tree(graph, search_for_minimum=True):
     assert isinstance(graph, UndirectedGraph)
     vertices = graph.get_all_vertices()
     mst = [None] * len(vertices)
     mst_index = 0
     ds = DisjointSet()
     for v in vertices:
         ds.make_set(v)
     sorted_edges = sorted(graph.get_all_edges(), key=lambda x: x.get_weight())
     if not search_for_minimum:
         sorted_edges.reverse()
     for edge in sorted_edges:
         u, v = edge.vertices
         if not ds.same_set(u, v):
             mst[mst_index] = edge
             mst_index += 1
             ds.union(u, v)
     return mst[:mst_index]
 
 
 
 
 
 
 
 
 
 
 
 
 import operator
 from heapq import *
 
 
 
 class Dijkstra:
 
     def __init__(self, graph):
         if min(edge.get_weight() for edge in graph.get_all_edges()) < 0:
             raise ValueError(""Graph has negative cost edges."")
         self.graph = graph
         self.vertices = graph.get_all_vertices()
         assert None not in self.vertices
         self.source = None
         self.distance = None
         self.bandwidth = None
         self.parent = None
 
     def generic_algorithm_no_priority_queue(self, initial_d_source, initial_d_all,
                                             objective_func, path_calc_weight_func, source, target=None):
 
         assert objective_func in [min, max]
 
         # initialize
         assert source in self.vertices
         d = {v: initial_d_all for v in self.vertices}
         p = {v: None for v in self.vertices}
         d[source] = initial_d_source
 
         # the actual thing
         queue = set(self.vertices)
         while queue:
             u = objective_func(queue, key=lambda x: d[x])
             queue.remove(u)
             d_u = d[u]
             if d_u == initial_d_all or u == target:
                 break
             for edge in self.graph.get_forward_edges(u):
                 v = edge.target_vertex
                 alt = path_calc_weight_func(d_u, edge.get_weight())
                 best = objective_func(alt, d[v])
                 if best != d[v]:
                     d[v] = alt
                     p[v] = u
         return d, p
 
     def generic_algorithm_with_priority_queue(self, initial_d_source, initial_d_all,
                                               objective_func, path_calc_weight_func, source, target=None):
         # next multiplicative factor is used to negate all d values when we our objective function is maximize
         # this is used so the min-heap acts actuallt like a max-heap
         heap_mult_factor = {min: 1, max: -1}[objective_func]
 
         # just a constant to identify vertices which were updated and therefore REMOVED from their previous position
         # noinspection PyPep8Naming
         REMOVED = '<dijkstra-removed-vertex>'
         assert REMOVED not in self.vertices
 
         # initialize
         assert source in self.vertices
         d = {v: initial_d_all for v in self.vertices}
         p = {v: None for v in self.vertices}
         d[source] = initial_d_source
 
         # entries in the queue are of the form:  [ current value d[vertex], unique int, vertex ]
         # this triplet is formed this way so the heapq methods sort according to d[u]
         # the unique (unused) integer in the middle of the triplet is there so the heapq methods do not
         # access comparisons of the vertices. This way the vertices may be of un-comparable types.
         # It seems a bit odd to work this way, but I thought it would have better performance than having the
         # queue entries of a new class type with its own comparator methods
 
         # the actual thing
         queue = [None] * len(d)
         unq_counter = 0
         for u, d_u in d.items():
             queue[unq_counter] = [d_u * heap_mult_factor, unq_counter, u]
             unq_counter += 1
         heapify(queue)
         entry_finder = dict({entry[-1]: entry for entry in queue})
         while queue:
             d_u, _, u = heappop(queue)
             d_u *= heap_mult_factor
             if u is REMOVED:
                 continue
             if d_u == initial_d_all or u == target:
                 break
             # del entry_finder[u]; # redundant. just wastes time
             for edge in self.graph.get_forward_edges(u):
                 v = edge.target_vertex
                 alt = path_calc_weight_func(d_u, edge.get_weight())
                 best = objective_func(alt, d[v])
                 if best != d[v]:
                     d[v] = alt
                     p[v] = u
                     entry_finder[v][-1] = REMOVED
                     updated_entry = [alt * heap_mult_factor, unq_counter, v]
                     unq_counter += 1
                     heappush(queue, updated_entry)
                     entry_finder[v] = updated_entry
 
         return d, p
 
     def run_shortest_paths(self, source, target, use_priority_queue=True):
         self.source = source
         if use_priority_queue:
             chosen_method = self.generic_algorithm_with_priority_queue
         else:
             chosen_method = self.generic_algorithm_no_priority_queue
         self.distance, self.parent = \
             chosen_method(0, float('infinity'), min, operator.add, source, target)
 
 
     def best_path(self, source, target, E, S):
 
         # next multiplicative factor is used to negate all d values when we our objective function is maximize
         # this is used so the min-heap acts actuallt like a max-heap
         heap_mult_factor = {min: 1, max: -1}[min]
 
         # just a constant to identify vertices which were updated and therefore REMOVED from their previous position
         # noinspection PyPep8Naming
         REMOVED = '<dijkstra-removed-vertex>'
         assert REMOVED not in self.vertices
 
         # initialize
         assert source in self.vertices
         d = {v: (float('infinity'), -2) for v in self.vertices}
         p = {v: None for v in self.vertices}
         horse = source[0]
         d[source] = (0, E[horse]/S[horse])
 
         # entries in the queue are of the form:  [ current value d[vertex], unique int, vertex ]
         # this triplet is formed this way so the heapq methods sort according to d[u]
         # the unique (unused) integer in the middle of the triplet is there so the heapq methods do not
         # access comparisons of the vertices. This way the vertices may be of un-comparable types.
         # It seems a bit odd to work this way, but I thought it would have better performance than having the
         # queue entries of a new class type with its own comparator methods
 
         # the actual thing
         queue = [None] * len(d)
         unq_counter = 0
         for u, d_u in d.items():
             queue[unq_counter] = [d_u * heap_mult_factor, unq_counter, u]
             unq_counter += 1
         heapify(queue)
         entry_finder = dict({entry[-1]: entry for entry in queue})
         while queue:
             d_u, _, u = heappop(queue)
             d_u *= heap_mult_factor
             if u is REMOVED:
                 continue
             if d_u == (float('infinity'), -2) or u == target:
                 break
             # del entry_finder[u]; # redundant. just wastes time
             for edge in self.graph.get_forward_edges(u):
                 v = edge.target_vertex
                 if u[0] != v[0]:
                     v = edge.target_vertex
                     horse = v[1]
                     alt = (d_u[0] + edge.get_weight()/S[horse], d_u[1] - edge.get_weight()/S[horse])
                     if alt[1] < 0:
                         continue
                     best = min(alt, d[v])
                 elif u[1] != v[1]:
                     # switch horse
                     best = (d_u[0], E[horse]/S[horse])
                 else:
                     continue
 
                 if best < d[v]:
                     d[v] = alt
                     p[v] = u
                     entry_finder[v][-1] = REMOVED
                     updated_entry = [alt * heap_mult_factor, unq_counter, v]
                     unq_counter += 1
                     heappush(queue, updated_entry)
                     entry_finder[v] = updated_entry
 
         self.distance, self.parent =d, p
 
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 
 def solve_one_case(io_wrapper):
     N, Q = [int(x) for x in io_wrapper.readline().split()]
     E, S = [], []
     for i in range(N):
         ei, si = [int(x) for x in io_wrapper.readline().split()]
         E.append(ei)
         S.append(si)
     D = []
     for i in range(N):
         D.append([int(x) for x in io_wrapper.readline().split()])
     assert Q == 1
     src, trgt = [int(x)-1 for x in io_wrapper.readline().split()]
 
     G = DirectedGraph()
     for city in range(N):
         for horse in range(N):
             G.add_vertex((city, horse))
     for city in range(N):
         for horse1 in range(N):
             G.add_edge((city, horse1), (city, city), 0)
     for city1 in range(N):
         for city2 in range(N):
             for horse in range(N):
                 if D[city1][city2] == -1:
                     pass
                 else:
                     time_to_pass_from_city1_to_city2_with_specific_horse = D[city1][city2] / S[horse]
                     G.add_edge((city1, horse), (city2, horse), time_to_pass_from_city1_to_city2_with_specific_horse)
 
     source = (src, src)
     target = (trgt, trgt)
 
     dij = Dijkstra(G)
     dij.best_path(source, target, E, S)
 
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' +  str(dij.distance[target][0]) + '\n')
 
 
 
 
 
 
 
 main_run()
",gcj/2017/8294486/bigOnion/5681755159789568/0/extracted/pony.py,35430,979,3318,Python,8294486,0,5681755159789568,bigOnion,2017
179062,activities.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 
 EMPTY = '?'
 CAMERON = 'c'
 JAMIE = 'j'
 BOTH = 'b'
 
 VALUES = {CAMERON: 1, JAMIE: 1, BOTH: 2000}
 
 def get_empty_sequences(full_day_time_table):
     assert full_day_time_table[0] != EMPTY
     l = full_day_time_table + [full_day_time_table[0]]
     empty_seqs = []
     i = 0
     while i < 1441:
         if l[i] != EMPTY:
             i += 1
             continue
         else:
             start = i
             start_color = l[i-1]
             assert start_color != EMPTY
             while l[i] == EMPTY:
                 i += 1
             end = i
             end_color = l[end]
             if start_color != end_color:
                 color = BOTH
             else:
                 color = start_color
             empty_seqs.append([end-start, start, end, color])
     return empty_seqs
 
 
 def fill_in_time_table(full_day_time_table):
     if full_day_time_table.count(EMPTY) == len(full_day_time_table):
         for i in range(12*60):
             full_day_time_table[i] = CAMERON
         for i in range(12 * 60, 24*60):
             full_day_time_table[i] = JAMIE
         return [CAMERON] * (12 * 60) + [JAMIE] * (12 * 60)
 
     while full_day_time_table[0] == EMPTY:
         del full_day_time_table[0]
         full_day_time_table.append(EMPTY)
 
     empty_seqs = get_empty_sequences(full_day_time_table)
     empty_seqs.sort(key=lambda x:VALUES[x[3]]*x[0])
 
     c_counter = full_day_time_table.count(CAMERON)
     j_counter = full_day_time_table.count(JAMIE)
     while c_counter != 720 and j_counter != 720:
         next_empty_seq = empty_seqs[0]
         if next_empty_seq[0] == 0:
             del empty_seqs[0]
         else:
             length, start, end, color = next_empty_seq
             full_day_time_table[start] = color
             if color == BOTH:
                 assert full_day_time_table[start - 1] in [CAMERON, JAMIE]
                 color = full_day_time_table[start - 1]
             if color == CAMERON:
                 full_day_time_table[start] = CAMERON
                 c_counter += 1
             elif color == JAMIE:
                 full_day_time_table[start] = JAMIE
                 j_counter += 1
             else:
                 raise ValueError()
 
             empty_seqs[0][0] -= 1
             empty_seqs[0][1] += 1
 
     assert full_day_time_table.count(CAMERON) <= 720 and full_day_time_table.count(JAMIE) <= 720
     assert full_day_time_table.count(CAMERON) == 720 or full_day_time_table.count(JAMIE) == 720
     if full_day_time_table.count(JAMIE) == 720:
         for i in range(len(full_day_time_table)):
             if full_day_time_table[i] == EMPTY:
                 full_day_time_table[i] = CAMERON
     if full_day_time_table.count(CAMERON) == 720:
         for i in range(len(full_day_time_table)):
             if full_day_time_table[i] == EMPTY:
                 full_day_time_table[i] = JAMIE
     assert full_day_time_table.count(CAMERON) == 720 and full_day_time_table.count(JAMIE) == 720
     return full_day_time_table
 
 
 def count_swaps(full_day_timetable):
     full_day_timetable = full_day_timetable + [full_day_timetable[0]]
     counter = 0
     for i in range(1, len(full_day_timetable)):
         if full_day_timetable[i] != full_day_timetable[i-1]:
             counter += 1
     return counter
 
 
 def solve_one_case(io_wrapper):
     A_c, A_j = [int(x) for x in io_wrapper.readline().split()]
 
     full_day_time_table = [EMPTY] * (24*60)
 
     for i in range(A_c):
         start, end = [int(x) for x in io_wrapper.readline().split()]
         assert start < end
         assert end <= 24 * 60
         for m in range(start, end):
             full_day_time_table[m] = CAMERON
 
     for i in range(A_j):
         start, end = [int(x) for x in io_wrapper.readline().split()]
         assert start < end
         assert end <= 24 * 60
         for m in range(start, end):
             full_day_time_table[m] = JAMIE
 
     full_day_time_table = fill_in_time_table(full_day_time_table)
     solution = count_swaps(full_day_time_table)
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(solution) + '\n')
 
 
 
 
 
 
 main_run()
",gcj/2017/3274486/bigOnion/5706636844859392/1/extracted/activities.py,12575,352,1158,Python,3274486,1,5706636844859392,bigOnion,2017
179064,pancake_surface.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 from math import pi
 
 
 def get_best_heights_surface(l, r, K):
     if K == 1:
         return 2*pi*l[-1][0]*l[-1][1]
     l2 = [x[0]*x[1] for x in l[:-1]]
     l2.sort()
     s = sum(l2[-(K-1):]) + l[-1][0]*l[-1][1]
     return 2*pi*s
 
 
 def best_surface(R_H_list, K):
     R_H_list.sort()
     best = 0
     for i in range(K-1, len(R_H_list)):
         #print('****', i, R_H_list[i])
         r = R_H_list[i][0]
         l = R_H_list[:i+1]
         t = get_best_heights_surface(l, r, K)
         b = t + pi*(r**2)
         if b > best:
             best = b
             #print('determined best', best)
     return best
 
 
 def solve_one_case(io_wrapper):
     #print('TEST CASE ', io_wrapper.get_test_case())
     N, K = [int(x) for x in io_wrapper.readline().split()]
     R_H = []
     for i in range(N):
         R_H.append([int(x) for x in io_wrapper.readline().split()])
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': ' + str(best_surface(R_H, K)) + '\n')
 
 
 main_run()
",gcj/2017/3274486/bigOnion/5768968631484416/1/extracted/pancake_surface.py,9407,265,881,Python,3274486,1,5768968631484416,bigOnion,2017
179066,ai_prob.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 from decimal import Decimal
 from random import random
 
 
 def increase(U, P):
     while U > Decimal(2)**(-100) and abs(P[-1] - P[0]) > Decimal(2)**(-100):
         end = 0
         while abs(P[end] - P[0]) < Decimal(2)**(-100):
             end += 1
         seq_len = end
         assert U > - Decimal(2)**(-80)
         delta = min(U/seq_len, P[end] - P[0])
         for i in range(seq_len):
             P[i] += delta
         U -= seq_len * delta
         assert U > - Decimal(2)**(-80)
 
     P = [x + U/len(P) for x in P]
     assert U > - Decimal(2) ** (-80)
     return 0, P
 
 
 def solve_small(N, K, U, P):
     assert N == K
     P.sort()
     while U > Decimal(2)**(-200):
         U, P = increase(U, P)
     prob = Decimal(1)
     for p in P:
         prob *= p
     return prob
 
 
 
 def solve_big(N, K, U, P):
     P.sort()
     assert K <= N
     P2 = P[-K:]
     updated_u, updated_p = increase(U, P2)
     updated_P = P[:-K] + updated_p
     assert len(updated_P) == N
 
     prob = get_prob_of_success(K, updated_P)
     return prob
 
 
 def get_prob_of_success(K, P):
     P = [float(x) for x in P] # do it?
     N_ITERATIONS = 100000
     return Decimal([[x > random() for x in P].count(True) >= K for _ in range(N_ITERATIONS)].count(True)) / N_ITERATIONS
 
 
 def solve_one_case(io_wrapper):
     if io_wrapper.get_test_case() % 10 == 0:
         print ('CASE ', io_wrapper.get_test_case())
     N, K = [int(x) for x in io_wrapper.readline().split()]
     U = Decimal(io_wrapper.readline())
     P = [Decimal(x) for x in io_wrapper.readline().split()]
     assert len(P) == N
 
     prob = solve_big(N, K, U, P)
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': %0.8f\n' % prob)
 
 
 
 main_run()
",gcj/2017/3274486/bigOnion/5633143511973888/1/extracted/ai_prob.py,10143,294,999,Python,3274486,1,5633143511973888,bigOnion,2017
179067,ai_prob.py,"###############################################################################
 #      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
 ###############################################################################
 
 from functools import wraps, update_wrapper
 import time
 import os
 
 ###############################
 #      useful decorators
 ###############################
 
 
 class DecoratedFunctionInfo:
 
     def __init__(self):
         self.memoization_registry_reset_on_new_test_case = []
         self.function_counters = {}
 
     def reset_memoization_on_new_test_case(self):
         for cache_d in self.memoization_registry_reset_on_new_test_case:
             cache_d.clear()
 
     def get_function_counters(self):
         return self.function_counters
 
 
 _GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()
 
 
 # a decorator for memoizing function outputs
 def memoize_it(reset_on_new_test_case=False):
     cache = {}
     if reset_on_new_test_case:
         _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)
 
     def real_decorator(function):
         def wrapper(*args, **kwargs):
             if args not in cache:
                 cache[args] = function(*args, **kwargs)
             return cache[args]
         return update_wrapper(wrapper, function)
     return real_decorator
 
 
 # a decorator to add time benchmarking for a function
 def time_it(inner_func):
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         start_time = time.time()
         res = inner_func(*args, **kwargs)
         end_time = time.time()
         print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
         print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
         print()
         return res
     return wrapper
 
 
 # a decorator for logging the function's inputs and outputs
 def log_it(arguments=True, output=True):
     def decorating_function(user_function):
         def wrapper(*args, **kwargs):
             if arguments:
                 print(time.ctime(),
                       ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
             result = user_function(*args, **kwargs)
             if output:
                 print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
             return result
         return update_wrapper(wrapper, user_function)
     return decorating_function
 
         
 # a decorator for counting the number of calls to the wrapped function
 def count_it(inner_func):
     func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
     assert type(func_counters) == dict
     assert inner_func.__qualname__ not in func_counters
     func_counters[inner_func.__qualname__] = 0
 
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         global func_counters
         func_counters[inner_func.__qualname__] += 1
         return inner_func(*args, **kwargs)
     return wrapper
 
 
 # a decorator for pre-processing the function and automatically save the result
 def pre_process_it(inner_func):
     import inspect
     import pickle
     a = inspect.signature(inner_func)
     if len(a.aparmeters):
         raise ValueError('A pre process function must not have arguments')
 
     # noinspection PyUnusedLocal
     @time_it
     @wraps(inner_func)
     def wrapper(*args, **kwargs):
         filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
         # noinspection PyArgumentList
         if filename not in os.listdir():
             print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
             pre_process_data = inner_func()
             print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
             print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
             with open(filename, 'wb') as f_pp:
                 pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
             print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
         print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
         with open(filename, 'rb') as f_pp:
             data = pickle.load(f_pp)
         print('--> Unpickling ended')
         print()
         return data
 
     return wrapper
  
 
 ###########################################
 # automatic runner
 ###########################################
 
 # a class to wrap automatically the IO files in one class
 # noinspection PyPep8Naming
 class GCJIOWrapper:
 
     def __init__(self, input_filename, parsed_filename, output_filename):
         self.__input_filename = input_filename
         self.__parsed_filename = parsed_filename
         self.__output_filename = output_filename
         self.__index_test_case = 0
         self.__input_file = None
         self.__parsed_file = None
         self.__output_file = None
 
     def __enter__(self):
         # open the IO files
         self.__input_file = open(self.__input_filename, 'r')
         self.__parsed_file = open(self.__parsed_filename, 'w')
         self.__output_file = open(self.__output_filename, 'w')
 
     # noinspection PyUnusedLocal
     def __exit__(self, type_e, value, tb):
         # close the IO files
         self.__input_file.close()
         self.__parsed_file.close()
         self.__output_file.close()
 
     def readline(self):
         # read one line from the input. write it as is to the parsed file
         l = self.__input_file.readline()
         self.__parsed_file.write(l)
         return l
     
     def new_test_case(self):
         # mark a new test case to the parsed file
         self.__index_test_case += 1
         self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
     
     def write(self, s):
         # write to the output file
         self.__output_file.write(s)
     
     def get_test_case(self):
         # return the index of the current test case
         return self.__index_test_case
         
 
 # This is the automatic runner    
 @time_it
 def main_run():
         
     # find the most current input file (.in) which is in the working directory 
     print('Directory : ', os.getcwd())
     # noinspection PyArgumentList
     file_names = [x for x in os.listdir()]
     l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
     if not l1:
         raise ValueError('No input file found')
     chosen_prefix = sorted(l1)[-1][1][:-3]
     input_filename = chosen_prefix + '.in'
     print('Chosen Input : ', input_filename)
     
     # filename of the file into which to parse the input file
     parsed_filename = chosen_prefix + '.parsed.txt'
 
     # filename of the output file. It has the same prefix, 
     # and it doesn't tread over the previous output file from previous attempts
     l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
     l2 = [int(x.split('-run')[-1]) for x in l2]
     output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
     output_filename = chosen_prefix + '-run' + output_file_index + '.out'
     print('Chosen Output : ', output_filename)
     print()
     
     io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
     with io_wrapper:
         solve_all_cases(io_wrapper)
 
     # print the chosen files once again for easy checking of correctness
     print()
     print('Conclusion :')
     print('Directory : ', os.getcwd())
     print('Chosen Input : ', input_filename)
     print('Chosen Output : ', output_filename)
 
 
 # the automatic solver. Handles the test case mechanism
 @time_it
 def solve_all_cases(io_wrapper):
     # noinspection PyPep8Naming
     T = int(io_wrapper.readline())
     for test_case in range(1, T+1):
         io_wrapper.new_test_case()
         assert io_wrapper.get_test_case() == test_case
         _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
         solve_one_case(io_wrapper)
 
 
 ###########################################
 # write code here
 ###########################################
 
 from decimal import Decimal
 
 
 def increase(U, P):
     while U > Decimal(2)**(-100) and abs(P[-1] - P[0]) > Decimal(2)**(-100):
         end = 0
         while abs(P[end] - P[0]) < Decimal(2)**(-100):
             end += 1
         seq_len = end
         assert U > - Decimal(2)**(-80)
         delta = min(U/seq_len, P[end] - P[0])
         print('******', P)
         print(P[:end+1])
         for i in range(seq_len):
             P[i] += delta
         print (U, delta,seq_len)
         U -= seq_len * delta
         print (U, delta,seq_len)
         assert U > - Decimal(2)**(-80)
 
     P = [x + U/len(P) for x in P]
     assert U > - Decimal(2) ** (-80)
     return 0, P
 
 def solve_small(N, K, U, P):
     assert N == K
     P.sort()
     while U > Decimal(2)**(-200):
         U, P = increase(U, P)
     prob = Decimal(1)
     for p in P:
         prob *= p
     return prob
 
 
 def solve_one_case(io_wrapper):
     N, K = [int(x) for x in io_wrapper.readline().split()]
     U = Decimal(io_wrapper.readline())
     P = [Decimal(x) for x in io_wrapper.readline().split()]
     assert len(P) == N
 
     prob = solve_small(N, K, U, P)
     io_wrapper.write('Case #' + str(io_wrapper.get_test_case()) + ': %0.8f\n' % prob)
 
 
 
 main_run()
",gcj/2017/3274486/bigOnion/5633143511973888/0/extracted/ai_prob.py,9653,275,929,Python,3274486,0,5633143511973888,bigOnion,2017
14194,0000000000048aaa.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def how_problematic(row, col, clashes_in_same_row, clashes_in_same_col):
    return len(clashes_in_same_row[row][col]) + len(clashes_in_same_col[row][col])


t = int(input())
for testcase in range(1, t+1):
    N = int(input())
    matrix = []
    for _ in range(N):
        matrix.append([int(x) for x in input().split()])

    clashes_in_same_row = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_row[row] = x
    clashes_in_same_col = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_col[row] = x

    for row in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[row][i] == matrix[row][j]:
                    clashes_in_same_row[row][i].append(j)

    for col in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[i][col] == matrix[j][col]:
                    clashes_in_same_col[i][col].append(j)

    fix_me = []
    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
                fix_me.append((row,col))
    fix_me.sort(key=lambda x:how_problematic(x[0],x[1], clashes_in_same_row, clashes_in_same_col), reverse=True)

    count_fixes = 0
    while fix_me:
        row, col = fix_me[0]
        for i in clashes_in_same_row[row][col]:
            clashes_in_same_row[row][i].remove(col)
        for i in clashes_in_same_col[row][col]:
            clashes_in_same_col[i][col].remove(row)
        clashes_in_same_row[row][col] = []
        clashes_in_same_col[row][col] = []
        count_fixes += 1

        fix_me = []
        for row in range(N):
            for col in range(N):
                if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
                    fix_me.append((row,col))
        fix_me.sort(key=lambda x:how_problematic(x[0],x[1], clashes_in_same_row, clashes_in_same_col), reverse=True)

    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col]:
                for i in clashes_in_same_row[row][col]:
                    clashes_in_same_row[row][i].remove(col)
                clashes_in_same_row[row][col] = []
                count_fixes += 1

    for row in range(N):
        for col in range(N):
            if clashes_in_same_col[row][col]:
                for i in clashes_in_same_col[row][col]:
                    clashes_in_same_col[i][col].remove(row)
                clashes_in_same_col[row][col] = []
                count_fixes += 1

    print('Case #{}: {}'.format(testcase, count_fixes))

",,2899,86,247,Python,7706,0000000000048aaa,0000000000045875,bigOnion,2018
14195,0000000000048863.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')

from itertools import product

def pprint(m):
    for line in m:
        print(line)


def how_problematic(row, col, clashes_in_same_row, clashes_in_same_col):

    if clashes_in_same_row[row][col]:
        x = len(clashes_in_same_row[row][col]) + 1
        if clashes_in_same_col[row][col]:
            x += len(clashes_in_same_col[row][col]) + 1

    else:
        if clashes_in_same_col[row][col]:
            x = len(clashes_in_same_col[row][col]) + 1
        else:
            x = 0

    return x


t = int(input())
for testcase in range(1, t+1):
    N = int(input())
    matrix = []
    for _ in range(N):
        matrix.append([int(x) for x in input().split()])

    clashes_in_same_row = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_row[row] = x
    clashes_in_same_col = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_col[row] = x

    #clashes_in_sames_row = [list([[]] * N) for i in range(N)]
    for row in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[row][i] == matrix[row][j]:
                    clashes_in_same_row[row][i].append(j)

    #clashes_in_sames_col = [list([[]] * N) for i in range(N)]
    for col in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[i][col] == matrix[j][col]:
                    clashes_in_same_col[i][col].append(j)

    fix_me = []
    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
                fix_me.append((row,col))
    fix_me.sort(key=lambda x:how_problematic(x[0],x[1], clashes_in_same_row, clashes_in_same_col), reverse=True)

    count_fixes = 0
    while fix_me:
        row, col = fix_me[0]
        for i in clashes_in_same_row[row][col]:
            clashes_in_same_row[row][i].remove(col)
        for i in clashes_in_same_col[row][col]:
            clashes_in_same_col[i][col].remove(row)
        clashes_in_same_row[row][col] = []
        clashes_in_same_col[row][col] = []
        count_fixes += 1

        fix_me = []
        for row in range(N):
            for col in range(N):
                if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
                    fix_me.append((row,col))
        fix_me.sort(key=lambda x:how_problematic(x[0],x[1], clashes_in_same_row, clashes_in_same_col), reverse=True)

    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col]:
                for i in clashes_in_same_row[row][col]:
                    clashes_in_same_row[row][i].remove(col)
                clashes_in_same_row[row][col] = []
                count_fixes += 1

    for row in range(N):
        for col in range(N):
            if clashes_in_same_col[row][col]:
                for i in clashes_in_same_col[row][col]:
                    clashes_in_same_col[i][col].remove(row)
                clashes_in_same_col[row][col] = []
                count_fixes += 1

    print('Case #{}: {}'.format(testcase, count_fixes))


# t = int(input())
# for testcase in range(1, t+1):
#     N = int(input())
#     matrix = []
#     for _ in range(N):
#         matrix.append([int(x) for x in input().split()])
#
#     clashes_in_same_row = [None] * N
#     for row in range(N):
#         x = []
#         for col in range(N):
#             x.append([])
#         clashes_in_same_row[row] = x
#     clashes_in_same_col = [None] * N
#     for row in range(N):
#         x = []
#         for col in range(N):
#             x.append([])
#         clashes_in_same_col[row] = x
#
#     #clashes_in_sames_row = [list([[]] * N) for i in range(N)]
#     for row in range(N):
#         for i in range(N):
#             for j in range(N):
#                 if i != j and matrix[row][i] == matrix[row][j]:
#                     clashes_in_same_row[row][i].append(j)
#
#     #clashes_in_sames_col = [list([[]] * N) for i in range(N)]
#     for col in range(N):
#         for i in range(N):
#             for j in range(N):
#                 if i != j and matrix[i][col] == matrix[j][col]:
#                     clashes_in_same_col[i][col].append(j)
#
#     # print(testcase)
#     # pprint(matrix)
#     # print()
#     # pprint(clashes_in_same_row)
#     # print()
#     # pprint(clashes_in_same_col)
#
#     count_fixes = 0
#     for row in range(N):
#         for col in range(N):
#             if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
#                 for i in clashes_in_same_row[row][col]:
#                     clashes_in_same_row[row][i].remove(col)
#                 for i in clashes_in_same_col[row][col]:
#                     clashes_in_same_col[i][col].remove(row)
#                 clashes_in_same_row[row][col] = []
#                 clashes_in_same_col[row][col] = []
#                 print('fixed',row,col)
#                 count_fixes += 1
#
#     # print('got here1')
#
#     for row in range(N):
#         for col in range(N):
#             if clashes_in_same_row[row][col]:
#                 for i in clashes_in_same_row[row][col]:
#                     clashes_in_same_row[row][i].remove(col)
#                 clashes_in_same_row[row][col] = []
#                 print('fixed',row,col)
#                 count_fixes += 1
#
#     # print('got here2')
#
#     for row in range(N):
#         for col in range(N):
#             if clashes_in_same_col[row][col]:
#                 for i in clashes_in_same_col[row][col]:
#                     clashes_in_same_col[i][col].remove(row)
#                 clashes_in_same_col[row][col] = []
#                 print('fixed',row,col)
#                 count_fixes += 1
#
#     print('Case #{}: {}'.format(testcase, count_fixes))
#
",,6047,185,602,Python,7706,0000000000048863,0000000000045875,bigOnion,2018
14196,0000000000047e03.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def pprint(m):
    for line in m:
        print(line)


t = int(input())
for testcase in range(1, t+1):
    N = int(input())
    matrix = []
    for _ in range(N):
        matrix.append([int(x) for x in input().split()])

    clashes_in_same_row = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_row[row] = x
    clashes_in_same_col = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_col[row] = x

    #clashes_in_sames_row = [list([[]] * N) for i in range(N)]
    for row in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[row][i] == matrix[row][j]:
                    clashes_in_same_row[row][i].append(j)

    #clashes_in_sames_col = [list([[]] * N) for i in range(N)]
    for col in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[i][col] == matrix[j][col]:
                    clashes_in_same_col[i][col].append(j)

    # print(testcase)
    # pprint(matrix)
    # print()
    # pprint(clashes_in_same_row)
    # print()
    # pprint(clashes_in_same_col)

    count_fixes = 0
    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
                for i in clashes_in_same_row[row][col]:
                    clashes_in_same_row[row][i].remove(col)
                for i in clashes_in_same_col[row][col]:
                    clashes_in_same_col[i][col].remove(row)
                clashes_in_same_row[row][col] = []
                clashes_in_same_col[row][col] = []
                count_fixes += 1

    # print('got here1')

    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col]:
                for i in clashes_in_same_row[row][col]:
                    clashes_in_same_row[row][i].remove(col)
                clashes_in_same_row[row][col] = []
                count_fixes += 1

    # print('got here2')

    for row in range(N):
        for col in range(N):
            if clashes_in_same_col[row][col]:
                for i in clashes_in_same_col[row][col]:
                    clashes_in_same_col[i][col].remove(row)
                clashes_in_same_col[row][col] = []
                count_fixes += 1

    print('Case #{}: {}'.format(testcase, count_fixes))

",,2624,87,245,Python,7706,0000000000047e03,0000000000045875,bigOnion,2018
14197,0000000000047717.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def pprint(m):
    for line in m:
        print(line)


t = int(input())
for testcase in range(1, t+1):
    N = int(input())
    matrix = []
    for _ in range(N):
        matrix.append([int(x) for x in input().split()])

    clashes_in_same_row = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_row[row] = x
    clashes_in_same_col = [None] * N
    for row in range(N):
        x = []
        for col in range(N):
            x.append([])
        clashes_in_same_col[row] = x

    #clashes_in_sames_row = [list([[]] * N) for i in range(N)]
    for row in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[row][i] == matrix[row][j]:
                    clashes_in_same_row[row][i].append(j)

    #clashes_in_sames_col = [list([[]] * N) for i in range(N)]
    for col in range(N):
        for i in range(N):
            for j in range(N):
                if i != j and matrix[i][col] == matrix[j][col]:
                    clashes_in_same_col[i][col].append(j)

    # print(testcase)
    # pprint(matrix)
    # print()
    # pprint(clashes_in_same_row)
    # print()
    # pprint(clashes_in_same_col)

    count_fixes = 0
    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col] and clashes_in_same_col[row][col]:
                for i in clashes_in_same_row[row][col]:
                    clashes_in_same_row[row][i].remove(col)
                for i in clashes_in_same_col[row][col]:
                    clashes_in_same_col[i][col].remove(row)
                clashes_in_same_row[row][col] = []
                clashes_in_same_col[row][col] = []
                count_fixes += 1

    # print('got here1')

    for row in range(N):
        for col in range(N):
            if clashes_in_same_row[row][col]:
                for i in clashes_in_same_row[row][col]:
                    clashes_in_same_row[row][i].remove(col)
                    clashes_in_same_row[row][col] = []
                    count_fixes += 1

    # print('got here2')

    for row in range(N):
        for col in range(N):
            if clashes_in_same_col[row][col]:
                for i in clashes_in_same_col[row][col]:
                    clashes_in_same_col[i][col].remove(row)
                    clashes_in_same_col[row][col] = []
                    count_fixes += 1

    print('Case #{}: {}'.format(testcase, count_fixes))

",,2640,87,245,Python,7706,0000000000047717,0000000000045875,bigOnion,2018
14198,0000000000045e0c.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve(B):
    if B[0] == 0:
        return None
    if B[-1] == 0:
        return None
    if sum(B) != len(B):
        return None

    get_to = [None] * len(B)
    j = 0
    for i in range(len(B)):
        for t in range(B[i]):
            get_to[j] = i
            j += 1
    assert j == len(B)

    rows_needed = max([abs(i-get_to[i]) for i in range(len(B))]) + 1
    solution = [['.'] * len(B) for row in range(rows_needed)]
    for i in range(len(B)):
        dest = get_to[i]
        if dest > i:
            for t in range(dest-i):
                solution[t][i+t] = '\\'
        if dest < i:
            for t in range(i - dest):
                solution[t][i - t] = '/'
    return solution






t = int(input())
for testcase in range(1, t+1):
    C = int(input())
    B = [int(x) for x in input().split()]
    assert len(B) == C
    solution = solve(B)

    if solution is None:
        print('Case #{}: IMPOSSIBLE'.format(testcase))
    else:
        print('Case #{}: {}'.format(testcase, len(solution)))
        for line in solution:
            print(''.join(line))

",,1239,54,158,Python,7706,0000000000045e0c,00000000000459f2,bigOnion,2018
47443,000000000003accf.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case():
    S = int(input())
    l = [None] * S
    for i in range(S):
        d,x,y = [int(x) for x in input().split()]
        l[i] = (d+x, d-y)

    M_data_array = [None]* S
    i = 0
    while i < S:
        M = l[i][0]
        j = i
        while j+1 < S and l[j+1][0] == M:
            j += 1
        for k in range(i, j+1):
            M_data_array[k] = (M, i, j)
        i = j + 1
    M_seqs = list(set(M_data_array))
    M_seqs.sort(key=lambda x:x[1])

    N_data_array = [None]* S
    i = 0
    while i < S:
        N = l[i][1]
        j = i
        while j+1 < S and l[j+1][1] == N:
            j += 1
        for k in range(i, j+1):
            N_data_array[k] = (N, i, j)
        i = j + 1
    N_seqs = list(set(N_data_array))
    N_seqs.sort(key=lambda x:x[1])


    best_length = 0
    best_set = set()

    for initial_seq in M_seqs:
        starting_index = initial_seq[1]
        M = initial_seq[0]
        mid_index = initial_seq[2]+1
        if mid_index < S:
            N = N_data_array[mid_index][0]
            mid_index = N_data_array[mid_index][2]+1
            while True:
                if mid_index < S and M_data_array[mid_index][0] == M:
                    mid_index = M_data_array[mid_index][2] + 1
                else:
                    end_index = mid_index
                    break
                if mid_index < S and N_data_array[mid_index][0] == N:
                    mid_index = N_data_array[mid_index][2] + 1
                else:
                    end_index = mid_index
                    break
        else:
            end_index = S

        length = end_index - starting_index
        if length > best_length:
            best_length = length
            best_set = set()
            best_set.add((starting_index, end_index))
        elif length == best_length:
            best_set.add((starting_index, end_index))

    for initial_seq in N_seqs:
        starting_index = initial_seq[1]
        N = initial_seq[0]
        mid_index = initial_seq[2] + 1
        if mid_index < S:
            M = M_data_array[mid_index][0]
            mid_index = M_data_array[mid_index][2] + 1
            while True:
                if mid_index < S and N_data_array[mid_index][0] == N:
                    mid_index = N_data_array[mid_index][2] + 1
                else:
                    end_index = mid_index
                    break
                if mid_index < S and M_data_array[mid_index][0] == M:
                    mid_index = M_data_array[mid_index][2] + 1
                else:
                    end_index = mid_index
                    break
        else:
            end_index = S

        length = end_index - starting_index
        if length > best_length:
            best_length = length
            best_set = set()
            best_set.add((starting_index, end_index))
        elif length == best_length:
            best_set.add((starting_index, end_index))

#    print('hola', best_length, best_set)


    return best_length, len(best_set)


t = int(input())
for testcase in range(1, t+1):
    y, z = solve_single_case()
    print('Case #{}: {} {}'.format(testcase, y, z))

",,3314,113,349,Python,7764,000000000003accf,000000000003675b,bigOnion,2018
47444,0000000000039d97.PYTHON3,"import sys
from functools import wraps, update_wrapper

if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


class DecoratedFunctionInfo:

    def __init__(self):
        self.memoization_registry_reset_on_new_test_case = []
        self.function_counters = {}

    def reset_memoization_on_new_test_case(self):
        for cache_d in self.memoization_registry_reset_on_new_test_case:
            cache_d.clear()

    def get_function_counters(self):
        return self.function_counters



_GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()

# a decorator for memoizing function outputs
def memoize_it(reset_on_new_test_case=False):
    cache = {}
    if reset_on_new_test_case:
        _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)

    def real_decorator(function):
        def wrapper(*args, **kwargs):
            if args not in cache:
                cache[args] = function(*args, **kwargs)
            return cache[args]
        return update_wrapper(wrapper, function)
    return real_decorator

@memoize_it()
def next_jump(q1, N):
    while not my_round(q1, N)[1] and q1 <= N:
        q1 += 1
    if q1 > N:
        return q1 + N+1
    else:
        return q1


def my_round(b, N):
    p = b*100 // N
    flag = False
    if (b*100-p*N) * 2 >= N:
        flag = True
        p += 1
    return p, flag


t = int(input())
for testcase in range(1, t+1):
    N, L = [int(x) for x in input().split()]
    q = [int(x) for x in input().split()]
    assert len(q) == L
    current_having = N-sum(q)
    q.extend([0] * current_having)
    q2 = [[next_jump(q1, N)-q1, q1] for q1 in q]
    q2.sort()
    i = 0
    while current_having:
        delta = min(current_having, q2[i][0])
        q2[i][1] += delta
        current_having -= delta
        assert current_having >= 0
        i += 1
    q2 = [x[1] for x in q2]

    percent_sum = 0
    for b in q2:
        percent_sum += my_round(b, N)[0]

    print('Case #{}: {}'.format(testcase, percent_sum))
    ",,2100,82,221,Python,7764,0000000000039d97,0000000000036601,bigOnion,2018
47445,0000000000037e1f.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case():
    S = int(input())
    l = [None] * S
    for i in range(S):
        d,x,y = [int(x) for x in input().split()]
        l[i] = (d+x, d-y)

    best_length = 0
    best_set = set()


    i = 0
    while i < S:
        M = l[i][0]
        j = i
        while j < S and l[j][0] == M:
            j += 1
        if j < S:
            k = j
            N = l[k][1]
            while k < S and (l[k][0] == M or l[k][1] == N):
                k += 1
            length = k - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i,k))
            elif length == best_length:
                best_set.add((i, k))
        else:
            assert j == S
            length = S - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i, S))
            elif length == best_length:
                best_set.add((i, S))

        i = j


    i = 0
    while i < S:
        M = l[i][1]
        j = i
        while j < S and l[j][1] == M:
            j += 1
        if j < S:
            k = j
            N = l[k][0]
            while k < S and (l[k][1] == M or l[k][0] == N):
                k += 1
            length = k - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i, k))
            elif length == best_length:
                best_set.add((i, k))

        else:
            assert j == S
            length = S - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i, S))

            elif length == best_length:
                best_set.add((i, S))

        i = j

    return best_length, len(best_set)


t = int(input())
for testcase in range(1, t+1):
    y, z = solve_single_case()
    print('Case #{}: {} {}'.format(testcase, y, z))

",,2162,89,274,Python,7764,0000000000037e1f,000000000003675b,bigOnion,2018
47446,0000000000037bea.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case():
    S = int(input())
    l = [None] * S
    for i in range(S):
        d,x,y = [int(x) for x in input().split()]
        l[i] = (d+x, d-y)

    best_length = 0
    best_set = set()


    i = 0
    while i < S:
        M = l[i][0]
        j = i
        while j < S and l[j][0] == M:
            j += 1
        if j < S:
            k = j
            N = l[k][1]
            while k < S and l[k][1] == N:
                k += 1
            next_i = k
            while k < S and (l[k][0] == M or l[k][1] == N):
                k += 1
            length = k - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i,k))
            elif length == best_length:
                best_set.add((i, k))
            i = next_i
        else:
            assert j == S
            length = S - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i, S))
            elif length == best_length:
                best_set.add((i, S))
            i = j


    i = 0
    while i < S:
        M = l[i][1]
        j = i
        while j < S and l[j][1] == M:
            j += 1
        if j < S:
            k = j
            N = l[k][0]
            while k < S and l[k][0] == N:
                k += 1
            next_i = k
            while k < S and (l[k][1] == M or l[k][0] == N):
                k += 1
            length = k - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i, k))
            elif length == best_length:
                best_set.add((i, k))
            i = next_i

        else:
            assert j == S
            length = S - i
            if length > best_length:
                best_length = length
                best_set = set()
                best_set.add((i, S))

            elif length == best_length:
                best_set.add((i, S))
            i = j

    return best_length, len(best_set)


t = int(input())
for testcase in range(1, t+1):
    y, z = solve_single_case()
    print('Case #{}: {} {}'.format(testcase, y, z))

",,2390,95,308,Python,7764,0000000000037bea,000000000003675b,bigOnion,2018
104338,000000000002c998.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from decimal import Decimal
import math


half = Decimal(1)/Decimal(2)
sqrt2 = Decimal(2).sqrt()
pi = Decimal(math.pi)
t = int(input())
for testcase in range(1, t+1):
    A = Decimal(input())
    theta = Decimal(math.acos(A / sqrt2))
    #sys.stderr.write(str(theta) + '\n')
    #sys.stderr.flush()
    theta1 = theta + pi/Decimal(4)
    theta2 = theta - pi/Decimal(4)
    print('Case #{}:'.format(testcase))
    x1, y1 = half*Decimal(math.cos(theta1)), half*Decimal(math.sin(theta1))
    x2, y2 = half*Decimal(math.cos(theta2)), half*Decimal(math.sin(theta2))
    print('%.20f %.20f 0' % (x1, y1))
    print('%.20f %.20f 0' % (x2, y2))
    print('0 0 0.5')
",,812,28,89,Python,00000000000000cb,000000000002c998,00000000000079cc,bigOnion,2018
104339,000000000002b293.PYTHON3,"import random
import sys

SHIFT = 10
OK = 'OK'
ERROR = 'ERROR'


def choose_next_attack_location(plan_map):
    best_score = -1
    l_best = []
    for x in range(1, len(plan_map)-1):
        for y in range(1, len(plan_map[0])-1):
            score = plan_map[x-1][y-1:y+2].count(False) + plan_map[x][y-1:y+2].count(False) + plan_map[x+1][y-1:y+2].count(False)
            if score > best_score:
                l_best = [(x, y)]
                best_score = score
            elif score == best_score:
                l_best.append((x, y))
    return random.choice(l_best)


def solve_single_case():
    line = input()
    A = int(line)
    e = max(int(A**0.5), 3)
    while e*(e+1) < A:
        e += 1
    if e*e >= A:
        plan_map = [[False] * e for _ in range(e)]
    else:
        plan_map = [[False] * e for _ in range(e+1)]
    sys.stderr.write('{} {} {}\n'.format(A, len(plan_map), len(plan_map[0])))
    sys.stderr.flush()
    print(SHIFT+1, SHIFT+1, flush=True)
    cntr = 1
    i, j = [int(x) for x in input().split()]
    while min(i, j) > 0:
        plan_map[i - SHIFT][j - SHIFT] = True
        x, y = choose_next_attack_location(plan_map)
        print(SHIFT + x, SHIFT + y, flush=True)
        cntr += 1
        i, j = [int(x) for x in input().split()]
    if i == j == 0:
        sys.stderr.write('OK  ' + str(cntr) + '\n')
        sys.stderr.flush()
        return OK
    else:
        sys.stderr.write('ERR ' + str(cntr) + '\n')
        sys.stderr.flush()
        return ERROR


line = input()
t = int(line)
sys.stderr.write('t=  ' + str(t) + '\n')
sys.stderr.flush()
for testcase in range(1, t+1):
    sys.stderr.write('testcase  ' + str(testcase) + '\n')
    sys.stderr.flush()
    retval = solve_single_case()
    if retval != OK:
        break
",,1771,64,211,Python,00000000000000cb,000000000002b293,0000000000007a30,bigOnion,2018
104340,000000000001fba3.PYTHON3,"import sys

SHIFT = 10
OK = 'OK'
ERROR = 'ERROR'


def solve_single_case():
    line = input()
    A = int(line)
    width = A//3
    if A % 3 != 0:
        width += 1
    plan_map = [[False, False, False] for _ in range(width)]
    curr_index = 1
    print(SHIFT+curr_index, SHIFT+1, flush=True)
    i, j = [int(x) for x in input().split()]
    while min(i, j) > 0:
        plan_map[i-SHIFT][j-SHIFT] = True
        while all(plan_map[curr_index]) and curr_index < width-2:
            curr_index += 1
        print(SHIFT+curr_index, SHIFT+1, flush=True)
        i, j = [int(x) for x in input().split()]
    if i == j == 0:
        return OK
    else:
        return ERROR


line = input()
t = int(line)
for testcase in range(1, t+1):
    retval = solve_single_case()
    if retval != OK:
        break
",,804,36,112,Python,00000000000000cb,000000000001fba3,0000000000007a30,bigOnion,2018
104341,000000000001fb7a.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


SHIFT = 10
OK = 'OK'
ERROR = 'ERROR'


def solve_single_case():
    line = input()
    A = int(line)
    width = A//3
    if A % 3 != 0:
        width += 1
    plan_map = [[False, False, False] for _ in range(width)]
    curr_index = 1
    print(SHIFT+curr_index, SHIFT+1, flush=True)
    i, j = [int(x) for x in input().split()]
    while min(i, j) > 0:
        plan_map[i-SHIFT][j-SHIFT] = True
        while all(plan_map[curr_index]) and curr_index < width-2:
            curr_index += 1
        print(SHIFT+curr_index, SHIFT+1, flush=True)
        i, j = [int(x) for x in input().split()]
    if i == j == 0:
        return OK
    else:
        return ERROR


line = input()
t = int(line)
for testcase in range(1, t+1):
    retval = solve_single_case()
    if retval != OK:
        break
",,946,40,127,Python,00000000000000cb,000000000001fb7a,0000000000007a30,bigOnion,2018
104342,000000000001ac95.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def find_first_err(line):
    line_a = line[::2]
    line_b = line[1::2]
    line_a.sort()
    line_b.sort()
    if len(line_b) == len(line_a):
        line_a.append((10**9)+1000)
    for i in range(len(line_b)):
        if line_a[i] > line_b[i]:
            return i*2
        if line_b[i] > line_a[i+1]:
            return i*2+1
    return 'OK'


t = int(input())
for testcase in range(1, t+1):
    n = int(input())
    line = [int(x) for x in input().split()]
    assert len(line) == n
    print('Case #{}: {}'.format(testcase, find_first_err(line)))

",,709,29,76,Python,00000000000000cb,000000000001ac95,00000000000079cb,bigOnion,2018
104343,000000000001703a.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def calculate_damage(p):
    damage = 0
    power = 1
    for char in p:
        if char == 'S':
            damage += power
        elif char == 'C':
            power *= 2
    return damage


t = int(input())
for testcase in range(1, t+1):
    d, p = input().split()
    d = int(d)
    assert p.count('S') + p.count('C') == len(p)
    possible_flag = p.count('S') <= d
    p = p.rstrip('C')
    swaps = 0
    while calculate_damage(p) > d:
        i = p.rfind('C')
        if i == -1:
            assert not possible_flag
            break
        assert p[i+1] == 'S'
        p = p[:i] + 'SC' + p[i+2:]
        if p[-1] == 'C':
            p = p[:-1]
        swaps += 1
    if possible_flag:
        print('Case #{}: {}'.format(testcase, swaps))
    else:
        print('Case #{}: IMPOSSIBLE'.format(testcase))
",,968,40,123,Python,00000000000000cb,000000000001703a,0000000000007966,bigOnion,2018
258539,000000000000172c.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


t = int(input())
for testcase in range(1, t+1):
    a, b = [int(x) for x in input().split()]
    n = int(input())
    guessed = False
    while not guessed:
        m = (b+a)//2
        print(m, flush=True)
        response = input().strip()
        if response == 'CORRECT':
            guessed = True
        elif response == 'TOO_SMALL':
            a = m + 1
        elif response == 'TOO_BIG':
            b = m - 1
        else:
            sys.exit()
",,612,24,77,Python,0000000000000130,000000000000172c,0000000000000523,bigOnion,2018
258540,00000000000015c9.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


t = int(input())
for testcase in range(1, t+1):
    a, b = [int(x) for x in input().split()]
    n = int(input())
    guessed = False
    while not guessed:
        m = (b+a)//2
        print(m, flush=True)
        response = input().strip()
        if response == ' CORRECT':
            guessed = True
        elif response == 'TOO_SMALL':
            a = m + 1
        elif response == 'TOO_BIG':
            b = m - 1
        else:
            sys.exit()
",,613,24,78,Python,0000000000000130,00000000000015c9,0000000000000523,bigOnion,2018
258541,000000000000158a.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


t = int(input())
for testcase in range(1, t+1):
    a, b = [int(x) for x in input().split()]
    n = int(input())
    guessed = False
    while not guessed:
        m = (b+a)//2
        print(m, flush=True)
        response = input()
        if response == ' CORRECT':
            guessed = True
        elif response == 'TOO_SMALL':
            a = m + 1
        elif response == 'TOO_BIG':
            b = m - 1
        else:
            pass # sys.exit()
",,612,24,80,Python,0000000000000130,000000000000158a,0000000000000523,bigOnion,2018
258542,0000000000001698.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


t = int(input())
for testcase in range(1, t+1):
    a, b = [int(x) for x in input().split()]
    n = int(input())
    guessed = False
    while not guessed:
        m = (b+a)//2
        print(m, flush=True)
        response = input()
        if response == ' CORRECT':
            guessed = True
        elif response == 'TOO_SMALL':
            a = m + 1
        elif response == 'TOO_BIG':
            b = m - 1
        else:
            sys.exit()
",,605,24,78,Python,0000000000000130,0000000000001698,0000000000000523,bigOnion,2018
258543,00000000000013da.PYTHON3,"import sys
if 'local_testing' in sys.argv:
    sys.stdin = open('sample.in', 'r')


def solve(n, k):
    interval_ctr = {n:1}
    curr = 0
    while curr + interval_ctr[max(interval_ctr)] < k:
        m = max(interval_ctr)
        if m % 2 == 1:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]*2
        else:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]
            interval_ctr[n+1] = interval_ctr.get(n+1,0) + interval_ctr[m]
        curr += interval_ctr[m]
        del interval_ctr[m]
    m = max(interval_ctr)
    if m % 2 == 1:
        return (m-1)//2, (m-1)//2
    else:
        return m//2, m//2-1

t = int(input())
for i in range(1, t+1):
    n, k = [int(x) for x in input().split()]
    s = solve(n, k)
    print('Case #{}: {} {}'.format(i, s[0], s[1]))

",,862,32,103,Python,0000000000000130,00000000000013da,0000000000000652,bigOnion,2018
258544,0000000000000f25.PYTHON3,"def solve(n, k):
    interval_ctr = {n:1}
    curr = 0
    while curr + interval_ctr[max(interval_ctr)] < k:
        m = max(interval_ctr)
        if m % 2 == 1:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]*2
        else:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]
            interval_ctr[n+1] = interval_ctr.get(n+1,0) + interval_ctr[m]
        curr += interval_ctr[m]
        del interval_ctr[m]
    m = max(interval_ctr)
    if m % 2 == 1:
        return (m-1)//2, (m-1)//2
    else:
        return m//2, m//2-1

t = int(input())
for i in range(1, t+1):
    n, k = [int(x) for x in input().split()]
    s = solve(n, k)
    print('Case #{}: {} {}'.format(i, s[0], s[1]))

",,778,27,93,Python,0000000000000130,0000000000000f25,0000000000000652,bigOnion,2018
258545,0000000000000eec.PYTHON3,"def solve(n, k):
    interval_ctr = {n:1}
    curr = 0
    while curr + interval_ctr[max(interval_ctr)] < k:
        m = max(interval_ctr)
        if m % 2 == 1:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]*2
        else:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]
            interval_ctr[n+1] = interval_ctr.get(n+1,0) + interval_ctr[m]
        curr += interval_ctr[m]
        del interval_ctr[m]
    m = max(interval_ctr)
    if m % 2 == 1:
        return (m-1)//2, (m-1)//2
    else:
        return m//2, m//2-1

t = int(input())
for i in range(1, t+1):
    n, k = [int(x) for x in input().split()]
    s = solve(n, k)
    print('Case {}: {} {}'.format(i, s[0], s[1]))

",,777,27,93,Python,0000000000000130,0000000000000eec,0000000000000652,bigOnion,2018
258546,0000000000000faf.PYTHON3,"def solve(n, k):
    interval_ctr = {n:1}
    curr = 0
    while curr + interval_ctr[max(interval_ctr)] < k:
        m = max(interval_ctr)
        if m % 2 == 1:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]*2
        else:
            n = (m-1)//2
            interval_ctr[n] = interval_ctr.get(n,0) + interval_ctr[m]
            interval_ctr[n+1] = interval_ctr.get(n+1,0) + interval_ctr[m]
        curr += interval_ctr[m]
        del interval_ctr[m]
    m = max(interval_ctr)
    if m % 2 == 1:
        return (m-1)//2, (m-1)//2
    else:
        return m//2, m//2-1

t = int(input())
for i in range(1, t+1):
    n, k = [int(x) for x in input().split()]
    s = solve(n, k)
    print('Case {}: {} {}'.format(i, s[0], s[1])

",,776,27,93,Python,0000000000000130,0000000000000faf,0000000000000652,bigOnion,2018
11906,000000000014c54a.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    m = int(input())
    formulas = []
    for i in range(m):
        t, s = [int(x)-1 for x in input().split()]
        formulas.append((t, s))
    amounts = [int(x) for x in input().split()]

    best = -1

    while amounts[0] > best:
        best = amounts[0]
        if best == float('inf'):
            break

        for _ in range(m):
            for metal in range(m):
                if amounts[metal] == float('inf'):
                    t, s = formulas[metal]
                    amounts[t] = float('inf')
                    amounts[s] = float('inf')
                else:
                    if metal not in formulas[metal]:
                        t, s = formulas[metal]
                        a = amounts[metal]
                        amounts[t] += a
                        amounts[s] += a
                        amounts[metal] = 0
                    else:
                        t, s = formulas[metal]
                        if t == metal:
                            other = s
                        else:
                            other = t
                        if amounts[metal] != 0:
                            amounts[other] = float('inf')

    if best == float('inf'):
        solution = 'UNBOUNDED'
    else:
        solution = str(best % 1000000007)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",,1627,54,154,Python,0000000000051679,000000000014c54a,0000000000146185,bigOnion,2019
11907,000000000014c473.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    m = int(input())
    formulas = [0] * m
    for i in range(m):
        t, s = [int(x)-1 for x in input().split()]
        formulas[i] = (t, s)
    amounts = [int(x) for x in input().split()]

    best = -1

    while amounts[0] > best:
        best = amounts[0]
        if best == float('inf'):
            break

        for _ in range(m):
            for metal in range(m):
                if amounts[metal] == float('inf'):
                    t, s = formulas[metal]
                    amounts[t] = float('inf')
                    amounts[s] = float('inf')
                else:
                    if metal not in formulas[metal]:
                        t, s = formulas[metal]
                        a = amounts[metal]
                        amounts[t] += a
                        amounts[s] += a
                        amounts[metal] = 0
                    else:
                        t, s = formulas[metal]
                        if t == metal:
                            other = s
                        else:
                            other = t
                        if amounts[metal] != 0:
                            amounts[other] = float('inf')

    if best == float('inf'):
        solution = 'UNBOUNDED'
    else:
        solution = str(best % 1000000007)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",,1629,54,158,Python,0000000000051679,000000000014c473,0000000000146185,bigOnion,2019
11908,000000000014bda7.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


# def read_big_line():
#
#     sys.stdin.read(1)


def solve_single_case(test_case):
    m = int(input())
    formulas = [0] * m
    for i in range(m):
        t, s = [int(x)-1 for x in input().split()]
        formulas[i] = (t, s)
    amounts = [int(x) for x in input().split()]

    best = -1

    while amounts[0] > best:
        best = amounts[0]
        if best == float('inf'):
            break

        for it in range(m):
            for metal in range(m):
                if amounts[metal] == float('inf'):
                    t, s = formulas[metal]
                    amounts[t] = float('inf')
                    amounts[s] = float('inf')
                else:
                    if metal not in formulas[metal]:
                        t, s = formulas[metal]
                        a = amounts[metal]
                        amounts[t] += a
                        amounts[s] += a
                        amounts[metal] = 0
                    else:
                        t, s = formulas[metal]
                        if t == metal:
                            other = s
                        else:
                            other = t
                        if amounts[metal] != 0:
                            amounts[other] = float('inf')

    if best == float('inf'):
        solution = 'UNBOUNDED'
    else:
        solution = str(best)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",,1668,59,162,Python,0000000000051679,000000000014bda7,0000000000146185,bigOnion,2019
11909,000000000014a58f.PYTHON3,"import time
import inspect
from sys import exit


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


with IoNoLog() as io:

    def solve_single_case(test_case):
        # stderr.write('starting case {}\n'.format(test_case))
        # stderr.flush()
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 0', inspect.getframeinfo(inspect.currentframe()).lineno)
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        curr_day = int(line)
        if curr_day != 100 or curr_day == -1:
            exit(0)
        io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)",,1855,57,137,Python,0000000000051679,000000000014a58f,00000000001461c8,bigOnion,2019
11910,0000000000149f0a.PYTHON3,"import time
import inspect
from sys import exit


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


with IoNoLog() as io:

    def solve_single_case(test_case):
        # stderr.write('starting case {}\n'.format(test_case))
        # stderr.flush()
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 0', inspect.getframeinfo(inspect.currentframe()).lineno)
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        curr_day = int(line)
        if curr_day != 100 or curr_day == -1:
            exit(0)
        io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,1779,56,134,Python,0000000000051679,0000000000149f0a,00000000001461c8,bigOnion,2019
11911,0000000000149cce.PYTHON3,"import sys
from fractions import Fraction
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def find_solution(n, l):
    lower_bound = Fraction(0, 1)
    upper_bound = Fraction(10**100,1)
    for i in range(1, n):
        c1, j1 = l[i-1]
        c2, j2 = l[i]
        if c1 >= c2 and j1 >= j2:
            return 'IMPOSSIBLE'
        if j2 > j1 and c2 > c1:
            pass  # always good
        if j1 == j2 or c1 == c2:
            pass  # always good
        elif j2 > j1:
            lower_bound = max(lower_bound, Fraction(c1-c2, j2-j1))
        elif c2 > c1:
            upper_bound = min(upper_bound, Fraction(c1-c2, j2-j1))
    if upper_bound <= lower_bound:
        return 'IMPOSSIBLE'
    mid_range = (upper_bound + lower_bound) / 2

    max_denominator_a = 1
    max_denominator_b = 10**20
    while max_denominator_b > max_denominator_a:
        mid_denominator = (max_denominator_a + max_denominator_b) // 2
        if lower_bound < mid_range.limit_denominator(mid_denominator) < upper_bound:
            max_denominator_b = mid_denominator
        else:
            max_denominator_a = mid_denominator + 1

    c = max_denominator_a

    max_j = 10**100
    min_j = 1
    while min_j < max_j:
        mid_j = (min_j + max_j) // 2
        if Fraction(mid_j, c) > lower_bound:
            max_j = mid_j
        else:
            min_j = mid_j + 1
    return '{} {}'.format(c, min_j)


def solve_single_case(test_case):
    n = int(input())
    l = []
    for i in range(n):
        c_i, j_i = [int(x) for x in input().split()]
        l.append((c_i, j_i))

    solution = find_solution(n, l)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

",,1849,65,218,Python,0000000000051679,0000000000149cce,0000000000146184,bigOnion,2019
11912,0000000000149e29.PYTHON3,"import sys
from fractions import Fraction
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def find_solution(n, l):
    lower_bound = Fraction(0, 1)
    upper_bound = Fraction(10**100,1)
    for i in range(1, n):
        c1, j1 = l[i-1]
        c2, j2 = l[i]
        if c1 >= c2 and j1 >= j2:
            return 'IMPOSSIBLE'
        if j2 > j1 and c2 > c1:
            pass  # always good
        if j1 == j2 or c1 == c2:
            pass  # always good
        elif j2 > j1:
            lower_bound = max(lower_bound, Fraction(c1-c2, j2-j1))
        elif c2 > c1:
            upper_bound = min(upper_bound, Fraction(c1-c2, j2-j1))
    if upper_bound <= lower_bound:
        return 'IMPOSSIBLE'
    print(upper_bound, lower_bound)
    mid_range = (upper_bound + lower_bound) / 2

    max_denominator_a = 1
    max_denominator_b = 10**20
    while max_denominator_b > max_denominator_a:
        mid_denominator = (max_denominator_a + max_denominator_b) // 2
        if lower_bound < mid_range.limit_denominator(mid_denominator) < upper_bound:
            max_denominator_b = mid_denominator
        else:
            max_denominator_a = mid_denominator + 1

    c = max_denominator_a

    max_j = 10**100
    min_j = 1
    while min_j < max_j:
        mid_j = (min_j + max_j) // 2
        if Fraction(mid_j, c) > lower_bound:
            max_j = mid_j
        else:
            min_j = mid_j + 1
    return '{} {}'.format(c, min_j)


def solve_single_case(test_case):
    n = int(input())
    l = []
    for i in range(n):
        c_i, j_i = [int(x) for x in input().split()]
        l.append((c_i, j_i))

    solution = find_solution(n, l)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

",,1885,66,220,Python,0000000000051679,0000000000149e29,0000000000146184,bigOnion,2019
11913,0000000000147a59.PYTHON3,"import time
import inspect
from sys import exit
from sys import stderr


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoNoLog() as io:

    def solve_single_case(test_case):
        # stderr.write('starting case {}\n'.format(test_case))
        # stderr.flush()
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 0', inspect.getframeinfo(inspect.currentframe()).lineno)
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        curr_day = int(line)
        if curr_day != 100 or curr_day == -1:
            exit(0)
        io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,3262,94,240,Python,0000000000051679,0000000000147a59,00000000001461c8,bigOnion,2019
11914,000000000014743c.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoNoLog() as io:

    def solve_single_case(test_case):
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 0', inspect.getframeinfo(inspect.currentframe()).lineno)
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        curr_day = int(line)
        if curr_day != 100 or curr_day == -1:
            exit(0)
        io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,3151,91,230,Python,0000000000051679,000000000014743c,00000000001461c8,bigOnion,2019
11915,000000000014710e.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 0', inspect.getframeinfo(inspect.currentframe()).lineno)
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        curr_day = int(line)
        if curr_day != 100 or curr_day == -1:
            exit(0)
        io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,3153,91,230,Python,0000000000051679,000000000014710e,00000000001461c8,bigOnion,2019
11916,00000000001470ee.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 0', inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        curr_day = int(line)
        if curr_day != 100 or curr_day == -1:
            exit(0)
        io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,3069,90,227,Python,0000000000051679,00000000001470ee,00000000001461c8,bigOnion,2019
11917,0000000000146e75.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):
        for i in range(1, 20):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('{} 100'.format(i), inspect.getframeinfo(inspect.currentframe()).lineno)
        for i in range(20,100):
            line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            curr_day = int(line)
            if curr_day != i or curr_day == -1:
                exit(0)
            io.writeline('20 100', inspect.getframeinfo(inspect.currentframe()).lineno)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,2811,84,209,Python,0000000000051679,0000000000146e75,00000000001461c8,bigOnion,2019
66776,0000000000130330.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 52
        res = res % (2 ** 52)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 27)
        r3 = (res - (r4*2**13) - (r5*2**10)) >> 18

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3298,100,278,Python,51706,0000000000130330,0000000000122837,bigOnion,2019
66777,000000000012fee2.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 52
        res = res % (2 ** 52)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 27)
        r3 = (res - (r4*2**13) >> 18)

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3285,100,276,Python,51706,000000000012fee2,0000000000122837,bigOnion,2019
66778,000000000012ff13.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 52
        res = res % (2 ** 52)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 27)
        r3 = (res - (r4*2**5) >> 18)

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3284,100,276,Python,51706,000000000012ff13,0000000000122837,bigOnion,2019
66779,000000000012fba8.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 52
        res = res % (2 ** 52)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 27)
        r3 = (res >> 18) - (r4//(2**5))

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3287,100,276,Python,51706,000000000012fba8,0000000000122837,bigOnion,2019
66780,000000000012f073.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 52
        res = res % (2 ** 52)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 27)
        r3 = res >> 18

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3270,100,274,Python,51706,000000000012f073,0000000000122837,bigOnion,2019
66781,000000000012e637.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 53
        res = res % (2 ** 53)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 26)
        r3 = res >> 18

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3270,100,274,Python,51706,000000000012e637,0000000000122837,bigOnion,2019
66782,000000000012e616.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('210', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 52
        res = res % (2 ** 52)
        r5 = res >> 42
        res = res % (2 ** 42)
        r6 = res >> 35

        io.writeline('54', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 54
        res = res % (2 ** 54)
        r2 = res >> 27
        res = res % (2 ** 26)
        r3 = res >> 18

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3270,100,274,Python,51706,000000000012e616,0000000000122837,bigOnion,2019
66783,000000000012dbf8.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        io.writeline('189', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r4 = res >> 47
        res = res % (2 ** 47)
        r5 = res >> 37
        res = res % (2 ** 37)
        r6 = res >> 31

        io.writeline('50', inspect.getframeinfo(inspect.currentframe()).lineno)
        res = int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno))
        r1 = res >> 50
        res = res % (2 ** 50)
        r2 = res >> 25
        res = res % (2 ** 25)
        r3 = res >> 16

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3270,100,274,Python,51706,000000000012dbf8,0000000000122837,bigOnion,2019
66784,000000000012cb57.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def count_ppl(x, y, l):
    cnt = 0
    for x_ppl, y_ppl, d_ppl in l:
        if d_ppl == 's' and y_ppl > y:
            cnt += 1
        if d_ppl == 'n' and y_ppl < y:
            cnt += 1
        if d_ppl == 'e' and x_ppl < x:
            cnt += 1
        if d_ppl == 'w' and x_ppl > x:
            cnt += 1
    return cnt


def solve_single_case(test_case):
    P, Q = [int(x) for x in input().split()]
    l = []
    for _ in range(P):
        x, y, d = input().lower().split()
        x, y = int(x), int(y)
        l.append((x,y,d))

    best_cnt = -1
    for x in range(Q+1):
        for y in range(Q+1):
            cnt = count_ppl(x,y,l)
            if cnt > best_cnt:
                best_cnt = cnt
                best_x = x
                best_y = y

    solution = '{} {}'.format(best_x, best_y)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)




",,1117,49,149,Python,51706,000000000012cb57,000000000012295c,bigOnion,2019
66785,000000000012b755.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    C = [int(x) for x in input().split()]
    D = [int(x) for x in input().split()]

    cnt = 0
    for r in range(N):
        for l in range(r+1):
            if abs(max(C[l:r+1]) - max(D[l:r+1])) <= K:
                cnt += 1

    solution = str(cnt)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)




",,642,29,77,Python,51706,000000000012b755,0000000000122838,bigOnion,2019
66786,000000000012b76f.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    C = [int(x) for x in input().split()]
    D = [int(x) for x in input().split()]

    cnt = 0
    for r in range(N):
        for l in range(r+1):
            if abs(max(C[l:r+1]) - max(D[l:r+1])) <= k:
                cnt += 1

    solution = str(cnt)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)




",,642,29,77,Python,51706,000000000012b76f,0000000000122838,bigOnion,2019
66787,0000000000129eea.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        found = False
        for r1 in range(101):
            for r2 in range(101):
                for r3 in range(101):
                    if 24*r2-2*r3 == 30*day_res[2]-28*day_res[1]-day_res[6] and 2*r1+r2 == day_res[2]-day_res[1] and 4*r1+r3 == day_res[3]-day_res[2]:
                        best_r1 = r1
                        best_r2 = r2
                        best_r3 = r3
                        found = True
                        break
                if found:
                    break
            if found:
                break
        r1=  best_r1
        r2 = best_r2
        r3 = best_r3
        r4 = day_res[4] - day_res[3] - 8*r1 - 2*r2
        r5 = day_res[5] - day_res[4] - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 -r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3683,110,298,Python,51706,0000000000129eea,0000000000122837,bigOnion,2019
66788,0000000000129b8e.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))


        for r1 in range(101):
            for r2 in range(101):
                for r3 in range(101):
                    if 24*r2-2*r3 == 30*day_res[2]-28*day_res[1]-day_res[6] and 2*r1+r2 == day_res[2]-day_res[1] and 4*r1+r3 == day_res[3]-day_res[2]:
                        best_r1 = r1
                        best_r2 = r2
                        best_r3 = r3
        r1=  best_r1
        r2 = best_r2
        r3 = best_r3
        r4 = day_res[4] - day_res[3] - 8*r1 - 2*r2
        r5 = day_res[5] - day_res[4] - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 -r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3499,104,285,Python,51706,0000000000129b8e,0000000000122837,bigOnion,2019
66789,000000000012999d.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))


        for r1 in range(101):
            for r2 in range(101):
                for r3 in range(101):
                    if 24*r2-2*r3 == 30*day_res[2]-28*day_res[1]-day_res[6] and 2*r1+r2 == day_res[2]-day_res[1] and 4*r1+r3 == day_res[3]-day_res[2]:
                        best_r1 = r1
                        best_r2 = r2
                        best_r3 = r3
        r1=  best_r1
        r2 = best_r2
        r3 = best_r3
        r4 = day_res[4] - day_res[3] - 8*r1
        r5 = day_res[5] - day_res[4] - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 -r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3492,104,283,Python,51706,000000000012999d,0000000000122837,bigOnion,2019
66790,0000000000127644.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3222,96,268,Python,51706,0000000000127644,0000000000122837,bigOnion,2019
66791,0000000000127357.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoNoLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        if result == -1:
            exit(0)
        assert result == 1


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3247,97,272,Python,51706,0000000000127357,0000000000122837,bigOnion,2019
66792,0000000000126c8c.PYTHON3,"import time
import inspect
# from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoNoLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        assert result == 1


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3204,95,268,Python,51706,0000000000126c8c,0000000000122837,bigOnion,2019
66793,0000000000126a05.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoNoLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        assert result == 1


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,3202,95,267,Python,51706,0000000000126a05,0000000000122837,bigOnion,2019
66794,00000000001268ce.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline('{} {} {} {} {} {}'.format(r1,r2,r3,r4,r5,r6), inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        assert result == 1
        #
        #
        #
        #
        # line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        # N, B, F = [int(x) for x in line.split()]
        # testers = [
        #     '0000000011111111',
        #     '0000111100001111',
        #     '0011001100110011',
        #     '0101010101010101'
        #     ]
        # answers = []
        # for query in testers:
        #     send = (query * ((N // 16) + 1))[:N]
        #     io.writeline(send, inspect.getframeinfo(inspect.currentframe()).lineno)
        #     answer = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        #     assert len(answer) == N-B
        #     answers.append(answer)
        #
        # unbroken_bits = [-1]
        # for i in range(N-B):
        #     identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
        #     starting_from = unbroken_bits[-1] + 1
        #     if starting_from % 16 <= identify:
        #         next_good_bit = (starting_from // 16) * 16 + identify
        #     else:
        #         next_good_bit = ((starting_from // 16) + 1) * 16 + identify
        #     unbroken_bits.append(next_good_bit)
        # unbroken_bits.remove(-1)
        # assert list(sorted(unbroken_bits)) == unbroken_bits
        # assert max(unbroken_bits) < N
        # broken = [x for x in range(N) if x not in unbroken_bits]
        # output = ' '.join(map(str, broken))
        # io.writeline(output, inspect.getframeinfo(inspect.currentframe()).lineno)
        # line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        # result = int(line)
        # assert result == 1

        ###############  until here


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,4906,135,442,Python,51706,00000000001268ce,0000000000122837,bigOnion,2019
66795,000000000012670d.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day+1), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline(f'{r1} {r2} {r3} {r4} {r5} {r6}', inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        assert result == 1
        #
        #
        #
        #
        # line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        # N, B, F = [int(x) for x in line.split()]
        # testers = [
        #     '0000000011111111',
        #     '0000111100001111',
        #     '0011001100110011',
        #     '0101010101010101'
        #     ]
        # answers = []
        # for query in testers:
        #     send = (query * ((N // 16) + 1))[:N]
        #     io.writeline(send, inspect.getframeinfo(inspect.currentframe()).lineno)
        #     answer = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        #     assert len(answer) == N-B
        #     answers.append(answer)
        #
        # unbroken_bits = [-1]
        # for i in range(N-B):
        #     identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
        #     starting_from = unbroken_bits[-1] + 1
        #     if starting_from % 16 <= identify:
        #         next_good_bit = (starting_from // 16) * 16 + identify
        #     else:
        #         next_good_bit = ((starting_from // 16) + 1) * 16 + identify
        #     unbroken_bits.append(next_good_bit)
        # unbroken_bits.remove(-1)
        # assert list(sorted(unbroken_bits)) == unbroken_bits
        # assert max(unbroken_bits) < N
        # broken = [x for x in range(N) if x not in unbroken_bits]
        # output = ' '.join(map(str, broken))
        # io.writeline(output, inspect.getframeinfo(inspect.currentframe()).lineno)
        # line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        # result = int(line)
        # assert result == 1

        ###############  until here


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)

# cd ""C:\Users\hai\Dropbox\challenges\gcj\2019\round1b\B - Draupnir""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",,4893,135,442,Python,51706,000000000012670d,0000000000122837,bigOnion,2019
66796,000000000012486c.PYTHON3,"import time
import inspect
from sys import exit


# TODO: writing to files might be allowed on google's machines. If so, then unify IONoLog into IOWithLog, and use only the super class


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s, flush=True)


class IoWithLog(IoNoLog):
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        super().change_test_case(test_case)
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line = super().readline(line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        super().writeline(s, line_number)
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()


with IoWithLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        day_res = [None]
        for day in range(6):
            io.writeline(str(day), inspect.getframeinfo(inspect.currentframe()).lineno)
            day_res.append(int(io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)))

        r1 = (day_res[5] - day_res[4]) // 16
        r2 = (day_res[2] - 4*r1) - (day_res[1] - 2*r1)
        r3 = (day_res[3] - day_res[2]) - 4*r1
        r4 = (day_res[4] - day_res[3]) - 8*r1 - 2*r2
        r5 = (day_res[5] - day_res[4]) - 16*r1
        r6 = day_res[1] - 2*r1 - r2 - r3 - r4 - r5

        io.writeline(f'{r1},{r2},{r3},{r4},{r5},{r6}', inspect.getframeinfo(inspect.currentframe()).lineno)

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        assert result == 1
        #
        #
        #
        #
        # line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        # N, B, F = [int(x) for x in line.split()]
        # testers = [
        #     '0000000011111111',
        #     '0000111100001111',
        #     '0011001100110011',
        #     '0101010101010101'
        #     ]
        # answers = []
        # for query in testers:
        #     send = (query * ((N // 16) + 1))[:N]
        #     io.writeline(send, inspect.getframeinfo(inspect.currentframe()).lineno)
        #     answer = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        #     assert len(answer) == N-B
        #     answers.append(answer)
        #
        # unbroken_bits = [-1]
        # for i in range(N-B):
        #     identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
        #     starting_from = unbroken_bits[-1] + 1
        #     if starting_from % 16 <= identify:
        #         next_good_bit = (starting_from // 16) * 16 + identify
        #     else:
        #         next_good_bit = ((starting_from // 16) + 1) * 16 + identify
        #     unbroken_bits.append(next_good_bit)
        # unbroken_bits.remove(-1)
        # assert list(sorted(unbroken_bits)) == unbroken_bits
        # assert max(unbroken_bits) < N
        # broken = [x for x in range(N) if x not in unbroken_bits]
        # output = ' '.join(map(str, broken))
        # io.writeline(output, inspect.getframeinfo(inspect.currentframe()).lineno)
        # line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        # result = int(line)
        # assert result == 1

        ###############  until here


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t, w = [int(x) for x in line.split()]
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,4743,132,423,Python,51706,000000000012486c,0000000000122837,bigOnion,2019
138901,00000000000ee65f.PYTHON3,"import time
import inspect


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self, line_number=0):
        return input().replace('\n', '')

    def writeline(self, s, line_number=0):
        if s[-1] == '\n':
            s = s[:-1]
        print(s)


class IoWithLog:
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.strftime('%H:%M:%S')))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        self.file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
        self.file.flush()

    def readline(self, line_number=0):
        line_number = ('0000' + str(line_number))[-4:]
        self.file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
        self.file.flush()
        line = input().replace('\n', '')
        self.file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
        self.file.flush()
        return line

    def writeline(self, s, line_number=0):
        line_number = ('0000' + str(line_number))[-4:]
        if s[-1] == '\n':
            s = s[:-1]
        self.file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
        self.file.flush()
        print(s)


with IoNoLog() as io:

    def solve_single_case(test_case):

        ###############  change this method here

        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        N, B, F = [int(x) for x in line.split()]
        testers = [
            '0000000011111111',
            '0000111100001111',
            '0011001100110011',
            '0101010101010101'
            ]
        answers = []
        for query in testers:
            send = (query * ((N // 16) + 1))[:N]
            io.writeline(send, inspect.getframeinfo(inspect.currentframe()).lineno)
            answer = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
            assert len(answer) == N-B
            answers.append(answer)

        unbroken_bits = [-1]
        for i in range(N-B):
            identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
            starting_from = unbroken_bits[-1] + 1
            if starting_from % 16 <= identify:
                next_good_bit = (starting_from // 16) * 16 + identify
            else:
                next_good_bit = ((starting_from // 16) + 1) * 16 + identify
            unbroken_bits.append(next_good_bit)
        unbroken_bits.remove(-1)
        assert list(sorted(unbroken_bits)) == unbroken_bits
        assert max(unbroken_bits) < N
        broken = [x for x in range(N) if x not in unbroken_bits]
        output = ' '.join(map(str, broken))
        io.writeline(output, inspect.getframeinfo(inspect.currentframe()).lineno)
        line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
        result = int(line)
        assert result == 1

        ###############  until here


    line = io.readline(inspect.getframeinfo(inspect.currentframe()).lineno)
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,3617,108,283,Python,51705,00000000000ee65f,00000000000881de,bigOnion,2019
138902,00000000000ecc01.PYTHON3,"import time


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self):
        return input().replace('\n', '')

    def writeline(self, s):
        if s[-1] == '\n':
            s = s[:-1]
        print(s)


class IoWithLog:
    def __enter__(self):
        self.filename = 'gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.ctime()))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.ctime()))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        self.file.write('\n{}: starting test case {}\n'.format(time.ctime(), test_case))
        self.file.flush()

    def readline(self):
        self.file.write('{}: reading input line\n'.format(time.ctime()))
        self.file.flush()
        line = input().replace('\n', '')
        self.file.write('{}: received input: {}\n'.format(time.ctime(), line))
        self.file.flush()
        return line

    def writeline(self, s):
        if s[-1] == '\n':
            s = s[:-1]
        self.file.write('{}: writing output: {}\n'.format(time.ctime(), s))
        self.file.flush()
        print(s)


with IoNoLog() as io:
    def solve_single_case(test_case):
        line = io.readline()
        N, B, F = [int(x) for x in line.split()]
        testers = [
            '0000000011111111',
            '0000111100001111',
            '0011001100110011',
            '0101010101010101'
            ]
        answers = []
        for query in testers:
            send = (query * ((N // 16) + 1))[:N]
            io.writeline(send)
            answer = io.readline()
            assert len(answer) == N-B
            answers.append(answer)

        unbroken_bits = [-1]
        for i in range(N-B):
            identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
            starting_from = unbroken_bits[-1] + 1
            if starting_from % 16 <= identify:
                next_good_bit = (starting_from // 16) * 16 + identify
            else:
                next_good_bit = ((starting_from // 16) + 1) * 16 + identify
            unbroken_bits.append(next_good_bit)
        unbroken_bits.remove(-1)
        assert list(sorted(unbroken_bits)) == unbroken_bits
        assert max(unbroken_bits) < N
        broken = [x for x in range(N) if x not in unbroken_bits]
        io.writeline(' '.join(map(str, broken)))
        line = io.readline()
        result = int(line)
        assert result == 1


    line = io.readline()
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,2914,98,255,Python,51705,00000000000ecc01,00000000000881de,bigOnion,2019
138903,00000000000ec6c6.PYTHON3,"import time


class IoNoLog:
    def __enter__(self):
        return self

    def __exit__(self, type_, value, traceback):
        pass

    def change_test_case(self, test_case):
        pass

    def readline(self):
        return input().replace('\n', '')

    def writeline(self, s):
        if s[-1] == '\n':
            s = s[:-1]
        print(s)


class IoWithLog:
    def __enter__(self):
        self.filename = r'c:\Users\hai\Desktop\gcj_log.txt'
        self.file = open(self.filename, 'w')
        self.file.write('{}: starting log\n'.format(time.ctime()))
        self.file.flush()
        return self

    def __exit__(self, type_, value, traceback):
        self.file.write('\n{}: ending log\n'.format(time.ctime()))
        self.file.flush()
        self.file.close()

    def change_test_case(self, test_case):
        self.file.write('\n{}: starting test case {}\n'.format(time.ctime(), test_case))
        self.file.flush()

    def readline(self):
        self.file.write('{}: reading input line\n'.format(time.ctime()))
        self.file.flush()
        line = input().replace('\n', '')
        self.file.write('{}: received input: {}\n'.format(time.ctime(), line))
        self.file.flush()
        return line

    def writeline(self, s):
        if s[-1] == '\n':
            s = s[:-1]
        self.file.write('{}: writing output: {}\n'.format(time.ctime(), s))
        self.file.flush()
        print(s)


with IoNoLog() as io:
    def solve_single_case(test_case):
        line = io.readline()
        N, B, F = [int(x) for x in line.split()]
        testers = [
            '0000000011111111',
            '0000111100001111',
            '0011001100110011',
            '0101010101010101'
            ]
        answers = []
        for query in testers:
            send = (query * ((N // 16) + 1))[:N]
            io.writeline(send)
            answer = io.readline()
            assert len(answer) == N-B
            answers.append(answer)

        unbroken_bits = [-1]
        for i in range(N-B):
            identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
            starting_from = unbroken_bits[-1] + 1
            if starting_from % 16 <= identify:
                next_good_bit = (starting_from // 16) * 16 + identify
            else:
                next_good_bit = ((starting_from // 16) + 1) * 16 + identify
            unbroken_bits.append(next_good_bit)
        unbroken_bits.remove(-1)
        assert list(sorted(unbroken_bits)) == unbroken_bits
        assert max(unbroken_bits) < N
        broken = [x for x in range(N) if x not in unbroken_bits]
        io.writeline(' '.join(map(str, broken)))
        line = io.readline()
        result = int(line)
        assert result == 1


    line = io.readline()
    t = int(line)
    for test_case_index in range(1, t+1):
        io.change_test_case(test_case_index)
        solve_single_case(test_case_index)
",,2936,98,255,Python,51705,00000000000ec6c6,00000000000881de,bigOnion,2019
138904,00000000000dd252.PYTHON3,"# import sys
# if 'bigonion_local_testing' in sys.argv:
#     sys.stderr.write('    using a file as standard input\n')
#     sys.stdin = open('sample.in', 'r')

import sys


sys.stderr.write('I am here')


def solve_single_case(test_case):
    line = input()
    sys.stderr.write('read line: ' + line)
    N, B, F = [int(x) for x in line]
    testers = [
        '0000000011111111',
        '0000111100001111',
        '0011001100110011',
        '0101010101010101'
        ]
    answers = []
    for query in testers:
        send = (query * ((N // 16) + 1))[:N]
        print(send)
        line = input().replace('\n', '')
        sys.stderr.write('read line: ' + line)
        answer = line
        assert len(answer) == N-B
        answers.append(answer)

    unbroken_bits = [-1]
    for i in range(N-B):
        identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
        starting_from = unbroken_bits[-1] + 1
        if starting_from % 16 <= identify:
            next_good_bit = (starting_from // 16) * 16 + identify
        else:
            next_good_bit = ((starting_from // 16) + 1) * 16 + identify
        unbroken_bits.append(next_good_bit)
    unbroken_bits.remove(-1)
    assert list(sorted(unbroken_bits)) == unbroken_bits
    assert max(unbroken_bits) < N
    broken = [x for x in range(N) if x not in unbroken_bits]
    print(' '.join(map(str, broken)))
    line = input().replace('\n', '')
    sys.stderr.write('read line: ' + line)
    result = int(line)
    assert result == 1
    # solution = ''
    # print('Case #{}: {}'.format(test_case, solution))


line = input().replace('\n', '')
sys.stderr.write('read line: ' + line)
t = int(line)
for test_case_index in range(1, t+1):
    solve_single_case(test_case_index)
",,1769,59,204,Python,51705,00000000000dd252,00000000000881de,bigOnion,2019
138905,00000000000dbb42.PYTHON3,"# import sys
# if 'bigonion_local_testing' in sys.argv:
#     sys.stderr.write('    using a file as standard input\n')
#     sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    N, B, F = [int(x) for x in input()]
    testers = [
        '0000000011111111',
        '0000111100001111',
        '0011001100110011',
        '0101010101010101'
        ]
    answers = []
    for query in testers:
        send = (query * ((N // 16) + 1))[:N]
        print(send)
        answer = input().replace('\n', '')
        assert len(answer) == N-B
        answers.append(answer)

    unbroken_bits = [-1]
    for i in range(N-B):
        identify = int(answers[0][i] + answers[1][i] + answers[2][i] + answers[3][i], 2)
        starting_from = unbroken_bits[-1] + 1
        if starting_from % 16 <= identify:
            next_good_bit = (starting_from // 16) * 16 + identify
        else:
            next_good_bit = ((starting_from // 16) + 1) * 16 + identify
        unbroken_bits.append(next_good_bit)
    unbroken_bits.remove(-1)
    assert list(sorted(unbroken_bits)) == unbroken_bits
    assert max(unbroken_bits) < N
    broken = [x for x in range(N) if x not in unbroken_bits]
    print(' '.join(map(str, broken)))
    result = int(input())
    assert result == 1
    # solution = ''
    # print('Case #{}: {}'.format(test_case, solution))


t = int(input())
for test_case_index in range(1, t+1):
    solve_single_case(test_case_index)
",,1453,46,165,Python,51705,00000000000dbb42,00000000000881de,bigOnion,2019
138906,00000000000d84ff.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def gcd(a, b):
    if a == 1 or b == 1:
        return 1
    while a != 0 and b != 0:
        a, b = b % a, a
    return b


def solve_single_case(test_case):
    N, L = [int(x) for x in input().split()]
    ciphertext = [int(x) for x in input().split()]
    assert len(ciphertext) == L
    i = 0
    while ciphertext[i] == ciphertext[i+1]:
        i += 1
    prime_text = [None] * (L+1)
    prime_text[i+1] = gcd(ciphertext[i], ciphertext[i+1])
    for j in range(i+2, L+1):
        prime_text[j] = ciphertext[j-1] // prime_text[j-1]
    for j in range(i, -1, -1):
        prime_text[j] = ciphertext[j] // prime_text[j+1]
    assert None not in prime_text
    st = set(prime_text)
    assert len(st) == 26
    dictt = {}
    for prime, char in zip(sorted(st), 'abcdefghijklmnopqrstuvwxyz'.upper()):
        dictt[prime] = char
    plaintext = ''.join(dictt[prime] for prime in prime_text)
    print('Case #{}: {}'.format(test_case, plaintext))


t = int(input())
for test_case_index in range(1, t+1):
    solve_single_case(test_case_index)
",,1195,41,152,Python,51705,00000000000d84ff,000000000008830b,bigOnion,2019
138907,00000000000caa6f.PYTHON3,"import sys
if 'bigonion_local_testing' in sys.argv:
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case():
    N = int(input())
    P = input().replace('\n', '')
    assert len(P) == 2*N-2
    assert P.count('S') + P.count('E') == len(P)
    P2 = ''.join([chr(ord('S') + ord('E') - ord(c)) for c in P])
    return P2


t = int(input())
for testcase in range(1, t+1):
    s = solve_single_case()
    print('Case #{}: {}'.format(testcase, s))


",,515,22,64,Python,51705,00000000000caa6f,00000000000881da,bigOnion,2019
138908,00000000000c907e.PYTHON3,"t = int(input())
for test_case in range(1, t+1):
    N = int(input())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    while l2[0] == '0':
        l2 = l2[1:]
    print('Case #' + str(test_case) + ': ' + ''.join(l1) + ' ' + ''.join(l2))

",,389,18,54,Python,51705,00000000000c907e,0000000000088231,bigOnion,2019
138909,00000000000c9003.PYTHON3,"t = int(input())
for test_case in range(1, t+1):
    N = int(input())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    while l2[0] == '0':
        l2 = l2[1:]
    print('Case ' + str(test_case) + ': ' + ''.join(l1) + ' ' + ''.join(l2))

",,388,18,54,Python,51705,00000000000c9003,0000000000088231,bigOnion,2019
138910,00000000000c8e18.PYTHON3,"t = int(input())
for test_case in range(1, t+1):
    N = int(input())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    while l2[0] == '0':
        l2 = l2[1:]
    print('Case ' + str(test_case) + ': ' + str(int(''.join(l1))) + ' ' + str(int(''.join(l2))))

",,408,18,54,Python,51705,00000000000c8e18,0000000000088231,bigOnion,2019
138911,00000000000c8afd.PYTHON3,"t = int(input())
for test_case in range(1, t+1):
    N = int(input())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    print('Case ' + str(test_case) + ': ' + str(int(''.join(l1))) + ' ' + str(int(''.join(l2))))

",,364,16,47,Python,51705,00000000000c8afd,0000000000088231,bigOnion,2019
138912,00000000000c8963.PYTHON3,"from sys import stdin

t = int(stdin.readline())
for test_case in range(1, t+1):
    N = int(stdin.readline())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    print('Case ' + str(test_case) + ': ' + str(int(''.join(l1))) + ' ' + str(int(''.join(l2))))

",,405,18,51,Python,51705,00000000000c8963,0000000000088231,bigOnion,2019
138913,00000000000c8778.PYTHON3,"from sys import stdin

t = int(stdin.readline())
for test_case in range(1, t+1):
    N = int(stdin.readline())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    print('Case ' + str(test_case) + ': ' + str(int(''.join(l1))) + ' ' + str(int(''.join(l2))) + '\n')

",,412,18,53,Python,51705,00000000000c8778,0000000000088231,bigOnion,2019
138914,00000000000c7baf.PYTHON3,"###############################################################################
#      Coded by Hai Brenner (Israel) for the Google Code Jam Competition      #
###############################################################################

from functools import wraps, update_wrapper
import time
import os

###############################
#      useful decorators
###############################


class DecoratedFunctionInfo:

    def __init__(self):
        self.memoization_registry_reset_on_new_test_case = []
        self.function_counters = {}

    def reset_memoization_on_new_test_case(self):
        for cache_d in self.memoization_registry_reset_on_new_test_case:
            cache_d.clear()

    def get_function_counters(self):
        return self.function_counters


_GLOBAL_DECORATED_FUNCTIONS_INFO = DecoratedFunctionInfo()


# a decorator for memoizing function outputs
def memoize_it(reset_on_new_test_case=False):
    cache = {}
    if reset_on_new_test_case:
        _GLOBAL_DECORATED_FUNCTIONS_INFO.memoization_registry_reset_on_new_test_case.append(cache)

    def real_decorator(func):
        def wrapper(*args, **kwargs):
            if args not in cache:
                cache[args] = func(*args, **kwargs)
            return cache[args]
        return update_wrapper(wrapper, func)
    return real_decorator


# a decorator to add time benchmarking for a function
def time_it(inner_func):
    @wraps(inner_func)
    def wrapper(*args, **kwargs):
        print('--> Start function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
        start_time = time.time()
        res = inner_func(*args, **kwargs)
        end_time = time.time()
        print('--> End   function \'' + inner_func.__qualname__ + '\' : ', time.ctime())
        print('--> Elapsed time \'' + inner_func.__qualname__ + '\' : ', end_time-start_time)
        print()
        return res
    return wrapper


# a decorator for logging the function's inputs and outputs
def log_it(arguments=True, output=True):
    def decorating_function(user_function):
        def wrapper(*args, **kwargs):
            if arguments:
                print(time.ctime(),
                      ': function \'' + user_function.__qualname__ + '\' arguments args=', args, 'kwargs=', kwargs)
            result = user_function(*args, **kwargs)
            if output:
                print(time.ctime(), ': function \'' + user_function.__qualname__ + '\' outputs ', result)
            return result
        return update_wrapper(wrapper, user_function)
    return decorating_function

        
# a decorator for counting the number of calls to the wrapped function
def count_it(inner_func):
    func_counters = _GLOBAL_DECORATED_FUNCTIONS_INFO.function_counters
    assert type(func_counters) == dict
    assert inner_func.__qualname__ not in func_counters
    func_counters[inner_func.__qualname__] = 0

    @wraps(inner_func)
    def wrapper(*args, **kwargs):
        global func_counters
        func_counters[inner_func.__qualname__] += 1
        return inner_func(*args, **kwargs)
    return wrapper


# a decorator for pre-processing the function and automatically save the result
def pre_process_it(inner_func):
    import inspect
    import pickle
    a = inspect.signature(inner_func)
    if len(a.aparmeters):
        raise ValueError('A pre process function must not have arguments')

    # noinspection PyUnusedLocal
    @time_it
    @wraps(inner_func)
    def wrapper(*args, **kwargs):
        filename = 'pre-process_' + inner_func.__qualname__ + '.pickle'
        # noinspection PyArgumentList
        if filename not in os.listdir():
            print('--> Pre process started for function \'' + inner_func.__qualname__ + '\' ....')
            pre_process_data = inner_func()
            print('--> Pre process ended for function \'' + inner_func.__qualname__ + '\'')
            print('--> Pickling started for function \'' + inner_func.__qualname__ + '\' ....')
            with open(filename, 'wb') as f_pp:
                pickle.dump(pre_process_data, f_pp, pickle.HIGHEST_PROTOCOL)
            print('--> Pickling ended for function \'' + inner_func.__qualname__ + '\'')
        print('--> Unpickling pre-processed data of function \'' + inner_func.__qualname__ + '\' ...')
        with open(filename, 'rb') as f_pp:
            data = pickle.load(f_pp)
        print('--> Unpickling ended')
        print()
        return data

    return wrapper
 

###########################################
# automatic runner
###########################################

# a class to wrap automatically the IO files in one class
# noinspection PyPep8Naming
class GCJIOWrapper:

    def __init__(self, input_filename, parsed_filename, output_filename):
        self.__input_filename = input_filename
        self.__parsed_filename = parsed_filename
        self.__output_filename = output_filename
        self.__index_test_case = 0
        self.__input_file = None
        self.__parsed_file = None
        self.__output_file = None

    def __enter__(self):
        # open the IO files
        self.__input_file = open(self.__input_filename, 'r')
        self.__parsed_file = open(self.__parsed_filename, 'w')
        self.__output_file = open(self.__output_filename, 'w')

    # noinspection PyUnusedLocal
    def __exit__(self, type_e, value, tb):
        # close the IO files
        self.__input_file.close()
        self.__parsed_file.close()
        self.__output_file.close()

    def readline(self):
        # read one line from the input. write it as is to the parsed file
        l = self.__input_file.readline()
        self.__parsed_file.write(l)
        return l
    
    def new_test_case(self):
        # mark a new test case to the parsed file
        self.__index_test_case += 1
        self.__parsed_file.write('\n## _BigOnion Test case: ' + str(self.__index_test_case) + ' ##\n')
    
    def write(self, s):
        # write to the output file
        self.__output_file.write(s)
    
    def get_test_case(self):
        # return the index of the current test case
        return self.__index_test_case
        

# This is the automatic runner    
@time_it
def main_run():
        
    # find the most current input file (.in) which is in the working directory 
    print('Directory : ', os.getcwd())
    # noinspection PyArgumentList
    file_names = [x for x in os.listdir()]
    l1 = [(os.stat(x).st_mtime, x) for x in file_names if x.endswith('.in')]
    if not l1:
        raise ValueError('No input file found')
    chosen_prefix = sorted(l1)[-1][1][:-3]
    input_filename = chosen_prefix + '.in'
    print('Chosen Input : ', input_filename)
    
    # filename of the file into which to parse the input file
    parsed_filename = chosen_prefix + '.parsed.txt'

    # filename of the output file. It has the same prefix, 
    # and it doesn't tread over the previous output file from previous attempts
    l2 = [x.split('.')[0] for x in file_names if x.endswith('.out') and x.startswith(chosen_prefix)]
    l2 = [int(x.split('-run')[-1]) for x in l2]
    output_file_index = ('000' + str(max([0] + l2) + 1))[-3:]
    output_filename = chosen_prefix + '-run' + output_file_index + '.out'
    print('Chosen Output : ', output_filename)
    print()
    
    io_wrapper = GCJIOWrapper(input_filename, parsed_filename, output_filename)
    with io_wrapper:
        solve_all_cases(io_wrapper)

    # print the chosen files once again for easy checking of correctness
    print()
    print('Conclusion :')
    print('Directory : ', os.getcwd())
    print('Chosen Input : ', input_filename)
    print('Chosen Output : ', output_filename)


# the automatic solver. Handles the test case mechanism
@time_it
def solve_all_cases(io_wrapper):
    # noinspection PyPep8Naming
    T = int(io_wrapper.readline())
    for test_case in range(1, T+1):
        io_wrapper.new_test_case()
        assert io_wrapper.get_test_case() == test_case
        _GLOBAL_DECORATED_FUNCTIONS_INFO.reset_memoization_on_new_test_case()
        solve_one_case(io_wrapper)


###########################################
# write code here
###########################################


def solve_one_case(io_wrapper):
    # fill details here
    N = int(io_wrapper.readline())
    s = str(N)
    l1 = []
    l2 = []
    for c in s:
        if c == '4':
            l1.append('2')
            l2.append('2')
        else:
            l1.append(c)
            l2.append('0')
    io_wrapper.write(f'Case {io_wrapper.get_test_case()}: {int("""".join(l1))} {int("""".join(l2))}\n')


main_run()
",,8562,246,806,Python,51705,00000000000c7baf,0000000000088231,bigOnion,2019
2615,00000000002a034c,"import sys

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    find_and_write_solution(test_case, N, K)


def find_and_write_solution(test_case, N, K):
    solution = find_solution(N, K)
    write_solution(solution, test_case, N, K)


def find_solution(N, K):
    if N == 2:
        solution = solve_n_is_2(K)
    elif N == 3:
        solution = solve_n_is_3(K)
    else:
        solution = solve_larger_n(N, K)
    return solution


def write_solution(solution, test_case, N, K):
    if solution is None:
        print('Case #{}: IMPOSSIBLE'.format(test_case))
    else:
        validate_latin_square(solution)
        diag = [solution[i][i] for i in range(N)]
        assert sum(diag) == K
        print('Case #{}: POSSIBLE'.format(test_case))
        print_matrix(solution)


def solve_n_is_2(K):
    if K == 2:
        return [[1, 2], [2, 1]]
    if K == 4:
        return [[2, 1], [1, 2]]
    return None


def solve_n_is_3(K):
    if K == 3:
        return [[1, 2, 3], [3, 1, 2], [2, 3, 1]]
    if K == 6:
        return [[2, 3, 1], [1, 2, 3], [3, 1, 2]]
    if K == 9:
        return [[3, 1, 2], [2, 3, 1], [1, 2, 3]]
    return None


def solve_larger_n(N, K):
    assert N >= 4

    if N == 4 and K == 10:
        return [[1, 4, 2, 3], [4, 1, 3, 2], [2, 3, 4, 1], [3, 2, 1, 4]]

    elif K % N == 0:
        mat = most_trivial_square(N)
        d = K // N
        if d != 1:
            swap_symbols(mat, 1, d)
        return mat

    elif K == N + 1 or K == N**2 - 1:
        return None

    elif K == N + 2 or K == N**2 - 2:
        mat = initial_matrix(N)
        if K != N + 2:
            swap_symbols(mat, 1, N)
            swap_symbols(mat, 2, N-1)
        return mat

    elif N + 3 <= K <= N**2 - 3:
        mat = most_trivial_square(N)
        mat[-1], mat[-2] = mat[-2], mat[-1]
        for i in range(1, N+1):
            for j in range(1, N+1):
                for l in range(1, N+1):
                    if i != j and i != l and j != l and i * (N-2) + j + l == K:
                        if mat[0][0] != i:
                            swap_symbols(mat, mat[0][0], i)
                        if mat[N-2][N-2] != j:
                            swap_symbols(mat, mat[N-2][N-2], j)
                        if mat[N-1][N-1] != l:
                            swap_symbols(mat, mat[N-1][N-1], l)
                        return mat

    raise ValueError()


def swap_symbols(square, s1, s2):
    N = len(square)
    for r in range(N):
        for c in range(N):
            if square[r][c] == s1:
                square[r][c] = s2
            elif square[r][c] == s2:
                square[r][c] = s1


def most_trivial_square(N):
    mat = [list(range(1, N + 1))]
    for _ in range(N - 1):
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    return mat


def initial_matrix(N):
    if N % 2 == 0:
        mat = initial_matrix_even_n(N)
    else:
        mat = initial_matrix_odd_n(N)
    return mat


def initial_matrix_even_n(N):
    row1 = list(range(1, N + 1))
    row2 = []
    for i in range(N):
        if i % 2 == 0:
            row2.append(row1[i + 1])
        else:
            row2.append(row1[i - 1])
    mat = [row1, row2]
    while len(mat) < N:
        prev_row1 = mat[-2]
        prev_row2 = mat[-1]
        mat.append(prev_row1[-2:] + prev_row1[:-2])
        mat.append(prev_row2[-2:] + prev_row2[:-2])
    mat[-1], mat[-2] = mat[-2], mat[-1]
    return mat


def initial_matrix_odd_n(N):
    mat = [list(range(1, N+1))]
    while len(mat) < N - 3:
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    mat.append([None] * N)
    mat.append([None] * N)
    mat.append([None] * N)
    mat[N-3][N-3] = 1
    mat[N-2][N-1] = 1
    mat[N-1][N-2] = 1
    mat[N-3][0] = 2
    mat[N-2][N-2] = 2
    mat[N-1][N-1] = 2
    for val in range(3, N+1):
        for row_index in [N-3, N-2, N-1]:
            row = mat[row_index]
            col_index = row.index(1)
            found = False
            while not found:
                if col_index == N:
                    col_index = 0
                    continue
                if row[col_index] is not None:
                    col_index += 1
                    continue
                column = [mat[r][col_index] for r in range(N)]
                if val in column:
                    col_index += 1
                    continue
                found = True
            row[col_index] = val

    return mat


def validate_latin_square(mat):
    N = len(mat)
    s = set(range(1, N+1))
    for row in mat:
        assert set(row) == s
    for c in range(N):
        column = [mat[r][c] for r in range(N)]
        assert set(column) == s


def print_matrix(mat):
    for row in mat:
        print(' '.join(str(x) for x in row))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

# for N in range(48, 51):
#     for K in range(N, N**2 + 1):
#         find_and_write_solution(-1, N, K)
",00000000002a034c.PYTHON3,5209,204,649,Python,000000000019fd27,00000000002a034c,0000000000209aa0,bigOnion,2020
2616,000000000029fd5f,"import sys
from functools import lru_cache

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from time import sleep


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    find_and_write_solution(test_case, N, K)


def find_and_write_solution(test_case, N, K):
    solution = find_solution(N, K)
    write_solution(solution, test_case, N, K)


def find_solution(N, K):
    if N == 2:
        solution = solve_n_is_2(K)
    elif N == 3:
        solution = solve_n_is_3(K)
    else:
        solution = solve_larger_n(N, K)
    return solution


def write_solution(solution, test_case, N, K):
    if solution is None:
        print('Case #{}: IMPOSSIBLE'.format(test_case))
    else:
        validate_latin_square(solution)
        diag = [solution[i][i] for i in range(N)]
        if sum(diag) != K:
            sleep(200000)
        print('Case #{}: POSSIBLE'.format(test_case))
        print_matrix(solution)


def solve_n_is_2(K):
    if K == 2:
        return [[1, 2], [2, 1]]
    if K == 4:
        return [[2, 1], [1, 2]]
    return None


def solve_n_is_3(K):
    if K == 3:
        return [[1, 2, 3], [3, 1, 2], [2, 3, 1]]
    if K == 6:
        return [[2, 3, 1], [1, 2, 3], [3, 1, 2]]
    if K == 9:
        return [[3, 1, 2], [2, 3, 1], [1, 2, 3]]
    return None


def solve_larger_n(N, K):
    if N < 4:
        sleep(20000)

    if N == 4 and K == 10:
        return [[1, 4, 2, 3], [4, 1, 3, 2], [2, 3, 4, 1], [3, 2, 1, 4]]

    elif K % N == 0:
        mat = most_trivial_square(N)
        d = K // N
        if d != 1:
            swap_symbols(mat, 1, d)
        return mat

    elif K == N + 1 or K == N**2 - 1:
        return None

    elif K == N + 2 or K == N**2 - 2:
        mat = initial_matrix(N)
        if K != N + 2:
            swap_symbols(mat, 1, N)
            swap_symbols(mat, 2, N-1)
        return mat

    elif N + 3 <= K <= N**2 - 3:
        mat = most_trivial_square(N)
        mat[-1], mat[-2] = mat[-2], mat[-1]
        for i in range(1, N+1):
            for j in range(1, N+1):
                for l in range(1, N+1):
                    if i != j and i != l and j != l and i * (N-2) + j + l == K:
                        if mat[0][0] != i:
                            swap_symbols(mat, mat[0][0], i)
                        if mat[N-2][N-2] != j:
                            swap_symbols(mat, mat[N-2][N-2], j)
                        if mat[N-1][N-1] != l:
                            swap_symbols(mat, mat[N-1][N-1], l)
                        return mat

    raise ValueError()


def swap_symbols(square, s1, s2):
    N = len(square)
    for r in range(N):
        for c in range(N):
            if square[r][c] == s1:
                square[r][c] = s2
            elif square[r][c] == s2:
                square[r][c] = s1


def most_trivial_square(N):
    mat = [list(range(1, N + 1))]
    for _ in range(N - 1):
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    return mat


@lru_cache
def initial_matrix(N):
    if N % 2 == 0:
        mat = initial_matrix_even_n(N)
    else:
        mat = initial_matrix_odd_n(N)
    return mat


@lru_cache
def initial_matrix_even_n(N):
    row1 = list(range(1, N + 1))
    row2 = []
    for i in range(N):
        if i % 2 == 0:
            row2.append(row1[i + 1])
        else:
            row2.append(row1[i - 1])
    mat = [row1, row2]
    while len(mat) < N:
        prev_row1 = mat[-2]
        prev_row2 = mat[-1]
        mat.append(prev_row1[-2:] + prev_row1[:-2])
        mat.append(prev_row2[-2:] + prev_row2[:-2])
    mat[-1], mat[-2] = mat[-2], mat[-1]
    return mat


@lru_cache
def initial_matrix_odd_n(N):
    mat = [list(range(1, N+1))]
    while len(mat) < N - 3:
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    mat.append([None] * N)
    mat.append([None] * N)
    mat.append([None] * N)
    mat[N-3][N-3] = 1
    mat[N-2][N-1] = 1
    mat[N-1][N-2] = 1
    mat[N-3][0] = 2
    mat[N-2][N-2] = 2
    mat[N-1][N-1] = 2
    for val in range(3, N+1):
        for row_index in [N-3, N-2, N-1]:
            row = mat[row_index]
            col_index = row.index(1)
            found = False
            while not found:
                if col_index == N:
                    col_index = 0
                    continue
                if row[col_index] is not None:
                    col_index += 1
                    continue
                column = [mat[r][col_index] for r in range(N)]
                if val in column:
                    col_index += 1
                    continue
                found = True
            row[col_index] = val

    return mat


def validate_latin_square(mat):
    N = len(mat)
    s = set(range(1, N+1))
    for row in mat:
        if set(row) != s:
            sleep(20000)
    for c in range(N):
        column = [mat[r][c] for r in range(N)]
        if set(column) != s:
            sleep(20000)


def print_matrix(mat):
    for row in mat:
        print(' '.join(str(x) for x in row))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

# for N in range(48, 51):
#     for K in range(N, N**2 + 1):
#         find_and_write_solution(-1, N, K)
",000000000029fd5f.PYTHON3,5383,215,664,Python,000000000019fd27,000000000029fd5f,0000000000209aa0,bigOnion,2020
2617,000000000029fc6a,"import sys
from functools import lru_cache

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from time import sleep


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    find_and_write_solution(test_case, N, K)


def find_and_write_solution(test_case, N, K):
    solution = find_solution(N, K)
    write_solution(solution, test_case, N, K)


def find_solution(N, K):
    if N == 2:
        solution = solve_n_is_2(K)
    elif N == 3:
        solution = solve_n_is_3(K)
    else:
        solution = solve_larger_n(N, K)
    return solution


def write_solution(solution, test_case, N, K):
    if solution is None:
        print('Case #{}: IMPOSSIBLE'.format(test_case))
    else:
        validate_latin_square(solution)
        diag = [solution[i][i] for i in range(N)]
        if sum(diag) != K:
            sleep(200000)
        print('Case #{}: POSSIBLE'.format(test_case))
        print_matrix(solution)


def solve_n_is_2(K):
    if K == 2:
        return [[1, 2], [2, 1]]
    if K == 4:
        return [[2, 1], [1, 2]]
    return None


def solve_n_is_3(K):
    if K == 3:
        return [[1, 2, 3], [3, 1, 2], [2, 3, 1]]
    if K == 6:
        return [[2, 3, 1], [1, 2, 3], [3, 1, 2]]
    if K == 9:
        return [[3, 1, 2], [2, 3, 1], [1, 2, 3]]
    return None


def solve_larger_n(N, K):
    if N < 4:
        sleep(20000)

    if N == 4 and K == 10:
        return [[1, 4, 2, 3], [4, 1, 3, 2], [2, 3, 4, 1], [3, 2, 1, 4]]

    elif K % N == 0:
        mat = most_trivial_square(N)
        d = K // N
        if d != 1:
            swap_symbols(mat, 1, d)
        return mat

    elif K == N + 1 or K == N**2 - 1:
        return None

    elif K == N + 2 or K == N**2 - 2:
        mat = initial_matrix(N)
        if K != N + 2:
            swap_symbols(mat, 1, N)
            swap_symbols(mat, 2, N-1)
        return mat

    elif N + 3 <= K <= N**2 - 3:
        mat = most_trivial_square(N)
        mat[-1], mat[-2] = mat[-2], mat[-1]
        for i in range(1, N+1):
            for j in range(1, N+1):
                for l in range(1, N+1):
                    if i != j and i != l and j != l and i * (N-2) + j + l == K:
                        if mat[0][0] != i:
                            swap_symbols(mat, mat[0][0], i)
                        if mat[N-2][N-2] != j:
                            swap_symbols(mat, mat[N-2][N-2], j)
                        if mat[N-1][N-1] != l:
                            swap_symbols(mat, mat[N-1][N-1], l)
                        return mat

    raise ValueError()


def swap_symbols(square, s1, s2):
    N = len(square)
    for r in range(N):
        for c in range(N):
            if square[r][c] == s1:
                square[r][c] = s2
            elif square[r][c] == s2:
                square[r][c] = s1


def most_trivial_square(N):
    mat = [list(range(1, N + 1))]
    for _ in range(N - 1):
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    return mat


@lru_cache
def initial_matrix(N):
    if N % 2 == 0:
        mat = initial_matrix_even_n(N)
    else:
        mat = initial_matrix_odd_n(N)
    return mat


@lru_cache
def initial_matrix_even_n(N):
    row1 = list(range(1, N + 1))
    row2 = []
    for i in range(N):
        if i % 2 == 0:
            row2.append(row1[i + 1])
        else:
            row2.append(row1[i - 1])
    mat = [row1, row2]
    while len(mat) < N:
        prev_row1 = mat[-2]
        prev_row2 = mat[-1]
        mat.append(prev_row1[-2:] + prev_row1[:-2])
        mat.append(prev_row2[-2:] + prev_row2[:-2])
    mat[-1], mat[-2] = mat[-2], mat[-1]
    return mat


@lru_cache
def initial_matrix_odd_n(N):
    mat = [list(range(1, N+1))]
    while len(mat) < N - 3:
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    mat.append([None] * N)
    mat.append([None] * N)
    mat.append([None] * N)
    mat[N-3][N-3] = 1
    mat[N-2][N-1] = 1
    mat[N-1][N-2] = 1
    mat[N-3][0] = 2
    mat[N-2][N-2] = 2
    mat[N-1][N-1] = 2
    for val in range(3, N+1):
        for row_index in [N-3, N-2, N-1]:
            row = mat[row_index]
            col_index = row.index(1)
            found = False
            while not found:
                if col_index == N:
                    col_index = 0
                    continue
                if row[col_index] is not None:
                    col_index += 1
                    continue
                column = [mat[r][col_index] for r in range(N)]
                if val in column:
                    col_index += 1
                    continue
                found = True
            row[col_index] = val

    return mat


def validate_latin_square(mat):
    N = len(mat)
    s = set(range(1, N+1))
    for row in mat:
        assert set(row) == s
    for c in range(N):
        column = [mat[r][c] for r in range(N)]
        assert set(column) == s


def print_matrix(mat):
    for row in mat:
        print(' '.join(str(x) for x in row))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

# for N in range(48, 51):
#     for K in range(N, N**2 + 1):
#         find_and_write_solution(-1, N, K)
",000000000029fc6a.PYTHON3,5339,213,662,Python,000000000019fd27,000000000029fc6a,0000000000209aa0,bigOnion,2020
2618,000000000029fae5,"import sys
from functools import lru_cache

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from time import sleep


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    find_and_write_solution(test_case, N, K)


def find_and_write_solution(test_case, N, K):
    solution = find_solution(N, K)
    write_solution(solution, test_case, N, K)


def find_solution(N, K):
    if N == 2:
        solution = solve_n_is_2(K)
    elif N == 3:
        solution = solve_n_is_3(K)
    else:
        solution = solve_larger_n(N, K)
    return solution


def write_solution(solution, test_case, N, K):
    if solution is None:
        print('Case #{}: IMPOSSIBLE'.format(test_case))
    else:
        validate_latin_square(solution)
        diag = [solution[i][i] for i in range(N)]
        if sum(diag) != K:
            sleep(200000)
        print('Case #{}: POSSIBLE'.format(test_case))
        print_matrix(solution)


def solve_n_is_2(K):
    if K == 2:
        return [[1, 2], [2, 1]]
    if K == 4:
        return [[2, 1], [1, 2]]
    return None


def solve_n_is_3(K):
    if K == 3:
        return [[1, 2, 3], [3, 1, 2], [2, 3, 1]]
    if K == 6:
        return [[2, 3, 1], [1, 2, 3], [3, 1, 2]]
    if K == 9:
        return [[3, 1, 2], [2, 3, 1], [1, 2, 3]]
    return None


def solve_larger_n(N, K):
    assert N >= 4

    if N == 4 and K == 10:
        return [[1, 4, 2, 3], [4, 1, 3, 2], [2, 3, 4, 1], [3, 2, 1, 4]]

    elif K % N == 0:
        mat = most_trivial_square(N)
        d = K // N
        if d != 1:
            swap_symbols(mat, 1, d)
        return mat

    elif K == N + 1 or K == N**2 - 1:
        return None

    elif K == N + 2 or K == N**2 - 2:
        mat = initial_matrix(N)
        if K != N + 2:
            swap_symbols(mat, 1, N)
            swap_symbols(mat, 2, N-1)
        return mat

    elif N + 3 <= K <= N**2 - 3:
        mat = most_trivial_square(N)
        mat[-1], mat[-2] = mat[-2], mat[-1]
        for i in range(1, N+1):
            for j in range(1, N+1):
                for l in range(1, N+1):
                    if i != j and i != l and j != l and i * (N-2) + j + l == K:
                        if mat[0][0] != i:
                            swap_symbols(mat, mat[0][0], i)
                        if mat[N-2][N-2] != j:
                            swap_symbols(mat, mat[N-2][N-2], j)
                        if mat[N-1][N-1] != l:
                            swap_symbols(mat, mat[N-1][N-1], l)
                        return mat

    raise ValueError()


def swap_symbols(square, s1, s2):
    N = len(square)
    for r in range(N):
        for c in range(N):
            if square[r][c] == s1:
                square[r][c] = s2
            elif square[r][c] == s2:
                square[r][c] = s1


def most_trivial_square(N):
    mat = [list(range(1, N + 1))]
    for _ in range(N - 1):
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    return mat


@lru_cache
def initial_matrix(N):
    if N % 2 == 0:
        mat = initial_matrix_even_n(N)
    else:
        mat = initial_matrix_odd_n(N)
    return mat


@lru_cache
def initial_matrix_even_n(N):
    row1 = list(range(1, N + 1))
    row2 = []
    for i in range(N):
        if i % 2 == 0:
            row2.append(row1[i + 1])
        else:
            row2.append(row1[i - 1])
    mat = [row1, row2]
    while len(mat) < N:
        prev_row1 = mat[-2]
        prev_row2 = mat[-1]
        mat.append(prev_row1[-2:] + prev_row1[:-2])
        mat.append(prev_row2[-2:] + prev_row2[:-2])
    mat[-1], mat[-2] = mat[-2], mat[-1]
    return mat


@lru_cache
def initial_matrix_odd_n(N):
    mat = [list(range(1, N+1))]
    while len(mat) < N - 3:
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    mat.append([None] * N)
    mat.append([None] * N)
    mat.append([None] * N)
    mat[N-3][N-3] = 1
    mat[N-2][N-1] = 1
    mat[N-1][N-2] = 1
    mat[N-3][0] = 2
    mat[N-2][N-2] = 2
    mat[N-1][N-1] = 2
    for val in range(3, N+1):
        for row_index in [N-3, N-2, N-1]:
            row = mat[row_index]
            col_index = row.index(1)
            found = False
            while not found:
                if col_index == N:
                    col_index = 0
                    continue
                if row[col_index] is not None:
                    col_index += 1
                    continue
                column = [mat[r][col_index] for r in range(N)]
                if val in column:
                    col_index += 1
                    continue
                found = True
            row[col_index] = val

    return mat


def validate_latin_square(mat):
    N = len(mat)
    s = set(range(1, N+1))
    for row in mat:
        assert set(row) == s
    for c in range(N):
        column = [mat[r][c] for r in range(N)]
        assert set(column) == s


def print_matrix(mat):
    for row in mat:
        print(' '.join(str(x) for x in row))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

# for N in range(48, 51):
#     for K in range(N, N**2 + 1):
#         find_and_write_solution(-1, N, K)
",000000000029fae5.PYTHON3,5322,212,661,Python,000000000019fd27,000000000029fae5,0000000000209aa0,bigOnion,2020
2619,000000000029f990,"import sys
from functools import lru_cache

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


SAVE_LOCATION_SYMBOL1 = '*'
SAVE_LOCATION_SYMBOL2 = '#'
SAVE_LOCATION_SYMBOL3 = '^'


def solve_single_case(test_case):
    N, K = [int(x) for x in input().split()]
    find_and_write_solution(test_case, N, K)


def find_and_write_solution(test_case, N, K):
    solution = find_solution(N, K)
    write_solution(solution, test_case, N, K)


def find_solution(N, K):
    if N == 2:
        solution = solve_n_is_2(K)
    elif N == 3:
        solution = solve_n_is_3(K)
    else:
        solution = solve_larger_n(N, K)
    return solution


def write_solution(solution, test_case, N, K):
    if solution is None:
        print('Case #{}: IMPOSSIBLE'.format(test_case))
    else:
        validate_latin_square(solution)
        diag = [solution[i][i] for i in range(N)]
        assert sum(diag) == K
        print('Case #{}: POSSIBLE'.format(test_case))
        print_matrix(solution)


def solve_n_is_2(K):
    if K == 2:
        return [[1, 2], [2, 1]]
    if K == 4:
        return [[2, 1], [1, 2]]
    return None


def solve_n_is_3(K):
    if K == 3:
        return [[1, 2, 3], [3, 1, 2], [2, 3, 1]]
    if K == 6:
        return [[2, 3, 1], [1, 2, 3], [3, 1, 2]]
    if K == 9:
        return [[3, 1, 2], [2, 3, 1], [1, 2, 3]]
    return None


def solve_larger_n(N, K):
    assert N >= 4

    if N == 4 and K == 10:
        return [[1, 4, 2, 3], [4, 1, 3, 2], [2, 3, 4, 1], [3, 2, 1, 4]]

    elif K % N == 0:
        mat = most_trivial_square(N)
        d = K // N
        if d != 1:
            swap_symbols(mat, 1, d)
        return mat

    elif K == N + 1 or K == N**2 - 1:
        return None

    elif K == N + 2 or K == N**2 - 2:
        mat = initial_matrix(N)
        if K != N + 2:
            swap_symbols(mat, 1, N)
            swap_symbols(mat, 2, N-1)
        return mat

    elif N + 3 <= K <= N**2 - 3:
        mat = most_trivial_square(N)
        mat[-1], mat[-2] = mat[-2], mat[-1]
        for i in range(1, N+1):
            for j in range(1, N+1):
                for l in range(1, N+1):
                    if i != j and i != l and j != l and i * (N-2) + j + l == K:
                        if mat[0][0] != i:
                            swap_symbols(mat, mat[0][0], i)
                        if mat[N-2][N-2] != j:
                            swap_symbols(mat, mat[N-2][N-2], j)
                        if mat[N-1][N-1] != l:
                            swap_symbols(mat, mat[N-1][N-1], l)
                        return mat

    raise ValueError()


def swap_symbols(square, s1, s2):
    N = len(square)
    for r in range(N):
        for c in range(N):
            if square[r][c] == s1:
                square[r][c] = s2
            elif square[r][c] == s2:
                square[r][c] = s1


def most_trivial_square(N):
    mat = [list(range(1, N + 1))]
    for _ in range(N - 1):
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    return mat


@lru_cache
def initial_matrix(N):
    if N % 2 == 0:
        mat = initial_matrix_even_n(N)
    else:
        mat = initial_matrix_odd_n(N)
    return mat


@lru_cache
def initial_matrix_even_n(N):
    row1 = list(range(1, N + 1))
    row2 = []
    for i in range(N):
        if i % 2 == 0:
            row2.append(row1[i + 1])
        else:
            row2.append(row1[i - 1])
    mat = [row1, row2]
    while len(mat) < N:
        prev_row1 = mat[-2]
        prev_row2 = mat[-1]
        mat.append(prev_row1[-2:] + prev_row1[:-2])
        mat.append(prev_row2[-2:] + prev_row2[:-2])
    mat[-1], mat[-2] = mat[-2], mat[-1]
    return mat


@lru_cache
def initial_matrix_odd_n(N):
    mat = [list(range(1, N+1))]
    while len(mat) < N - 3:
        prev_row = mat[-1]
        mat.append(prev_row[-1:] + prev_row[:-1])
    mat.append([None] * N)
    mat.append([None] * N)
    mat.append([None] * N)
    mat[N-3][N-3] = 1
    mat[N-2][N-1] = 1
    mat[N-1][N-2] = 1
    mat[N-3][0] = 2
    mat[N-2][N-2] = 2
    mat[N-1][N-1] = 2
    for val in range(3, N+1):
        for row_index in [N-3, N-2, N-1]:
            row = mat[row_index]
            col_index = row.index(1)
            found = False
            while not found:
                if col_index == N:
                    col_index = 0
                    continue
                if row[col_index] is not None:
                    col_index += 1
                    continue
                column = [mat[r][col_index] for r in range(N)]
                if val in column:
                    col_index += 1
                    continue
                found = True
            row[col_index] = val

    return mat


def validate_latin_square(mat):
    N = len(mat)
    s = set(range(1, N+1))
    for row in mat:
        assert set(row) == s
    for c in range(N):
        column = [mat[r][c] for r in range(N)]
        assert set(column) == s


def print_matrix(mat):
    for row in mat:
        print(' '.join(str(x) for x in row))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

# for N in range(48, 51):
#     for K in range(N, N**2 + 1):
#         find_and_write_solution(-1, N, K)
",000000000029f990.PYTHON3,5360,213,665,Python,000000000019fd27,000000000029f990,0000000000209aa0,bigOnion,2020
2621,0000000000284f7f,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')

from itertools import permutations

solutions = {}


def apply_permutation_on_symbols(square, perm):
    N = len(square)
    assert len(perm) == N
    assert min(perm) == 1
    assert max(perm) == N
    translate_symbols = {}
    for i in range(1, N+1):
        translate_symbols[i] = perm[i-1]

    square2 = [[None] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            symbol = square[r][c]
            square2[r][c] = translate_symbols[symbol]
    return square2


def register_solution(s):
    square = [[int(x) for x in row.strip().split()] for row in s.strip().split('\n')]
    N = len(square)
    symbols = list(range(1, N+1))
    for perm in permutations(symbols):
        square2 = apply_permutation_on_symbols(square, perm)
        diagonal = [square2[i][i] for i in range(N)]
        trace = sum(diagonal)
        solutions[(N, trace)] = square2


# ############ N = 2

register_solution('''
1 2
2 1
''')


# ############ N = 3

register_solution('''
1 2 3
3 1 2
2 3 1
''')

register_solution('''
3 1 2
1 2 3
2 3 1
''')


# ############ N = 4

register_solution('''
1 2 3 4
4 1 2 3
3 4 1 2
2 3 4 1
''')

register_solution('''
3 2 1 4
2 1 4 3
1 4 3 2
4 3 2 1
''')

register_solution('''
1 3 4 2
3 4 2 1
2 1 3 4
4 2 1 3
''')


# ############ N = 5

register_solution('''
1 2 3 4 5
5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
2 3 4 5 1
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2 3 4 5
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
3 4 5 1 2
2 3 4 5 1
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
1 5 2 4 3
2 1 3 5 4
4 2 1 3 5
3 4 5 2 1
5 3 4 1 2
''')


def validate_square(square):
    N = len(square)
    s = set(range(1, N+1))
    for row in square:
        assert set(row) == s
    for c in range(N):
        column = [square[r][c] for r in range(N)]
        assert set(column) == s


T = int(input())
for test_case_index in range(1, T+1):
    N, K = [int(x) for x in input().split()]
    if (N, K) in solutions:
        print('Case #{}: POSSIBLE'.format(test_case_index))
        solution = solutions[(N, K)]
        validate_square(solution)
        assert sum(solution[i][i] for i in range(N)) == K
        assert len(solution) == N
        for row in solution:
            print(' '.join(str(x) for x in row))
    else:
        print('Case #{}: IMPOSSIBLE'.format(test_case_index))
",0000000000284f7f.PYTHON3,2637,156,450,Python,000000000019fd27,0000000000284f7f,0000000000209aa0,bigOnion,2020
2622,0000000000284f5e,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')

from itertools import permutations

solutions = {}


def apply_permutation_on_symbols(square, perm):
    N = len(square)
    assert len(perm) == N
    assert min(perm) == 1
    assert max(perm) == N
    translate_symbols = {}
    for i in range(1, N+1):
        translate_symbols[i] = perm[i-1]

    square2 = [[None] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            symbol = square[r][c]
            square2[r][c] = translate_symbols[symbol]
    return square2


def register_solution(s):
    square = [[int(x) for x in row.strip().split()] for row in s.strip().split('\n')]
    N = len(square)
    symbols = list(range(1, N+1))
    for perm in permutations(symbols):
        square2 = apply_permutation_on_symbols(square, perm)
        diagonal = [square2[i][i] for i in range(N)]
        trace = sum(diagonal)
        solutions[(N, trace)] = square2


# ############ N = 2

register_solution('''
1 2
2 1
''')


# ############ N = 3

register_solution('''
1 2 3
3 1 2
2 3 1
''')

register_solution('''
3 1 2
1 2 3
2 3 1
''')


# ############ N = 4

register_solution('''
1 2 3 4
4 1 2 3
3 4 1 2
2 3 4 1
''')

register_solution('''
3 2 1 4
2 1 4 3
1 4 3 2
4 3 2 1
''')

register_solution('''
1 3 4 2
3 4 2 1
2 1 3 4
4 2 1 3
''')


# ############ N = 5

register_solution('''
1 2 3 4 5
5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
2 3 4 5 1
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2 3 4 5
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
3 4 5 1 2
2 3 4 5 1
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
1 5 2 4 3
2 1 3 5 4
4 2 1 3 5
4 2 1 3 5
3 4 5 2 1
5 3 4 1 2
''')


def validate_square(square):
    N = len(square)
    s = set(range(1, N+1))
    for row in square:
        assert set(row) == s
    for c in range(N):
        column = [square[r][c] for r in range(N)]
        assert set(column) == s


T = int(input())
for test_case_index in range(1, T+1):
    N, K = [int(x) for x in input().split()]
    if (N, K) in solutions:
        print('Case #{}: POSSIBLE'.format(test_case_index))
        solution = solutions[(N, K)]
        validate_square(solution)
        assert sum(solution[i][i] for i in range(N)) == K
        assert len(solution) == N
        for row in solution:
            print(' '.join(str(x) for x in row))
    else:
        print('Case #{}: IMPOSSIBLE'.format(test_case_index))
",0000000000284f5e.PYTHON3,2647,157,455,Python,000000000019fd27,0000000000284f5e,0000000000209aa0,bigOnion,2020
2623,0000000000283954,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')

from itertools import permutations

solutions = {}


def apply_permutation_on_symbols(square, perm):
    N = len(square)
    assert len(perm) == N
    assert min(perm) == 1
    assert max(perm) == N
    translate_symbols = {}
    for i in range(1, N+1):
        translate_symbols[i] = perm[i-1]

    square2 = [[None] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            symbol = square[r][c]
            square2[r][c] = translate_symbols[symbol]
    return square2


def register_solution(s):
    square = [[int(x) for x in row.strip().split()] for row in s.strip().split('\n')]
    N = len(square)
    symbols = list(range(1, N+1))
    for perm in permutations(symbols):
        square2 = apply_permutation_on_symbols(square, perm)
        diagonal = [square2[i][i] for i in range(N)]
        trace = sum(diagonal)
        solutions[(N, trace)] = square2


# ############ N = 2

register_solution('''
1 2
2 1
''')


# ############ N = 3

register_solution('''
1 2 3
3 1 2
2 3 1
''')

register_solution('''
3 1 2
1 2 3
2 3 1
''')


# ############ N = 4

register_solution('''
1 2 3 4
4 1 2 3
3 4 1 2
2 3 4 1
''')

register_solution('''
3 2 1 4
2 1 4 3
1 4 3 2
4 3 2 1
''')

register_solution('''
1 3 4 2
3 4 2 1
2 1 3 4
4 2 1 3
''')


# ############ N = 5

register_solution('''
1 2 3 4 5
5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
2 3 4 5 1
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2 3 4 5
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
3 4 5 1 2
2 3 4 5 1
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')


def validate_square(square):
    N = len(square)
    s = set(range(1, N+1))
    for row in square:
        assert set(row) == s
    for c in range(N):
        column = [square[r][c] for r in range(N)]
        assert set(column) == s


T = int(input())
for test_case_index in range(1, T+1):
    N, K = [int(x) for x in input().split()]
    if (N, K) in solutions:
        print('Case #{}: POSSIBLE'.format(test_case_index))
        solution = solutions[(N, K)]
        validate_square(solution)
        assert sum(solution[i][i] for i in range(N)) == K
        assert len(solution) == N
        for row in solution:
            print(' '.join(str(x) for x in row))
    else:
        print('Case #{}: IMPOSSIBLE'.format(test_case_index))

# for N in range(2, 6):
#     for K in range(1, N**2+1):
#         # N, K = [int(x) for x in input().split()]
#         if (N, K) in solutions:
#             print('Case #{}: POSSIBLE'.format('{} {}'.format(N, K)))
#             solution = solutions[(N, K)]
#             validate_square(solution)
#             assert sum(solution[i][i] for i in range(N)) == K
#             assert len(solution) == N
#             for row in solution:
#                 print(' '.join(str(x) for x in row))
#         else:
#             print('Case #{}: IMPOSSIBLE'.format('{} {}'.format(N, K)))
",0000000000283954.PYTHON3,3141,162,498,Python,000000000019fd27,0000000000283954,0000000000209aa0,bigOnion,2020
2625,0000000000281116,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')

from itertools import permutations

solutions = {}


def apply_permutation_on_symbols(square, perm):
    N = len(square)
    assert len(perm) == N
    assert min(perm) == 1
    assert max(perm) == N
    translate_symbols = {}
    for i in range(1, N+1):
        translate_symbols[i] = perm[i-1]

    square2 = [[None] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            symbol = square[r][c]
            square2[r][c] = translate_symbols[symbol]
    return square2


def register_solution(s):
    square = [[int(x) for x in row.strip().split()] for row in s.strip().split('\n')]
    N = len(square)
    symbols = list(range(1, N+1))
    for perm in permutations(symbols):
        square2 = apply_permutation_on_symbols(square, perm)
        diagonal = [square2[i][i] for i in range(N)]
        trace = sum(diagonal)
        solutions[(N, trace)] = square2


# ############ N = 2

register_solution('''
1 2
2 1
''')


# ############ N = 3

register_solution('''
1 2 3
3 1 2
2 3 1
''')

register_solution('''
3 1 2
1 2 3
2 3 1
''')


# ############ N = 4

register_solution('''
1 2 3 4
4 1 2 3
3 4 1 2
2 3 4 1
''')

register_solution('''
3 2 1 4
2 1 4 3
1 4 3 2
4 3 2 1
''')

register_solution('''
1 3 4 2
3 4 2 1
2 1 3 4
4 2 1 3
''')


# ############ N = 5

register_solution('''
1 2 3 4 5
5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
2 3 4 5 1
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2 3 4 5
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
3 4 5 1 2
2 3 4 5 1
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')


def validate_square(square):
    N = len(square)
    s = set(range(1, N+1))
    for row in square:
        assert set(row) == s
    for c in range(N):
        column = [square[r][c] for r in range(N)]
        assert set(column) == s


T = int(input())
for test_case_index in range(1, T+1):
    N, K = [int(x) for x in input().split()]
    if (N, K) in solutions:
        print('Case #{}: POSSIBLE'.format(test_case_index))
        solution = solutions[(N, K)]
        validate_square(solution)
        assert sum(solution[i][i] for i in range(N)) == K
        assert len(solution) == N
        for row in solution:
            print(' '.join(str(x) for x in row))
    else:
        print('Case #{}: IMPOSSIBLE'.format(test_case_index))
",0000000000281116.PYTHON3,2559,148,423,Python,000000000019fd27,0000000000281116,0000000000209aa0,bigOnion,2020
2626,00000000002802d8,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')

from itertools import permutations

solutions = {}


def apply_permutation_on_symbols(square, perm):
    N = len(square)
    assert len(perm) == N
    assert min(perm) == 1
    assert max(perm) == N
    translate_symbols = {}
    for i in range(1, N+1):
        translate_symbols[i] = perm[i-1]

    square2 = [[None] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            symbol = square[r][c]
            square2[r][c] = translate_symbols[symbol]
    return square2


def register_solution(s):
    square = [[int(x) for x in row.strip().split()] for row in s.strip().split('\n')]
    N = len(square)
    symbols = list(range(1, N+1))
    for perm in permutations(symbols):
        square2 = apply_permutation_on_symbols(square, perm)
        diagonal = [square2[i][i] for i in range(N)]
        trace = sum(diagonal)
        solutions[(N, trace)] = square2


# ############ N = 2

register_solution('''
1 2
2 1
''')


# ############ N = 3

register_solution('''
1 2 3
3 1 2
2 3 1
''')

register_solution('''
3 1 2
1 2 3
2 3 1
''')


# ############ N = 4

register_solution('''
1 2 3 4
4 1 2 3
3 4 1 2
2 3 4 1
''')

register_solution('''
3 2 1 4
2 1 4 3
1 4 3 2
4 3 2 1
''')

register_solution('''
1 3 4 2
3 4 2 1
2 1 3 4
4 2 1 3
''')


# ############ N = 5

register_solution('''
1 2 3 4 5
5 1 2 3 4
4 5 1 2 3
3 4 5 1 2
2 3 4 5 1
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
5 1 2 3 4
1 2 3 4 5
''')

register_solution('''
2 3 4 5 1
3 4 5 1 2
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')

register_solution('''
3 4 5 1 2
2 3 4 5 1
4 5 1 2 3
1 2 3 4 5
5 1 2 3 4
''')


T = int(input())
for test_case_index in range(1, T+1):
    N, K = [int(x) for x in input().split()]
    if (N, K) in solutions:
        print('Case #{}: POSSIBLE'.format(test_case_index))
        solution = solutions[(N, K)]
        for row in solution:
            print(' '.join(str(x) for x in row))
    else:
        print('Case #{}: IMPOSSIBLE'.format(test_case_index))
",00000000002802d8.PYTHON3,2198,135,378,Python,000000000019fd27,00000000002802d8,0000000000209aa0,bigOnion,2020
2627,000000000026f1b0,"import time
import inspect
from sys import exit
import sys

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def _readline(log_file, line_number=0):
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
    log_file.flush()
    line = input().replace('\n', '')
    log_file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
    log_file.flush()
    return line


def _writeline(log_file, s, line_number=0):
    if s[-1] == '\n':
        s = s[:-1]
    print(s, flush=True)
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
    log_file.flush()


def _addlog(logfile, s, line_number=0):
    s = s.strip()
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: [{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
    log_file.flush()

def change_test_case(log_file, test_case):
    log_file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
    log_file.flush()


def read_list_of_integers(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return [int(x) for x in line.split()]


def read_single_integer(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return int(line)


def read_string(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return line.strip()


def write_string(log_file, s, line_number=0):
    _writeline(log_file, s, line_number)


def write_integer(log_file, n, line_number=0):
    _writeline(log_file, '{}'.format(n), line_number)


def ask_index(log_file, n, line_number=0):
    write_integer(log_file, n + 1, line_number)
    return str(read_single_integer(log_file, line_number))


def solve_single_case(log_file, b):
    _addlog(log_file, '************* initial 10 queries')
    bits = ['?'] * b
    for _ in range(5):
        bits[0] = ask_index(log_file, 0, inspect.getframeinfo(inspect.currentframe()).lineno)
        bits[b-1] = ask_index(log_file, b-1, inspect.getframeinfo(inspect.currentframe()).lineno)

    # initialization
    b = len(bits)
    if bits[0] == bits[-1]:
        complement_check_index = 0
        reverse_check_index = None
    else:
        complement_check_index = None
        reverse_check_index = 0

    # loop to learn

    while '?' in bits:

        _addlog(log_file, '************* 10 more queries')

        # check if complement is needed
        if complement_check_index is not None:
            complement_check_value = bits[complement_check_index]
            x = ask_index(log_file, complement_check_index, inspect.getframeinfo(inspect.currentframe()).lineno)
            if x != complement_check_value:
                complement_bits(bits)
        else:
            _ = ask_index(log_file, 0, inspect.getframeinfo(inspect.currentframe()).lineno)

        # check if reverse is needed
        if reverse_check_index is not None:
            reverse_check_value = bits[reverse_check_index]
            x = ask_index(log_file, reverse_check_index, inspect.getframeinfo(inspect.currentframe()).lineno)
            if x != reverse_check_value:
                reverse_bits(bits)
        else:
            _ = ask_index(log_file, 0, inspect.getframeinfo(inspect.currentframe()).lineno)

        # learn 4 more pairs
        p = bits.index('?')
        for i in range(p, min(p+4, b//2)):
            j = reversed_index(b, i)
            bits[i] = ask_index(log_file, i, inspect.getframeinfo(inspect.currentframe()).lineno)
            bits[j] = ask_index(log_file, j, inspect.getframeinfo(inspect.currentframe()).lineno)
            if reverse_check_index is None and bits[i] != bits[j]:
                reverse_check_index = i
            if complement_check_index is None and bits[i] == bits[j]:
                complement_check_index = i

        _addlog(log_file, '************* exited loop')

    # write solution

    solution = ''.join(bits)
    write_string(log_file, solution, inspect.getframeinfo(inspect.currentframe()).lineno)
    judgement = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if judgement[0] == 'N':
        sys.exit()


def reversed_index(b, i):
    return b-1-i


def reverse_bits(bits):
    bits[:] = bits[::-1]


def complement_bits(bits):
    for i in range(len(bits)):
        if bits[i] == '0':
            bits[i] = '1'
        elif bits[i] == '1':
            bits[i] = '0'


with open('log_file.txt', 'w') as log_file:
    t, b = read_list_of_integers(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    for test_case_index in range(1, t+1):
        change_test_case(log_file, test_case_index)
        solve_single_case(log_file, b)

# cd ""current directory""
# python interactive_runner.py python testing_tool.py 0 -- python solution.py
# python interactive_runner.py python testing_tool.py 1 -- python solution.py
# python interactive_runner.py python testing_tool.py 2 -- python solution.py
",000000000026f1b0.PYTHON3,5236,161,438,Python,000000000019fd27,000000000026f1b0,0000000000209a9e,bigOnion,2020
2628,0000000000260429,"import time
import inspect
from sys import exit
import sys

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def _readline(log_file, line_number=0):
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
    log_file.flush()
    line = input().replace('\n', '')
    log_file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
    log_file.flush()
    return line


def _writeline(log_file, s, line_number=0):
    if s[-1] == '\n':
        s = s[:-1]
    print(s, flush=True)
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
    log_file.flush()


def change_test_case(log_file, test_case):
    log_file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
    log_file.flush()


def read_list_of_integers(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return [int(x) for x in line.split()]


def read_single_integer(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return int(line)


def read_string(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return line.strip()


def write_string(log_file, s, line_number=0):
    _writeline(log_file, s, line_number)


def write_integer(log_file, n, line_number=0):
    _writeline(log_file, '{}'.format(n), line_number)


def solve_single_case():
    b = [None] * 10
    for i in range(10):
        write_integer(log_file, i+1, inspect.getframeinfo(inspect.currentframe()).lineno)
        x = read_single_integer(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
        b[i] = str(x)
    solution = ''.join(b)
    write_string(log_file, solution, inspect.getframeinfo(inspect.currentframe()).lineno)
    judgement = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if judgement[0] == 'N':
        sys.exit()

with open('log_file.txt', 'w') as log_file:
    t, b = read_list_of_integers(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    for test_case_index in range(1, t+1):
        change_test_case(log_file, test_case_index)
        solve_single_case()

# cd ""current directory""
# python interactive_runner.py python testing_tool.py 0 -- python draupnir.py
",0000000000260429.PYTHON3,2532,82,201,Python,000000000019fd27,0000000000260429,0000000000209a9e,bigOnion,2020
2629,00000000002442d5,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


COLORLESS = 'x'
IMPOSSIBLE = 'IMPOSSIBLE'
COLORS = ['C', 'J']


def get_other_color(color):
    return chr(ord('C') + ord('J') - ord(color))


def get_neighbors(tasks, i):
    s, e = tasks[i]
    result = [j for j, task in enumerate(tasks) if i != j and not (task[1] <= s or e <= task[0])]
    return result


def get_coloring(tasks):
    N = len(tasks)
    coloring = [COLORLESS] * N
    while COLORLESS in coloring:
        ind = coloring.index(COLORLESS)
        queue = [ind]
        coloring[ind] = 'C'
        while queue:
            i = queue.pop()
            neighbors = get_neighbors(tasks, i)
            current_color = coloring[i]
            other_color = get_other_color(current_color)
            for neighbor in neighbors:
                if coloring[neighbor] == current_color:
                    return IMPOSSIBLE
                if coloring[neighbor] == COLORLESS:
                    coloring[neighbor] = other_color
                    queue.append(neighbor)
    return ''.join(coloring)


def solve_single_case(test_case):
    N = int(input())
    tasks = []
    for i in range(N):
        tasks.append(tuple([int(x) for x in input().split()]))
    solution = get_coloring(tasks)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",00000000002442d5.PYTHON3,1576,59,162,Python,000000000019fd27,00000000002442d5,000000000020bdf9,bigOnion,2020
2630,000000000024421d,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


COLORLESS = 'x'
IMPOSSIBLE = 'IMPOSSIBLE'
COLORS = ['C', 'J']


def get_other_color(color):
    return chr(ord('C') + ord('J') - ord(color))


def get_neighbors(tasks, i):
    s, e = tasks[i]
    result = [j for j, task in enumerate(tasks) if not (task[1] <= s or e <= task[0])]
    return result


def get_coloring(tasks):
    N = len(tasks)
    coloring = [COLORLESS] * N
    while COLORLESS in coloring:
        ind = coloring.index(COLORLESS)
        queue = [ind]
        coloring[ind] = 'C'
        while queue:
            i = queue.pop()
            neighbors = get_neighbors(tasks, i)
            current_color = coloring[i]
            other_color = get_other_color(current_color)
            for neighbor in neighbors:
                if coloring[neighbor] == current_color:
                    return IMPOSSIBLE
                if coloring[neighbor] == COLORLESS:
                    coloring[neighbor] = other_color
                    queue.append(neighbor)
    return ''.join(coloring)


def solve_single_case(test_case):
    N = int(input())
    tasks = []
    for i in range(N):
        tasks.append(tuple([int(x) for x in input().split()]))
    solution = get_coloring(tasks)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000024421d.PYTHON3,1565,59,158,Python,000000000019fd27,000000000024421d,000000000020bdf9,bigOnion,2020
2632,000000000023f028,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    s = input().strip()
    solution = ''
    par = 0
    for c in s:
        n = int(c)
        if n > par:
            solution += '(' * (n-par)
            par = n
        if n < par:
            solution += ')' * (par-n)
            par = n
        solution += c
    solution += ')' * par
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000023f028.PYTHON3,698,31,86,Python,000000000019fd27,000000000023f028,0000000000209a9f,bigOnion,2020
2633,000000000023e608,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    N = int(input())
    mat = []
    for _ in range(N):
        mat.append([int(x) for x in input().split()])

    trace = sum(mat[i][i] for i in range(N))

    r = 0
    for i in range(N):
        row = mat[i]
        if len(set(row)) != N:
            r += 1
    c = 0
    for j in range(N):
        col = [mat[i][j] for i in range(N)]
        if len(set(col)) != N:
            c += 1

    print('Case #{}: {} {} {}'.format(test_case, trace, r, c))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000023e608.PYTHON3,804,36,102,Python,000000000019fd27,000000000023e608,000000000020993c,bigOnion,2020
393000,0000000000304ea9,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from itertools import product
impossible = 'IMPOSSIBLE'


def find_path(X, Y):
    for length in range(1, 7):
        for path in product('SNEW', repeat=length):
            x = 0
            y = 0
            for i in range(len(path)):
                if path[i] == 'S':
                    y -= 2**i
                if path[i] == 'N':
                    y += 2**i
                if path[i] == 'E':
                    x += 2**i
                if path[i] == 'W':
                    x -= 2**i
            if x == X and y == Y:
                return ''.join(path)
    return impossible


def solve_single_case(test_case):
    X, Y = [int(q) for q in input().split()]
    solution = find_path(X, Y)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)


",0000000000304ea9.PYTHON3,1075,45,120,Python,000000000019fef2,0000000000304ea9,00000000002d5b62,bigOnion,2020
393001,0000000000305069,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from itertools import product
impossible = 'IMPOSSIBLE'


def find_path(X, Y):
    for length in range(1, 8):
        for path in product('SNEW', repeat=length):
            x = 0
            y = 0
            for i in range(len(path)):
                if path[i] == 'S':
                    y -= 2**i
                if path[i] == 'N':
                    y += 2**i
                if path[i] == 'E':
                    x += 2**i
                if path[i] == 'W':
                    x -= 2**i
            if x == X and y == Y:
                return ''.join(path)
    return impossible


def solve_single_case(test_case):
    X, Y = [int(q) for q in input().split()]
    solution = find_path(X, Y)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)


",0000000000305069.PYTHON3,1075,45,120,Python,000000000019fef2,0000000000305069,00000000002d5b62,bigOnion,2020
393002,0000000000304d00,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from itertools import product
impossible = 'IMPOSSIBLE'


def find_path(X, Y):
    for length in range(1, 9):
        for path in product('SNEW', repeat=length):
            x = 0
            y = 0
            for i in range(len(path)):
                if path[i] == 'S':
                    y -= 2**i
                if path[i] == 'N':
                    y += 2**i
                if path[i] == 'E':
                    x += 2**i
                if path[i] == 'W':
                    x -= 2**i
            if x == X and y == Y:
                return ''.join(path)
    return impossible


def solve_single_case(test_case):
    X, Y = [int(q) for q in input().split()]
    solution = find_path(X, Y)
    print('Case #{}: {}'.format(test_case, solution))


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)


",0000000000304d00.PYTHON3,1075,45,120,Python,000000000019fef2,0000000000304d00,00000000002d5b62,bigOnion,2020
393003,0000000000304b65,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


from itertools import product
impossible = 'IMPOSSIBLE'


def find_path(X, Y):
    for length in range(1, 9):
        for path in product('SNEW', repeat=length):
            x = 0
            y = 0
            for i in range(len(path)):
                if path[i] == 'S':
                    y -= 2**i
                if path[i] == 'N':
                    y += 2**i
                if path[i] == 'E':
                    x += 2**i
                if path[i] == 'W':
                    x -= 2**i
            if x == X and y == Y:
                return path
    return impossible


def solve_single_case(test_case):
    X, Y = [int(q) for q in input().split()]
    solution = find_path(X, Y)
    print('Case #{}: {}'.format(test_case, solution))


# def get_path(x, y):
#     if x == 0:
#         return get_path_for_x_0(y)
#     if y == 0:
#         return get_path_for_y_0(x)
#     path = get_path_for_positive_x_y(abs(x), abs(y))
#     if path == impossible:
#         return path
#     else:
#         if x < 0:
#             path = path.replace('E', '*').replace('W', 'E').replace('*', 'W')
#         if y < 0:
#             path = path.replace('N', '*').replace('S', 'N').replace('*', 'S')
#         return path
#
#
# def get_path_for_x_0(y):
#     if y > 0:
#         y_bits = bin(y)[2:]
#         if '0' in y_bits:
#             return impossible
#         return 'N' * len(y_bits)
#     else:
#         y_bits = bin(y)[3:]
#         if '0' in y_bits:
#             return impossible
#         return 'S' * len(y_bits)
#
#
# def get_path_for_y_0(x):
#     if x > 0:
#         x_bits = bin(x)[2:]
#         if '0' in x_bits:
#             return impossible
#         return 'E' * len(x_bits)
#     else:
#         x_bits = bin(x)[3:]
#         if '0' in x_bits:
#             return impossible
#         return 'W' * len(x_bits)
#
#
# def get_path_for_positive_x_y(x, y):
#     path = ''
#     while x > 0 or y > 0:
#         if x == 0:
#             path += get_path_for_x_0(y)
#             break
#         if y == 0:
#             path += get_path_for_y_0(x)
#             break
#
#         if x % 2 == y % 2:
#             return impossible
#         if x % 2 == 1:
#             if ((x - 1) // 2) % 2 == (y // 2) % 2:
#                 path += 'W'
#                 x += 1
#             else:
#                 path += 'E'
#                 x -= 1
#         else:
#             if ((y - 1) // 2) % 2 == (x // 2) % 2:
#                 path += 'S'
#                 y += 1
#             else:
#                 path += 'N'
#                 y -= 1
#         x //= 2
#         y //= 2
#     return path


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)


",0000000000304b65.PYTHON3,2933,118,414,Python,000000000019fef2,0000000000304b65,00000000002d5b62,bigOnion,2020
393004,0000000000303cac,"import time
import inspect
from sys import exit
import sys

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def _readline(log_file, line_number=0):
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: WAIT[{}]\n'.format(time.strftime('%H:%M:%S'), line_number))
    log_file.flush()
    line = input().replace('\n', '')
    log_file.write('{}: READ[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, line))
    log_file.flush()
    return line


def _writeline(log_file, s, line_number=0):
    if s[-1] == '\n':
        s = s[:-1]
    print(s, flush=True)
    line_number = ('0000' + str(line_number))[-4:]
    log_file.write('{}: WRIT[{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
    log_file.flush()


def _addlog(logfile, s, line_number=0):
    s = s.strip()
    line_number = ('0000' + str(line_number))[-4:]
    logfile.write('{}: [{}]: {}\n'.format(time.strftime('%H:%M:%S'), line_number, s))
    logfile.flush()


def change_test_case(log_file, test_case):
    log_file.write('\n{}: starting test case {}\n'.format(time.strftime('%H:%M:%S'), test_case))
    log_file.flush()


def read_list_of_integers(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return [int(x) for x in line.split()]


def read_single_integer(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return int(line)


def read_string(log_file, line_number=0):
    line = _readline(log_file, line_number)
    return line.strip()


def write_string(log_file, s, line_number=0):
    _writeline(log_file, s, line_number)


def write_integer(log_file, n, line_number=0):
    _writeline(log_file, '{}'.format(n), line_number)


def write_list_of_integers(log_file, l, line_number=0):
    _writeline(log_file, ' '.join(str(n) for n in l), line_number)


HIT_CENTER = 'SUCCESS'


def solve_one_case():
    point_inside = None
    for i in range(5):
        for j in range(5):
            x = -10**9 + 2*10**9 // 10 * (2*i+1)
            y = -10**9 + 2*10**9 // 10 * (2*j+1)
            write_list_of_integers(log_file, [x, y])
            answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
            if answer.lower() == 'center':
                return
            elif answer.lower() == 'hit':
                point_inside = (x, y)
                break
            elif answer.lower() == 'miss':
                continue
            else:
                exit()
        if point_inside is not None:
            break

    if point_inside is None:
        exit()

    up = find_up_point(point_inside)
    if up == HIT_CENTER:
        return
    down = find_down_point(point_inside)
    if down == HIT_CENTER:
        return
    left = find_left_point(point_inside)
    if left == HIT_CENTER:
        return
    right = find_right_point(point_inside)
    if right == HIT_CENTER:
        return

    center_x = (left[0] + right[0]) // 2
    center_y = (up[1] + down[1]) // 2
    write_list_of_integers(log_file, [center_x, center_y])
    answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if answer.lower() == 'center':
        return
    else:
        exit()


def find_up_point(point_inside):
    x, y = point_inside
    write_list_of_integers(log_file, [x, 10**9])
    answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if answer.lower() == 'center':
        return HIT_CENTER
    if answer.lower() == 'hit':
        return x, 10**9
    if answer.lower() == 'wrong':
        exit()
    a = y
    b = 10 ** 9
    while b > a + 1:
        m = (a + b) // 2
        write_list_of_integers(log_file, [x, m])
        answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
        if answer.lower() == 'center':
            return HIT_CENTER
        if answer.lower() == 'wrong':
            exit()
        if answer.lower() == 'hit':
            a = m
        else:
            b = m
    return x, a


def find_down_point(point_inside):
    x, y = point_inside
    write_list_of_integers(log_file, [x, -10**9])
    answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if answer.lower() == 'center':
        return HIT_CENTER
    if answer.lower() == 'hit':
        return x, -10**9
    if answer.lower() == 'wrong':
        exit()
    a = -10**9
    b = y
    while b > a + 1:
        m = (a + b) // 2
        write_list_of_integers(log_file, [x, m])
        answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
        if answer.lower() == 'center':
            return HIT_CENTER
        if answer.lower() == 'wrong':
            exit()
        if answer.lower() == 'hit':
            b = m
        else:
            a = m
    return x, b


def find_right_point(point_inside):
    x, y = point_inside
    write_list_of_integers(log_file, [10**9, y])
    answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if answer.lower() == 'center':
        return HIT_CENTER
    if answer.lower() == 'hit':
        return 10**9, y
    if answer.lower() == 'wrong':
        exit()
    a = x
    b = 10 ** 9
    while b > a + 1:
        m = (a + b) // 2
        write_list_of_integers(log_file, [m, y])
        answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
        if answer.lower() == 'center':
            return HIT_CENTER
        if answer.lower() == 'wrong':
            exit()
        if answer.lower() == 'hit':
            a = m
        else:
            b = m
    return a, y


def find_left_point(point_inside):
    x, y = point_inside
    write_list_of_integers(log_file, [-10**9, y])
    answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    if answer.lower() == 'center':
        return HIT_CENTER
    if answer.lower() == 'hit':
        return -10**9, y
    if answer.lower() == 'wrong':
        exit()
    a = -10 ** 9
    b = x
    while b > a + 1:
        m = (a + b) // 2
        write_list_of_integers(log_file, [m, y])
        answer = read_string(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
        if answer.lower() == 'center':
            return HIT_CENTER
        if answer.lower() == 'wrong':
            exit()
        if answer.lower() == 'hit':
            b = m
        else:
            a = m
    return b, y


with open('log_file.txt', 'w') as log_file:
    T, A, B = read_list_of_integers(log_file, inspect.getframeinfo(inspect.currentframe()).lineno)
    for test_case_index in range(1, T+1):
        change_test_case(log_file, test_case_index)
        solve_one_case()
",0000000000303cac.PYTHON3,6841,235,650,Python,000000000019fef2,0000000000303cac,00000000002d5b63,bigOnion,2020
393005,00000000002fdbdb,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    R, S = [int(x) for x in input().split()]
    solution = solve_rec(R, S)
    print('Case #{}: {}'.format(test_case, len(solution)))
    for operation in solution:
        print('{} {}'.format(operation[0], operation[1]))


def solve_rec(R, S):
    if R == 1:
        return []
    partial_solution = []
    for i in range(S-1):
        partial_solution.append((R*(S-1)-i, R-1))
    return partial_solution + solve_rec(R-1, S)


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

",00000000002fdbdb.PYTHON3,781,32,80,Python,000000000019fef2,00000000002fdbdb,00000000002d5b64,bigOnion,2020
393006,00000000002fcfb3,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    R, S = [int(x) for x in input().split()]
    solution = solve_rec(R, S)
    print('Case #{}: {}'.format(test_case, len(solution)))
    for operation in solution:
        print('{} {}'.format(operation[0], operation[1]))


def solve_rec(R, S):
    if R == 1:
        return []
    partial_solution = []
    return partial_solution + solve_rec(R-1, S)


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)

",00000000002fcfb3.PYTHON3,706,30,74,Python,000000000019fef2,00000000002fcfb3,00000000002d5b64,bigOnion,2020
393007,00000000002fb184,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


impossible = 'IMPOSSIBLE'


def solve_single_case(test_case):
    X, Y = [int(q) for q in input().split()]

    solution = get_path(X, Y)
    print('Case #{}: {}'.format(test_case, solution))


def get_path(x, y):
    if x == 0:
        return get_path_for_x_0(y)
    if y == 0:
        return get_path_for_y_0(x)
    path = get_path_for_positive_x_y(abs(x), abs(y))
    if path == impossible:
        return path
    else:
        if x < 0:
            path = path.replace('E', '*').replace('W', 'E').replace('*', 'W')
        if y < 0:
            path = path.replace('N', '*').replace('S', 'N').replace('*', 'S')
        return path


def get_path_for_x_0(y):
    if y > 0:
        y_bits = bin(y)[2:]
        if '0' in y_bits:
            return impossible
        return 'N' * len(y_bits)
    else:
        y_bits = bin(y)[3:]
        if '0' in y_bits:
            return impossible
        return 'S' * len(y_bits)


def get_path_for_y_0(x):
    if x > 0:
        x_bits = bin(x)[2:]
        if '0' in x_bits:
            return impossible
        return 'E' * len(x_bits)
    else:
        x_bits = bin(x)[3:]
        if '0' in x_bits:
            return impossible
        return 'W' * len(x_bits)


def get_path_for_positive_x_y(x, y):
    path = ''
    while x > 0 or y > 0:
        if x == 0:
            path += get_path_for_x_0(y)
            break
        if y == 0:
            path += get_path_for_y_0(x)
            break

        if x % 2 == y % 2:
            return impossible
        if x % 2 == 1:
            if ((x - 1) // 2) % 2 == (y // 2) % 2:
                path += 'W'
                x += 1
            else:
                path += 'E'
                x -= 1
        else:
            if ((y - 1) // 2) % 2 == (x // 2) % 2:
                path += 'S'
                y += 1
            else:
                path += 'N'
                y -= 1
        x //= 2
        y //= 2
    return path


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)


",00000000002fb184.PYTHON3,2243,99,276,Python,000000000019fef2,00000000002fb184,00000000002d5b62,bigOnion,2020
493311,000000000034000c,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


def solve_(C, edges, X):
    X = [-1] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)
    l = list(sorted(list(order.items())))
    order2 = [None] * (len(X))
    for i, t in enumerate(l):
        st = t[1]
        for computer_name in st:
            order2[computer_name] = i
    solution = [abs(order2[u-1] - order2[v-1]) for (u,v) in edges]
    for i in range(len(solution)):
        if solution[i] == 0:
            solution[i] = 50000
    return solution

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000034000c.PYTHON3,1218,43,138,Python,000000000019ffb9,000000000034000c,000000000033871f,bigOnion,2020
493312,000000000033f61c,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


def solve_(C, edges, X):
    X = [-1] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)
    l = list(sorted(list(order.items())))
    order2 = [None] * (len(X))
    for i, t in enumerate(l):
        st = t[1]
        for computer_name in st:
            order2[computer_name] = i
    return [abs(order2[u-1] - order2[v-1]) for (u,v) in edges]

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033f61c.PYTHON3,1098,39,124,Python,000000000019ffb9,000000000033f61c,000000000033871f,bigOnion,2020
493313,000000000033ee8a,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


def solve_(C, edges, X):
    X = [-100, 0] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)
    l = list(sorted(list(order.items())))
    order2 = [None] * (len(X))
    for i, t in enumerate(l):
        st = t[1]
        for computer_name in st:
            order2[computer_name] = i
    return [abs(order2[u] - order2[v]) for (u,v) in edges]

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033ee8a.PYTHON3,1099,39,125,Python,000000000019ffb9,000000000033ee8a,000000000033871f,bigOnion,2020
493314,000000000033efb2,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


# def solve_(C, edges, X):
#     X = [None, 0] + X
#
#     order = defaultdict(list)
#     # print(X)
#     l = list(enumerate(X))[1:]
#     # print(l)
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     order2 = [0] * (len(X)+2)
#     # print(list(order.items()))
#     l = list(sorted(list(order.items())))
#     print(l)
#     i = 0
#     for o, st in l:
#         for computer_name in st:
#             order2[computer_name] = i
#         i += 1
#
#     solution = [50000] * len(edges)
#     for i, edge in enumerate(edges):
#         u, v = edge
#         solution[i] = abs(order2[u] - order2[v])
#     return solution


def solve_(C, edges, X):
    X = [0] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)

    l = list(sorted(list(order.items())))
    order2 = [None] * (len(X))
    for i, t in enumerate(l):
        st = t[1]
        for computer_name in st:
            order2[computer_name] = i

    return [abs(order2[u-1] - order2[v-1]) for (u,v) in edges]

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033efb2.PYTHON3,2433,91,322,Python,000000000019ffb9,000000000033efb2,000000000033871f,bigOnion,2020
493315,000000000033dc9a,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


# def solve_(C, edges, X):
#     X = [None, 0] + X
#
#     order = defaultdict(list)
#     # print(X)
#     l = list(enumerate(X))[1:]
#     # print(l)
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     order2 = [0] * (len(X)+2)
#     # print(list(order.items()))
#     l = list(sorted(list(order.items())))
#     print(l)
#     i = 0
#     for o, st in l:
#         for computer_name in st:
#             order2[computer_name] = i
#         i += 1
#
#     solution = [50000] * len(edges)
#     for i, edge in enumerate(edges):
#         u, v = edge
#         solution[i] = abs(order2[u] - order2[v])
#     return solution


def solve_(C, edges, X):
    X = [0] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)

    l = list(sorted(list(order.items())))
    order2 = [None] * (len(X))
    for i, t in enumerate(l):
        st = t[1]
        for computer_name in st:
            order2[computer_name] = i

    solution = [None] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u-1] - order2[v-1])
    return solution

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033dc9a.PYTHON3,2535,95,335,Python,000000000019ffb9,000000000033dc9a,000000000033871f,bigOnion,2020
493316,000000000033dbed,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


# def solve_(C, edges, X):
#     X = [None, 0] + X
#
#     order = defaultdict(list)
#     # print(X)
#     l = list(enumerate(X))[1:]
#     # print(l)
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     order2 = [0] * (len(X)+2)
#     # print(list(order.items()))
#     l = list(sorted(list(order.items())))
#     print(l)
#     i = 0
#     for o, st in l:
#         for computer_name in st:
#             order2[computer_name] = i
#         i += 1
#
#     solution = [50000] * len(edges)
#     for i, edge in enumerate(edges):
#         u, v = edge
#         solution[i] = abs(order2[u] - order2[v])
#     return solution


def solve_(C, edges, X):
    X = [0] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)

    l = list(sorted(list(order.items())))
    i = 0
    order2 = [None] * (len(X))
    for o, st in l:
        for computer_name in st:
            order2[computer_name] = i
        i += 1

    solution = [None] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u-1] - order2[v-1])
    return solution

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033dbed.PYTHON3,2532,96,338,Python,000000000019ffb9,000000000033dbed,000000000033871f,bigOnion,2020
493317,000000000033ddc6,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


# def solve_(C, edges, X):
#     X = [None, 0] + X
#
#     order = defaultdict(list)
#     # print(X)
#     l = list(enumerate(X))[1:]
#     # print(l)
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     order2 = [0] * (len(X)+2)
#     # print(list(order.items()))
#     l = list(sorted(list(order.items())))
#     print(l)
#     i = 0
#     for o, st in l:
#         for computer_name in st:
#             order2[computer_name] = i
#         i += 1
#
#     solution = [50000] * len(edges)
#     for i, edge in enumerate(edges):
#         u, v = edge
#         solution[i] = abs(order2[u] - order2[v])
#     return solution


def solve_(C, edges, X):
    X = [0] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)

    order2 = [None] * (len(X))
    l = list(sorted(list(order.items())))
    i = 0
    for o, st in l:
        for computer_name in st:
            order2[computer_name] = i
        i += 1

    solution = [50000] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u-1] - order2[v-1])
    return solution

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033ddc6.PYTHON3,2533,96,338,Python,000000000019ffb9,000000000033ddc6,000000000033871f,bigOnion,2020
493318,000000000033defc,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [abs(int(x)) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


# def solve_(C, edges, X):
#     X = [None, 0] + X
#
#     order = defaultdict(list)
#     # print(X)
#     l = list(enumerate(X))[1:]
#     # print(l)
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     order2 = [0] * (len(X)+2)
#     # print(list(order.items()))
#     l = list(sorted(list(order.items())))
#     print(l)
#     i = 0
#     for o, st in l:
#         for computer_name in st:
#             order2[computer_name] = i
#         i += 1
#
#     solution = [50000] * len(edges)
#     for i, edge in enumerate(edges):
#         u, v = edge
#         solution[i] = abs(order2[u] - order2[v])
#     return solution


def solve_(C, edges, X):
    X = [0] + X
    order = defaultdict(list)
    for computer_name, p in enumerate(X):
        order[p].append(computer_name)

    order2 = [0] * (len(X))
    l = list(sorted(list(order.items())))
    i = 0
    for o, st in l:
        for computer_name in st:
            order2[computer_name] = i
        i += 1

    solution = [50000] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u-1] - order2[v-1])
    return solution

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033defc.PYTHON3,2530,96,338,Python,000000000019ffb9,000000000033defc,000000000033871f,bigOnion,2020
493319,000000000033e11b,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [-int(x) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


# def solve_(C, edges, X):
#     X = [None, 0] + X
#
#     order = defaultdict(list)
#     # print(X)
#     l = list(enumerate(X))[1:]
#     # print(l)
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     order2 = [0] * (len(X)+2)
#     # print(list(order.items()))
#     l = list(sorted(list(order.items())))
#     print(l)
#     i = 0
#     for o, st in l:
#         for computer_name in st:
#             order2[computer_name] = i
#         i += 1
#
#     solution = [50000] * len(edges)
#     for i, edge in enumerate(edges):
#         u, v = edge
#         solution[i] = abs(order2[u] - order2[v])
#     return solution


def solve_(C, edges, X):
    X = [0] + X

    order = defaultdict(list)
    # print(X)
    l = list(enumerate(X))
    # print(l)
    for computer_name, p in l:
        order[p].append(computer_name)

    order2 = [0] * (len(X))
    # print(list(order.items()))
    l = list(sorted(list(order.items())))
    # print(l)
    i = 0
    for o, st in l:
        for computer_name in st:
            order2[computer_name] = i
        i += 1

    solution = [50000] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u-1] - order2[v-1])
    return solution

T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033e11b.PYTHON3,2621,102,349,Python,000000000019ffb9,000000000033e11b,000000000033871f,bigOnion,2020
493320,000000000033dd54,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [-int(x) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


def solve_(C, edges, X):
    X = [None, 0] + X

    order = defaultdict(list)
    # print(X)
    l = list(enumerate(X))[1:]
    # print(l)
    for computer_name, p in l:
        order[p].append(computer_name)

    order2 = [0] * (len(X)+2)
    # print(list(order.items()))
    l = list(sorted(list(order.items())))
    print(l)
    i = 0
    for o, st in l:
        for computer_name in st:
            order2[computer_name] = i
        i += 1

    solution = [50000] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u] - order2[v])
    return solution


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033dd54.PYTHON3,1972,76,248,Python,000000000019ffb9,000000000033dd54,000000000033871f,bigOnion,2020
493321,000000000033db77,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [-int(x) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


def solve_(C, edges, X):
    X = [None, 0] + X

    order = defaultdict(list)
    order[0].append(1)
    # print(X)
    l = list(enumerate(X))[1:]
    # print(l)
    for computer_name, p in l:
        order[p].append(computer_name)

    order2 = [0] * (len(X)+2)
    # print(list(order.items()))
    l = list(sorted(list(order.items())))
    i = 0
    for o, st in l:
        for computer_name in st:
            order2[computer_name] = i
        i += 1

    solution = [50000] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(order2[u] - order2[v])
    return solution


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033db77.PYTHON3,1982,76,248,Python,000000000019ffb9,000000000033db77,000000000033871f,bigOnion,2020
493322,000000000033d977,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [-int(x) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


# def solve_(C, edges, X):
#     edges_values = {}
#     for edge in edges:
#         edges_values[edge] = 50000
#
#     order = defaultdict(list)
#     order[0].append(1)
#     l = list(enumerate([None, None] + X))[2:]
#     for computer_name, p in l:
#         order[p].append(computer_name)
#
#     l = list(sorted(order.items()))
#     for i in range(1, len(l)):
#         set1 = set(l[i-1][1])
#         set2 = set(l[i][1])
#         for edge in edges:
#             if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
#                 edges_values[edge] = 1
#
#     solution = [edges_values[edge] for edge in edges]
#     return solution


def solve_(C, edges, X):
    X = [None, 0] + X
    solution = [50000] * len(edges)
    for i, edge in enumerate(edges):
        u, v = edge
        solution[i] = abs(X[u] - X[v])
    return solution


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033d977.PYTHON3,1564,58,203,Python,000000000019ffb9,000000000033d977,000000000033871f,bigOnion,2020
493323,000000000033d465,"import sys
from collections import defaultdict

try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    C, D = [int(x) for x in input().split()]
    X = [-int(x) for x in input().split()]
    edges =[]
    for i in range(D):
        edges.append(tuple([int(x) for x in input().split()]))
    solution = ' '.join(map(str, solve_(C, edges, X)))
    print('Case #{}: {}'.format(test_case, solution))


def solve_(C, edges, X):
    edges_values = {}
    for edge in edges:
        edges_values[edge] = 50000

    order = defaultdict(list)
    order[0].append(1)
    l = list(enumerate([None, None] + X))[2:]
    for computer_name, p in l:
        order[p].append(computer_name)

    l = list(sorted(order.items()))
    for i in range(1, len(l)):
        set1 = set(l[i-1][1])
        set2 = set(l[i][1])
        for edge in edges:
            if (edge[0] in set1 and edge[1] in set2) or (edge[1] in set1 and edge[0] in set2):
                edges_values[edge] = 1

    solution = [edges_values[edge] for edge in edges]
    return solution



T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033d465.PYTHON3,1325,50,151,Python,000000000019ffb9,000000000033d465,000000000033871f,bigOnion,2020
493324,000000000033b260,"import sys
try:
    import bigonion_local_testing
except Exception:
    pass
if 'bigonion_local_testing' in globals():
    sys.stderr.write('    using a file as standard input\n')
    sys.stdin = open('sample.in', 'r')


def solve_single_case(test_case):
    L, R = [int(x) for x in input().split()]
    yn, yl, yr = solve_(L,R)
    print('Case #{}: {} {} {}'.format(test_case, yn, yl, yr))


def solve_(L, R):
    # print('\nstacks are ', L, R)
    switch = False
    if R > L:
        L, R = R, L
        switch = True
        # print('switched. stacks are ', L, R)

    take_first = get_take_first(L, R)
    # print('take first =', take_first)
    L -= take_first*(take_first+1)//2

    if L == R:
        switch = False

    # print('stack sizes are ', L, R)
    # print('start taking in L from', take_first+1, 'and in R from ', take_first+2)
    n1 = get_take_second(L, take_first+1)
    # print('take second1 =', n1)
    n2 = get_take_second(R, take_first+2)
    # print('take second2 =', n2)
    # print('results', n1,n2)

    if n1 > n2:
        yn = take_first + n2*2+1
        yl = L - (((take_first+1) + ((take_first+1) + (n2)*2))*(n2+1)//2)
        yr = R - (((take_first+2) + ((take_first+2) + (n2-1)*2)) * n2 // 2)
    else:
        yn = take_first + n2*2
        yl = L - (((take_first+1) + ((take_first+1) + (n2-1)*2)) * n2 //2)
        yr = R - (((take_first+2) + ((take_first+2) + (n2-1)*2)) * n2 // 2)

    if switch:
        yl, yr = yr, yl

    return yn, yl, yr


def get_take_first(L, R):
    d = L - R
    if d == 0:
        return 0
    if d == 1:
        return 1
    a = 1
    b = 10**10
    while b > a + 1:
        m = (a+b)//2
        if d >= m*(m+1)//2:
            a = m
        else:
            b = m
    return a


def get_take_second(stack, initial):
    if stack < initial:
        return 0
    parity = initial & 1
    a = initial
    b = 10**10 + parity
    while b > a + 2:
        m = (a + b) // 2
        if m&1 != parity:
            m -= 1
        taken = (m+initial)*((m-initial)//2+1)//2
        if taken <= stack:
            a = m
        else:
            b = m
    return (a - initial)//2+1


T = int(input())
for test_case_index in range(1, T+1):
    solve_single_case(test_case_index)
",000000000033b260.PYTHON3,2237,93,327,Python,000000000019ffb9,000000000033b260,00000000003384ea,bigOnion,2020
45747,solve.py,"# coding: shift-jis
 # ([])
 
 import sys
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 
 for number in range(test_cnt):
 	count   = int(f.readline())
 	candies = map(int, f.readline().split())
 	
 	ret = reduce(lambda a,b: a^b, candies)
 	if ret == 0:
 		candies.sort()
 		total = sum(candies[1:])
 		print 'Case #%d:'%(number+1), total
 	else:
 		print 'Case #%d: NO'%(number+1)
 	
",gcj/2011/975485/oonishi/1059486/1/extracted/solve.py,400,23,47,Python,975485,1,1059486,oonishi,2011
45748,solve.py,"# coding: shift-jis
 
 import sys
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 
 for number in range(test_cnt):
 	count   = int(f.readline())
 	candies = map(int, f.readline().split())
 	
 	ret = reduce(lambda a,b: a^b, candies)
 	if ret == 0:
 		candies.sort()
 		total = sum(candies[1:])
 		print 'Case #%d:'%(number+1), total
 	else:
 		print 'Case #%d: NO'%(number+1)
 	
",gcj/2011/975485/oonishi/1059486/0/extracted/solve.py,390,22,45,Python,975485,0,1059486,oonishi,2011
45749,solve.py,"# coding: shift-jis
 
 import sys
 
 f = file(sys.argv[1])
 
 line_cnt = int(f.readline())
 
 class Robot:
 	def __init__(this):
 		this.time     = 0
 		this.position = 1
 
 for number, s in enumerate(f):
 	line = s.split()
 	cnt = int(line[0])
 	
 	robots = {'O':Robot(), 'B':Robot()}
 	
 	time = 0
 	
 	for i in range(1, cnt+1):
 		which  = line[2*i-1]
 		button = int(line[2*i])
 		
 		r = robots[which]
 		
 		elapse   = time   - r.time
 		distance = abs(button - r.position)
 		
 		if distance < elapse:
 			time += 1
 		else:
 			time += distance - elapse + 1
 			
 		r.position = button
 		r.time = time
 	
 	print 'Case #%d:'%(number+1), time
",gcj/2011/975485/oonishi/1080487/1/extracted/solve.py,651,40,88,Python,975485,1,1080487,oonishi,2011
45751,solve.py,"# coding: shift-jis
 
 import sys
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 
 for number in range(test_cnt):
 	count = int(f.readline())
 	elems = map(int, f.readline().split())
 	
 	ret = count
 	for i, e in enumerate(elems):
 		if i+1 == e: ret -= 1
 	
 	
 	print 'Case #%d:'%(number+1), '%0.6lf'%float(ret)",gcj/2011/975485/oonishi/992486/1/extracted/solve.py,327,19,41,Python,975485,1,992486,oonishi,2011
45753,solve.py,"# coding: shift-jis
 
 def Order(s):
 	l = list(s)
 	l.sort()
 	return reduce(lambda a,b: a+b, l)
 	
 	
 import sys
 
 f = file(sys.argv[1])
 
 line_cnt = int(f.readline())
 
 
 for number, s in enumerate(f):
 	line = s.split()
 	
 	cntC  = int(line[0])
 	
 	combine = {}
 	for rule in line[1:cntC+1]:
 		combine[Order(rule[:2])] = rule[2]
 	
 	read = cntC+1
 	cntD  = int(line[read])
 	#ruleD = line[read+1:read+1+cntD]
 	oppose = set()
 	for rule in line[read+1:read+1+cntD]:
 		oppose.add(Order(rule))
 		
 	
 	read = read+1+cntD
 	cntN = int(line[read])
 	spell = line[read+1]
 	
 	# print number+1
 	# print '\t', cntC, ruleC
 	# print '\t', cntD, ruleD
 	# print '\t', cntN, elements
 	
 	
 	pos = 1
 	while 1:
 		if pos >= len(spell) or len(spell) < 2:
 			break
 
 		if pos == 0:
 			pos = 1
 			
 		pair = Order(spell[pos-1:pos+1])
 		
 		if pair in combine:
 			spell = spell[:pos-1] + combine[pair] + spell[pos+1:]
 			#pos -= 1
 			continue
 		
 			
 		for pos2 in range(pos-1, -1, -1):
 			pair = Order(spell[pos] + spell[pos2])
 			if pair in oppose:
 				spell = spell[pos+1:]
 				pos = 0
 				#spell = spell[:pos2] + spell[pos+1:]
 				#pos = pos2 - 1
 				break
 			
 		pos += 1
 		
 	if spell:
 		ret = '[' + spell[0]
 		for c in spell[1:]:
 			ret += ', ' + c
 		ret += ']'
 	else:
 		ret = '[]'
 	print 'Case #%d:'%(number+1), ret
 			
 		
 	
 	#print 'Case #%d:'%(number+1), time
",gcj/2011/975485/oonishi/1026487/1/extracted/solve.py,1402,82,193,Python,975485,1,1026487,oonishi,2011
73464,solve.py,"# coding: shift-jis
 
 import sys
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 for case in range(1, test_cnt+1):
 	V, H = map(int, f.readline().split())
 	row = [list(f.readline()[:-1]) for _ in range(V) ] 
 	
 	ret = True
 	for v in range(V):
 		for h in range(H):
 			if row[v][h] == '#':
 				if v == V-1 or h == H-1:
 					ret = False
 					break
 				if row[v][h+1] != '#' or row[v+1][h] != '#' or row[v+1][h+1]!='#':
 					ret = False
 					break
 				
 				row[v][h]     = '/'
 				row[v][h+1]   = '\\'
 				row[v+1][h]   = '\\'
 				row[v+1][h+1] = '/'
 					
 	
 	print 'Case #%d:'%case
 	if ret:
 		for r in row:
 			print reduce(lambda a,b:a+b, r)
 	else:
 		print 'Impossible'
",gcj/2011/1128486/oonishi/1060485/1/extracted/solve.py,704,36,98,Python,1128486,1,1060485,oonishi,2011
73466,solve.py,"# coding: shift-jis
 
 import sys
 
 def Factor(N):
 	ret = []
 	d = 2
 	d2= d**2
 	while N >= d*2:
 		if N % d == 0:
 			ret += [d]
 		d += 1
 	return ret
 
 def Iter(p, it):
 	for i in it:
 		if i % p == 0 or p % i == 0:
 			yield i
 	
 	
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 for case in range(1, test_cnt+1):
 	N, L, H = map(int, f.readline().split())
 	frs = map(int, f.readline().split())
 	
 	it = Iter(frs[0], xrange(L, H+1))
 	for fr in frs[1:]:
 		it = Iter(fr, it)
 	
 	try:
 		val = it.next()
 		ret = True
 	except StopIteration:
 		ret = False
 	if ret:
 		print 'Case #%d:'%case + ' %d'%val
 	else:
 		print 'Case #%d: NO'%case",gcj/2011/1128486/oonishi/1076485/0/extracted/solve.py,664,42,113,Python,1128486,0,1076485,oonishi,2011
105400,solve.py,"# coding: shift-jis
 
 import sys
 
 INF = 0xFFFFFFFF
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 for case in range(test_cnt):
 	C, D = map(int, f.readline().split())
 	
 	vps = [map(int, f.readline().split()) for _ in range(C)]
 	for i in range(C-1, 0, -1):
 		vps[i][0] -= vps[i-1][0]
 	vps[0][0] = D
 		
 	
 	time = 0.0
 	r2   = 0
 	for i in range(C):
 		cnt = vps[i][1]
 		time += float(D*(cnt-1))/2
 		
 		if D > vps[i][0]:
 			d2 = D - vps[i][0]
 		else:#if vps[i][0] >= D
 			r2 += vps[i][0] - D
 			d2 = 0
 		
 		if r2 > d2:
 			r2 -= d2
 		else:
 			time += float(d2-r2)/2
 			r2 = 0
 				
 	print 'Case #%d: '%(case+1) + '%0.7f'%time
",gcj/2011/1150485/oonishi/1058489/0/extracted/solve.py,660,39,100,Python,1150485,0,1058489,oonishi,2011
105401,solve.py,"# coding: shift-jis
 
 import sys
 
 f = file(sys.argv[1])
 
 test_cnt = int(f.readline())
 
 for case in range(test_cnt):
 	n = int(f.readline())
 	res = [list(f.readline()[:-1]) for _ in range(n)]
 	#print res
 	
 	wps = []
 	owps = []
 	#oppcnts = []
 	for team in range(n):
 		win = 0
 		loss= 0
 		
 		# WP
 		for i in range(n):
 			if res[team][i] == '1':
 				win += 1
 			elif res[team][i] == '0':
 				loss += 1
 		wp = float(win)/(loss+win)
 		wps += [wp]
 		#print wp
 		
 		# OWP
 		owp = 0.0
 		oppcnt = 0
 		for i in range(n):
 			if i == team: continue
 			if res[team][i] == '.':
 				continue
 			oppcnt += 1
 			
 			win = 0
 			loss= 0
 			for j in range(n):
 				if j == team: continue
 				if res[i][j] == '1':
 					win += 1
 				elif res[i][j] == '0':
 					loss += 1
 			owp += float(win)/(loss+win)
 		owp /= oppcnt
 		#oppcnts += [oppcnt]
 		
 		owps += [owp]
 		#print owp
 	print 'Case #%d:'%(case+1)
 	for team in range(n):
 		#oowp = (sum(owps) - owps[team])/oppcnts[team]
 		oowp = 0.0
 		oppcnt = 0
 		for i in range(n):
 			if res[team][i] == '.':
 				continue
 			oppcnt += 1
 			oowp += owps[i]
 		oowp /= oppcnt
 			
 		#print wps[team],owps[team],oowp
 		print '%0.7f'%(0.25*wps[team] + 0.5*owps[team] + 0.25*oowp)
 		
",gcj/2011/1150485/oonishi/1048486/1/extracted/solve.py,1257,69,184,Python,1150485,1,1048486,oonishi,2011
14032,solve.py,"# coding: shift-jis
 
 
 
 def solve(s):
 	N = len(s)
 	S = sum(s)
 	A = float(S)*2/N
 	
 	T = [1]*N
 	for i in range(len(s)):
 		if s[i] > A:
 			T[i] = 0
 			
 	N = sum(T)
 	S2 = sum(map(lambda x,y: x*y, s, T))
 	
 	def func(i):
 		if T[i] == 0:
 			return 0.0
 		x = s[i]
 		x = ((S+S2)/N-x)/S*100
 		return x
 	#ret = map(lambda x: (S*2/N-x)/S*100, s)
 	ret = map(func, range(len(s)))
 	#for i in range(len(ret)):
 	#	if ret[i]<0:
 	#		return [100.0]*i + [0.0] + [100.0]*(N-i-1)
 	return ret
 
 if __name__=='__main__':
 	import sys
 	f = file(sys.argv[1])
 	caseCnt = int(f.readline())
 	for case in range(1, caseCnt+1):
 		a = f.readline().split()
 		N = int(a[0])
 		s = map(float, a[1:])
 		
 		answer = solve(s)
 		res = '%0.6f'%answer[0]
 		for r in answer[1:]:
 			res += ' %0.6f'%r
 		print ""Case #%d:""%case, res
 	",gcj/2012/1836486/oonishi/1480487/1/extracted/solve.py,827,45,123,Python,1836486,1,1480487,oonishi,2012
14034,solve.py,"# coding: shift-jis
 
 D = {}
 
 import itertools
 def Iter(Len):
 	for i in range(2, Len):
 		for c in itertools.combinations(range(Len),i):
 			yield c
 
 def calc(target, ex, a):
 	for i in range(len(a)):
 		if i in ex: continue
 		if D[a[i]].has_key(target):
 			return D[a[i]][target]
 		if a[i] == target:
 			D[a[i]][target] = [i]
 			return [i]
 		elif a[i] < target:
 			#target -= a[i]
 			#ex = ex + (i,)
 			ret = calc(target-a[i], ex + (i,), a)
 			if ret:
 				D[a[i]][target] = ret + [i]
 				return ret + [i]
 	for i in range(len(a)):
 		if i in ex: continue
 		D[a[i]][target] = []
 	return []
 			
 def solve(a):
 	S = sum(a)
 	for ex in Iter(len(a)):
 		target = 0
 		for i in ex:
 			target += a[i]
 		if target*2 > S: break
 		ret = calc(target, ex, a)
 		if ret != []:
 			return [map(lambda x: a[x], ex), map(lambda x: a[x], ret)]
 	return []
 
 if __name__=='__main__':
 	import sys
 	f = file(sys.argv[1])
 	caseCnt = int(f.readline())
 	for case in range(1, caseCnt+1):
 		a = map(int, f.readline().split())
 		a = a[1:]
 		a.sort()
 		
 		D = {}
 		for ai in a:
 			D[ai] = {}
 		
 		answer = solve(a)
 		
 		if answer == []:
 			print ""Case #%d: Impossible""%case
 			continue
 		print ""Case #%d:""%case
 		
 		res = '%d'%answer[0][0]
 		for r in answer[0][1:]:
 			res += ' %d'%r
 		print res
 		
 		res = '%d'%answer[1][0]
 		for r in answer[1][1:]:
 			res += ' %d'%r
 		print res
 	",gcj/2012/1836486/oonishi/1484496/0/extracted/solve.py,1412,72,209,Python,1836486,0,1484496,oonishi,2012
64166,solve.py,"# coding: shift-jis
 
 import sys
 f = file(""B-large.in"")
 #f = file(""test.in"")
 #w = sys.stdout
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 for no in range(cnt):
 	l = f.readline()[:-1].split()
 	T, s, p = map(int, l[:3])
 	ts = map(int, l[3:])
 	ns = p*3-2 if p*3-2 > 0 else 0
 	ss = p*3-4 if p*3-4 > 0 else 31
 	l = filter(lambda x: x<ns, ts)
 	c = min([len(filter(lambda x: x>=ss, l)), s])
 	
 	print>>w, ""Case #%d:""%(no+1), T-len(l)+c
 
 
",gcj/2012/1460488/oonishi/1595491/1/extracted/solve.py,460,21,73,Python,1460488,1,1595491,oonishi,2012
64167,solve.py,"# coding: shift-jis
 
 import sys
 f = file(""B-small-attempt0.in"")
 #f = file(""test.in"")
 #w = sys.stdout
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 for no in range(cnt):
 	l = f.readline()[:-1].split()
 	T, s, p = map(int, l[:3])
 	ts = map(int, l[3:])
 	ns = p*3-2 if p*3-2 > 0 else 0
 	ss = p*3-4 if p*3-4 > 0 else 31
 	l = filter(lambda x: x<ns, ts)
 	c = min([len(filter(lambda x: x>=ss, l)), s])
 	
 	print>>w, ""Case #%d:""%(no+1), T-len(l)+c
 
 
",gcj/2012/1460488/oonishi/1595491/0/extracted/solve.py,469,21,73,Python,1460488,0,1595491,oonishi,2012
64168,solve.py,"# coding: shift-jis
 
 import sys
 #f = file(""test.in"")
 #w = sys.stdout
 f = file(""C-small-attempt0.in"")
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 from math import log
 for no in range(cnt):
 	A, B = map(int, f.readline()[:-1].split())
 	
 	count = 0
 	for n in range(A, B):
 		d = int(log(n, 10))+1
 		s = set()
 		for e in range(1, d):
 			c = 10**e
 			r = (n % c)*10**(d-e)
 			b = n / c
 			if r+b>n and r+b<=B and (n, r+b) not in s:
 				s.add((n, r+b))
 				count += 1
 				
 	print>>w, ""Case #%d:""%(no+1), count
 
 
",gcj/2012/1460488/oonishi/1483488/0/extracted/solve.py,543,28,86,Python,1460488,0,1483488,oonishi,2012
64169,solve.py,"# coding: shift-jis
 
 a = ""abcdefghijklmnopqrstuvwxyz""
 d = {}
 for c in a:
 	d[c] = ""*""
 
 i = ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
 o = ""our language is impossible to understand""
 for k, v in zip(i, o):
 	d[k] = v
 i = ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
 o = ""there are twenty six factorial possibilities""
 for k, v in zip(i, o):
 	d[k] = v
 i = ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
 o = ""so it is okay if you want to just give up""
 for k, v in zip(i, o):
 	d[k] = v
 
 
 i = ""y qee""
 o = ""a zoo""
 for k, v in zip(i, o):
 	d[k] = v
 d['z'] = 'q'
 import sys
 f = file(""A-small-attempt1.in"")
 #w = sys.stdout
 w = file(""answer.txt"", ""w"")
 cnt = int(f.readline()[:-1])
 for no in range(cnt):
 	i = f.readline()[:-1]
 	o = """"
 	for k in i:
 		o += d[k]
 	print>>w, ""Case #%d:""%(no+1), o
 
 
",gcj/2012/1460488/oonishi/1483485/0/extracted/solve.py,816,40,157,Python,1460488,0,1483485,oonishi,2012
100760,solve.py,"# coding: shift-jis
 
 from math import sqrt
 
 def solve(X, T, D, A):
 	N = len(X)
 	x = 0.0
 	t = 0.0
 	ans = [0.0]*(N+1)
 	ans[0] = sqrt(2*D/A)
 	for i in range(N):
 		if X[i] <= D:
 			v = sqrt(2*X[i]*A)
 			t = (sqrt(v**2 + 2*A*(D-X[i])) - v)/A
 			ans[i+1] = t + T[i]
 		else:
 			if i != 0:
 				xp = X[i-1]
 				tp = T[i-1]
 			else:
 				xp = 0.0
 				tp = 0.0
 			
 			if T[i]-tp == 0.0:
 				ans[i+1] = tp
 				continue
 				
 			v = (X[i]-xp)/(T[i]-tp)
 			t = (D-xp)/v
 			ans[i+1] = tp + t
 	
 	#print ans
 	return max(ans)
 
 if __name__=='__main__':
 	import sys
 	f = file(sys.argv[1])
 	caseCnt = int(f.readline())
 	for case in range(1, caseCnt+1):
 		l = f.readline().split()
 		D = float(l[0])
 		N = int(l[1])
 		A = int(l[2])
 		x = [0.0]*N
 		t = [0.0]*N
 		for i in range(N):
 			t[i], x[i] = map(float, f.readline().split())
 		a = map(float, f.readline().split())
 		print ""Case #%d:""%case
 		for ai in a:
 			print '%0.6f'%solve(x, t, D, ai)
",gcj/2012/1781488/oonishi/1482492/1/extracted/solve.py,970,52,149,Python,1781488,1,1482492,oonishi,2012
100762,solve.py,"# coding: shift-jis
 
 def dfs(x, r):
 	for i in range(N):
 		if D[x][i]:
 			if P[i] == r: return True
 			P[i] = r
 			if dfs(i, r):
 				return True
 	return False
 			
 
 def solve(x):
 	global P
 	if sum(D[x]) > 1:
 		P = [-1]*N
 		return dfs(x, x)
 	return False
 
 if __name__=='__main__':
 	import sys
 	f = file(sys.argv[1])
 	caseCnt = int(f.readline())
 	for case in range(1, caseCnt+1):
 		N = int(f.readline())
 		D = [[0]*N for _ in range(N)]
 		for i in range(N):
 			a = map(int, f.readline().split()[1:])
 			for ai in a:
 				D[i][ai-1] = 1
 		
 		for i in range(N):
 			ret = solve(i)
 			if ret: break
 		else:
 			ret = False
 		print ""Case #%d:""%case, 'Yes' if ret else 'No'
",gcj/2012/1781488/oonishi/1674486/0/extracted/solve.py,697,38,106,Python,1781488,0,1674486,oonishi,2012
7538,a.py,"# coding: cp932
 
 import sys
 import math
 
 
 f   = file(sys.argv[1])
 out = file(sys.argv[1][:-3] + '.out', 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	name, n = f.readline().split()
 	n = int(n)
 	L = len(name)
 	score = [0]*L
 
 	seq = 0
 	for i in range(L-1, -1, -1):
 		if not name[i] in ('a', 'i', 'u', 'e', 'o'):
 			seq += 1
 		else:
 			seq = 0
 		score[i] = seq
 	pre = 0
 	ans = 0
 	for i in range(L):
 		if score[i] >= n:
 			ans += (i+1-pre)*(L-(i+n-1))
 			pre = i+1
 	print>>out,  'Case #%d:'%case, ans
",gcj/2013/2437488/oonishi/2751486/1/extracted/a.py,550,32,89,Python,2437488,1,2751486,oonishi,2013
7540,c.py,"# coding: cp932
 import sys
 import math
 
 def C(n, k):
 	if n == 0: return 1
 	if k == 0: return 1
 	if k == n: return 1
 
 	val = 1
 	for i in range(k):
 		val *= (n-i)
 	for i in range(1, k+1):
 		val /= i
 	return val
 
 f   = file(sys.argv[1])
 out = file(sys.argv[1][:-3] + '.out', 'w')
 
 caseCnt = int(f.readline())
 
 
 
 for case in range(1, caseCnt+1):
 	N = int(f.readline())
 	tr = []
 	
 	W = []
 	
 	for i in range(N):
 		d, n, w, e, s, dd, dp, ds = map(int, f.readline().split())
 		tr += [(d, n, w, e, s, dd, dp, ds)]
 	tr.sort(lambda l,r:cmp(l[0], r[0]))
 	
 	attack = 0
 	#D = 0
 	while 1:
 		d = tr[0][0]
 		
 		if len(tr) > 1:
 			for i in range(len(tr)):
 				if tr[i][0] > d: break
 			
 			rm = tr[:i]
 			tr = tr[i:]
 		else:
 			rm = [tr[0]]
 			tr = []
 		
 		for i, t in enumerate(rm):
 			t = list(t)
 			try:
 				
 				for w in W:
 					if w[0] > t[2]: raise StopIteration()
 					if w[1] >= t[2] and w[2] >= t[4]:
 						t[2] = w[1]
 						if t[2] >= t[3]: break
 				else:
 					raise StopIteration()
 						
 			except StopIteration:
 				attack += 1
 				#print 'suc', d, i, t
 				pass
 			else:
 				pass
 				#print 'suc', i, t
 				#attack += 1
 				
 		for i, t in enumerate(rm):
 			
 			W += [(t[2], t[3], t[4])]
 			W.sort(lambda l,r: cmp(l[0], r[0]))
 				
 				
 		#print D
 		#for t in rm:
 		#	print '\t', t
 		
 		for t in rm:
 			if t[1] <= 1: continue
 			t = list(t)
 			t[0] += t[5]
 			t[1] -= 1
 			t[2] += t[6]
 			t[3] += t[6]
 			t[4] += t[7]
 			
 			t = tuple(t)
 			for j in range(len(tr)):
 				if tr[j][0]>t[0]:
 					tr = tr[:j] + [t] + tr[j:]
 					break
 			else:
 				tr += [t]
 		if not tr: break
 	#print 'a', attack
 	print>>out, 'Case #%d:'%case, attack",gcj/2013/2437488/oonishi/2755486/0/extracted/c.py,1724,99,280,Python,2437488,0,2755486,oonishi,2013
7541,b.py,"# coding: cp932
 import sys
 import math
 
 f   = file(sys.argv[1])
 out = file(sys.argv[1][:-3] + '.out', 'w')
 
 caseCnt = int(f.readline())
 
 
 
 for case in range(1, caseCnt+1):
 	X, Y = map(int, f.readline().split())
 	
 				
 	if X > 0:
 		ew = 'WE'*X
 	else:
 		ew = 'EW'*-X
 	
 	if Y > 0:
 		ns = 'SN'*Y
 	else:
 		ns = 'NS'*-Y
 	
 	print>>out, 'Case #%d:'%case, ew+ns
 		
 		
 '''
 		s = s[1:]
 		cnt += 1
 		E = (cnt, x+cnt, y, path+'E')
 		W = (cnt, x-cnt, y, path+'W')
 		N = (cnt, x, y+cnt, path+'N')
 		S = (cnt, x, y-cnt, path+'S')
 				
 		e = E
 		if (e[1], e[2]) == (X, Y):
 			break
 		e = W
 		if (e[1], e[2]) == (X, Y):
 			break
 		e = N
 		if (e[1], e[2]) == (X, Y):
 			break
 		e = S
 		if (e[1], e[2]) == (X, Y):
 			break
 			
 		s += [E, W, N, S]
 	print>>out,  'Case #%d:'%case, e[3]
 '''
 	
 	",gcj/2013/2437488/oonishi/2749486/0/extracted/b.py,824,54,137,Python,2437488,0,2749486,oonishi,2013
19028,a.py,"# coding: cp932
 import sys
 import math
 f   = file(sys.argv[1])
 out = file(sys.argv[1][:-3] + '.out', 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	A, N = map(int, f.readline().split())
 	m    = map(int, f.readline().split())
 	
 	assert len(m) == N
 	
 	m.sort()
 	
 	op = 0
 	ops = [N]
 	try:
 		for i, r in enumerate(m):
 			op2 = 0
 			while A <= r:
 				A = 2 * A - 1
 				op2 += 1
 				if op2 >= N - i:
 					op += op2
 					raise StopIteration()
 			op += op2
 			
 			A += r
 			ops += [op + N - i - 1]
 	except StopIteration:
 		pass
 		
 	
 	print>>out, 'Case #%d:'%case, min(ops + [op])
 	
 	#print op
 	
 	#a = 2
 	#b = 2*R - 1
 	#c = T
 	#ans = int(2 * c / (b + math.sqrt(b**2 + 4 * c * a)))
 	#print>>out, 'Case #%d:'%case, ans
 	##while (R+1)**2 - R**2 <= T:
 	##	cnt += 1
 	##	T -= (R+1)**2 - R**2
 	##	R += 2
 	#
 	##print cnt",gcj/2013/2434486/oonishi/2692487/1/extracted/a.py,874,50,157,Python,2434486,1,2692487,oonishi,2013
39480,a.py,"# coding: cp932
 # coding: cp932
 import sys
 import math
 f   = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	R, T = map(int, f.readline().split())
 	cnt = 0
 	
 	a = 2
 	b = 2*R - 1
 	c = T
 	ans = int(2 * c / (b + math.sqrt(b**2 + 4 * c * a)))
 	print>>out, 'Case #%d:'%case, ans
 	#while (R+1)**2 - R**2 <= T:
 	#	cnt += 1
 	#	T -= (R+1)**2 - R**2
 	#	R += 2
 	
 	#print cnt",gcj/2013/2418487/oonishi/2464487/1/extracted/a.py,449,24,85,Python,2418487,1,2464487,oonishi,2013
114366,a-small.py,"# coding: cp932
 import sys
 f   = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	board = [
 		f.readline()[:4],
 		f.readline()[:4],
 		f.readline()[:4],
 		f.readline()[:4],
 	]
 	f.readline()
 	xwin = False
 	owin = False
 	rest = False
 	# 
 	for row in board:
 		if row.replace('T', 'X') == 'XXXX':
 			xwin = True
 		elif row.replace('T', 'O') == 'OOOO':
 			owin = True
 		if '.' in row: rest = True
 	# c
 	for i in range(4):
 		col = ''.join([row[i] for row in board])
 		if col.replace('T', 'X') == 'XXXX':
 			xwin = True
 		elif col.replace('T', 'O') == 'OOOO':
 			owin = True
 	# 
 	up = ''.join([row[i] for i, row in enumerate(board)])
 	if up.replace('T', 'X') == 'XXXX':
 		xwin = True
 	elif up.replace('T', 'O') == 'OOOO':
 		owin = True
 	down = ''.join([row[3-i] for i, row in enumerate(board)])
 	if down.replace('T', 'X') == 'XXXX':
 		xwin = True
 	elif down.replace('T', 'O') == 'OOOO':
 		owin = True
 	
 	assert not (xwin==owin==True)
 	
 	if xwin:
 		result = 'X won'
 	elif owin:
 		result = 'O won'
 	elif rest:
 		result = 'Game has not completed'
 	else:
 		result = 'Draw'
 		
 	print>>out, 'Case #%d:'%case, result
 
 out.close()
",gcj/2013/2270488/oonishi/2453486/1/extracted/a-small.py,1236,59,177,Python,2270488,1,2453486,oonishi,2013
114368,c-small.py,"# coding: cp932
 import sys
 f   = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 Num = [
 	0,
 	1,
 	4,
 	9,
 	121,
 	484,
 	10201,
 	12321,
 	14641,
 	40804,
 	44944,
 	1002001,
 	1234321,
 	4008004,
 	100020001,
 	102030201,
 	104060401,
 	121242121,
 	123454321,
 	125686521,
 	400080004,
 	404090404,
 	10000200001,
 	10221412201,
 	12102420121,
 	12345654321,
 	40000800004,
 	1000002000001,
 	1002003002001,
 	1004006004001,
 	1020304030201,
 	1022325232201,
 	1024348434201,
 	1210024200121,
 	1212225222121,
 	1214428244121,
 	1232346432321,
 	1234567654321,
 	4000008000004,
 	4004009004004,
 ]
 
 for case in range(1, caseCnt+1):
 	L, H = f.readline().split()
 	L = int(L); H = int(H)
 	assert L <= H
 	
 	for i in range(len(Num)):
 		if L <= Num[i]:
 			break
 	else:
 		print>>out, 'Case #%d:'%case, 0
 		continue
 
 	lb = i - 1
 
 	for i in range(1, len(Num)+1):
 		if H >= Num[len(Num)-i]:
 			break
 	else:
 		print>>out, 'Case #%d:'%case, 0
 		continue
 	ub = len(Num)-i
 		
 	print>>out, 'Case #%d:'%case, ub - lb
 
 out.close()
",gcj/2013/2270488/oonishi/2463486/1/extracted/c-small.py,1082,76,124,Python,2270488,1,2463486,oonishi,2013
114370,b-small.py,"# coding: cp932
 import sys
 f   = file(sys.argv[1])
 out = file(sys.argv[2], 'w')
 
 caseCnt = int(f.readline())
 
 for case in range(1, caseCnt+1):
 	V, H = f.readline().split()
 	V = int(V); H = int(H)
 	
 	field = [map(int, list(f.readline().split())) for _ in range(V)]
 	#print field
 	
 	rowMax = [max(row) for row in field]
 	colMax = [max([row[i] for row in field]) for i in range(H)]
 	#print rowMax, colMax
 		
 	result = 'YES'
 	for row in range(V):
 		for col in range(H):
 			if field[row][col] < rowMax[row] and field[row][col] < colMax[col]:
 				result = 'NO'
 				break
 		else:
 			continue
 		break
 	print>>out, 'Case #%d:'%case, result
 
 out.close()
",gcj/2013/2270488/oonishi/2449486/1/extracted/b-small.py,673,31,92,Python,2270488,1,2449486,oonishi,2013
7567,a.py,"# coding: cp932
 
 lines = iter('''
 3
 3 2
 01 11 10
 11 00 10
 2 3
 101 111
 010 001
 2 2
 01 10
 10 01
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 lines = iter(open(r'A-small-attempt1.in').read().splitlines(False))
 out = Out(open('a-small-' + date + '.answer', 'w'))
 
 #lines = iter(open(r'A-large.in').read().splitlines(False))
 #out = Out(open('a-large-' + date + '.answer', 'w'))
 
 
 class OffsetedList:
 	def __init__(me, size, offset, init=0):
 		me.l = [init]*(size+offset)
 		me.offset = offset
 	def __getitem__(me, index):
 		return me.l[index+me.offset]
 	def __setitem__(me, index, value):
 		me.l[index+me.offset] = value
 	
 from collections import namedtuple, defaultdict
 from itertools import count
 
 caseCnt = int(next(lines))
 MAX = (1<<32)-1
 def dfs(L, O, R, m):
 	if m == L:
 		return MAX
 	
 	ret0 = dfs(L, O, R, m+1)
 	
 	new = [0]*len(O)
 	for j, o in enumerate(O):
 		new[j] = o ^ (1<<m)
 	new.sort()
 	if new == R:
 		return 1
 	
 	ret1 = dfs(L, new, R, m+1) + 1
 	return min(ret0, ret1)
 
 def solve(L, O, R):
 	R.sort()
 	O.sort()
 	if R == O: return 0
 	ret = dfs(L,O,R,0)
 	if ret == MAX: return 'NOT POSSIBLE'
 	return ret
 	
 def from_bin(s):
 	return eval('0b'+s)
 	
 
 for case in range(1, caseCnt+1):
 	N,L = map(int, next(lines).split())
 	O   = list(map(from_bin, next(lines).split()))
 	R   = list(map(from_bin, next(lines).split()))
 	#solve(N,X,Y)
 	print('Case #%d:'%(case), solve(L,O,R), file=out)
 	# print()
 	# print()
",gcj/2014/2984486/oonishi/5634947029139456/0/extracted/a.py,1823,92,230,Python,2984486,0,5634947029139456,oonishi,2014
84521,d.py,"# coding: cp932
 
 
 lines = iter('''
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
 '''.splitlines(False)[1:])
 import sys
 out = sys.stdout
 
 sys.setrecursionlimit(1500)
 
 #lines = iter(open(r'D-small-attempt2.in').readlines(False))
 #out = open('d-small.answer', 'w')
 
 lines = iter(open(r'D-large.in').readlines(False))
 out = open('d-large.answer', 'w')
 
 caseCnt = int(next(lines))
 
 def solve(N, K):
 	if N == [] and K == []:
 		return 0
 	if K[-1] > N[-1]:
 		return solve(N[:-1], K[1:])
 	else:
 		return solve(N[:-1], K[:-1])+1
 
 for case in range(1, caseCnt+1):
 	C = int(next(lines))
 	N = sorted(map(float, next(lines).split()), reverse=True)
 	K = sorted(map(float, next(lines).split()), reverse=True)
 	
 	# if C == 1:
 		# if N[0] > K[0]:
 			# print('Case #%d: 1 1'%case, file=out)
 		# else:
 			# print('Case #%d: 0 0'%case, file=out)
 		# continue
 	
 	W=0
 	k = 0
 	for i, n in enumerate(N):
 		if n < K[k]:
 			k += 1
 		else:
 			W += 1
 	
 	D = solve(N, K)
 	print('Case #%d: %d %d'%(case, D, W), file=out)
 	#import pdb;pdb.set_trace()
 	
",gcj/2014/2974486/oonishi/5644738749267968/1/extracted/d.py,1203,64,166,Python,2974486,1,5644738749267968,oonishi,2014
84522,d.py,"# coding: cp932
 
 
 lines = iter('''
 4
 1
 0.5
 0.6
 2
 0.7 0.2
 0.8 0.3
 3
 0.5 0.1 0.9
 0.6 0.4 0.3
 9
 0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
 0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
 '''.splitlines(False)[1:])
 import sys
 out = sys.stdout
 
 sys.setrecursionlimit(1500)
 
 lines = iter(open(r'D-small-attempt2.in').readlines(False))
 out = open('d-small.answer', 'w')
 
 #lines = iter(open(r'D-large.in').readlines(False))
 #out = open('d-large.answer', 'w')
 
 caseCnt = int(next(lines))
 
 def solve(N, K):
 	if N == [] and K == []:
 		return 0
 	if K[-1] > N[-1]:
 		return solve(N[:-1], K[1:])
 	else:
 		return solve(N[:-1], K[:-1])+1
 
 for case in range(1, caseCnt+1):
 	C = int(next(lines))
 	N = sorted(map(float, next(lines).split()), reverse=True)
 	K = sorted(map(float, next(lines).split()), reverse=True)
 	
 	# if C == 1:
 		# if N[0] > K[0]:
 			# print('Case #%d: 1 1'%case, file=out)
 		# else:
 			# print('Case #%d: 0 0'%case, file=out)
 		# continue
 	
 	W=0
 	k = 0
 	for i, n in enumerate(N):
 		if n < K[k]:
 			k += 1
 		else:
 			W += 1
 	
 	D = solve(N, K)
 	print('Case #%d: %d %d'%(case, D, W), file=out)
 	#import pdb;pdb.set_trace()
 	
",gcj/2014/2974486/oonishi/5644738749267968/0/extracted/d.py,1203,64,166,Python,2974486,0,5644738749267968,oonishi,2014
84523,b.py,"# coding: cp932
 
 
 lines = iter('''
 5
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
 100.0 1.0 100000.0
 '''.splitlines(False)[1:])
 import sys
 out = sys.stdout
 
 lines = iter(open(r'B-large.in').readlines(False))
 out = open('b-large.answer', 'w')
 
 caseCnt = int(next(lines))
 
 for case in range(1, caseCnt+1):
 	C, F, X = map(float, next(lines).split())
 	
 	v = 2.0
 	total = 0.0
 	goal = X/v
 	while 1:
 		farm = C/v + total
 		if farm >= goal:
 			answer = goal
 			break
 		v += F
 		total = farm
 		if goal > X/v + total:
 			goal = X/v + total	
 	print('Case #%d: %0.6lf'%(case, answer), file=out)
 	#import pdb;pdb.set_trace()
 	
 
",gcj/2014/2974486/oonishi/5709773144064000/1/extracted/b.py,680,39,97,Python,2974486,1,5709773144064000,oonishi,2014
84524,b.py,"# coding: cp932
 
 
 lines = iter('''
 5
 30.0 1.0 2.0
 30.0 2.0 100.0
 30.50000 3.14159 1999.19990
 500.0 4.0 2000.0
 100.0 1.0 100000.0
 '''.splitlines(False)[1:])
 
 lines = iter(open(r'B-small-attempt0.in').readlines(False))
 
 caseCnt = int(next(lines))
 
 for case in range(1, caseCnt+1):
 	C, F, X = map(float, next(lines).split())
 	
 	v = 2.0
 	total = 0.0
 	goal = X/v
 	while 1:
 		farm = C/v + total
 		if farm >= goal:
 			answer = goal
 			break
 		v += F
 		total = farm
 		if goal > X/v + total:
 			goal = X/v + total	
 	print('Case #%d: %0.6lf'%(case, answer))
 	#import pdb;pdb.set_trace()
 	
 
",gcj/2014/2974486/oonishi/5709773144064000/0/extracted/b.py,614,36,87,Python,2974486,0,5709773144064000,oonishi,2014
84525,c.py,"# coding: cp932
 
 lines = iter('''
 13
 5 5 23
 3 1 1
 1 3 1
 2 2 1
 4 7 3
 10 10 82
 10 1 4
 1 10 5
 2 10 8
 10 2 8
 2 10 9
 10 2 7
 5 3 3
 '''.splitlines(False)[1:])
 import sys
 out = sys.stdout
 
 sys.setrecursionlimit(1500)
 
 
 class MyException(Exception):
 	pass
 #lines = iter(open(r'C-small-attempt7.in').readlines(False))
 #out = open('c-small.answer', 'w')
 
 lines = iter(open(r'C-large.in').readlines(False))
 out = open('c-large.answer', 'w')
 def solve(C, R, M):
 	board = [['.']*C for _ in range(R)]
 	board[-1][-1] = 'c'
 	try:
 		for r in range(R-2):
 			for c in range(C-2):
 				if r == R-3 and c == C-3:
 					raise StopIteration()
 				board[r][c] = '*'
 				M -= 1
 				if M == 0:
 					return board 
 	except StopIteration:
 		pass
 		
 	if M % 2 == 0:
 		for r in range(R-3):
 			board[r][C-1] = '*'
 			board[r][C-2] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		for c in range(C-3):
 			board[R-1][c] = '*'
 			board[R-2][c] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		
 		
 		raise MyException()
 	else:
 		board[R-3][C-3] = '*'
 		M -= 1
 		if M == 0:
 			return board
 		for r in range(R-2):
 			board[r][C-1] = '*'
 			board[r][C-2] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		for c in range(C-2):
 			board[R-1][c] = '*'
 			board[R-2][c] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		
 		raise MyException()
 		
 	
 caseCnt = int(next(lines))
 
 for case in range(1, caseCnt+1):
 	R,C,M = map(int, next(lines).split())
 	
 	print('Case #%d:'%case, file=out)
 	if M == 0:
 		print('c' + '.'*(C-1), file=out)
 		for _ in range(R-1):
 			print('.'*C, file=out)
 	elif R*C==M+1:
 		print('c' + '*'*(C-1), file=out)
 		for _ in range(R-1):
 			print('*'*C, file=out)
 	elif C == 1 and R == 1:
 		print('Impossible', file=out)
 	elif C == 1:
 		if M > R-1:
 			print('Impossible', file=out)
 		else:
 			print('c', file=out)
 			for _ in range(R-M-1):
 				print('.', file=out)
 			for _ in range(M):
 				print('*', file=out)
 	elif R == 1:
 		if M > C-1:
 			print('Impossible', file=out)
 		else:
 			print('c' + '.'*(C-M-1) + '*'*M, file=out)
 	elif C == 2:
 		if M %2 or M//2 > R-2:
 			print('Impossible', file=out)
 		else:
 			print('c.', file=out)
 			for _ in range(R-M//2-1):
 				print('..', file=out)
 			for _ in range(M//2):
 				print('**', file=out)
 	elif R == 2:
 		if M %2 or M//2 > C-2:
 			print('Impossible', file=out)
 		else:
 			print('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)
 			print(      '.'*(C-M//2)   + '*'*(M//2), file=out)
 	elif M > R*C-4:
 		print('Impossible', file=out)
 	else:
 		try:
 			board = solve(C, R, M)
 			for line in board:
 				print(''.join(line), file=out)
 		except MyException:
 			print('Impossible', file=out)
 	# if C == 1:
 		# if N[0] > K[0]:
 			# print('Case #%d: 1 1'%case, file=out)
 		# else:
 			# print('Case #%d: 0 0'%case, file=out)
 		# continue
 	
 	#import pdb;pdb.set_trace()
 	
",gcj/2014/2974486/oonishi/5690574640250880/1/extracted/c.py,2917,147,414,Python,2974486,1,5690574640250880,oonishi,2014
84526,c.py,"# coding: cp932
 
 lines = iter('''
 13
 5 5 23
 3 1 1
 1 3 1
 2 2 1
 4 7 3
 10 10 82
 10 1 4
 1 10 5
 2 10 8
 10 2 8
 2 10 9
 10 2 7
 5 3 3
 '''.splitlines(False)[1:])
 import sys
 out = sys.stdout
 
 sys.setrecursionlimit(1500)
 
 
 class MyException(Exception):
 	pass
 lines = iter(open(r'C-small-attempt7.in').readlines(False))
 out = open('c-small.answer', 'w')
 
 #lines = iter(open(r'C-large.in').readlines(False))
 #out = open('c-large.answer', 'w')
 def solve(C, R, M):
 	board = [['.']*C for _ in range(R)]
 	board[-1][-1] = 'c'
 	try:
 		for r in range(R-2):
 			for c in range(C-2):
 				if r == R-3 and c == C-3:
 					raise StopIteration()
 				board[r][c] = '*'
 				M -= 1
 				if M == 0:
 					return board 
 	except StopIteration:
 		pass
 		
 	if M % 2 == 0:
 		for r in range(R-3):
 			board[r][C-1] = '*'
 			board[r][C-2] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		for c in range(C-3):
 			board[R-1][c] = '*'
 			board[R-2][c] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		
 		
 		raise MyException()
 	else:
 		board[R-3][C-3] = '*'
 		M -= 1
 		if M == 0:
 			return board
 		for r in range(R-2):
 			board[r][C-1] = '*'
 			board[r][C-2] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		for c in range(C-2):
 			board[R-1][c] = '*'
 			board[R-2][c] = '*'
 			M -= 2
 			if M == 0:
 				return board
 		
 		raise MyException()
 		
 	
 caseCnt = int(next(lines))
 
 for case in range(1, caseCnt+1):
 	R,C,M = map(int, next(lines).split())
 	
 	print('Case #%d:'%case, file=out)
 	if M == 0:
 		print('c' + '.'*(C-1), file=out)
 		for _ in range(R-1):
 			print('.'*C, file=out)
 	elif R*C==M+1:
 		print('c' + '*'*(C-1), file=out)
 		for _ in range(R-1):
 			print('*'*C, file=out)
 	elif C == 1 and R == 1:
 		print('Impossible', file=out)
 	elif C == 1:
 		if M > R-1:
 			print('Impossible', file=out)
 		else:
 			print('c', file=out)
 			for _ in range(R-M-1):
 				print('.', file=out)
 			for _ in range(M):
 				print('*', file=out)
 	elif R == 1:
 		if M > C-1:
 			print('Impossible', file=out)
 		else:
 			print('c' + '.'*(C-M-1) + '*'*M, file=out)
 	elif C == 2:
 		if M %2 or M//2 > R-2:
 			print('Impossible', file=out)
 		else:
 			print('c.', file=out)
 			for _ in range(R-M//2-1):
 				print('..', file=out)
 			for _ in range(M//2):
 				print('**', file=out)
 	elif R == 2:
 		if M %2 or M//2 > C-2:
 			print('Impossible', file=out)
 		else:
 			print('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)
 			print(      '.'*(C-M//2)   + '*'*(M//2), file=out)
 	elif M > R*C-4:
 		print('Impossible', file=out)
 	else:
 		try:
 			board = solve(C, R, M)
 			for line in board:
 				print(''.join(line), file=out)
 		except MyException:
 			print('Impossible', file=out)
 	# if C == 1:
 		# if N[0] > K[0]:
 			# print('Case #%d: 1 1'%case, file=out)
 		# else:
 			# print('Case #%d: 0 0'%case, file=out)
 		# continue
 	
 	#import pdb;pdb.set_trace()
 	
",gcj/2014/2974486/oonishi/5690574640250880/0/extracted/c.py,2917,147,414,Python,2974486,0,5690574640250880,oonishi,2014
84527,a.py,"# coding: cp932
 
 #input = open(r'C:\MyDocument\home\gcj\2014-04-12\a.sample')
 input = open(r'C:\MyDocument\home\gcj\2014-04-12\A-small-attempt0.in')
 caseCnt = int(input.readline())
 for caseNo in range(1, caseCnt+1):
 	ans1 = int(input.readline())
 	for i in range(1, 5):
 		line = input.readline()
 		if ans1 == i:
 			candidates = set(map(int, line.split()))
 		
 	ans2 = int(input.readline())
 	for i in range(1, 5):
 		line = input.readline()
 		if ans2 == i:
 			answers = candidates.intersection(set(map(int, line.split())))
 		
 	if len(answers) == 0:
 		print('Case #%d: Volunteer cheated!'%caseNo)
 	elif len(answers) > 1:
 		print('Case #%d: Bad magician!'%caseNo)
 	elif len(answers) == 1:
 		answer = answers.pop()
 		print('Case #%d: %d'%(caseNo, answer))
",gcj/2014/2974486/oonishi/5756407898963968/0/extracted/a.py,773,26,82,Python,2974486,0,5756407898963968,oonishi,2014
126342,a.py,"# coding: cp932
 
 lines = iter('''
 5
 2
 mmaw
 maw
 2
 gcj
 cj
 3
 aaabbb
 ab
 aabb
 2
 abc
 abc
 3
 aabc
 abbc
 abcc
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'A-small-attempt0.in'
 infile = 'A-large.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 
 
 class OffsetedList:
 	def __init__(me, size, offset, init=0):
 		me.l = [init]*(size+offset)
 		me.offset = offset
 	def __getitem__(me, index):
 		return me.l[index+me.offset]
 	def __setitem__(me, index, value):
 		me.l[index+me.offset] = value
 		
 def Choice(n, c):
 	if c == 0: return 1
 	
 	ret = 1
 	div = 2
 	for i in range(n, n-c, -1):
 		ret *= i
 		while ret % div == 0 and div <= c:
 			ret //= div
 			div += 1
 	return ret
 
 	
 from collections import namedtuple, defaultdict
 from itertools import count
 from ctypes import*
 
 
 
 memcpy = cdll.msvcrt.memcpy
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 def equation(a, b, c):
 	right = 1.0e+10
 	left  = -1.0
 	while right-left>1.0e-6:
 		t = (right+left)/2
 		val = a*t*t + b*t + c
 		if val**2 < 1.0e-12:
 			return t
 		elif val > 0:
 			right = t
 		else:
 			left = t
 		#print(t)
 	return left
 MAX = 1<<31		
 def diff(M):
 	V = len(M)
 	H = len(M[0])
 	
 	
 	ans = 0
 	for i in range(H):
 		mn = MAX
 		for j in range(V):
 			s = 0
 			for k in range(V):
 				try:
 					d = M[j][i] - M[k][i]
 				except IndexError:
 					print(j,i,k)
 					print(len(M[0]))
 					print(len(M[1]))
 					raise
 				if d < 0: d = -d
 				s += d
 			mn = min(s, mn)
 		ans += mn
 	return ans
 		
 		
 def solve(S):
 	s = S[0]
 	prev = ''
 	m = []
 	d = []
 	for c in s:
 		if c == prev:
 			m[-1] += 1
 		else:
 			m += [1]
 			d += [c]
 		prev = c
 	M = [m]
 	D = tuple(d)
 
 	for s in S[1:]:
 		prev = ''
 		m    = []
 		di   = -1
 		for c in s:
 			if c == prev:
 				m[-1] += 1
 			else:
 				di += 1
 				if di >= len(D) or D[di] != c: return 'Fegla Won'
 				m += [1]
 				
 			prev = c
 		if di != len(D)-1:
 			return 'Fegla Won'
 		M += [m]
 	#print(M, D)
 	
 	return diff(M)
 
 	
 	
 	
 #print(solve(13, 1, 3))
 caseCnt = int(next(lines))
 
 class C:
 	def __init__(me, cnt, typ):
 		me.cnt = cnt
 		me.typ = typ
 	def __repr__(me):
 		return 'C(%d,%d)'%(me.cnt, me.typ)
 
 for case in range(1, caseCnt+1):
 	(N,) = map(int, next(lines).split())
 	S = []
 	for _ in range(N):
 		S += [next(lines).split()[0]]
 	#import pdb;pdb.set_trace()
 	print('Case #%d:'%(case), solve(S), file=out)
 
",gcj/2014/2994486/oonishi/5751500831719424/1/extracted/a.py,2892,182,425,Python,2994486,1,5751500831719424,oonishi,2014
126343,a.py,"# coding: cp932
 
 lines = iter('''
 5
 2
 mmaw
 maw
 2
 gcj
 cj
 3
 aaabbb
 ab
 aabb
 2
 abc
 abc
 3
 aabc
 abbc
 abcc
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'A-small-attempt0.in'
 #infile = 'C-large-practice.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 
 
 class OffsetedList:
 	def __init__(me, size, offset, init=0):
 		me.l = [init]*(size+offset)
 		me.offset = offset
 	def __getitem__(me, index):
 		return me.l[index+me.offset]
 	def __setitem__(me, index, value):
 		me.l[index+me.offset] = value
 		
 def Choice(n, c):
 	if c == 0: return 1
 	
 	ret = 1
 	div = 2
 	for i in range(n, n-c, -1):
 		ret *= i
 		while ret % div == 0 and div <= c:
 			ret //= div
 			div += 1
 	return ret
 
 	
 from collections import namedtuple, defaultdict
 from itertools import count
 from ctypes import*
 
 
 
 memcpy = cdll.msvcrt.memcpy
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 def equation(a, b, c):
 	right = 1.0e+10
 	left  = -1.0
 	while right-left>1.0e-6:
 		t = (right+left)/2
 		val = a*t*t + b*t + c
 		if val**2 < 1.0e-12:
 			return t
 		elif val > 0:
 			right = t
 		else:
 			left = t
 		#print(t)
 	return left
 MAX = 1<<31		
 def diff(M):
 	V = len(M)
 	H = len(M[0])
 	
 	
 	ans = 0
 	for i in range(H):
 		mn = MAX
 		for j in range(V):
 			s = 0
 			for k in range(V):
 				try:
 					d = M[j][i] - M[k][i]
 				except IndexError:
 					print(j,i,k)
 					print(len(M[0]))
 					print(len(M[1]))
 					raise
 				if d < 0: d = -d
 				s += d
 			mn = min(s, mn)
 		ans += mn
 	return ans
 		
 		
 def solve(S):
 	s = S[0]
 	prev = ''
 	m = []
 	d = []
 	for c in s:
 		if c == prev:
 			m[-1] += 1
 		else:
 			m += [1]
 			d += [c]
 		prev = c
 	M = [m]
 	D = tuple(d)
 
 	for s in S[1:]:
 		prev = ''
 		m    = []
 		di   = -1
 		for c in s:
 			if c == prev:
 				m[-1] += 1
 			else:
 				di += 1
 				if di >= len(D) or D[di] != c: return 'Fegla Won'
 				m += [1]
 				
 			prev = c
 		if di != len(D)-1:
 			return 'Fegla Won'
 		M += [m]
 	#print(M, D)
 	
 	return diff(M)
 
 	
 	
 	
 #print(solve(13, 1, 3))
 caseCnt = int(next(lines))
 
 class C:
 	def __init__(me, cnt, typ):
 		me.cnt = cnt
 		me.typ = typ
 	def __repr__(me):
 		return 'C(%d,%d)'%(me.cnt, me.typ)
 
 for case in range(1, caseCnt+1):
 	(N,) = map(int, next(lines).split())
 	S = []
 	for _ in range(N):
 		S += [next(lines).split()[0]]
 	#import pdb;pdb.set_trace()
 	print('Case #%d:'%(case), solve(S), file=out)
 
",gcj/2014/2994486/oonishi/5751500831719424/0/extracted/a.py,2902,182,425,Python,2994486,0,5751500831719424,oonishi,2014
126344,c.py,"# coding: cp932
 
 lines = iter('''
 4
 3 2
 10001
 20000
 10000
 1 2
 2 3
 5 4
 36642
 28444
 50012
 29651
 10953
 1 4
 2 3
 2 5
 4 5
 5 5
 36642
 28444
 50012
 29651
 10953
 1 2
 1 4
 2 3
 2 5
 4 5
 6 6
 10001
 10002
 10003
 10004
 10005
 10006
 1 2
 1 6
 2 3
 2 4
 3 5
 4 5
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'C-small-attempt0.in'
 #infile = 'C-large-practice.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 
 
 class OffsetedList:
 	def __init__(me, size, offset, init=0):
 		me.l = [init]*(size+offset)
 		me.offset = offset
 	def __getitem__(me, index):
 		return me.l[index+me.offset]
 	def __setitem__(me, index, value):
 		me.l[index+me.offset] = value
 		
 def Choice(n, c):
 	if c == 0: return 1
 	
 	ret = 1
 	div = 2
 	for i in range(n, n-c, -1):
 		ret *= i
 		while ret % div == 0 and div <= c:
 			ret //= div
 			div += 1
 	return ret
 
 	
 from collections import namedtuple, defaultdict
 from itertools import count
 from ctypes import*
 
 
 
 memcpy = cdll.msvcrt.memcpy
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 def equation(a, b, c):
 	right = 1.0e+10
 	left  = -1.0
 	while right-left>1.0e-6:
 		t = (right+left)/2
 		val = a*t*t + b*t + c
 		if val**2 < 1.0e-12:
 			return t
 		elif val > 0:
 			right = t
 		else:
 			left = t
 		#print(t)
 	return left
 	
 # def check(a, F):
 	# if not a:
 		
 	
 	# for i, f in enumerate(F):
 		# if f[0] == a[0] and f[1] == a[1]:
 			# if check(a[1:], F[:i] + F[i+1:]):
 				# return True
 			# else:
 				
 		# elif f[1] == a[0] and f[0] == a[1]:
 			# if check(a[1:], F[:i] + F[i+1:]):
 				# return False
 	# else:
 		# return False
 		
 # def wark(n, l, Z, G):
 	# if l: return []
 	
 	# #G[l[0]].sort(key=lambda n:Z[n])
 	# if l[1] in G[l[0]]:
 		# dst = l[1:]
 		# while dst:
 			# new = wark(l[0], dst, Z, G)
 			# if new == dst:
 	# else:
 		# return l
 	
 # def walk(n, l, G):
 	# if l[1] in G[l[0]]:
 		# l = walk(l[0], l[1:], G):
 		
 	# elif l[1] in G[n]:
 		# walk(n, l[1:], G):
 	# else:
 		# return l[1:]
 		
 def walk(n, l, G):
 	if not l: return []
 	while l[0] in G[n]:
 		l = walk(l[0], l[1:], G)
 		if not l:
 			return []
 	else:
 		return l
 		
 	
 
 def ascending(l):
 	if not l:
 		yield []
 		return 
 	for i, n in enumerate(l):
 		for a in ascending(l[:i] + l[i+1:]):
 			yield [n] + a
 	
 def solve(Z,F):
 	G = defaultdict(list)
 	for f in F:
 		G[f[0]] += [f[1]]
 		G[f[1]] += [f[0]]
 	
 	
 	l = list(range(len(Z)))
 	l.sort(key=lambda n:Z[n])
 	for a in ascending(l):
 		l = walk(a[0], a[1:], G)
 		if not l:
 			return ''.join([Z[n] for n in a])
 			#a = wark(a[0], a[1:], G, set())
 	raise Exception()
 	
 	
 	
 #print(solve(13, 1, 3))
 caseCnt = int(next(lines))
 
 class C:
 	def __init__(me, cnt, typ):
 		me.cnt = cnt
 		me.typ = typ
 	def __repr__(me):
 		return 'C(%d,%d)'%(me.cnt, me.typ)
 
 for case in range(1, caseCnt+1):
 	N,M = map(int, next(lines).split())
 	Z = []
 	for _ in range(N):
 		Z += [next(lines).split()[0]]
 	F = []
 	for _ in range(M):
 		x, y = map(int, next(lines).split())
 		F += [(x-1, y-1)]
 	#print(N,M,Z,F)
 	
 	print('Case #%d:'%(case), solve(Z,F), file=out)
 
",gcj/2014/2994486/oonishi/5731331665297408/0/extracted/c.py,3582,221,546,Python,2994486,0,5731331665297408,oonishi,2014
126345,b.py,"# coding: cp932
 
 lines = iter('''
 5
 3 4 2
 4 5 2
 7 8 5
 45 56 35
 103 143 88
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'B-small-attempt0.in'
 #infile = 'C-large-practice.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 
 
 class OffsetedList:
 	def __init__(me, size, offset, init=0):
 		me.l = [init]*(size+offset)
 		me.offset = offset
 	def __getitem__(me, index):
 		return me.l[index+me.offset]
 	def __setitem__(me, index, value):
 		me.l[index+me.offset] = value
 		
 def Choice(n, c):
 	if c == 0: return 1
 	
 	ret = 1
 	div = 2
 	for i in range(n, n-c, -1):
 		ret *= i
 		while ret % div == 0 and div <= c:
 			ret //= div
 			div += 1
 	return ret
 
 	
 from collections import namedtuple, defaultdict
 from itertools import count
 from ctypes import*
 
 
 
 memcpy = cdll.msvcrt.memcpy
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 def equation(a, b, c):
 	right = 1.0e+10
 	left  = -1.0
 	while right-left>1.0e-6:
 		t = (right+left)/2
 		val = a*t*t + b*t + c
 		if val**2 < 1.0e-12:
 			return t
 		elif val > 0:
 			right = t
 		else:
 			left = t
 		#print(t)
 	return left
 			
 
 		
 		
 def solve(A,B,K):
 	cnt = 0
 	for a in range(A):
 		for b in range(B):
 			if a&b < K:
 				cnt += 1
 	return cnt
 
 	
 	
 	
 #print(solve(13, 1, 3))
 caseCnt = int(next(lines))
 
 class C:
 	def __init__(me, cnt, typ):
 		me.cnt = cnt
 		me.typ = typ
 	def __repr__(me):
 		return 'C(%d,%d)'%(me.cnt, me.typ)
 
 for case in range(1, caseCnt+1):
 	A,B,K = map(int, next(lines).split())
 	#import pdb;pdb.set_trace()
 	print('Case #%d:'%(case), solve(A,B,K), file=out)
 
",gcj/2014/2994486/oonishi/5658282861527040/0/extracted/b.py,2062,118,272,Python,2994486,0,5658282861527040,oonishi,2014
154227,b.py,"
 # coding: cp932
 
 lines = iter('''
 2
 3
 1 2 3
 5
 1 8 10 3 7
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'B-small-attempt2.in'
 infile = 'B-large.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 import time
 from collections import namedtuple, defaultdict
 from itertools import count, product, combinations
 from ctypes import*
 
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 from math import log, cos, sin
 import time
 import inspect
 
 #print(setup(3, 4))
 
 MIN = -float('inf')
 MAX = float('inf')
 
 def gdc(P,Q):
 	r = P%Q
 	if r == 0:
 		return Q
 	return gdc(Q,r)
 	
 	
 		
 
 #T = Union(100)
 #print(T.top(1))
 #print(T.tail(1))
 #T.combine(1,0)
 #print(T.top(1))
 #print(T.tail(1))
 
 ie = enumerate
 ir = range
 ic = combinations
 ip = product
 
 def count(L):
 	#X = sorted(L)
 	cnt = 0
 	while L:
 		I = list(ir(len(L)))
 		x = min(I, key=lambda n:L[n])
 		cnt += x
 		L = L[:x] + L[x+1:]
 		#print(L)
 		
 	return cnt
 		
 		
 #print(count([3,1,2,0]))
 #exit()
 def solve(N,A):
 	if case == 12: import pdb;pdb.set_trace()
 	X = list(ir(N))
 	#X.sort(key=lambda n:A[n], reverse=True)
 	#print(X, [A[x] for x in X])
 	#count(X)
 	x = max(X, key=lambda n:A[n])
 	print(A)
 	#print(x, A[x])
 	#for i in 
 	#count(A[:x]) + count(A[x+1][::-1])
 	
 	X = A[x]
 	mid = N // 2
 	cnt = abs(x-mid)
 	#A = A[:x] + A[x+1:]
 	#left  = A[:len(A)//2]
 	#right = A[len(A)//2:][::-1]
 	
 	ans = MAX
 	for i in ir(N):
 		cnt = abs(x-i)
 		if i == x:
 			left = A[:i]
 			right= A[i+1:][::-1]
 		elif i< x:
 			a = A[:x] + A[x+1:]
 			left = a[:i]
 			right= a[i:][::-1]
 		else: # i > x
 			a = A[:x] + A[x+1:]
 			left = a[:i-1]
 			right= a[i-1:][::-1]
 		t = count(left) + cnt + count(right)
 		#print(t, i, right, left)
 		ans = min(ans, t)
 	#print(ans)
 	return ans
 			
 	A = A[:x] + A[x+1:]
 	left  = A[:len(A)//2]
 	right = A[len(A)//2:][::-1]
 	
 	
 	return count(left) + cnt + count(right)
 	#A = A[:x] + A[x+1:]
 	#N = len(A)
 	mn = MAX
 	for n in range(1<<N):
 		a = deepcopy(A)
 		for j in range(N):
 			if (n>>j)&1:
 				a[j] = X*10-a[j]
 		mn = min(count(a), mn)
 	return mn
 	
 def solve(N,A):
 	ans = 0
 	#if case == 12: import pdb;pdb.set_trace()
 	while A:
 		N = len(A)
 		L = list(ir(N))
 		x = min(L, key= lambda n:A[n])
 		if x == 0 or x == N-1:
 			A = A[:x]+ A[x+1:]
 			continue
 			
 		a = min(N - x - 1, x)
 		ans += a
 		A = A[:x]+ A[x+1:]
 	return ans
 
 #dll = cdll.LoadLibrary(r'x64\Release\c.dll')
 #dll.solve.restype = c_int
 #dll.solve.argtypes= (c_int,c_int,c_int,CFUNCTYPE(None, c_void_p))
 
 caseCnt = int(next(lines))
 for case in range(1, caseCnt+1):
 	(N,) = map(int, next(lines).split())
 	(*A,) = map(int, next(lines).split())
 	start = time.time()
 	print('Case #%d:'%(case), solve(N,A), file=out)
 	print(time.time()-start)
 
",gcj/2014/3014486/oonishi/5721094409420800/1/extracted/b.py,3247,176,441,Python,3014486,1,5721094409420800,oonishi,2014
154228,b.py,"
 # coding: cp932
 
 lines = iter('''
 2
 3
 1 2 3
 5
 1 8 10 3 7
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'B-small-attempt2.in'
 #infile = 'B-large-practice.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 import time
 from collections import namedtuple, defaultdict
 from itertools import count, product, combinations
 from ctypes import*
 
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 from math import log, cos, sin
 import time
 import inspect
 
 #print(setup(3, 4))
 
 MIN = -float('inf')
 MAX = float('inf')
 
 def gdc(P,Q):
 	r = P%Q
 	if r == 0:
 		return Q
 	return gdc(Q,r)
 	
 	
 		
 
 #T = Union(100)
 #print(T.top(1))
 #print(T.tail(1))
 #T.combine(1,0)
 #print(T.top(1))
 #print(T.tail(1))
 
 ie = enumerate
 ir = range
 ic = combinations
 ip = product
 
 def count(L):
 	#X = sorted(L)
 	cnt = 0
 	while L:
 		I = list(ir(len(L)))
 		x = min(I, key=lambda n:L[n])
 		cnt += x
 		L = L[:x] + L[x+1:]
 		#print(L)
 		
 	return cnt
 		
 		
 #print(count([3,1,2,0]))
 #exit()
 def solve(N,A):
 	X = list(ir(N))
 	#X.sort(key=lambda n:A[n], reverse=True)
 	#print(X, [A[x] for x in X])
 	#count(X)
 	x = max(X, key=lambda n:A[n])
 	print(A)
 	print(x, A[x])
 	#for i in 
 	#count(A[:x]) + count(A[x+1][::-1])
 	X = A[x]
 	#A = A[:x] + A[x+1:]
 	#N = len(A)
 	mn = MAX
 	for n in range(1<<N):
 		a = deepcopy(A)
 		for j in range(N):
 			if (n>>j)&1:
 				a[j] = X*10-a[j]
 		mn = min(count(a), mn)
 	return mn
 
 #dll = cdll.LoadLibrary(r'x64\Release\c.dll')
 #dll.solve.restype = c_int
 #dll.solve.argtypes= (c_int,c_int,c_int,CFUNCTYPE(None, c_void_p))
 
 caseCnt = int(next(lines))
 for case in range(1, caseCnt+1):
 	(N,) = map(int, next(lines).split())
 	(*A,) = map(int, next(lines).split())
 	start = time.time()
 	print('Case #%d:'%(case), solve(N,A), file=out)
 	print(time.time()-start)
 
",gcj/2014/3014486/oonishi/5721094409420800/0/extracted/b.py,2288,126,279,Python,3014486,0,5721094409420800,oonishi,2014
154229,d.py,"
 # coding: cp932
 
 lines = iter('''
 2
 4 2
 AAA
 AAB
 AB
 B
 5 2
 A
 B
 C
 D
 E
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'D-small-attempt0.in'
 #infile = 'B-large-practice.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 import time
 from collections import namedtuple, defaultdict
 from itertools import count, product, combinations
 from ctypes import*
 
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 from math import log, cos, sin
 import time
 import inspect
 
 #print(setup(3, 4))
 
 MIN = -float('inf')
 MAX = float('inf')
 
 def gdc(P,Q):
 	r = P%Q
 	if r == 0:
 		return Q
 	return gdc(Q,r)
 	
 	
 		
 
 #T = Union(100)
 #print(T.top(1))
 #print(T.tail(1))
 #T.combine(1,0)
 #print(T.top(1))
 #print(T.tail(1))
 
 ie = enumerate
 ir = range
 ic = combinations
 ip = product
 
 MOD = 1000000007
 
 def solve(M,N,S):
 	G = [[0]*M for i in ir(M)]
 	for i,j in ic(ir(M), 2):
 		s = S[i]
 		s2= S[j]
 		for n in ir(min(len(s), len(s2))):
 			if s[n] != s2[n]:break
 		else:
 			n += 1
 		G[i][j] = n
 		G[j][i] = n
 	for g in G:print(g)
 	#print(M,N,S)
 def solve(M,N,S):
 	ans = 0
 	cnt = 0
 	used = set()
 	for n in range(N**M):
 		D = [0]*M
 		for i in ir(M):
 			D[i] = n%N
 			n //= N
 
 		#temp = ['']*N
 		#for i,s in ie(S):
 		#	temp[D[i]] += s
 		#temp.sort()
 		#temp = tuple(temp)
 		#if temp in used:
 		#	continue
 		#used.add(temp)
 		
 		#temp = [0]*N
 		#for i in ir(N):
 		#	temp[D[i]] += 1
 		#if 0 in temp: continue
 		
 		T = [set() for _ in ir(N)]
 		for i,s in ie(S):
 			t = T[D[i]]
 			for j,_ in ie(s):
 				t.add(s[:j+1])
 		#print(T)
 		c = sum([len(t)+1 if t else 0 for t in T])
 		if ans < c:
 			ans = c
 			cnt = 1
 		elif ans == c:
 			cnt += 1
 		#ans = max(c,ans)
 	return '%d %d'%(ans, cnt)
 	
 #dll = cdll.LoadLibrary(r'x64\Release\c.dll')
 #dll.solve.restype = c_int
 #dll.solve.argtypes= (c_int,c_int,c_int,CFUNCTYPE(None, c_void_p))
 
 caseCnt = int(next(lines))
 for case in range(1, caseCnt+1):
 	(M,N) = map(int, next(lines).split())
 	S = []
 	for _ in ir(M):
 		(s,) = map(str, next(lines).split())
 		S += [s]
 	start = time.time()
 	print('Case #%d:'%(case), solve(M,N,S), file=out)
 	print(time.time()-start)
 
",gcj/2014/3014486/oonishi/5649687893770240/0/extracted/d.py,2642,153,363,Python,3014486,0,5649687893770240,oonishi,2014
154230,c.py,"
 # coding: cp932
 
 lines = iter('''
 2
 3 3 2
 2 0 2 0
 0 2 0 2
 5 6 4
 1 0 1 0
 3 1 3 3
 0 2 1 3
 1 5 2 5
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'C-small-attempt4.in'
 #infile = 'B-large-practice.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 import time
 from collections import namedtuple, defaultdict
 from itertools import count, product, combinations
 from ctypes import*
 
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 from math import log, cos, sin
 import time
 import inspect
 
 #print(setup(3, 4))
 
 MIN = -float('inf')
 MAX = float('inf')
 
 def gdc(P,Q):
 	r = P%Q
 	if r == 0:
 		return Q
 	return gdc(Q,r)
 	
 	
 		
 
 #T = Union(100)
 #print(T.top(1))
 #print(T.tail(1))
 #T.combine(1,0)
 #print(T.top(1))
 #print(T.tail(1))
 
 ie = enumerate
 ir = range
 ic = combinations
 ip = product
 
 
 def solve(W,H,B,P):
 	print(W,H,B,P)
 	R = [[1]*W for _ in ir(H)]
 	for x0,y0,x1,y1 in P:
 		for x,y in ip(ir(x0,x1+1), ir(y0,y1+1)):
 			R[y][x] = 0
 	#print(R)
 	cnt = 0
 	for j in ir(W):
 		x,y = j,0
 		if R[y][x] == 0: continue
 		while y<H-1:
 			if x > 0 and R[y][x-1] == 1:
 				R[y][x-1] = 0
 				x -= 1
 				continue
 			if R[y+1][x] == 1:
 				R[y+1][x] = 0
 				y += 1
 				continue
 			if x < W-1 and R[y][x+1] == 1:
 				R[y][x+1] = 0
 				x += 1
 				continue
 			break
 		else:
 			cnt += 1
 	return cnt
 #dll = cdll.LoadLibrary(r'x64\Release\c.dll')
 #dll.solve.restype = c_int
 #dll.solve.argtypes= (c_int,c_int,c_int,CFUNCTYPE(None, c_void_p))
 
 caseCnt = int(next(lines))
 for case in range(1, caseCnt+1):
 	(W,H,B) = map(int, next(lines).split())
 	P = []
 	for _ in ir(B):
 		(*a,) = map(int, next(lines).split())
 		P += [a]
 	start = time.time()
 	print('Case #%d:'%(case), solve(W,H,B,P), file=out)
 	print(time.time()-start)
 
",gcj/2014/3014486/oonishi/5158144455999488/0/extracted/c.py,2247,125,301,Python,3014486,0,5158144455999488,oonishi,2014
154231,d.py,"
 # coding: cp932
 
 lines = iter('''
 3
 3 100
 10 20 70
 4 100
 30 40 60 70
 5 100
 10 20 30 40 60
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 infile = 'A-small-attempt0.in'
 infile = 'A-large.in'
 lines = iter(open(infile).read().splitlines(False))
 out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 import time
 from collections import namedtuple, defaultdict
 from itertools import count, product, combinations
 from ctypes import*
 
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 from math import log, cos, sin
 import time
 import inspect
 
 #print(setup(3, 4))
 
 MIN = -float('inf')
 MAX = float('inf')
 
 def gdc(P,Q):
 	r = P%Q
 	if r == 0:
 		return Q
 	return gdc(Q,r)
 	
 	
 		
 
 #T = Union(100)
 #print(T.top(1))
 #print(T.tail(1))
 #T.combine(1,0)
 #print(T.top(1))
 #print(T.tail(1))
 
 ie = enumerate
 ir = range
 ic = combinations
 ip = product
 
 
 def solve(N,X,F):
 	F.sort(reverse=True)
 	#print(N,X,F)
 	cnt = 0
 	while F:
 		cnt += 1
 		f = F.pop()
 		if f > X: raise
 		for i,t in ie(F):
 			if f+t <= X:
 				F = F[:i] + F[i+1:]
 				break
 	return cnt
 #dll = cdll.LoadLibrary(r'x64\Release\c.dll')
 #dll.solve.restype = c_int
 #dll.solve.argtypes= (c_int,c_int,c_int,CFUNCTYPE(None, c_void_p))
 
 caseCnt = int(next(lines))
 for case in range(1, caseCnt+1):
 	(N,X) = map(int, next(lines).split())
 	(*F,) = map(int, next(lines).split())
 	start = time.time()
 	print('Case #%d:'%(case), solve(N,X,F), file=out)
 	print(time.time()-start)
 
",gcj/2014/3014486/oonishi/5737429512224768/1/extracted/d.py,1877,105,227,Python,3014486,1,5737429512224768,oonishi,2014
154232,a.py,"
 # coding: cp932
 
 lines = iter('''
 '''.splitlines(False)[1:])
 
 
 from math import sqrt
 from datetime import datetime
 import sys
 class Out:
 	def __init__(me, f):
 		me.file = f
 	def write(me, *args):
 		sys.stdout.write(*args)
 		me.file.write(*args)
 out = sys.stdout
 #sys.setrecursionlimit(1500)
 
 #from decimal import Decimal, getcontext
 #getcontext().prec = 64
 
 date = datetime.now().strftime('%Y%m%d-%H%M%S')
 
 #infile = 'test.in'
 #infile = 'B-large-practice.in'
 #lines = iter(open(infile).read().splitlines(False))
 #out = Out(open(infile[:-3] + (date + '.answer'), 'w'))
 
 import time
 from collections import namedtuple, defaultdict
 from itertools import count, product, combinations
 from ctypes import*
 
 from copy import deepcopy
 
 MAX = float('inf')
 
 import sys
 sys.setrecursionlimit(1500)
 
 from math import log, cos, sin
 import time
 import inspect
 
 #print(setup(3, 4))
 
 MIN = -float('inf')
 MAX = float('inf')
 
 def gdc(P,Q):
 	r = P%Q
 	if r == 0:
 		return Q
 	return gdc(Q,r)
 	
 	
 		
 
 #T = Union(100)
 #print(T.top(1))
 #print(T.tail(1))
 #T.combine(1,0)
 #print(T.top(1))
 #print(T.tail(1))
 
 ie = enumerate
 ir = range
 ic = combinations
 ip = product
 
 
 def solve(N,A):
 	return cnt
 #dll = cdll.LoadLibrary(r'x64\Release\c.dll')
 #dll.solve.restype = c_int
 #dll.solve.argtypes= (c_int,c_int,c_int,CFUNCTYPE(None, c_void_p))
 
 caseCnt = int(next(lines))
 for case in range(1, caseCnt+1):
 	(N,) = map(int, next(lines).split())
 	A = []
 	for _ in ir(N):
 		(*a,) = map(int, next(lines).split())
 		A += [a]
 	start = time.time()
 	print('Case #%d:'%(case), solve(N,A), file=out)
 	print(time.time()-start)
 
",gcj/2014/3014486/oonishi/5737429512224768/0/extracted/a.py,1670,90,186,Python,3014486,0,5737429512224768,oonishi,2014
15555,b.py,"#coding: cp932
 # 2015 Round1-B Probleb B
 input = iter('''
 4
 2 3 6
 4 1 2
 3 3 8
 5 2 0
 '''.splitlines()[1:])
 import sys
 output = sys.stderr
 
 from ctypes import *
 #cdll.c.solve.restype = c_ulonglong
 
 
 filename = r'B-small-attempt0.in'
 #filename = r'A-large.in'
 input  = open(filename)
 output = open(filename[:-3]+'.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 	
 def solve(R,C,N):
 	best = float('inf')
 	for L in itertools.combinations(range(R*C),N):
 		G = [[0]*C for _ in range(R)]
 		for n in L:
 			G[n//C][n%C] = 1
 		cnt = 0
 		for r in range(R-1):
 			for c in range(C-1):
 				if G[r][c] == 1 and G[r+1][c] == 1:
 					cnt += 1
 				if G[r][c] == 1 and G[r][c+1] == 1:
 					cnt += 1
 		r = R-1	
 		for c in range(C-1):
 			if G[r][c] == 1 and G[r][c+1] == 1:
 				cnt += 1
 				r = R-1	
 		c = C-1
 		for r in range(R-1):
 			if G[r][c] == 1 and G[r+1][c] == 1:
 				cnt += 1
 		best = min(cnt,best)
 	return best
 
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	R,C,N = map(int, next(input).split())
 	answer = solve(R,C,N)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/8224486/oonishi/5769900270288896/0/extracted/b.py,1593,85,248,Python,8224486,0,5769900270288896,oonishi,2015
15556,a.py,"#coding: cp932
 # 2015 Round1-B Probleb A
 input = iter('''
 10
 90
 10
 100
 1000
 1
 19
 23
 101
 1001
 10001
 '''.splitlines()[1:])
 import sys
 output = sys.stderr
 
 from ctypes import *
 #cdll.c.solve.restype = c_ulonglong
 
 inf = float('inf')
 
 filename = r'A-small-attempt7.in'
 #filename = r'A-large.in'
 input  = open(filename)
 output = open(filename[:-3]+'.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 	
 def solve(N):
 	M = 1
 	c = 1
 	for i in range(1,15):
 		if N<M*10:
 			break
 		M *= 10
 		c += 10*(i-1)+9
 	print(N,M,c)
 	if N == M:
 		return c
 		
 	ns = str(N)
 	ms = str(M)
 	for j,_ in enumerate(ns[:-1]):
 		if ms[j] == ns[j]:
 			continue
 		for i in range(9,int(ms[-1])-1,-1):
 			ms2 = ms[:j] + str(i) + ms[j:-1]
 			print('a', j,ns,ms2,c)
 			if ms2<=ns:
 				break
 		c += int(ms2[j]) - int(ms[-1]) + 1
 		print('b', j ,ns,ms2,c)
 		ms = ms2
 	print('c',ns,ms,c)
 	M = int(ms)
 		
 	return c + (N-M)
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 import os
 for caseNo in range(caseCnt):
 	N, = map(int, next(input).split())
 	#ch = os.fork()
 	#print('ch=', ch, os.getpid())
 	#if ch != 0:
 	#	continue
 	answer = solve(N)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 	print('case %d: %lf'%(caseNo,time.time()-st))",gcj/2015/8224486/oonishi/5688567749672960/0/extracted/a.py,1684,101,245,Python,8224486,0,5688567749672960,oonishi,2015
84938,d.py,"#coding: cp932
 # 2015 Qualification Problem D
 input = iter('''
 5
 2 1 2
 2 1 3
 4 4 1
 2 2 2
 3 2 3
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 #input  = open(r'D-small-attempt3.in')
 #output = open(r'D-small-attempt3.out', 'w')
 
 input  = open(r'D-large.in')
 output = open(r'D-large.out', 'w')
 
 
 def solve(X,R,C):
 	if X>=7:
 		return 'RICHARD'
 	if R*C%X:
 		return 'RICHARD'
 	if X>2 and R+C-1<=X:
 		return 'RICHARD'
 	if R>C:
 		C,R=R,C
 		
 	if R<(X+1)//2:
 		return 'RICHARD'
 		
 	if X-R+1 >= R:
 		C,R = R,C
 	
 	if X<C: return 'GABRIEL'
 	
 	K = X-C
 	#import pdb;pdb.set_trace()
 	if K == 0:
 		if C*(R-1) % X == 0:
 			return 'GABRIEL'
 		for r in range(1,R-1):
 			if C*r % X == 0:
 				return 'GABRIEL'
 			if C*(R-r-1) % X == 0:
 				return 'GABRIEL'
 		return 'RICHARD'
 	
 	for k1 in range(K+1):
 		k2 = K-k1
 		for r in range(k1,R-k2):
 			n = C*r - k1
 			m = C*(R-r-1) - k2
 			
 			if n%X == 0 and m%X == 0:
 				break
 		else:
 			return 'RICHARD'
 	return 'GABRIEL'
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	X,R,C = map(int, next(input).split())
 	answer = solve(X,R,C)
 	print(X,R,C)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 print(time.time()-st)",gcj/2015/6224486/oonishi/5658571765186560/1/extracted/d.py,1259,71,179,Python,6224486,1,5658571765186560,oonishi,2015
84939,d.py,"#coding: cp932
 # 2015 Qualification Problem D
 input = iter('''
 5
 2 1 2
 2 1 3
 4 4 1
 2 2 2
 3 2 3
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 input  = open(r'D-small-attempt3.in')
 output = open(r'D-small-attempt3.out', 'w')
 
 #input  = open(r'C-small-practice-2.in')
 #output = open(r'C-large-practice.out', 'w')
 
 
 def solve(X,R,C):
 	if X>=7:
 		return 'RICHARD'
 	if R*C%X:
 		return 'RICHARD'
 	if X>2 and R+C-1<=X:
 		return 'RICHARD'
 	if R>C:
 		C,R=R,C
 		
 	if R<(X+1)//2:
 		return 'RICHARD'
 		
 	if X-R+1 >= R:
 		C,R = R,C
 	
 	if X<C: return 'GABRIEL'
 	
 	K = X-C
 	#import pdb;pdb.set_trace()
 	if K == 0:
 		if C*(R-1) % X == 0:
 			return 'GABRIEL'
 		for r in range(1,R-1):
 			if C*r % X == 0:
 				return 'GABRIEL'
 			if C*(R-r-1) % X == 0:
 				return 'GABRIEL'
 		return 'RICHARD'
 	
 	for k1 in range(K+1):
 		k2 = K-k1
 		for r in range(k1,R-k2):
 			n = C*r - k1
 			m = C*(R-r-1) - k2
 			
 			if n%X == 0 and m%X == 0:
 				break
 		else:
 			return 'RICHARD'
 	return 'GABRIEL'
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	X,R,C = map(int, next(input).split())
 	answer = solve(X,R,C)
 	print(X,R,C)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 print(time.time()-st)",gcj/2015/6224486/oonishi/5658571765186560/0/extracted/d.py,1279,71,179,Python,6224486,0,5658571765186560,oonishi,2015
84940,b.py,"#coding: cp932
 # 2015 Qualification Problem B
 input = iter('''
 6
 4
 8 8 6 1
 1
 4
 5
 4 5 5 5 5
 4
 1 2 1 2
 1
 4
 1
 1000 1000 1000 1000
 4
 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 #input  = open(r'B-small-attempt6.in')
 #output = open(r'B-small-attempt6-2.out', 'w')
 
 input  = open(r'B-large.in')
 output = open(r'B-large.out', 'w')
 
 
 def div(m,d):
 	if d == 1:
 		return (m,)
 		
 	if (m,d) in div.memo:
 		return div.memo[(m,d)]
 		
 	x = (m+d-1)//d
 	res = (x,) + div(m-x, d-1)
 	div.memo[(m,d)] = res
 	return res
 div.memo = {}
 
 
 def solve(D):
 	if D == []:
 		return 0
 	D = sorted(D)
 	N = len(D)
 	
 	cand = [D[-1]]
 	m = D.pop()
 	if m <= 3:
 		return m
 	for d in range(2,max(m//3+1,3)):
 		add = div(m,d)
 		res = solve(D+list(add))+d-1
 		cand += [res]
 	return min(cand)
 
 	
 def bsearch(key, l):
 	if l == []:
 		return 0
 	if len(l) == 1:
 		if key >= l[0]:
 			return 0
 		else:
 			return 1
 	
 	m = len(l)//2
 	
 	
 	if key == l[m]: return m
 	if key < l[m]:
 		return m + bsearch(key, l[m:])
 	if key > l[m]:
 		return bsearch(key, l[:m])
 		
 	raise
 		
 #print(bsearch(11,[10,6,1]))
 #print(bsearch(10,[10,6,1]))
 #print(bsearch( 9,[10,6,1]))
 #print(bsearch( 7,[10,6,1]))
 #print(bsearch( 6,[10,6,1]))
 #print(bsearch( 5,[10,6,1]))
 #print(bsearch( 2,[10,6,1]))
 #print(bsearch( 1,[10,6,1]))
 #print(bsearch( 0,[10,6,1]))
 #print(bsearch( 2,[1]))
 #print(bsearch( 1,[1]))
 #print(bsearch( 0,[1]))
 #raise
 
 def solve(D):
 	D.sort()
 	D.reverse()
 	
 	print(D)
 	
 	M = D[0]
 	L = []
 	
 	for d in D:
 		l = []
 		for v in range(1,M+1):
 			if d <= v:
 				u = 0
 			else:
 				u = d//v - (1 if d%v==0 else 0)
 			
 			l += [u]
 		L += [l]
 	#for l in L:
 	#	print(l)
 	
 	best = M
 	for v in range(1,M+1):
 		divcnt = 0
 		for l in L:
 			divcnt += l[v-1]
 		best = min(best, v+divcnt)
 		
 	
 	return best
 
 
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	d = int(next(input))
 	*D, = map(int, next(input).split())
 	answer = solve(D)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
",gcj/2015/6224486/oonishi/5686275109552128/1/extracted/b.py,4665,135,815,Python,6224486,1,5686275109552128,oonishi,2015
84941,b.py,"#coding: cp932
 # 2015 Qualification Problem B
 input = iter('''
 5
 1
 3
 4
 1 2 1 2
 1
 4
 4
 8 1 8 6
 1
 9
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 input  = open(r'B-small-attempt6.in')
 output = open(r'B-small-attempt6.out', 'w')
 
 #input  = open(r'C-small-practice-2.in')
 #output = open(r'C-large-practice.out', 'w')
 
 
 def div(m,d):
 	if d == 1:
 		return (m,)
 		
 	if (m,d) in div.memo:
 		return div.memo[(m,d)]
 		
 	x = (m+d-1)//d
 	res = (x,) + div(m-x, d-1)
 	div.memo[(m,d)] = res
 	return res
 div.memo = {}
 
 
 def solve(D):
 	if D == []:
 		return 0
 	D = sorted(D)
 	N = len(D)
 	
 	cand = [D[-1]]
 	m = D.pop()
 	if m <= 3:
 		return m
 	for d in range(2,max(m//3+1,3)):
 		add = div(m,d)
 		res = solve(D+list(add))+d-1
 		cand += [res]
 	return min(cand)
 		
 	cnt = 0
 	cand = [D[-1]]
 	while D[-1] > 3:
 		cnt += 1
 		d = D.pop()
 		new = (d+1)//2
 		D += [new, d-new]
 		D.sort()
 		cand += [D[-1]+cnt]
 	print(D)
 	print(cand)
 	return min(cand)
 
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	d = int(next(input))
 	*D, = map(int, next(input).split())
 	answer = solve(D)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
",gcj/2015/6224486/oonishi/5686275109552128/0/extracted/b.py,1192,76,171,Python,6224486,0,5686275109552128,oonishi,2015
84942,c2.py,"#coding: cp932
 # 2015 Qualification Problem C
 
 
 import ctypes
 dll = ctypes.cdll.c
 dll.solve.argtypes = (ctypes.c_char_p, ctypes.c_int, ctypes.c_int)
 dll.hello.argtypes = (ctypes.c_char_p, ctypes.c_int, ctypes.c_int)
 #dll.hello('ijk'.encode(), 32, 88)
 #exit()
 #s = b'kjkjkj'
 #dll.hello(s, len(s), 1);
 #s = b'kjk'
 #dll.hello(s, len(s), 1);
 #s = b'jkjkjkj'
 #dll.hello(s, len(s), 1);
 #s = b'kj'
 #dll.hello(s, len(s), 1);
 #exit()
 input = iter('''
 1
 2 1420
 kj
 2 1
 ik
 3 1
 kji
 2 6
 ji
 1 10000
 i
 2 6
 ji
 2 6
 jijj
 2 1
 ik
 3 1
 ijk
 3 1
 kji
 2 6
 ji
 1 10000
 i
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 #input  = open(r'C-small-attempt0.in')
 #output = open(r'C-small-attempt0-3.out', 'w')
 
 input  = open(r'C-large.in')
 output = open(r'C-large.out', 'w')
 
 M = {
 'h': {'h':('h',0), 'i':('i',0), 'j':('j',0), 'k':('k',0)},
 'i': {'h':('i',0), 'i':('h',1), 'j':('k',0), 'k':('j',1)},
 'j': {'h':('j',0), 'i':('k',1), 'j':('h',1), 'k':('i',0)},
 'k': {'h':('k',0), 'i':('j',0), 'j':('i',1), 'k':('h',1)},
 }
 
 M = [
 	['h','i','j','k'],
 	['i','h','k','j'],
 	['j','k','h','i'],
 	['k','j','i','h'],
 ]
 
 F = [
 	[0,0,0,0],
 	[0,1,0,1],
 	[0,1,1,0],
 	[0,0,1,1],
 ]
 
 def cnv(c, d, f):
 	c2 = M[ord(c)-ord('h')][ord(d)-ord('h')]
 	f2 = F[ord(c)-ord('h')][ord(d)-ord('h')]
 	return c2,(f2+f)%2
 	
 	
 
 def setup(S):
 	global I,K,J
 	L = len(S)
 	I = [('h',0)]
 	
 	ci = 'h'
 	fi = 0
 	for i in range(L-2):
 		ci,fi = cnv(ci,S[i],fi)
 		I += [(ci,fi)]
 	print('yes')	
 	K = [('h',0)]
 	ck = 'h'
 	fk = 0
 	for i in range(L-1,-1,-1):
 		ck,fk = cnv(S[i],ck,fk)
 		K += [(ck,fk)]
 	K.reverse()
 	print('yes')	
 	J = []
 	for i in range(L-1):
 		X = [('h',0)]
 		cj,fj = 'h',0
 		for j in range(i,L):
 			cj,fj = cnv(S[j],cj,fj)
 			X += [(cj,fj)]
 		J += [X]
 	
 	print(I)
 	print(K)
 	#print(J)
 	
 			
 	#print(I)
 	
 def cnvs(s):
 	c = 'h'
 	f = 0
 	for d in s:
 		c,f = cnv(c,d,f)
 	return c,f
 	
 
 def solve(S,X):
 	print(S)
 	setup(S)
 	
 	#S = S*X
 	L = len(S)
 	for xi in range(min(X,4)+1):
 		for xj in range(min(max(X-xi,0),4)+1):
 			for xk in range(min(max(X-xi-xj,0),4)+1):
 				for i in range(1,L-1):
 					ci,fi = I[i]
 					if xj == 0:
 						for j in range(i,L-1):
 							cj,fj = J[i][j-i]
 							ck,fk = K[j]
 							print((ci,fi),(cj,fj),(ck,fk))
 					else:
 						for j in range(L-1):
 							cj1,fj1 = K[i]
 							cj2,fj2 = I[j]
 							ck,fk = K[j]
 							print((ci,fi),(cj,fj),(ck,fk))
 				
 	for i in range(1,L-1):
 		ci,fi = I[i]
 		if ci != 'i' or fi != 0: continue
 		cj,fj = 'h',0
 		for k in range(i+1,L):
 			ck,fk = K[k]
 			
 			
 			cj,fj = cnv(cj,S[k-1],fj)
 			#print(i,k,k-1,S[i:k],cj,fj)
 			if ck != 'k' or fk != 0: continue
 			if cj == 'j' and fj == 0:
 				return 'YES'
 	#raise
 	return 'NO'
 
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	L,X, = map(int, next(input).split())
 	S = next(input).strip()
 	#answer = solve(S,X)
 	#print('Case #%d:'%(caseNo+1), answer, file=output)
 	answer = dll.solve(S.encode(),L,X)
 	print('Case #%d:'%(caseNo+1), 'YES' if answer else 'NO', file=output)
 	
 print(time.time()-st)",gcj/2015/6224486/oonishi/5670465267826688/1/extracted/c2.py,3156,178,407,Python,6224486,1,5670465267826688,oonishi,2015
84944,c.py,"#coding: cp932
 # 2015 Qualification Problem C
 input = iter('''
 5
 2 1
 ik
 3 1
 ijk
 3 1
 kji
 2 6
 ji
 1 10000
 i
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 input  = open(r'C-small-attempt0.in')
 output = open(r'C-small-attempt0.out', 'w')
 
 #input  = open(r'C-small-practice-2.in')
 #output = open(r'C-large-practice.out', 'w')
 
 M = {
 '1': {'1':('1',0), 'i':('i',0), 'j':('j',0), 'k':('k',0)},
 'i': {'1':('i',0), 'i':('1',1), 'j':('k',0), 'k':('j',1)},
 'j': {'1':('j',0), 'i':('k',1), 'j':('1',1), 'k':('i',0)},
 'k': {'1':('k',0), 'i':('j',0), 'j':('i',1), 'k':('1',1)},
 }
 
 def cnv(c, d, f):
 	c2,f2 = M[c][d]
 	return c2,(f2+f)%2
 	
 	
 
 def setup(S):
 	global I,K
 	L = len(S)
 	I = [('1',0)]
 	
 	ci = '1'
 	fi = 0
 	for i in range(L-2):
 		ci,fi = cnv(ci,S[i],fi)
 		I += [(ci,fi)]
 		
 	K = []
 	ck = '1'
 	fk = 0
 	for i in range(L-1,1,-1):
 		ck,fk = cnv(S[i],ck,fk)
 		K += [(ck,fk)]
 	K.reverse()
 	K = [None,None,] + K
 	#print(I)
 	
 def cnvs(s):
 	c = '1'
 	f = 0
 	for d in s:
 		c,f = cnv(c,d,f)
 	return c,f
 	
 
 def solve(S,X):
 	S = S*X
 	setup(S)
 	L = len(S)
 	for i in range(1,L-1):
 		ci,fi = I[i]
 		if ci != 'i' or fi != 0: continue
 		cj,fj = '1',0
 		for k in range(i+1,L):
 			ck,fk = K[k]
 			
 			
 			cj,fj = cnv(cj,S[k-1],fj)
 			#print(i,k,k-1,S[i:k],cj,fj)
 			if ck != 'k' or fk != 0: continue
 			if cj == 'j' and fj == 0:
 				return 'YES'
 	#raise
 	return 'NO'
 
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	L,X, = map(int, next(input).split())
 	S = next(input).strip()
 	answer = solve(S,X)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 print(time.time()-st)",gcj/2015/6224486/oonishi/5670465267826688/0/extracted/c.py,1691,97,236,Python,6224486,0,5670465267826688,oonishi,2015
84945,a.py,"#coding: cp932
 # 2015 Qualification Problem A
 input = iter('''
 4
 4 11111
 1 09
 5 110011
 0 1
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 #input  = open(r'A-small-attempt0.in')
 #output = open(r'A-small-attempt0.out', 'w')
 
 input  = open(r'A-large.in')
 output = open(r'A-large.out', 'w')
 
 def solve(S):
 	stood = S[0]
 	
 	res = 0
 	for need,cnt in enumerate(S[1:], 1):
 		if need > stood:
 			add = need - stood
 			stood += add
 			res += add
 		stood += cnt
 	return res
 		
 
 
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	_,S = next(input).split()
 	*S, = map(int, S)
 	answer = solve(S)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
",gcj/2015/6224486/oonishi/5639104758808576/1/extracted/a.py,689,40,93,Python,6224486,1,5639104758808576,oonishi,2015
84946,a.py,"#coding: cp932
 # 2015 Qualification Problem A
 input = iter('''
 4
 4 11111
 1 09
 5 110011
 0 1
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 input  = open(r'A-small-attempt0.in')
 output = open(r'A-small-attempt0.out', 'w')
 #
 #input  = open(r'C-small-practice-2.in')
 #output = open(r'C-large-practice.out', 'w')
 
 def solve(S):
 	stood = S[0]
 	
 	res = 0
 	for need,cnt in enumerate(S[1:], 1):
 		if need > stood:
 			add = need - stood
 			stood += add
 			res += add
 		stood += cnt
 	return res
 		
 
 
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	_,S = next(input).split()
 	*S, = map(int, S)
 	answer = solve(S)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
",gcj/2015/6224486/oonishi/5639104758808576/0/extracted/a.py,710,40,94,Python,6224486,0,5639104758808576,oonishi,2015
122922,c2.py,"#coding: cp932
 # 2015 Round1-A Probleb C
 input = iter('''
 2
 5
 0 0
 10 0
 10 10
 0 10
 5 5
 9
 0 0
 5 0
 10 0
 0 5
 5 5
 10 5
 0 10
 5 10
 10 10
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 from ctypes import *
 #cdll.c.solve.restype = c_ulonglong
 
 
 filename = r'C-small-attempt2.in'
 #filename = r'C-large-practice (1).in'
 input  = open(filename)
 output = open(filename[:-3]+'2.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 	
 def isinclude(T,p):
 	for i in range(3):
 		v1 = (T[(i+1)%3][0]-T[i][0], T[(i+1)%3][1]-T[i][1])
 		v2 = (T[(i+2)%3][0]-T[i][0], T[(i+2)%3][1]-T[i][1])
 		u  = (p[0]-T[i][0], p[1]-T[i][1])
 		
 		c1 = v1[0]*u[1]-v1[1]*u[0]
 		c2 = v2[0]*u[1]-v2[1]*u[0]
 		if c1*c2>=0:
 			return False
 			
 	return True
 
 #import pdb;pdb.set_trace()
 #print(isinclude([(0,0),(10,0),(0,5)],(5,0)))
 #raise
 def solve(F):
 	res = [float('inf')]*len(F)
 	for n in range(2**len(F)):
 		l = [x for x in range(len(F)) if (n>>x)&1]
 		if len(l) <= 3:
 			for i in range(len(F)):
 				res[i] = min(res[i],len(F)-bitcnt(n))
 			continue
 		
 		check = [True]*len(F)
 		
 		#if n == 511:
 		#	import pdb;pdb.set_trace()
 		
 		for T in itertools.permutations(l, 3):
 			S = [F[t] for t in T]
 			for i in l:
 				if i in T: continue
 				if isinclude(S, F[i]):
 					check[i] = False
 		#print(check)
 		#if bitcnt(n) == 9:
 		#	print(n, check)
 		for i,c in enumerate(check):
 			if c:
 				res[i] = min(res[i],len(F)-bitcnt(n))
 			
 				
 	return res
 		
 	
 	#for i,p in enumerate(F):
 		
 	
 def line(p1,p2):
 	if p1[0]-p2[0] == 0 and p1[1]-p2[1] == 0:
 		raise
 	
 	if p1[0]-p2[0] == 0:
 		return (1, 0, -p1[0])
 	if p1[1]-p2[1] == 0:
 		return (0, 1, -p1[1])
 	
 	a = (p2[1]-p1[1])
 	b = -(p2[0]-p1[0])
 	c = -p1[0]*a-p1[1]*b
 	return a,b,c
 # print(line((5,5),(0,0)))
 # print(line((1,9),(0,9)))
 # print(line((0,9),(1,9)))
 # print(line((1,9),(1,0)))
 # print(line((0,2),(1,3)))
 # print(line((0,2),(1,-5)))
 # print(line((1,-5),(0,2)))
 # raise
 def solve(F):
 	if len(F)<=3:
 		return [0]*len(F)
 	print(F)
 	res = []
 	for i,p1 in enumerate(F):
 		#if i == 4:
 		#	import pdb;pdb.set_trace()
 		best = len(F) - 3#float('inf')
 		for j,p2 in enumerate(F):
 			if i==j:continue
 			a,b,c = line(p1,p2)
 			
 			left = 0
 			right= 0
 			
 			for k,p in enumerate(F):
 				if k in (i,j): continue
 				h = a*p[0]+b*p[1]+c
 				if h < 0:
 					left += 1
 				elif h > 0:
 					right += 1
 			best = min([best, left, right])
 		res += [best]
 		
 				
 	return res
 
 	
 #def solve(F):
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	N, = map(int, next(input).split())
 	F = []
 	for i in range(N):
 		X,Y = map(int, next(input).split())
 		F += [(X,Y)]
 	answer = solve(F)
 	print('Case #%d:'%(caseNo+1), file=output)
 	for a in answer:
 		print(a, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/4224486/oonishi/6377668744314880/0/extracted/c2.py,3284,180,442,Python,4224486,0,6377668744314880,oonishi,2015
122923,a.py,"#coding: cp932
 # 2015 Round1-A Probleb C
 input = iter('''
 4
 4
 10 5 15 5
 2
 100 100
 8
 81 81 81 81 81 81 81 0
 6
 23 90 40 0 100 9
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 from ctypes import *
 #cdll.c.solve.restype = c_ulonglong
 
 
 filename = r'A-small-attempt0.in'
 filename = r'A-large.in'
 input  = open(filename)
 output = open(filename[:-3]+'.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 	
 def solve1(M):
 	cnt = 0
 	prev = M[0]
 	for m in M[1:]:
 		if m < prev:
 			cnt += prev-m
 		prev = m
 	
 	return cnt
 
 def solve2(M):
 	cnt = 0
 	D = [m1-m2 for m1,m2 in zip(M[:-1],M[1:])]
 	d = max(D)
 	for m in M[:-1]:
 		cnt += min(m,d)
 	
 	return cnt
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	N, = map(int, next(input).split())
 	*M, = map(int, next(input).split())
 	answer1 = solve1(M)
 	answer2 = solve2(M)
 	print('Case #%d:'%(caseNo+1), answer1,answer2, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/4224486/oonishi/6404600001200128/1/extracted/a.py,1398,84,215,Python,4224486,1,6404600001200128,oonishi,2015
122924,a.py,"#coding: cp932
 # 2015 Round1-A Probleb A
 input = iter('''
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 from ctypes import *
 cdll.c.solve.restype = c_ulonglong
 
 
 #filename = r'C-small-practice (1).in'
 #filename = r'C-large-practice (1).in'
 #input  = open(filename)
 #output = open(filename[:-3]+'.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 	
 def solve():
 	return 0
 
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	N,M = map(int, next(input).split())
 	Ac = [0]*N
 	At = [0]*N
 	*A, = map(int, next(input).split())
 	for i,(c,t) in enumerate(zip(A[::2], A[1::2])):
 		Ac[i] = c
 		At[i] = t
 		
 	Bc = [0]*M
 	Bt = [0]*M
 	*B, = map(int, next(input).split())
 	for i,(c,t) in enumerate(zip(B[::2], B[1::2])):
 		Bc[i] = c
 		Bt[i] = t
 	#*A, = map(int, next(input).split())
 	#*A, = zip(A[::2],A[1::2])
 	#*B, = map(int, next(input).split())
 	#*B, = zip(B[::2],B[1::2])
 	#print(A,B)
 	answer = solve(Ac,At,Bc,Bt)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 print(time.time()-st)",gcj/2015/4224486/oonishi/6404600001200128/0/extracted/a.py,1474,76,198,Python,4224486,0,6404600001200128,oonishi,2015
122925,b.py,"#coding: cp932
 # 2015 Round1-A Probleb B
 input = iter('''
 3
 2 4
 10 5
 3 12
 7 7 7
 3 8
 4 2 1
 '''.splitlines()[1:])
 import sys
 output = sys.stdout
 
 from ctypes import *
 #cdll.c.solve.restype = c_ulonglong
 
 
 filename = r'B-small-attempt2.in'
 #filename = r'C-large-practice (1).in'
 input  = open(filename)
 output = open(filename[:-3]+'.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 	
 def gcd(n,m):
 	r = n%m
 	while r:
 		n = m
 		m = r
 		r = n%m
 	return m
 	
 
 def solve(N,M):
 	print(N,M)
 	
 	x = M[0]
 	for m in M[1:]:
 		g = gcd(m,x)
 		x = m*x//g
 		
 	y = 0
 	for m in M:
 		y += x//m
 	print(M,x,y)
 	#return x
 	
 	N %= y
 	if N==0:
 		N = y
 	
 	C = list(range(len(M)))
 	m = M[:]
 	c = len(M)
 	while c<N:
 		for i,_ in enumerate(m):
 			m[i] -= 1
 			if m[i] == 0:
 				C[i] = c
 				c += 1
 				m[i] = M[i]
 	print(C,N)
 	#C.index(N-1)+1
 	return C.index(N-1)+1
 
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	B,N = map(int, next(input).split())
 	*M, = map(int, next(input).split())
 	answer = solve(N,M)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 print(time.time()-st)",gcj/2015/4224486/oonishi/5765824346324992/0/extracted/b.py,1573,104,245,Python,4224486,0,5765824346324992,oonishi,2015
137768,c.py,"#coding: cp932
 # 2015 Round1-C Probleb C
 input = iter('''
 4
 1 2 3
 1 2
 1 3 6
 1 2 5
 2 1 3
 3
 1 6 100
 1 5 10 25 50 100
 '''.splitlines()[1:])
 import sys
 output = sys.stderr
 
 from ctypes import *
 inf = float('inf')
 #cdll.c.solve.restype = c_ulonglong
 #cdll.c.walk
 sys.setrecursionlimit(1500)
 
 filename = ''
 
 filename = r'C-small-attempt0.in'
 #filename = r'A-large-practice (2).in'
 
 if filename:
 	input  = open(filename)
 	output = open(filename[:-3]+'3.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 
 			
 #def insert(H,h,less):
 def insert(H,h):
 	right = len(H)
 	left  = -1
 	while right-left>1:
 		#if len(H)>10000:
 		#	print(right, left)
 		mid = (left+right)//2
 		if h.t>H[mid].t:
 			right = mid
 		else:
 			left = mid
 	#print('y',left, right,h.t)
 	return right
 	#H.insert(right,h)
 	
 
 import collections
 def solve(C,V,D):
 	d = set(D)
 	
 	d.add(1)
 	if V == 1:
 		return len(d)-len(D)
 		
 	d.add(2)
 	if V == 2:
 		return len(d)-len(D)
 		
 	if V == 3:
 		return len(d)-len(D)
 		
 	
 	
 	
 	
 	while 1:
 		can = [0]*(V+1)
 		can[0] = 1
 		for n in d:
 			new = can[:]
 			for i in range(V+1):
 				#print(i,n,can)
 				if can[i] == 1 and i+n <= V:
 					new[i+n] = 1
 			can = new
 				
 		if can == [1]*(V+1):
 			break
 			
 		print(d,can.index(0))
 		print(can)
 		d.add(can.index(0))
 	
 	
 	return len(d)-len(D)
 		
 	#print(E)
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	C,D,V = map(int, next(input).split())
 	*D, = map(int, next(input).split())
 	answer = solve(C,V,D)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/4244486/oonishi/5646553574277120/0/extracted/c.py,2064,130,281,Python,4244486,0,5646553574277120,oonishi,2015
137769,b.py,"#coding: cp932
 # 2015 Round1-C Probleb B
 input = iter('''
 6
 7 6 6
 BANANAS
 MONKEY
 2 3 4
 AA
 AAA
 2 1 2
 AB
 B
 6 2 2
 GOOGLE
 GO
 26 11 100
 ABCDEFGHIJKLMNOPQRSTUVWXYZ
 ROSENCRANTZ
 4 3 100
 TEST
 ABA
 '''.splitlines()[1:])
 import sys
 output = sys.stderr
 
 from ctypes import *
 inf = float('inf')
 #cdll.c.solve.restype = c_ulonglong
 #cdll.c.walk
 sys.setrecursionlimit(1500)
 
 filename = ''
 
 filename = r'B-small-attempt0.in'
 #filename = r'A-large-practice (2).in'
 
 if filename:
 	input  = open(filename)
 	output = open(filename[:-3]+'3.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 
 			
 #def insert(H,h,less):
 def insert(H,h):
 	right = len(H)
 	left  = -1
 	while right-left>1:
 		#if len(H)>10000:
 		#	print(right, left)
 		mid = (left+right)//2
 		if h.t>H[mid].t:
 			right = mid
 		else:
 			left = mid
 	#print('y',left, right,h.t)
 	return right
 	#H.insert(right,h)
 
 
 import collections
 def solve(K,L,S):
 	l = len(L)
 	for i in range(1,len(L)):
 		if L[i:] == L[:len(L)-i]:
 			l = i
 			break
 	else:
 		l = len(L)
 	print(l)
 	
 	banana = len(K)//l
 	
 	
 	have = 0
 	ex = 0.0
 	for x in range(len(K)**S):
 		
 		s = ''
 		for i in range(S):
 			s += K[x%len(K)]
 			x //= len(K)
 			
 		cnt = 0
 		for i in range(S-len(L)+1):
 			if s[i:].startswith(L):
 				cnt += 1
 		have = max(cnt,have)
 		ex += cnt/(len(K)**S)
 	
 	
 	
 	return have-ex
 		
 	#print(E)
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	K,L,S = map(int, next(input).split())
 	K = next(input).split()[0]
 	L = next(input).split()[0]
 
 	answer = solve(K,L,S)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/4244486/oonishi/5708284669460480/0/extracted/b.py,2111,136,288,Python,4244486,0,5708284669460480,oonishi,2015
137770,a.py,"#coding: cp932
 # 2015 Round1-C Probleb A
 input = iter('''
 5
 1 4 2
 1 7 7
 1 5 1
 1 5 2
 1 10 8
 '''.splitlines()[1:])
 import sys
 output = sys.stderr
 
 from ctypes import *
 inf = float('inf')
 #cdll.c.solve.restype = c_ulonglong
 #cdll.c.walk
 #sys.setrecursionlimit(1500)
 
 filename = ''
 
 filename = r'A-small-attempt5.in'
 filename = r'A-large.in'
 
 if filename:
 	input  = open(filename)
 	output = open(filename[:-3]+'4.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 
 			
 #def insert(H,h,less):
 def insert(H,h):
 	right = len(H)
 	left  = -1
 	while right-left>1:
 		#if len(H)>10000:
 		#	print(right, left)
 		mid = (left+right)//2
 		if h.t>H[mid].t:
 			right = mid
 		else:
 			left = mid
 	#print('y',left, right,h.t)
 	return right
 	#H.insert(right,h)
 	
 
 import collections
 def solve(R,C,W):
 	print(R,C,W)
 	if W == 1:
 		return R*C
 		
 	n = C//W*(R-1)
 	
 	#import pdb;pdb.set_trace()
 	return n + solve1(1,C,W)
 	
 def solve1(R,C,W):
 	if C>=2*W:
 		return max(1+solve(R,C-W,W), 1+W)
 	elif W==C:
 		return W
 	else:
 		return W+1
 		
 		
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	R,C,W = map(int, next(input).split())
 	answer = solve(R,C,W)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/4244486/oonishi/5640146288377856/1/extracted/a.py,1723,105,229,Python,4244486,1,5640146288377856,oonishi,2015
137771,a.py,"#coding: cp932
 # 2015 Round1-C Probleb A
 input = iter('''
 5
 1 4 2
 1 7 7
 1 5 1
 1 5 2
 1 10 8
 '''.splitlines()[1:])
 import sys
 output = sys.stderr
 
 from ctypes import *
 inf = float('inf')
 #cdll.c.solve.restype = c_ulonglong
 #cdll.c.walk
 #sys.setrecursionlimit(1500)
 
 filename = ''
 
 filename = r'A-small-attempt5.in'
 #filename = r'A-large-practice (2).in'
 
 if filename:
 	input  = open(filename)
 	output = open(filename[:-3]+'3.out', 'w')
 
 
 def bsearch(key, l):
 	if l == []: return 0
 	if len(l) == 1:
 		return 0 if l[0] > key else 1
 	m = len(l)//2
 	if l[m] > key:
 		return bsearch(key, l[:m])
 	else:
 		return bsearch(key, l[m:])+m
 
 import copy
 import itertools
 import pickle
 import math
 
 def binint(x):
 	n = 0
 	for i,c in enumerate(x[::-1]):
 		if c == '1':
 			n |= (1<<i)
 	return n
 
 def bitcnt(x):
 	r = 0
 	for i in range(64):
 		r += (x>>i)&1
 	return r
 
 			
 #def insert(H,h,less):
 def insert(H,h):
 	right = len(H)
 	left  = -1
 	while right-left>1:
 		#if len(H)>10000:
 		#	print(right, left)
 		mid = (left+right)//2
 		if h.t>H[mid].t:
 			right = mid
 		else:
 			left = mid
 	#print('y',left, right,h.t)
 	return right
 	#H.insert(right,h)
 	
 
 import collections
 def solve(R,C,W):
 	print(R,C,W)
 	if W == 1:
 		return R*C
 		
 	n = C//W*(R-1)
 	
 	#import pdb;pdb.set_trace()
 	if 2*W > C:
 		d = 2*W-C 
 		return n + d + (W-d)*2
 	else:
 		return n + (C-1)//W + (W-1)*2
 	
 def solve(R,C,W):
 	print(R,C,W)
 	if C>=2*W:
 		return max(1+solve(R,C-W,W), 1+W)
 	elif W==C:
 		return W
 	else:
 		return W+1
 	
 import time
 st = time.time()
 caseCnt = int(next(input))
 for caseNo in range(caseCnt):
 	R,C,W = map(int, next(input).split())
 	answer = solve(R,C,W)
 	print('Case #%d:'%(caseNo+1), answer, file=output)
 	
 	print(caseNo,time.time()-st)",gcj/2015/4244486/oonishi/5640146288377856/0/extracted/a.py,1811,108,247,Python,4244486,0,5640146288377856,oonishi,2015
24259,a.py,"#coding: utf8
 
 s = '''\
 7
 CAB
 JAM
 CODE
 ABAAB
 CABCBBABC
 ABCABCABC
 ZXCASDQWE
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('A-small-attempt0.in')
 #out   = open('A-small-attempt0.out', 'w')
 
 input = open('A-large.in')
 out   = open('A-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 def solve(S):
 	res = S[0]
 	for c in S[1:]:
 		if c + res <= res + c:
 			res += c
 		else:
 			res = c + res
 	return res
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	#N, = map(int, next(input).split())
 	S = next(input).strip()
 	print(S)
 	ans = solve(S)
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/4304486/oonishi/5631989306621952/1/extracted/a.py,955,53,113,Python,4304486,1,5631989306621952,oonishi,2016
24260,a.py,"#coding: utf8
 
 s = '''\
 7
 CAB
 JAM
 CODE
 ABAAB
 CABCBBABC
 ABCABCABC
 ZXCASDQWE
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('A-small-attempt0.in')
 out   = open('A-small-attempt0.out', 'w')
 
 #input = open('A-large.in')
 #out   = open('A-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 def solve(S):
 	res = S[0]
 	for c in S[1:]:
 		if c + res <= res + c:
 			res += c
 		else:
 			res = c + res
 	return res
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	#N, = map(int, next(input).split())
 	S = next(input).strip()
 	print(S)
 	ans = solve(S)
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/4304486/oonishi/5631989306621952/0/extracted/a.py,955,53,113,Python,4304486,0,5631989306621952,oonishi,2016
24261,c.py,"#coding: utf8
 
 #print(10*9*8*7*6*5*4*3*2*1)
 #raise
 
 s = '''\
 4
 4
 2 3 4 1
 4
 3 3 4 1
 4
 3 3 4 3
 10
 7 8 10 10 9 2 9 6 3 3
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('C-small-attempt1.in')
 #out   = open('C-small-attempt12.out', 'w')
 
 input = open('C-large.in')
 out   = open('C-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 #print(10*9*8*7*6*5*4*3*2*1)
 #raise
 #for 
 #for s in permutations(range(10)):
 #	#print(s)
 #	pass
 #raise
 def solve(F):
 	N = len(F)
 	F = [f-1 for f in F]
 	#print(F)
 	#ans = N*2
 	#for s in permutations(range(N)):
 	#	
 	#	val = 0
 	#	for i in range(1, N-1):
 	#		if s[i-1] != F[s[i]] and s[i+1] != F[s[i]]:
 	#			val += 1
 	#	if s[-1] != F[s[0]] and s[1] != F[s[0]]:
 	#		val += 1
 	#	if s[0] != F[s[-1]] and s[-2] != F[s[-1]]:
 	#		val += 1
 	#	if val < ans:
 	#		print(s)
 	#	#print(s, val)
 	#	ans = min(val, ans)
 	##raise
 	ans = 0
 	loved = [0]*N
 	for f in F:
 		loved[f] += 1
 	#if 0 not in loved:
 	#	return N
 		
 	cmax = 0
 	L = [0]*N
 	pair = set()
 	for i in range(N):
 		used = [0]*N
 		x = i
 		count = 0
 		#path = []
 		while not used[x]:
 			used[x] = 1
 			count += 1
 			last = x
 			#path += [x]
 			x = F[x]
 		
 		if x == i:
 			cmax = max(count, cmax)
 		if F[last] == x and F[x] == last:
 			#print(x, last, i)
 			L[last] = max(L[last], count-1)
 			L[x] = max(L[x], 1)
 			if last>x:
 				last,x = x,last
 			pair.add((last, x))
 	#print(L, pair)
 	ans = cmax
 	sm = 0
 	for p in pair:
 		sm +=  (L[p[0]] + L[p[1]])
 	return max(ans, sm)
 	
 
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	N, = map(int, next(input).split())
 	*F, = map(int, next(input).split())
 	ans = solve(F)
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/4304486/oonishi/5631572862566400/1/extracted/c.py,2053,112,322,Python,4304486,1,5631572862566400,oonishi,2016
130972,a.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 s = '''\
 5
 0
 1
 2
 11
 1692
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('A-small-attempt0.in')
 #out   = open('A-small-attempt0.out', 'w')
 
 input = open('A-large.in')
 out   = open('A-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 X = 10**9 + 7
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 def solve(N):
 	if N == 0:
 		return 'INSOMNIA'
 	used = [0]*10
 	n = 0
 	while 0 in used:
 		n += N
 		for c in str(n):
 			used[int(c)] = 1
 	return n
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	N, = map(int, next(input).split())
 	print(N)
 	ans = solve(N)
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/6254486/oonishi/5652388522229760/1/extracted/a.py,1039,55,124,Python,6254486,1,5652388522229760,oonishi,2016
130973,a.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 s = '''\
 5
 0
 1
 2
 11
 1692
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('A-small-attempt0.in')
 out   = open('A-small-attempt0.out', 'w')
 
 #input = open('D-large.in')
 #out   = open('D-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 X = 10**9 + 7
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 def solve(N):
 	if N == 0:
 		return 'INSOMNIA'
 	used = [0]*10
 	n = 0
 	while 0 in used:
 		n += N
 		for c in str(n):
 			used[int(c)] = 1
 	return n
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	N, = map(int, next(input).split())
 	print(N)
 	ans = solve(N)
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/6254486/oonishi/5652388522229760/0/extracted/a.py,1039,55,124,Python,6254486,0,5652388522229760,oonishi,2016
130974,d.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 s = '''\
 5
 2 3 2
 1 1 1
 2 1 1
 2 1 2
 3 2 3
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('D-small-attempt1.in')
 #out   = open('D-small-attempt1.out', 'w')
 
 input = open('D-large.in')
 out   = open('D-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 X = 10**9 + 7
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 #LLL LLLLLLLLL
 #GLL GGGGLLGLL
 #LGL LGLGGGLGL
 #LLG LLGLLGGGG
 #GGL GGGGGGGGL
 #GLG GGGGLGGGG
 #LGG LGGGGGGGG
 #GGG GGGGGGGGG
 
 
 #GLLL GGGGGLLLGLLLGLLL
 #LGLL LGLLGGGGLGLLLGLL
 #LLGL LLGLLLGLGGGGLLGL
 #LLLG LLLGLLLGLLLGGGGG
 #GGLL GGGGGGGGGGLLGGLL
 #LGGL LGGLGGGGGGGGLGGL
 #LLGG LLGGLLGGGGGGGGGG
 #GLGL
 #LGLG
 #GLLG
 #GGGL
 #GGLG
 #GLGG
 #LGGG
 #LLLL
 #GGGG
 
 def solve(K,C,S):
 	ans = []
 	#used = [0]*K
 	c = C
 	n = 0
 	k = 0
 	for s in range(S):
 		n = 0
 		for c in range(C):
 			n = n*K + k
 			k += 1
 			if k == K:
 				break
 		ans += [n+1]
 		if k == K:
 			return ans
 			
 		
 	return []
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	K,C,S = map(int, next(input).split())
 	print(K,C,S)
 	ans = solve(K,C,S)
 	if not ans: ans = ['IMPOSSIBLE']
 	#if s[-1] == '-':
 	#	ans += 1
 	#L = [0]
 	#while L:
 	#    p = L.pop()
 	#    if S
 
 	print('Case #%d:'%(case+1), *ans, file=out)
",gcj/2016/6254486/oonishi/5636311922769920/1/extracted/d.py,1641,98,221,Python,6254486,1,5636311922769920,oonishi,2016
130975,d.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 s = '''\
 5
 2 3 2
 1 1 1
 2 1 1
 2 1 2
 3 2 3
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('D-small-attempt1.in')
 out   = open('D-small-attempt1.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 X = 10**9 + 7
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 #LLL LLLLLLLLL
 #GLL GGGGLLGLL
 #LGL LGLGGGLGL
 #LLG LLGLLGGGG
 #GGL GGGGGGGGL
 #GLG GGGGLGGGG
 #LGG LGGGGGGGG
 #GGG GGGGGGGGG
 
 
 #GLLL GGGGGLLLGLLLGLLL
 #LGLL LGLLGGGGLGLLLGLL
 #LLGL LLGLLLGLGGGGLLGL
 #LLLG LLLGLLLGLLLGGGGG
 #GGLL GGGGGGGGGGLLGGLL
 #LGGL LGGLGGGGGGGGLGGL
 #LLGG LLGGLLGGGGGGGGGG
 #GLGL
 #LGLG
 #GLLG
 #GGGL
 #GGLG
 #GLGG
 #LGGG
 #LLLL
 #GGGG
 
 def solve(K,C,S):
 	ans = []
 	#used = [0]*K
 	c = C
 	n = 0
 	k = 0
 	for s in range(S):
 		n = 0
 		for c in range(C):
 			n = n*K + k
 			k += 1
 			if k == K:
 				break
 		ans += [n+1]
 		if k == K:
 			return ans
 			
 		
 	return []
 #print([1,1,1,1].index(0))
 #raise
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	K,C,S = map(int, next(input).split())
 	print(K,C,S)
 	ans = solve(K,C,S)
 	if not ans: ans = ['IMPOSSIBLE']
 	#if s[-1] == '-':
 	#	ans += 1
 	#L = [0]
 	#while L:
 	#    p = L.pop()
 	#    if S
 
 	print('Case #%d:'%(case+1), *ans, file=out)
",gcj/2016/6254486/oonishi/5636311922769920/0/extracted/d.py,1575,95,214,Python,6254486,0,5636311922769920,oonishi,2016
130976,c.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 print(bin((1<<8) + 1))
 
 
 
 
 def cnv(n, b):
 	k = 1
 	res = 0
 	while n:
 		if n%2:
 			res += k
 		k *= b
 		n >>= 1
 	return res
 #print(cnv(n,3),cnv(11,3))
 
 cnt = 0
 n = (1<<16) + 1
 print(bin(n))
 for i in range((1<<15)+1, (1<<16)-1, 2):
 	#print(bin(i*n), bin(i), bin(n))
 	#print(i*n, n, i)
 	for d in range(3, 11):
 		#print(d, cnv(i*n, d), cnv(n, d), cnv(i*n, d)%cnv(n, d))
 		if cnv(i*n, d)%cnv(n, d):
 			raise
 	print(cnv(i*n, 10), *[cnv(n,d) for d in range(2, 11)])
 	cnt += 1
 	if cnt == 500:
 		break
 print(cnt)	
 
 
 
",gcj/2016/6254486/oonishi/5738606668808192/1/extracted/c.py,660,39,95,Python,6254486,1,5738606668808192,oonishi,2016
130977,c.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 print(bin((1<<8) + 1))
 
 
 
 
 def cnv(n, b):
 	k = 1
 	res = 0
 	while n:
 		if n%2:
 			res += k
 		k *= b
 		n >>= 1
 	return res
 #print(cnv(n,3),cnv(11,3))
 
 cnt = 0
 n = (1<<8) + 1
 print(bin(n))
 for i in range((1<<7)+1, (1<<8)-1, 2):
 	#print(bin(i*n), bin(i), bin(n))
 	#print(i*n, n, i)
 	for d in range(3, 11):
 		#print(d, cnv(i*n, d), cnv(n, d), cnv(i*n, d)%cnv(n, d))
 		if cnv(i*n, d)%cnv(n, d):
 			raise
 	print(cnv(i*n, 10), *[cnv(n,d) for d in range(2, 11)])
 	cnt += 1
 	if cnt == 50:
 		break
 print(cnt)	
 
 
 
",gcj/2016/6254486/oonishi/5738606668808192/0/extracted/c.py,656,39,95,Python,6254486,0,5738606668808192,oonishi,2016
130978,b.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 s = '''\
 5
 -
 -+
 +-
 +++
 --+-
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('B-small-attempt0.in')
 #out   = open('B-small-attempt0.out', 'w')
 
 input = open('B-large.in')
 out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 X = 10**9 + 7
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	s = next(input).strip()
 	ans = 0
 	#if s[-1] == '-':
 	#	ans += 1
 	s += '+'
 	for i in reversed(range(len(s)-1)):
 		if s[i] != s[i+1]:
 			ans += 1
 	#L = [0]
 	#while L:
 	#    p = L.pop()
 	#    if S
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/6254486/oonishi/5634697451274240/1/extracted/b.py,928,49,117,Python,6254486,1,5634697451274240,oonishi,2016
130979,b.py,"#coding: utf8
 # 2015 Round3 Problem Problem A. Fairland
 # https://code.google.com/codejam/contest/4254486/dashboard
 
 s = '''\
 5
 -
 -+
 +-
 +++
 --+-
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('B-small-attempt0.in')
 out   = open('B-small-attempt0.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 X = 10**9 + 7
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	s = next(input).strip()
 	ans = 0
 	#if s[-1] == '-':
 	#	ans += 1
 	s += '+'
 	for i in reversed(range(len(s)-1)):
 		if s[i] != s[i+1]:
 			ans += 1
 	#L = [0]
 	#while L:
 	#    p = L.pop()
 	#    if S
 
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/6254486/oonishi/5634697451274240/0/extracted/b.py,862,46,110,Python,6254486,0,5634697451274240,oonishi,2016
176613,b.py,"#coding: utf8
 
 
 s = '''\
 3
 2 2
 0.50 0.50
 4 2
 0.00 0.00 1.00 1.00
 3 2
 0.75 1.00 0.50
 '''
 
 
 
 filename = ''
 filename = 'B-small-attempt0.in'
 #filename = 'B-large-practice.in'
 if filename:
 	import glob
 	no = 0
 	for s in glob.glob(filename[:-3] + '-*.out'):
 		no = max(no, int(s[len(filename[:-3])+1:-4])+1)
 	outname = filename[:-3] + '-%d.out'%no
 else:	
 	outname = ''
 #outname = ''
 #new = defaultdict(lambda:float('inf'))	
 	
 import sys
 #set_trace()
 input = iter(s.splitlines(keepends=True))
 out = sys.stdout
 if filename:
 	input = open(filename)
 if outname and len(sys.argv) != 2:
 	print('out', outname)
 	out = open(outname, 'w')
 elif outname and len(sys.argv) == 2:
 	out = sys.stderr
 
 from pdb import set_trace
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 from math import sin,cos,tan,log,atan2,pi as PI
 
 
 
 def solve():
 	ans = 0.0
 	for p in combinations(range(N), K):
 		DP = [[0.0]*(K+1) for i in range(K)]
 		
 		DP[0][1] = D[p[0]]
 		DP[0][0] = 1.0 - D[p[0]]
 		for i in range(K-1):
 			for k in range(K):
 				DP[i+1][k]   += DP[i][k]*(1-D[p[i+1]])
 				DP[i+1][k+1] += DP[i][k]*D[p[i+1]]
 			#DP[i+1][K-1] += DP[i][K-1]*(1-D[i+1])
 		#print(DP[K-1])
 		ans = max(ans, DP[K-1][K//2])
 	return ans
 	
 CaseCnt = int(next(input))
 
 import time
 start0 = time.time()
 
 #if len(sys.argv) == 2:
 if 1:
 	for case in range(1,CaseCnt+1):
 		N,K = map(int,next(input).split())
 		*D, = map(float,next(input).split())
 		#for i in range(N):
 		#	d,l = map(int,next(input).split())
 		#	V += [(d,l)]
 		#D, = map(int,next(input).split())
 		if len(sys.argv) == 2 and case != int(sys.argv[1]): continue
 		#if case != 29: continue
 		start = time.time()
 		ans = solve()
 		print(case, time.time()-start)
 		print('Case #%d:'%case, ans, file=out)
 		
 else:	
 	import subprocess
 	import threading
 	import sys
 	ProcNo = 0
 	lock_output = threading.Lock()
 	
 	result = ['']*CaseCnt
 	
 	def SubProc(threadNo):
 		global CaseNo
 		while CaseNo <= CaseCnt:
 			case = CaseNo
 			CaseNo += 1
 			p = subprocess.Popen([sys.executable, __file__, str(case)]
 				, stdout=subprocess.PIPE
 				, stderr=subprocess.PIPE)
 			#p.wait()
 			while p.poll() is None:
 				time.sleep(0.01)
 			#elapsed = p.stdout.readline().decode().strip()
 			print(p.stdout.read().decode()[:-1], threadNo)
 			result[case-1] = p.stderr.read().decode().strip()
 			#with lock_output:
 			#	print(case, elapsed)
 				#print(result[case-1])
 	
 	CaseNo = 1
 	ts = [threading.Thread(target=SubProc, args=(no,)) for no in range(min(6,CaseCnt))]
 	for t in ts:
 		t.start()
 	for t in ts:
 		t.join()
 		
 	for s in result:
 		print(s, file=out)
 
 if len(sys.argv) != 2:
 	print(time.time()-start0)",gcj/2016/10224486/oonishi/5677604812095488/0/extracted/b.py,2817,125,328,Python,10224486,0,5677604812095488,oonishi,2016
197735,a.py,"#coding: utf8
 
 
 s = '''\
 4
 OZONETOWER
 WEIGHFOXTOURIST
 OURNEONFOE
 ETHER
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('A-small-attempt4.in')
 out   = open('A-small-attempt4.out', 'w')
 
 #input = open('C-large.in')
 #out   = open('C-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 L = {""ZERO"":'0', ""ONE"":'1', ""TWO"":'2', ""THREE"":'3', ""FOUR"":'4', ""FIVE"":'5', ""SIX"":'6', ""SEVEN"":'7', ""EIGHT"":'8', ""NINE"":'9'}
 L = [""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
 #Rev = {v:k for k,v in L.items()}
 
 #s = set()
 #for l in L:
 #	for c in l:
 #		s.add(c)
 #print(s)
 C = ['H', 'W', 'U', 'S', 'E', 'R', 'V', 'Z', 'O', 'T', 'F', 'I', 'G', 'N', 'X']
 #EOTEOEWNNEVOOONSTNEW
 #ONEONEONEONETWO
 #
 #EVSTW
 #
 #EOTEOEWNNEVOOONSTNEW
 
 def test(d, w):
 	d2 = deepcopy(d)
 	
 	for c in w:
 		if d2[c] == 0:
 			return False
 		d2[c] -= 1
 	return True
 	
 	
 def search(d, n):
 	d = deepcopy(d)
 	if n == 10:
 		for v in d.values():
 			if v != 0:
 				return 'ERROR'
 		return ''
 	w = L[n]
 	
 	res = search(d, n+1)
 	if res != 'ERROR':
 		return res
 	res = ''
 	while test(d, w):
 		res += str(n)
 		for c in w:
 			d[c] -= 1
 		ans = search(d, n+1)
 		if ans != 'ERROR':
 			return res + ans
 	
 	ans = search(d, n+1)
 	if ans != 'ERROR':
 		return res + ans
 	return 'ERROR'
 		
 	
 
 def solve(S):
 	d = defaultdict(int)
 	for c in S:
 		d[c] += 1
 	res = search(d, 0)
 	if res == 'ERROR':
 		raise
 	return res
 			
 
 def solve_(S):
 	D = {c:0 for c in C}
 	D['@'] = 0
 	res = ''
 	for c in (S + '@'):
 		D[c] += 1
 		for w in L:
 			d = deepcopy(D)
 			for k in w:
 				if d[k] == 0:
 					break
 				d[k] -= 1
 			else:
 				res += L[w]
 				for k in w:
 					D[k] -= 1
 					if D[k] < 0:
 						print(c)
 						print(d)
 						print(D)
 						print(w)
 						raise
 	
 	print(D)
 	res = ''.join(sorted(res))
 	
 	rev = ''
 	for c in res:
 		rev += Rev[c]
 		
 	if sorted(rev) != sorted(S):
 		print(S)
 		print(rev)
 		raise
 	
 	return res
 	
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	S = next(input).strip()
 	#N, = map(int, next(input).split())
 	#*F, = map(int, next(input).split())
 	print(S)
 	ans = solve(S)
 	
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/11254486/oonishi/5648941810974720/0/extracted/a.py,2546,143,364,Python,11254486,0,5648941810974720,oonishi,2016
197736,c.py,"#coding: utf8
 
 
 s = '''\
 3
 16
 AZ DM
 PL DM
 LO EZ
 RJ FY
 PL NN
 RX EZ
 RX NN
 RX OC
 PI OC
 PL PY
 RJ RU
 RX RU
 LO SV
 WE SV
 DL TT
 RJ TT
 3
 HYDROCARBON COMBUSTION
 QUAIL BEHAVIOR
 QUAIL COMBUSTION
 3
 CODE JAM
 SPACE JAM
 PEARL JAM
 2
 INTERGALACTIC PLANETARY
 PLANETARY INTERGALACTIC
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('C-small-attempt2.in')
 out   = open('C-small-attempt2.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 def test(R):
 	for i,(r1,r2) in enumerate(R):
 		if r1>1 and r2>1:
 			return i
 			
 	return -1
 		
 	
 def solve(S):
 	F = defaultdict(int)
 	L = defaultdict(int)
 	for s1,s2 in S:
 		F[s1] += 1
 		L[s2] += 1
 		
 	S.sort(key=lambda s:max(F[s[0]], L[s[1]]), reverse=True)
 	res = 0
 	while S:
 		s1,s2 = S[0]
 		print(S[0], F[s1], L[s2])
 		if F[s1] == 1 or L[s2] == 1:
 			pass
 		else:
 			res += 1
 			F[s1] -= 1
 			L[s2] -= 1
 		S = S[1:]
 		S.sort(key=lambda s:max(F[s[0]], L[s[1]]), reverse=True)
 	print([min(F[s[0]], L[s[1]]) for s in S])
 	return res
 		
 		
 	
 	
 	
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	N = int(next(input))
 	S = []
 	for i in range(N):
 		s1,s2 = next(input).split()
 		S +=[(s1,s2)]
 
 	#import pdb;pdb.set_trace()
 	ans = solve(S)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/11254486/oonishi/5686313294495744/0/extracted/c.py,1737,106,230,Python,11254486,0,5686313294495744,oonishi,2016
197737,b.py,"#coding: utf8
 
 
 s = '''\
 4
 ?5 10
 1? 2?
 ?2? ??3
 ? ?
 ?5 ?0
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('B-small-attempt0.in')
 #out   = open('B-small-attempt1.out', 'w')
 
 input = open('B-large.in')
 out   = open('B-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 def solve(C,J,d):
 	if C=='' and J=='':
 		return '', ''
 		
 	if C[0] != '?' and J[0] != '?':
 		d = int(C[0])-int(J[0]) + d*10
 		c,j  = solve(C[1:], J[1:], d)
 		return C[0] + c, J[0] + j
 	
 	if d == 0:
 		if C[0] == '?' and J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10)
 			return '0' + c, '0' + j
 		elif C[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10)
 			return J[0] + c, J[0] + j
 		elif J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10)
 			return C[0] + c, C[0] + j
 		else:
 			raise
 	elif d > 0:
 		if C[0] == '?' and J[0] == '?':
 			diff = min(d,9)
 			c,j  = solve(C[1:], J[1:], d)
 			return '0' + c, '1' + j
 		elif C[0] == '?':
 			c,j  = solve(C[1:], J[1:], d)
 			return J[0] + c, J[0] + j
 		elif J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d)
 			return C[0] + c, C[0] + j
 		else:
 			raise
 		
 			
 def it(s):
 	for i in range(10):
 		if s[0] != '?' and int(s[0]) != i:
 			continue
 		for j in range(10):
 			if s[1] != '?' and int(s[1]) != j:
 				continue
 			for k in range(10):
 				if s[2] != '?' and int(s[2]) != k:
 					continue
 				yield i*100 + j*10 + k
 			
 			
 def solve(C,J):
 	length = max(len(C),len(J))
 	C = C.rjust(3, '0')
 	J = J.rjust(3, '0')
 	
 	res = [99999, 999999, 999999]
 	for c in it(C):
 		for j in it(J):
 			diff = abs(c-j)
 			if res[0] > diff:
 				res = [diff, c, j]
 				
 			elif res[0] == diff and res[1] > c:
 				res = [diff, c, j]
 			elif res[0] == diff and res[1] == c and res[2] > j:
 				res = [diff, c, j]
 			#print(res)
 	return res[1:]
 	
 def solve(C,J,d):
 	if C=='' and J=='':
 		return '', ''
 		
 	if C[0] != '?' and J[0] != '?':
 		d = int(C[0])-int(J[0]) + d*10
 		c,j  = solve(C[1:], J[1:], d)
 		return C[0] + c, J[0] + j
 		
 		
 	if d == 0:
 		if C[0] == '?' and J[0] == '?':
 			c,j  = solve(C[1:], J[1:], 0)
 			c0,j0 = '0' + c, '0' + j
 			c,j  = solve(C[1:], J[1:], 10)
 			c1,j1 = '1' + c, '0' + j
 			c,j  = solve(C[1:], J[1:], -10)
 			c2,j2 = '0' + c, '1' + j
 			
 			d0 = abs(int(c0)-int(j0))
 			d1 = abs(int(c1)-int(j1))
 			d2 = abs(int(c2)-int(j2))
 			d,c,j = min([(d0,c0,j0),(d1,c1,j1),(d2,c2,j2)])
 			#if d2 < d0 and d2 < d1:
 			#	return c2,j2
 			#elif d1 < d0:
 			#	return c1,j1
 			#else:
 			#	return c0,j0
 			return c,j
 		elif C[0] == '?':
 			#c,j  = solve(C[1:], J[1:], 0)
 			#return J[0] + c, J[0] + j
 			
 			c,j  = solve(C[1:], J[1:], 0)
 			c0,j0 = J[0] + c, J[0] + j
 			
 			c1,j1 = c0,j0
 			if J[0] != '9':
 				c,j  = solve(C[1:], J[1:], 10)
 				c1,j1 = str(int(J[0])+1) + c, J[0] + j
 			
 			c2,j2 = c0,j0
 			if J[0] != '0':	
 				c,j  = solve(C[1:], J[1:], -10)
 				c2,j2 = str(int(J[0])-1) + c, J[0] + j
 			
 			d0 = abs(int(c0)-int(j0))
 			d1 = abs(int(c1)-int(j1))
 			d2 = abs(int(c2)-int(j2))
 			d,c,j = min([(d0,c0,j0),(d1,c1,j1),(d2,c2,j2)])
 			#if d2 < d0 and d2 < d1:
 			#	return c2,j2
 			#elif d1 < d0:
 			#	return c1,j1
 			#else:
 			#	return c0,j0
 			return c,j
 		elif J[0] == '?':
 			#c,j  = solve(C[1:], J[1:], 0)
 			#return C[0] + c, C[0] + j
 			c,j  = solve(C[1:], J[1:], 0)
 			c0,j0 = C[0] + c, C[0] + j
 			
 			c1,j1 = c0,j0
 			if C[0] != '0':
 				c,j  = solve(C[1:], J[1:], 10)
 				c1,j1 = C[0] + c, str(int(C[0])-1) + j
 			
 			c2,j2 = c0,j0
 			if C[0] != '9':	
 				c,j  = solve(C[1:], J[1:], -10)
 				c2,j2 = C[0] + c, str(int(C[0])+1) + j
 			
 			d0 = abs(int(c0)-int(j0))
 			d1 = abs(int(c1)-int(j1))
 			d2 = abs(int(c2)-int(j2))
 			
 			d,c,j = min([(d0,c0,j0),(d1,c1,j1),(d2,c2,j2)])
 			#if d2 < d0 and d2 < d1:
 			#	return c2,j2
 			#elif d1 < d0:
 			#	return c1,j1
 			#else:
 			#	return c0,j0
 			return c,j
 		else:
 			raise
 	elif d > 0:
 		if C[0] == '?' and J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10-9)
 			return '0' + c, '9' + j
 		elif C[0] == '?':
 			x = int(J[0])
 			c,j  = solve(C[1:], J[1:], d*10 - x)
 			return '0' + c, J[0] + j
 		elif J[0] == '?':
 			x = int(C[0])
 			c,j  = solve(C[1:], J[1:], d*10-(9-x))
 			return C[0] + c, '9' + j
 		else:
 			raise
 	elif d < 0:
 		if C[0] == '?' and J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10+9)
 			return '9' + c, '0' + j
 		elif C[0] == '?':
 			x = int(J[0])
 			c,j  = solve(C[1:], J[1:], d*10 + 9 - x)
 			return '9' + c, J[0] + j
 		elif J[0] == '?':
 			x = int(C[0])
 			c,j  = solve(C[1:], J[1:], d*10+x)
 			return C[0] + c, '0' + j
 		else:
 			raise
 	
 		
 	
 #solve('t', 'test')	
 	
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	C,J = next(input).split()
 
 	#import pdb;pdb.set_trace()
 	c,j = solve(C,J,0)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), c,j, file=out)
",gcj/2016/11254486/oonishi/5695413893988352/1/extracted/b.py,5232,234,835,Python,11254486,1,5695413893988352,oonishi,2016
197738,b.py,"#coding: utf8
 
 
 s = '''\
 4
 1? 2?
 ?2? ??3
 ? ?
 ?5 ?0
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('B-small-attempt0.in')
 out   = open('B-small-attempt0.out', 'w')
 
 #input = open('C-large.in')
 #out   = open('C-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 def solve(C,J,d):
 	if C=='' and J=='':
 		return '', ''
 		
 	if C[0] != '?' and J[0] != '?':
 		d = int(C[0])-int(J[0]) + d*10
 		c,j  = solve(C[1:], J[1:], d)
 		return C[0] + c, J[0] + j
 	
 	if d == 0:
 		if C[0] == '?' and J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10)
 			return '0' + c, '0' + j
 		elif C[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10)
 			return J[0] + c, J[0] + j
 		elif J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d*10)
 			return C[0] + c, C[0] + j
 		else:
 			raise
 	elif d > 0:
 		if C[0] == '?' and J[0] == '?':
 			diff = min(d,9)
 			c,j  = solve(C[1:], J[1:], d)
 			return '0' + c, '1' + j
 		elif C[0] == '?':
 			c,j  = solve(C[1:], J[1:], d)
 			return J[0] + c, J[0] + j
 		elif J[0] == '?':
 			c,j  = solve(C[1:], J[1:], d)
 			return C[0] + c, C[0] + j
 		else:
 			raise
 		
 			
 def it(s):
 	for i in range(10):
 		if s[0] != '?' and int(s[0]) != i:
 			continue
 		for j in range(10):
 			if s[1] != '?' and int(s[1]) != j:
 				continue
 			for k in range(10):
 				if s[2] != '?' and int(s[2]) != k:
 					continue
 				yield i*100 + j*10 + k
 			
 			
 def solve(C,J):
 	length = max(len(C),len(J))
 	C = C.rjust(3, '0')
 	J = J.rjust(3, '0')
 	
 	res = [99999, 999999, 999999]
 	for c in it(C):
 		for j in it(J):
 			diff = abs(c-j)
 			if res[0] > diff:
 				res = [diff, c, j]
 				
 			elif res[0] == diff and res[1] > c:
 				res = [diff, c, j]
 			elif res[0] == diff and res[1] == c and res[2] > j:
 				res = [diff, c, j]
 			#print(res)
 	return res[1:]
 	
 #solve('t', 'test')	
 	
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	C,J = next(input).split()
 	
 	c,j = solve(C,J)
 	
 	c = str(c).rjust(len(C), '0')
 	j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), c,j, file=out)
",gcj/2016/11254486/oonishi/5695413893988352/0/extracted/b.py,2369,113,364,Python,11254486,0,5695413893988352,oonishi,2016
218294,b.py,"#coding: utf8
 
 
 s = '''\
 3
 5 4
 2 1
 4 20
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('B-small-attempt0.in')
 out   = open('B-small-attempt0.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 
 def solve(B,M):
 	S = [0]*B
 	S[0] = 1
 	for i in range(1,B):
 		S[i] = sum(S[:i])
 	if M>S[-1]:
 		return []
 	
 	
 	if M==S[-1]:
 		ans =[[0]*B for _ in range(B)]
 		for i in range(B-1):
 			for j in range(i+1,B):
 				ans[i][j] = 1
 		return ans
 	ans =[[0]*B for _ in range(B)]
 	for i in range(B-1):
 		for j in range(i+1,B):
 			ans[i][j] = 1
 	for i in range(B-1,-1,-1):
 		if S[i]>M:
 			ans[i][-1] = 0
 			continue
 		M-=S[i]
 	return ans
 	
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	B,M = map(int,next(input).split())
 	ans = solve(B,M)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	if not ans:
 		print('Case #%d:'%(case+1), 'IMPOSSIBLE', file=out)
 	else:
 		print('Case #%d:'%(case+1), 'POSSIBLE', file=out)
 		for a in ans:
 			print(*a, file=out)
",gcj/2016/4314486/oonishi/5744014401732608/0/extracted/b.py,1394,73,173,Python,4314486,0,5744014401732608,oonishi,2016
218295,a.py,"#coding: utf8
 
 
 s = '''\
 4
 2
 2 2
 3
 3 2 2
 3
 1 1 2
 3
 2 3 1
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 #input = open('A-small-attempt0.in')
 #out   = open('A-small-attempt0.out', 'w')
 
 input = open('A-large.in')
 out   = open('A-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 
 def solve(S):
 	ans = []
 	while sum(S):
 		maxi = -1
 		maxi2= -1
 		for i,_ in enumerate(S):
 			if maxi==-1 or S[maxi] < S[i]:
 				maxi2 = maxi
 				maxi = i
 			elif maxi2 == -1 or S[maxi2] < S[i]:
 				maxi2 = i
 				
 		S[maxi] -= 1
 		if S[maxi2] and sum(S) // S[maxi2] < 2:
 			ans += [(maxi,maxi2)]
 			S[maxi2] -= 1
 		else:	
 			ans += [(maxi,-1)]
 	return ' '.join([chr(ord('A')+n) + (chr(ord('A')+k) if k !=-1 else '') for n,k in ans])
 	
 		
 		
 	
 	
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	N = int(next(input))
 	*S, = map(int, next(input).split())
 	ans = solve(S)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/4314486/oonishi/5753053697277952/1/extracted/a.py,1331,73,176,Python,4314486,1,5753053697277952,oonishi,2016
218296,a.py,"#coding: utf8
 
 
 s = '''\
 4
 2
 2 2
 3
 3 2 2
 3
 1 1 2
 3
 2 3 1
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('A-small-attempt0.in')
 out   = open('A-small-attempt0.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 
 def solve(S):
 	ans = []
 	while sum(S):
 		maxi = -1
 		maxi2= -1
 		for i,_ in enumerate(S):
 			if maxi==-1 or S[maxi] < S[i]:
 				maxi2 = maxi
 				maxi = i
 			elif maxi2 == -1 or S[maxi2] < S[i]:
 				maxi2 = i
 				
 		S[maxi] -= 1
 		if S[maxi2] and sum(S) // S[maxi2] < 2:
 			ans += [(maxi,maxi2)]
 			S[maxi2] -= 1
 		else:	
 			ans += [(maxi,-1)]
 	return ' '.join([chr(ord('A')+n) + (chr(ord('A')+k) if k !=-1 else '') for n,k in ans])
 	
 		
 		
 	
 	
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	N = int(next(input))
 	*S, = map(int, next(input).split())
 	ans = solve(S)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), ans, file=out)
",gcj/2016/4314486/oonishi/5753053697277952/0/extracted/a.py,1331,73,176,Python,4314486,0,5753053697277952,oonishi,2016
218297,c.py,"#coding: utf8
 
 
 s = '''\
 4
 1 1 1 10
 1 2 3 2
 1 1 3 2
 1 2 3 1
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('C-small-attempt6.in')
 out   = open('C-small-attempt6.out', 'w')
 
 input = open('C-large.in')
 out   = open('C-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 X = ((0,0,1),
 (0,1,2),
 (0,1,0),
 (0,0,0),(0,0,2),(0,1,1))
 def solve(J,P,S,K):
 	#import pdb;pdb.set_trace()
 	maxa = []
 	
 	*keys, = product(range(J), range(P), range(S))
 	
 	N = 1<<len(keys)
 	ans = []
 	for n in range(N):
 		for j in range(len(keys)):
 			if (n>>j)&1:
 				ans
 	
 	keys = product(range(J), range(P))
 	for xx in permutations(keys):
 		
 
 		#if xx == X:
 		#	import pdb; pdb.set_trace()
 		#k = K
 		ans = []
 		D = defaultdict(int)
 		
 		try:
 			for j,p in xx:
 				for s in range(S):
 						k1 = (-1, p, s)
 						k2 = ( j,-1, s)
 						k3 = ( j, p,-1)
 						if D[k1] >= K:
 							raise StopIteration()
 						if D[k2] >= K:
 							raise StopIteration()
 						if D[k3] >= K:
 							raise StopIteration()
 						#D.add(k1)
 						#D.add(k2)
 						#D.add(k3)
 						#if k < 0:
 						#	#print((j,p,s), D)
 						#	raise StopIteration()
 						D[k1] += 1
 						D[k2] += 1
 						D[k3] += 1
 						#print(j,p,s)
 						ans += [(j,p,s)]
 		except StopIteration as s:
 			pass
 
 		if len(maxa) < len(ans):
 			maxa = ans
 			#print()
 	return maxa
 
 def solve(J,P,S,K):
 	ans = []
 	for k in range(min(K,S)):
 		for j in range(J):
 			for p in range(P):
 				s = (p + j + k)%S
 				ans += [(j,p,s)]
 	return ans
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	J,P,S,K = map(int, next(input).split())
 	ans = solve(J,P,S,K)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), len(ans), file=out)
 	for a in ans:
 		a = [n+1 for n in a]
 		print(*a, file=out)
",gcj/2016/4314486/oonishi/5708921029263360/1/extracted/c.py,2158,112,285,Python,4314486,1,5708921029263360,oonishi,2016
218298,c.py,"#coding: utf8
 
 
 s = '''\
 4
 1 1 1 10
 1 2 3 2
 1 1 3 2
 1 2 3 1
 '''
 
 input = iter(s.splitlines(keepends=True))
 import sys
 out = sys.stdout
 input = open('C-small-attempt6.in')
 out   = open('C-small-attempt6.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 
 #input = open('B-large.in')
 #out   = open('B-large.out', 'w')
 #input = open('D-large-practice.in')
 #out   = open('D-large-practice.out', 'w')
 
 
 
 from itertools import combinations, permutations, combinations_with_replacement, product
 from collections import defaultdict
 from copy import deepcopy
 
 
 X = ((0,0,1),
 (0,1,2),
 (0,1,0),
 (0,0,0),(0,0,2),(0,1,1))
 def solve(J,P,S,K):
 	#import pdb;pdb.set_trace()
 	maxa = []
 	
 	*keys, = product(range(J), range(P), range(S))
 	
 	N = 1<<len(keys)
 	ans = []
 	for n in range(N):
 		for j in range(len(keys)):
 			if (n>>j)&1:
 				ans
 	
 	keys = product(range(J), range(P))
 	for xx in permutations(keys):
 		
 
 		#if xx == X:
 		#	import pdb; pdb.set_trace()
 		#k = K
 		ans = []
 		D = defaultdict(int)
 		
 		try:
 			for j,p in xx:
 				for s in range(S):
 						k1 = (-1, p, s)
 						k2 = ( j,-1, s)
 						k3 = ( j, p,-1)
 						if D[k1] >= K:
 							raise StopIteration()
 						if D[k2] >= K:
 							raise StopIteration()
 						if D[k3] >= K:
 							raise StopIteration()
 						#D.add(k1)
 						#D.add(k2)
 						#D.add(k3)
 						#if k < 0:
 						#	#print((j,p,s), D)
 						#	raise StopIteration()
 						D[k1] += 1
 						D[k2] += 1
 						D[k3] += 1
 						#print(j,p,s)
 						ans += [(j,p,s)]
 		except StopIteration as s:
 			pass
 
 		if len(maxa) < len(ans):
 			maxa = ans
 			#print()
 	return maxa
 
 def solve(J,P,S,K):
 	ans = []
 	for k in range(min(K,S)):
 		for j in range(J):
 			for p in range(P):
 				s = (p + j + k)%S
 				ans += [(j,p,s)]
 	return ans
 
 CaseCnt = int(next(input))
 for case in range(CaseCnt):
 	J,P,S,K = map(int, next(input).split())
 	ans = solve(J,P,S,K)
 	
 	#c = str(c).rjust(len(C), '0')
 	#j = str(j).rjust(len(J), '0')
 	
 	print('Case #%d:'%(case+1), len(ans), file=out)
 	for a in ans:
 		a = [n+1 for n in a]
 		print(*a, file=out)
",gcj/2016/4314486/oonishi/5708921029263360/0/extracted/c.py,2160,112,285,Python,4314486,0,5708921029263360,oonishi,2016
10352,B.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 input = """"""\
 6
 2 8
 9 5
 4684 7920 3600 5203 1730 6820 845 2970
 990 2527 3600 2821 476 2000 1350 3743
 2 1
 500 300
 900
 660
 2 1
 500 300
 1500
 809
 2 2
 50 100
 450 449
 1100 1101
 2 1
 500 300
 300
 500
 2 8
 10 10
 11 13 17 11 16 14 12 18
 14 13 17 11 16 14 12 18
 3 3
 70 80 90
 1260 1500 700
 800 1440 1600
 1700 1620 900
 """""".splitlines(keepends=True)
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'B-small-attempt1.in').readlines()
 	input = open(r'B-large.in').readlines()
 	output = open(""B.out"", ""w"")
 	
 input = iter(input)
 
 import math
 # print(math.ceil(18/1.1), 13/1.1)
 # print(math.floor(18/0.9), 13/0.9)
 # raise
 
 # def Round(d):
 	# n = int(d)
 	# r = d - n
 	# r = int(r*10)
 	# if r == 9:
 		# n += 1
 	# elif r > 1:
 		# n = 0
 	# return n
 # print(Round(0.9))
 # print(Round(1.5))
 # print(Round(0.89))
 # print(Round(2.1))
 # raise
 
 from collections import defaultdict
 
 def search(G,S,i,low,high):
 	if i == len(G) or S[i]==len(G[i]): return low, high
 	
 	l,h = G[i][S[i]]
 	if h<l:
 		S[i] += 1
 		return 1,-1
 		
 	if h<low:
 		S[i] += 1
 		return 1,-1
 	
 	if high<l:
 		return 1,-1
 		
 	l,h = search(G,S,i+1,max(low,l),min(high,h))
 	
 	if l<=h:
 		S[i] += 1
 	return l,h
 	
 # G = [
 # [(9, 9), (9, 10)],
 # [(10, 12), (11, 12)],
 # ]
 # S = [0,0]
 # l,h = search(G,S,0,-float('inf'),float('inf'))
 # print(l,h)
 # print(S)
 # print()
 
 # l,h = search(G,S,0,-float('inf'),float('inf'))
 # print(l,h)
 # print(S)
 #raise
 #raise
 
 def solve(N,P,R,I):
 	for i,l in enumerate(I):
 		#l = [n for n in l if int(n*10/R[i])%10 in (0,1,9)]
 		l.sort()#(reverse=True)
 		#print(l)
 	#return []
 	
 	
 	G = []
 	for i in range(N):
 		l = [(math.ceil(n/1.1/R[i]),math.floor(n/0.9/R[i])) for n in I[i]]
 		G += [l]
 		print(l)
 	#print(G)
 	
 	count = 0
 	S = [0]*N
 	for k in range(P):
 		#l,h = search(G,S,0,-float('inf'),float('inf'))
 		l,h = search(G,S,1,G[0][k][0],G[0][k][1])
 		if l == h == -1:
 			S[i] += 1
 		if l<=h:
 			count += 1
 		#print(l,h,S)
 	return count
 	
 		
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,P = map(int, next(input).split())
 	*R, = map(int, next(input).split())
 	I = []
 	for i in range(N):
 		*l, = map(int, next(input).split())
 		I += [l]
 		
 	res = solve(N,P,R,I)
 	print(""Case #%d:""%case, res, file=output)
 #'''",gcj/2017/5304486/oonishi/5697460110360576/1/extracted/B.py,2511,151,383,Python,5304486,1,5697460110360576,oonishi,2017
10353,B.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 input = """"""\
 6
 2 8
 9 5
 4684 7920 3600 5203 1730 6820 845 2970
 990 2527 3600 2821 476 2000 1350 3743
 2 1
 500 300
 900
 660
 2 1
 500 300
 1500
 809
 2 2
 50 100
 450 449
 1100 1101
 2 1
 500 300
 300
 500
 2 8
 10 10
 11 13 17 11 16 14 12 18
 14 13 17 11 16 14 12 18
 3 3
 70 80 90
 1260 1500 700
 800 1440 1600
 1700 1620 900
 """""".splitlines(keepends=True)
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'B-small-attempt1.in').readlines()
 	#input = open(r'B-large-practice.in').readlines()
 	output = open(""B.out"", ""w"")
 	
 input = iter(input)
 
 import math
 # print(math.ceil(18/1.1), 13/1.1)
 # print(math.floor(18/0.9), 13/0.9)
 # raise
 
 # def Round(d):
 	# n = int(d)
 	# r = d - n
 	# r = int(r*10)
 	# if r == 9:
 		# n += 1
 	# elif r > 1:
 		# n = 0
 	# return n
 # print(Round(0.9))
 # print(Round(1.5))
 # print(Round(0.89))
 # print(Round(2.1))
 # raise
 
 from collections import defaultdict
 
 def search(G,S,i,low,high):
 	if i == len(G) or S[i]==len(G[i]): return low, high
 	
 	l,h = G[i][S[i]]
 	if h<l:
 		S[i] += 1
 		return 1,-1
 		
 	if h<low:
 		S[i] += 1
 		return 1,-1
 	
 	if high<l:
 		return 1,-1
 		
 	l,h = search(G,S,i+1,max(low,l),min(high,h))
 	
 	if l<=h:
 		S[i] += 1
 	return l,h
 	
 # G = [
 # [(9, 9), (9, 10)],
 # [(10, 12), (11, 12)],
 # ]
 # S = [0,0]
 # l,h = search(G,S,0,-float('inf'),float('inf'))
 # print(l,h)
 # print(S)
 # print()
 
 # l,h = search(G,S,0,-float('inf'),float('inf'))
 # print(l,h)
 # print(S)
 #raise
 #raise
 
 def solve(N,P,R,I):
 	for i,l in enumerate(I):
 		#l = [n for n in l if int(n*10/R[i])%10 in (0,1,9)]
 		l.sort()#(reverse=True)
 		#print(l)
 	#return []
 	
 	
 	G = []
 	for i in range(N):
 		l = [(math.ceil(n/1.1/R[i]),math.floor(n/0.9/R[i])) for n in I[i]]
 		G += [l]
 		print(l)
 	#print(G)
 	
 	count = 0
 	S = [0]*N
 	for k in range(P):
 		#l,h = search(G,S,0,-float('inf'),float('inf'))
 		l,h = search(G,S,1,G[0][k][0],G[0][k][1])
 		if l == h == -1:
 			S[i] += 1
 		if l<=h:
 			count += 1
 		#print(l,h,S)
 	return count
 	
 		
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,P = map(int, next(input).split())
 	*R, = map(int, next(input).split())
 	I = []
 	for i in range(N):
 		*l, = map(int, next(input).split())
 		I += [l]
 		
 	res = solve(N,P,R,I)
 	print(""Case #%d:""%case, res, file=output)
 #'''",gcj/2017/5304486/oonishi/5697460110360576/0/extracted/B.py,2521,151,383,Python,5304486,0,5697460110360576,oonishi,2017
22473,A.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 input = """"""\
 5
 4 3
 4 5 6 4
 4 2
 4 5 6 4
 3 3
 1 1 1
 4 4
 1 2 3 5
 7 4
 1 2 3 5 8 7 3
 """""".splitlines(keepends=True)
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'A-small-attempt0.in').readlines()
 	input = open(r'A-large.in').readlines()
 	output = open(""A.out"", ""w"")
 	
 input = iter(input)
 
 
 import math
 from collections import defaultdict,deque
 
 sys.setrecursionlimit(1500)
 		
 import itertools
 # print(math.floor(2.5))
 # print(math.ceil(2.5))
 # raise
 
 def solve(N,P,G):
 	print((N,P,G))
 	
 	C = defaultdict(int)
 	for n in G:
 		C[n%P] += 1
 		
 	if P == 2:
 		return C[0] + (C[1]+1)//2
 		
 	if P == 3:
 		res = C[0]
 		n = min(C[1], C[(-1)%P])
 		res += n
 		C[1] -= n
 		C[(-1)%P] -= n
 		n = max(C[1], C[(-1)%P])
 		return res+(n+2)//3
 		
 	res = C[0]
 	n = min(C[1], C[(-1)%P])
 	res += n
 	
 	C[1] -= n
 	C[(-1)%P] -= n
 	m = max(C[1], C[(-1)%P])
 	
 	n = C[2]//2
 	C[2] -= n*2
 	res += n
 	
 	
 	
 	if C[2] != 0 and m>=2:
 		res += 1
 		m -= 2
 		C[2] = 0
 	if C[2] != 0:
 		return res + 1
 	
 	n = (m+3)//4
 	res += n
 	return res
 	
 def calc(p,P):
 	score = 0
 	sum = 0
 	for n in p:
 		if sum % P == 0:
 			score += 1
 		sum += n
 	return score
 def _solve(N,P,G):
 	best = 0
 	for p in itertools.permutations(G,N):
 		best = max(calc(p,P),best)
 	return best 
 	
 	
 import time
 
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	#N = int(next(input).strip())
 	N,P = [int(s) for s in next(input).split()]
 	G = [int(s) for s in next(input).split()]
 	t0 = time.time()
 	
 	res = solve(N,P,G)
 	#print(""Case #%d:""%case, '%0.20lf'%res, file=output)
 	print(""Case #%d:""%case, res, file=output)
 	print(time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/5314486/oonishi/5700919488413696/1/extracted/A.py,1895,120,286,Python,5314486,1,5700919488413696,oonishi,2017
22474,A.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 input = """"""\
 4
 4 3
 4 5 6 4
 4 2
 4 5 6 4
 3 3
 1 1 1
 4 4
 1 2 3 5
 """""".splitlines(keepends=True)
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'A-small-attempt0.in').readlines()
 	#input = open(r'').readlines()
 	output = open(""A.out"", ""w"")
 	
 input = iter(input)
 
 
 import math
 from collections import defaultdict,deque
 
 sys.setrecursionlimit(1500)
 		
 import itertools
 # print(math.floor(2.5))
 # print(math.ceil(2.5))
 # raise
 
 def solve(N,P,G):
 	print((N,P,G))
 	
 	C = defaultdict(int)
 	for n in G:
 		C[n%P] += 1
 		
 	if P == 2:
 		return C[0] + (C[1]+1)//2
 		
 	if P == 3:
 		res = C[0]
 		n = min(C[1], C[(-1)%P])
 		res += n
 		C[1] -= n
 		C[(-1)%P] -= n
 		n = max(C[1], C[(-1)%P])
 		return res+(n+2)//3
 		
 	res = C[0]
 	n = min(C[1], C[(-1)%P])
 	res += n
 	C[1] -= n
 	C[(-1)%P] -= n
 	m = max(C[1], C[(-1)%P])
 	
 	n = C[2]//2
 	C[2] -= n*2
 	res += 2
 	
 	if C[2] != 0 and m>=2:
 		res += 1
 		m -= 2
 		C[2] = 0
 	
 	n = m//4
 	res += n
 	return res
 	
 	
 import time
 
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	#N = int(next(input).strip())
 	N,P = [int(s) for s in next(input).split()]
 	G = [int(s) for s in next(input).split()]
 	t0 = time.time()
 	
 	res = solve(N,P,G)
 	#print(""Case #%d:""%case, '%0.20lf'%res, file=output)
 	print(""Case #%d:""%case, res, file=output)
 	print(time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/5314486/oonishi/5700919488413696/0/extracted/A.py,1586,99,229,Python,5314486,0,5700919488413696,oonishi,2017
111616,b.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 4
 132
 1000
 7
 111111111111111110
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\B-small-attempt0.in').readlines()
 	input = open(r'C:\Users\user1\Desktop\B-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\B.out', ""w"")
 	
 input = iter(input)
 
 def solve(N):
 	N = [int(n) for n in N]
 	
 	top = 0
 	for i in range(len(N)-1):
 		if N[i]>N[i+1]:
 			break
 		if N[i] != N[i+1]:
 			top = i+1
 	else:
 		return ''.join(map(str,N))
 	
 	for j in range(top+1,len(N)):
 		N[j] = 9
 	
 	N[top] -= 1
 	return ''.join(map(str,N)).strip('0')
 	
 	#for i,_ in enumerate(N[:-1]):
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N = next(input).strip()
 	res = solve(N)
 	if res!=-1:
 		print(""Case #%d:""%case, res, file=output)
 	else:
 		print(""Case #%d:""%case, ""IMPOSSIBLE"", file=output)
 	
 #'''
",gcj/2017/3264486/oonishi/5633382285312000/1/extracted/b.py,1092,58,123,Python,3264486,1,5633382285312000,oonishi,2017
111617,b.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 4
 132
 1000
 7
 111111111111111110
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\B-small-attempt0.in').readlines()
 	#input = open(r'C:\Users\user1\Desktop\A-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\B.out', ""w"")
 	
 input = iter(input)
 
 def solve(N):
 	N = [int(n) for n in N]
 	
 	top = 0
 	for i in range(len(N)-1):
 		if N[i]>N[i+1]:
 			break
 		if N[i] != N[i+1]:
 			top = i+1
 	else:
 		return ''.join(map(str,N))
 	
 	for j in range(top+1,len(N)):
 		N[j] = 9
 	
 	N[top] -= 1
 	return ''.join(map(str,N)).strip('0')
 	
 	#for i,_ in enumerate(N[:-1]):
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N = next(input).strip()
 	res = solve(N)
 	if res!=-1:
 		print(""Case #%d:""%case, res, file=output)
 	else:
 		print(""Case #%d:""%case, ""IMPOSSIBLE"", file=output)
 	
 #'''
",gcj/2017/3264486/oonishi/5633382285312000/0/extracted/b.py,1093,58,123,Python,3264486,0,5633382285312000,oonishi,2017
111618,d.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 2
 35 1
 o 1 30
 20 0
 2 0
 1 1
 o 1 1
 3 4
 + 2 3
 + 2 1
 x 3 1
 + 2 2
 85 2
 o 1 47
 + 1 22
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\D-small-attempt4.in').readlines()
 	input = open(r'C:\Users\user1\Desktop\D-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\D.out', ""w"")
 	
 input = iter(input)
 
 
 from collections import defaultdict
 from copy import deepcopy
 
 import random
 #for s in dir(random):print(s)
 #print(random.sample(range(10), 10))
 #raise
 
 def solve(N,E):
 	
 	C = [0]*N
 	R = [0]*N
 	Mo = [['.']*N for _ in range(N)]
 	X = [[0]*N for _ in range(N)]
 	for t,r,c in E:
 		if t in 'xo':
 			R[r] = 1
 			C[c] = 1
 			X[r][c] = 1
 		Mo[r][c] = t
 	#import pdb; pdb.set_trace()5
 	#for r in random.sample(range(N), N):
 	#	for c in random.sample(range(N), N):
 	for r in range(N):
 		for c in range(N):
 			if R[r] == 0 and C[c] == 0:
 				R[r] = 1
 				C[c] = 1
 				X[r][c] = 1
 	
 	#[print(x) for x in X]
 	Sq = {}
 	for i in range(N):
 		for j in range(N):
 			Sq[(i-j,i+j)] = (i,j)
 
 	R = set()
 	L = set()
 	
 	P = [[0]*N for _ in range(N)]
 	for t,r,c in E:
 		if t in '+o':
 			R.add(r-c)
 			L.add(r+c)
 			P[r][c] = 1
 	
 	#for r in random.sample(range(N), N):
 	#	for c in random.sample(range(N), N):
 	for r in range(N):
 		if r % 2:
 			r = N - (r+1)//2
 		for c in range(N):
 			#if c % 2:
 			#	c = N - (c+1)//2
 			if (r-c) not in R and (r+c) not in L:
 				R.add(r-c)
 				L.add(r+c)
 				P[r][c] = 1
 	#print(P)5
 	M = [['.']*N for _ in range(N)]
 	
 	#print(sum([sum(l) for l in X]))
 	#print(sum([sum(l) for l in P]))
 	
 	
 	score = 0
 	for r in range(N):
 		for c in range(N):
 			if X[r][c] and P[r][c]:
 				M[r][c] = 'o'
 				score += 2
 			elif X[r][c]:
 				M[r][c] = 'x'
 				score += 1
 			elif P[r][c]:
 				M[r][c] = ""+""
 				score += 1
 	#[print('\t'.join(m)) for m in M]
 	#print()
 	#[print(m) for m in M]
 	add = []
 	for r in range(N):
 		for c in range(N):
 			if M[r][c] != Mo[r][c]:
 				add += [(M[r][c],r,c)]
 			if M[r][c] == '.' and Mo[r][c] != '.':
 				raise
 			if M[r][c] != Mo[r][c] and M[r][c]!='o' and Mo[r][c]!='.':
 				print(M[r][c],Mo[r][c])
 				raise
 	
 	return score,add
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,M = map(int, next(input).split())
 	E = []
 	for m in range(M):
 		t,r,c = next(input).split()
 		r,c = int(r),int(c)
 		E += [(t,r-1,c-1)]
 	random.seed(0)
 	best = 0
 	for i in range(1):
 		score,add = solve(N,E)
 		if score > best:
 			best = score
 			best_add = add
 			#if score == 101:raise
 	score = best
 	add = best_add
 	print(""Case #%d:""%case, score, len(add), file=output)
 	for t,r,c in add:
 		print(t,r+1,c+1, file=output)
 	
 	
 #'''
",gcj/2017/3264486/oonishi/5719854539603968/1/extracted/d.py,2957,156,456,Python,3264486,1,5719854539603968,oonishi,2017
111619,d.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 2
 35 1
 o 1 30
 20 0
 2 0
 1 1
 o 1 1
 3 4
 + 2 3
 + 2 1
 x 3 1
 + 2 2
 85 2
 o 1 47
 + 1 22
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\D-small-attempt4.in').readlines()
 	#input = open(r'C:\Users\user1\Desktop\C-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\D.out', ""w"")
 	
 input = iter(input)
 
 
 from collections import defaultdict
 from copy import deepcopy
 
 import random
 #for s in dir(random):print(s)
 #print(random.sample(range(10), 10))
 #raise
 
 def solve(N,E):
 	
 	C = [0]*N
 	R = [0]*N
 	Mo = [['.']*N for _ in range(N)]
 	X = [[0]*N for _ in range(N)]
 	for t,r,c in E:
 		if t in 'xo':
 			R[r] = 1
 			C[c] = 1
 			X[r][c] = 1
 		Mo[r][c] = t
 	#import pdb; pdb.set_trace()5
 	#for r in random.sample(range(N), N):
 	#	for c in random.sample(range(N), N):
 	for r in range(N):
 		for c in range(N):
 			if R[r] == 0 and C[c] == 0:
 				R[r] = 1
 				C[c] = 1
 				X[r][c] = 1
 	
 	#[print(x) for x in X]
 	Sq = {}
 	for i in range(N):
 		for j in range(N):
 			Sq[(i-j,i+j)] = (i,j)
 
 	R = set()
 	L = set()
 	
 	P = [[0]*N for _ in range(N)]
 	for t,r,c in E:
 		if t in '+o':
 			R.add(r-c)
 			L.add(r+c)
 			P[r][c] = 1
 	
 	#for r in random.sample(range(N), N):
 	#	for c in random.sample(range(N), N):
 	for r in range(N):
 		if r % 2:
 			r = N - (r+1)//2
 		for c in range(N):
 			if (r-c) not in R and (r+c) not in L:
 				R.add(r-c)
 				L.add(r+c)
 				P[r][c] = 1
 	#print(P)5
 	M = [['.']*N for _ in range(N)]
 	
 	#print(sum([sum(l) for l in X]))
 	#print(sum([sum(l) for l in P]))
 	
 	
 	score = 0
 	for r in range(N):
 		for c in range(N):
 			if X[r][c] and P[r][c]:
 				M[r][c] = 'o'
 				score += 2
 			elif X[r][c]:
 				M[r][c] = 'x'
 				score += 1
 			elif P[r][c]:
 				M[r][c] = ""+""
 				score += 1
 	#[print('\t'.join(m)) for m in M]
 	#print()
 	#[print(m) for m in M]
 	add = []
 	for r in range(N):
 		for c in range(N):
 			if M[r][c] != Mo[r][c]:
 				add += [(M[r][c],r,c)]
 			if M[r][c] == '.' and Mo[r][c] != '.':
 				raise
 			if M[r][c] != Mo[r][c] and M[r][c]!='o' and Mo[r][c]!='.':
 				print(M[r][c],Mo[r][c])
 				raise
 	
 	return score,add
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,M = map(int, next(input).split())
 	E = []
 	for m in range(M):
 		t,r,c = next(input).split()
 		r,c = int(r),int(c)
 		E += [(t,r-1,c-1)]
 	random.seed(0)
 	best = 0
 	for i in range(1):
 		score,add = solve(N,E)
 		if score > best:
 			best = score
 			best_add = add
 			#if score == 101:raise
 	score = best
 	add = best_add
 	print(""Case #%d:""%case, score, len(add), file=output)
 	for t,r,c in add:
 		print(t,r+1,c+1, file=output)
 	
 	
 #'''
",gcj/2017/3264486/oonishi/5719854539603968/0/extracted/d.py,2920,154,446,Python,3264486,0,5719854539603968,oonishi,2017
111620,template.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 input = """"""\
 3
 ---+-++- 3
 +++++ 4
 -+-+- 4
 """""".splitlines(keepends=True)
 
 #input = open(r'C:\Users\user1\Downloads\A-small-attempt0.in').readlines()
 input = open(r'C:\Users\user1\Desktop\A-Large.in').readlines()
 input = iter(input)
 
 def solve(P,K):
 	P = [c=='+' for c in P]
 	#print(P, -K+1)
 	count = 0
 	for i,_ in enumerate(P[:-K+1]):
 		if P[i]: continue
 		count += 1
 		for k in range(K):
 			P[i+k] = not P[i+k]
 		#print(P)
 	for p in P[-K+1:]:
 		if not p: return -1
 	return count
 
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	P,K = next(input).split()
 	K = int(K)
 	res = solve(P,K)
 	if res!=-1:
 		print(""Case #%d:""%case, res)
 	else:
 		print(""Case #%d:""%case, ""IMPOSSIBLE"")
 	
 exit(0)
 if __name__ == '__main__':
 	import sys
 	print(sys.argv)
 	print(sys.executable)
 	print(sys.version)
 	import ctypes
 	print(ctypes.sizeof(ctypes.c_size_t))
 
 #'''
",gcj/2017/3264486/oonishi/5736519012712448/1/extracted/template.py,1088,56,127,Python,3264486,1,5736519012712448,oonishi,2017
111621,template.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 input = """"""\
 3
 ---+-++- 3
 +++++ 4
 -+-+- 4
 """""".splitlines(keepends=True)
 
 input = open(r'C:\Users\user1\Downloads\A-small-attempt0.in').readlines()
 input = iter(input)
 
 def solve(P,K):
 	P = [c=='+' for c in P]
 	#print(P, -K+1)
 	count = 0
 	for i,_ in enumerate(P[:-K+1]):
 		if P[i]: continue
 		count += 1
 		for k in range(K):
 			P[i+k] = not P[i+k]
 		#print(P)
 	for p in P[-K+1:]:
 		if not p: return -1
 	return count
 
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	P,K = next(input).split()
 	K = int(K)
 	res = solve(P,K)
 	if res!=-1:
 		print(""Case #%d:""%case, res)
 	else:
 		print(""Case #%d:""%case, ""IMPOSSIBLE"")
 	
 exit(0)
 if __name__ == '__main__':
 	import sys
 	print(sys.argv)
 	print(sys.executable)
 	print(sys.version)
 	import ctypes
 	print(ctypes.sizeof(ctypes.c_size_t))
 
 #'''
",gcj/2017/3264486/oonishi/5736519012712448/0/extracted/template.py,1023,55,124,Python,3264486,0,5736519012712448,oonishi,2017
111622,c.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 5
 4 2
 5 2
 6 2
 1000 1000
 1000 1
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\C-small-2-attempt0.in').readlines()
 	input = open(r'C:\Users\user1\Desktop\C-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\C.out', ""w"")
 	
 input = iter(input)
 
 from collections import defaultdict
 def solve(N,K):
 	B = defaultdict(int, {N:1})
 	while 1:
 		#print(B,K)
 		b = max([b for b in B.keys() if B[b]>0])
 		k = min(B[b],K)
 		
 		if K <= B[b]:
 			break
 		
 		B[(b-1)//2]   += k
 		B[b//2] += k
 		
 		B[b] = 0
 		K -= k
 	
 	return b//2, (b-1)//2
 	
 	#for i,_ in enumerate(N[:-1]):
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,K = map(int, next(input).split())
 	res = solve(N,K)
 	print(""Case #%d:""%case, *res, file=output)
 	
 #'''
",gcj/2017/3264486/oonishi/5654742835396608/2/extracted/c.py,1042,57,127,Python,3264486,2,5654742835396608,oonishi,2017
111623,c.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 5
 4 2
 5 2
 6 2
 1000 1000
 1000 1
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\C-small-2-attempt0.in').readlines()
 	#input = open(r'C:\Users\user1\Desktop\B-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\C.out', ""w"")
 	
 input = iter(input)
 
 from collections import defaultdict
 def solve(N,K):
 	B = defaultdict(int, {N:1})
 	while 1:
 		#print(B,K)
 		b = max([b for b in B.keys() if B[b]>0])
 		k = min(B[b],K)
 		
 		if K <= B[b]:
 			break
 		
 		B[(b-1)//2]   += k
 		B[b//2] += k
 		
 		B[b] = 0
 		K -= k
 	
 	return b//2, (b-1)//2
 	
 	#for i,_ in enumerate(N[:-1]):
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,K = map(int, next(input).split())
 	res = solve(N,K)
 	print(""Case #%d:""%case, *res, file=output)
 	
 #'''
",gcj/2017/3264486/oonishi/5654742835396608/1/extracted/c.py,1043,57,127,Python,3264486,1,5654742835396608,oonishi,2017
111624,c.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 os.system(sys.executable + "" %s %s""%(__file__, args))
 #os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 import sys
 input = """"""\
 5
 4 2
 5 2
 6 2
 1000 1000
 1000 1
 """""".splitlines(keepends=True)
 output = sys.stdout
 
 if 1:
 	input = open(r'C:\Users\user1\Desktop\C-small-1-attempt0.in').readlines()
 	#input = open(r'C:\Users\user1\Desktop\B-Large.in').readlines()
 	output = open(r'C:\Users\user1\Desktop\C.out', ""w"")
 	
 input = iter(input)
 
 from collections import defaultdict
 def solve(N,K):
 	B = defaultdict(int, {N:1})
 	while 1:
 		#print(B,K)
 		b = max([b for b in B.keys() if B[b]>0])
 		k = min(B[b],K)
 		
 		if K <= B[b]:
 			break
 		
 		B[(b-1)//2]   += k
 		B[b//2] += k
 		
 		B[b] = 0
 		K -= k
 	
 	return b//2, (b-1)//2
 	
 	#for i,_ in enumerate(N[:-1]):
 	
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,K = map(int, next(input).split())
 	res = solve(N,K)
 	print(""Case #%d:""%case, *res, file=output)
 	
 #'''
",gcj/2017/3264486/oonishi/5654742835396608/0/extracted/c.py,1043,57,127,Python,3264486,0,5654742835396608,oonishi,2017
164889,A.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 #os.system(sys.executable + "" %s %s""%(__file__, args))
 os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 # import ctypes
 # print(ctypes.cdll.test.test(8))
 # raise
 
 input = """"""\
 3
 2525 1
 2400 5
 300 2
 120 60
 60 90
 100 2
 80 100
 70 10
 """""".splitlines(keepends=True)
 
 
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'A-small-attempt0.in').readlines()
 	input = open(r'A-large.in').readlines()
 	output = open(""A.out"", ""w"")
 	
 input = iter(input)
 
 import math
 from collections import defaultdict
 
 sys.setrecursionlimit(1500)
 	
 def solve(D,N,O):
 	print(O)
 	l = [(D-K)/S for K,S in O]
 	print(l)
 	t = max(l)
 	return D/t
 	
 import time
 # raise
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	D,N = map(int, next(input).split())
 	O = []
 	for i in range(N):
 		K,S = map(int, next(input).split())
 		O += [(K,S)]
 	t0 = time.time()
 	#print(D,N)
 	res = solve(D,N,O)
 	print(""Case #%d:""%case, res, file=output)
 	print('Case', case, time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/8294486/oonishi/5630967708385280/1/extracted/A.py,1107,67,140,Python,8294486,1,5630967708385280,oonishi,2017
164890,A.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 #os.system(sys.executable + "" %s %s""%(__file__, args))
 os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 # import ctypes
 # print(ctypes.cdll.test.test(8))
 # raise
 
 input = """"""\
 3
 2525 1
 2400 5
 300 2
 120 60
 60 90
 100 2
 80 100
 70 10
 """""".splitlines(keepends=True)
 
 
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'A-small-attempt0.in').readlines()
 	#input = open(r'').readlines()
 	output = open(""A.out"", ""w"")
 	
 input = iter(input)
 
 import math
 from collections import defaultdict
 
 sys.setrecursionlimit(1500)
 	
 def solve(D,N,O):
 	print(O)
 	l = [(D-K)/S for K,S in O]
 	print(l)
 	t = max(l)
 	return D/t
 	
 import time
 # raise
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	D,N = map(int, next(input).split())
 	O = []
 	for i in range(N):
 		K,S = map(int, next(input).split())
 		O += [(K,S)]
 	t0 = time.time()
 	#print(D,N)
 	res = solve(D,N,O)
 	print(""Case #%d:""%case, res, file=output)
 	print('Case', case, time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/8294486/oonishi/5630967708385280/0/extracted/A.py,1098,67,140,Python,8294486,0,5630967708385280,oonishi,2017
164891,B.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 #os.system(sys.executable + "" %s %s""%(__file__, args))
 os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 # import ctypes
 # print(ctypes.cdll.test.test(8))
 # raise
 
 input = """"""\
 4
 6 2 0 2 0 2 0
 3 1 0 2 0 0 0
 6 2 0 1 1 2 0
 4 0 0 2 0 0 2
 """""".splitlines(keepends=True)
 
 
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'B-small-attempt1.in').readlines()
 	input = open(r'B-large.in').readlines()
 	output = open(""B.out"", ""w"")
 	
 input = iter(input)
 
 import math
 from collections import defaultdict
 
 sys.setrecursionlimit(1500)
 	
 #def solve(N,R,O,Y,G,B,V):
 def solve1(N,R,Y,B):
 	l = [(R,'R'),(Y,'Y'),(B,'B')]
 	l.sort()
 	if l[2][0] > l[1][0] + l[0][0]:
 		return 'IMPOSSIBLE'
 		
 	res = ''
 	n = l[1][0] + l[0][0] - l[2][0]
 	for i in range(n):
 		res += l[2][1] + l[0][1] + l[1][1]
 	for i in range(l[1][0]-n):
 		res += l[2][1] + l[1][1]
 	for i in range(l[0][0]-n):
 		res += l[2][1] + l[0][1]
 	
 	# r = b = y = 0
 	# for c in res:
 		# if c=='R': r += 1
 		# if c=='B': b += 1
 		# if c=='Y': y += 1
 	
 	# print(res)
 	# if r != R: raise
 	# if b != B: raise
 	# if y != Y: raise
 	
 	return res
 	
 def complementary(N,C,P,c):
 	if C > P: return 'IMPOSSIBLE'
 	if C == P:
 		if C+P != N: 'IMPOSSIBLE'
 		return c*C
 	return None
 	
 def solve(N,R,O,Y,G,B,V):
 	print((N,R,O,Y,G,B,V))
 	
 	res = complementary(N,O,B,'OB');
 	if res: return res
 	res = complementary(N,V,Y,'VY');
 	if res: return res
 	res = complementary(N,G,R,'GR');
 	if res: return res
 	
 	b = B-O
 	y = Y-V
 	r = R-G
 	
 	#res = solve1(R+Y+B, R, Y, B)
 	res = solve1(r+y+b, r, y, b)
 	if res == 'IMPOSSIBLE': return res
 	
 	p = res.find('R')
 	if p!=-1:
 		res = res[:p] + 'RG'*G + 'R' + res[p+1:]
 	p = res.find('B')
 	if p!=-1:
 		res = res[:p] + 'BO'*O + 'B' + res[p+1:]
 	p = res.find('Y')
 	if p!=-1:
 		res = res[:p] + 'YV'*V + 'Y' + res[p+1:]
 	
 	
 	# t = defaultdict(int)
 	# for c in res:
 		# t[c] += 1
 	# for c in 'RBYGOV':
 		# if t[c] != eval(c):
 			# print(c, t[c], eval(c), res)
 			# raise
 	# if len(res) != N: raise
 	
 	# X = {'R':1, 'B':2, 'Y':4, 'O':5, 'G':6, 'V':3}
 	# for c1,c2 in zip(res,res[1:]+res[0]):
 		# if X[c1] & X[c2]:
 			# print(c1,c2)
 			# raise
 		
 	return res
 
 
 # import random
 # def gen(n):
 	# c = 'R'#random.choice('RYBGOV')
 	# for i in range(n-1):
 		# if c[-1] == 'R':
 			# c += random.choice('YBG')
 		# elif c[-1] == 'B':
 			# c += random.choice('RYO')
 		# elif c[-1] == 'Y':
 			# c += random.choice('RBV')
 		# elif c[-1] == 'O':
 			# c += 'B'
 		# elif c[-1] == 'G':
 			# c += 'R'
 		# elif c[-1] == 'V':
 			# c += 'Y'
 	# while c[-1] not in 'BYG':
 		# if c[-1] == 'R':
 			# c += random.choice('YBG')
 		# elif c[-1] == 'B':
 			# c += random.choice('RYO')
 		# elif c[-1] == 'Y':
 			# c += random.choice('RBV')
 		# elif c[-1] == 'O':
 			# c += 'B'
 		# elif c[-1] == 'G':
 			# c += 'R'
 		# elif c[-1] == 'V':
 			# c += 'Y'
 	# return c
 # #print(gen(20))
 # for i in range(100):
 	# s = gen(20)
 	# print(s)
 	# t = defaultdict(int)
 	# for c in s:
 		# t[c] += 1
 
 	# print(solve(len(s),t['R'],t['O'],t['Y'],t['G'],t['B'],t['V']))
 
 # raise
 	
 	
 import time
 # raise
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	#Hd,Ad,Hk,Ak,B,D = map(int, next(input).split())
 	N,R,O,Y,G,B,V = map(int, next(input).split())
 	t0 = time.time()
 	print(N,R,O,Y,G,B,V)
 	res = solve(N,R,O,Y,G,B,V)
 	print(""Case #%d:""%case, res, file=output)
 	print(time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/8294486/oonishi/5654117850546176/1/extracted/B.py,3565,179,569,Python,8294486,1,5654117850546176,oonishi,2017
164892,B.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 #os.system(sys.executable + "" %s %s""%(__file__, args))
 os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 # import ctypes
 # print(ctypes.cdll.test.test(8))
 # raise
 
 input = """"""\
 4
 6 2 0 2 0 2 0
 3 1 0 2 0 0 0
 6 2 0 1 1 2 0
 4 0 0 2 0 0 2
 """""".splitlines(keepends=True)
 
 
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'B-small-attempt1.in').readlines()
 	#input = open(r'').readlines()
 	output = open(""B.out"", ""w"")
 	
 input = iter(input)
 
 import math
 from collections import defaultdict
 
 sys.setrecursionlimit(1500)
 	
 def solve(N,R,O,Y,G,B,V):
 	l = [(R,'R'),(Y,'Y'),(B,'B')]
 	l.sort()
 	if l[2][0] > l[1][0] + l[0][0]:
 		return 'IMPOSSIBLE'
 		
 	res = ''
 	n = l[1][0] + l[0][0] - l[2][0]
 	for i in range(n):
 		res += l[2][1] + l[0][1] + l[1][1]
 	for i in range(l[1][0]-n):
 		res += l[2][1] + l[1][1]
 	for i in range(l[0][0]-n):
 		res += l[2][1] + l[0][1]
 	
 	# r = b = y = 0
 	# for c in res:
 		# if c=='R': r += 1
 		# if c=='B': b += 1
 		# if c=='Y': y += 1
 	
 	# print(res)
 	# if r != R: raise
 	# if b != B: raise
 	# if y != Y: raise
 	
 	return res
 	
 import time
 # raise
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	#Hd,Ad,Hk,Ak,B,D = map(int, next(input).split())
 	N,R,O,Y,G,B,V = map(int, next(input).split())
 	t0 = time.time()
 	print(N,R,O,Y,G,B,V)
 	res = solve(N,R,O,Y,G,B,V)
 	print(""Case #%d:""%case, res, file=output)
 	print(time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/8294486/oonishi/5654117850546176/0/extracted/B.py,1535,81,230,Python,8294486,0,5654117850546176,oonishi,2017
164893,C.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 #os.system(sys.executable + "" %s %s""%(__file__, args))
 os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 # import ctypes
 # print(ctypes.cdll.test.test(8))
 # raise
 
 input = """"""\
 3
 3 1
 2 3
 2 4
 4 4
 -1 1 -1
 -1 -1 1
 -1 -1 -1
 1 3
 4 1
 13 10
 1 1000
 10 8
 5 5
 -1 1 -1 -1
 -1 -1 1 -1
 -1 -1 -1 10
 -1 -1 -1 -1
 1 4
 4 3
 30 60
 10 1000
 12 5
 20 1
 -1 10 -1 31
 10 -1 10 -1
 -1 -1 -1 10
 15 6 -1 -1
 2 4
 3 1
 3 2
 """""".splitlines(keepends=True)
 
 
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'C-small-attempt1.in').readlines()
 	input = open(r'C-large.in').readlines()
 	output = open(""C.out"", ""w"")
 	
 input = iter(input)
 
 import math
 from collections import defaultdict
 
 sys.setrecursionlimit(1500)
 
 
 def dijkstra(D,H,u):
 	print(u)
 	
 	que = [(u,0.0,H[u][0],H[u][1])]
 	#visit = [0] * len(D)
 	#visit[u] = 1
 	times = [float('inf')]*len(D)
 	times[u] = 0
 	
 	#while 0 in visit:
 	visit = [0]*len(D)
 	visit[u] = 1
 	while 0 in visit:
 		n,t,e,s = que.pop()
 		print(n)
 		times[n] = min(times[n],t)
 		visit[n] = 1
 		for i,d in enumerate(D[n]):
 			if d == -1: continue
 			
 			if e>=d:
 				que += [(i,t + d/s, e-d, s)]
 				e1,s1 = H[i]
 				que += [(i,t + d/s, e1, s1)]
 		que.sort(key=lambda t:t[1], reverse=True)
 		#print(que)
 		#print(times)
 		#print(que)
 		#n = min(filter(lambda n:visit[n]==0, range(len(D))), key=lambda n:que[n])
 		#visit[n] = 1
 		#for i,d in enumerate(D[n]):
 		#	if d == -1: continue
 		#	que[i] = min(que[i], que[n] + d)
 	#print(times)
 	return times
 
 
 def dijkstra(D,H,u):
 	visit = [0]*len(D)
 	distanse = [float('inf')]*len(D)
 	distanse[u] = 0
 	#visit[u] = 1
 	e,s = H[u]
 	while 0 in visit:
 		n = min(filter(lambda n:visit[n]==0, range(len(D))), key=lambda n:distanse[n])
 		visit[n] = 1
 		for i,d in enumerate(D[n]):
 			if d == -1: continue
 			if distanse[n]+d <= e:
 				distanse[i] = min(distanse[i], distanse[n]+d)
 	times = [d/s for d in distanse]
 	return times
 	
 def dijkstra2(T,u):
 	visit = [0]*len(D)
 	times = [float('inf')]*len(D)
 	times[u] = 0
 	while 0 in visit:
 		n = min(filter(lambda n:visit[n]==0, range(len(D))), key=lambda n:times[n])
 		visit[n] = 1
 		for i,t in enumerate(times):
 			times[i] = min(times[i], T[n][i]+times[n])
 	
 	return times
 	
 def solve(N,Q,H,D,P):
 	#import pdb;pdb.set_trace()
 	
 	T = [dijkstra(D,H,i) for i in range(len(D))]
 	
 	
 	X = {}
 	for u in {u for u,v in P}:
 		X[u] = dijkstra2(T,u)
 	return [X[u][v] for u,v in P]
 	
 	
 
 #solve(N,Q,H,D,P)
 
 import time
 # raise
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,Q = map(int, next(input).split())
 	H = []
 	for i in range(N):
 		e,s = map(int, next(input).split())
 		H += [(e,s)]
 	D = []
 	for i in range(N):
 		*d, = map(int, next(input).split())
 		D += [d]
 	P = []
 	for i in range(Q):
 		u,v = map(int, next(input).split())
 		P += [(u-1,v-1)]
 	t0 = time.time()
 	#print((N,Q,H,D,P));sys.stdout.flush()
 	res = solve(N,Q,H,D,P)
 	print(""Case #%d:""%case, *res, file=output)
 	print(time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/8294486/oonishi/5681755159789568/1/extracted/C.py,3137,171,445,Python,8294486,1,5681755159789568,oonishi,2017
164894,C.py,"r'''
 args = ' '.join([
 	r'',
 ])
 import os
 import sys
 #os.system(sys.executable + "" %s %s""%(__file__, args))
 os.system(r'C:\Python36-32\python' + "" %s %s""%(__file__, args))
 r'''
 
 # import ctypes
 # print(ctypes.cdll.test.test(8))
 # raise
 
 input = """"""\
 3
 3 1
 2 3
 2 4
 4 4
 -1 1 -1
 -1 -1 1
 -1 -1 -1
 1 3
 4 1
 13 10
 1 1000
 10 8
 5 5
 -1 1 -1 -1
 -1 -1 1 -1
 -1 -1 -1 10
 -1 -1 -1 -1
 1 4
 4 3
 30 60
 10 1000
 12 5
 20 1
 -1 10 -1 31
 10 -1 10 -1
 -1 -1 -1 10
 15 6 -1 -1
 2 4
 3 1
 3 2
 """""".splitlines(keepends=True)
 
 
 
 
 import sys
 output = sys.stdout
 if 1:
 	input = open(r'C-small-attempt1.in').readlines()
 	#input = open(r'').readlines()
 	output = open(""C.out"", ""w"")
 	
 input = iter(input)
 
 import math
 from collections import defaultdict
 
 sys.setrecursionlimit(1500)
 
 
 def dijkstra(D,H,u):
 	print(u)
 	
 	que = [(u,0.0,H[u][0],H[u][1])]
 	#visit = [0] * len(D)
 	#visit[u] = 1
 	times = [float('inf')]*len(D)
 	times[u] = 0
 	
 	#while 0 in visit:
 	visit = [0]*len(D)
 	visit[u] = 1
 	while 0 in visit:
 		n,t,e,s = que.pop()
 		print(n)
 		times[n] = min(times[n],t)
 		visit[n] = 1
 		for i,d in enumerate(D[n]):
 			if d == -1: continue
 			
 			if e>=d:
 				que += [(i,t + d/s, e-d, s)]
 				e1,s1 = H[i]
 				que += [(i,t + d/s, e1, s1)]
 		que.sort(key=lambda t:t[1], reverse=True)
 		#print(que)
 		#print(times)
 		#print(que)
 		#n = min(filter(lambda n:visit[n]==0, range(len(D))), key=lambda n:que[n])
 		#visit[n] = 1
 		#for i,d in enumerate(D[n]):
 		#	if d == -1: continue
 		#	que[i] = min(que[i], que[n] + d)
 	#print(times)
 	return times
 
 
 def dijkstra(D,H,u):
 	visit = [0]*len(D)
 	distanse = [float('inf')]*len(D)
 	distanse[u] = 0
 	#visit[u] = 1
 	e,s = H[u]
 	while 0 in visit:
 		n = min(filter(lambda n:visit[n]==0, range(len(D))), key=lambda n:distanse[n])
 		visit[n] = 1
 		for i,d in enumerate(D[n]):
 			if d == -1: continue
 			if distanse[n]+d <= e:
 				distanse[i] = min(distanse[i], distanse[n]+d)
 	times = [d/s for d in distanse]
 	return times
 	
 def dijkstra2(T,u):
 	visit = [0]*len(D)
 	times = [float('inf')]*len(D)
 	times[u] = 0
 	while 0 in visit:
 		n = min(filter(lambda n:visit[n]==0, range(len(D))), key=lambda n:times[n])
 		visit[n] = 1
 		for i,t in enumerate(times):
 			times[i] = min(times[i], T[n][i]+times[n])
 	
 	return times
 	
 def solve(N,Q,H,D,P):
 	#import pdb;pdb.set_trace()
 	
 	T = [dijkstra(D,H,i) for i in range(len(D))]
 	
 	
 	X = {}
 	for u in {u for u,v in P}:
 		X[u] = dijkstra2(T,u)
 	return [X[u][v] for u,v in P]
 	
 	
 
 #solve(N,Q,H,D,P)
 
 import time
 # raise
 caseCnt = int(next(input))
 for case in range(1,caseCnt+1):
 	N,Q = map(int, next(input).split())
 	H = []
 	for i in range(N):
 		e,s = map(int, next(input).split())
 		H += [(e,s)]
 	D = []
 	for i in range(N):
 		*d, = map(int, next(input).split())
 		D += [d]
 	P = []
 	for i in range(Q):
 		u,v = map(int, next(input).split())
 		P += [(u-1,v-1)]
 	t0 = time.time()
 	print((N,Q,H,D,P));sys.stdout.flush()
 	res = solve(N,Q,H,D,P)
 	print(""Case #%d:""%case, *res, file=output)
 	print(time.time()-t0)
 	sys.stdout.flush()
 #'''
",gcj/2017/8294486/oonishi/5681755159789568/0/extracted/C.py,3127,171,445,Python,8294486,0,5681755159789568,oonishi,2017
17231,0000000000047c94.PYTHON3,"r'''
s = """"""
import pdb
d = pdb.Pdb(stdin=open('/dev/tty'), stdout=open('/dev/tty', 'w'))
pdb.set_trace = d.set_trace
code = compile(open('{0}').read(), '{0}', 'exec')
#d.run(code)
_debug = 1
exec(code)
"""""".format(__file__)

import os, sys
p = os.popen(f'{sys.executable} -c ""{s}"" ', 'w')

s = """"""
code = compile(open('{0}').read(), '{0}', 'exec')
exec(code, {{'_debug':1}})
"""""".format(__file__)
#p = os.popen(f'{sys.executable} -u -c ""{s}"" ', 'w')
#p = os.popen(f'{sys.executable} -u {__file__}', 'w')

p.write(""""""\
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1
"""""")
code = p.close()
exit(code)
#'''


import sys
_print = print

#def print(*args, file=sys.stderr, flush=True, **argv):
#    _print(*args, file=file, flush=flush, **argv)

def print(*args, file=sys.stderr, **argv):
    if globals().get('_debug'):
        _print(*args, file=file, **argv)
    return

def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

from math import *
from functools import reduce
from random import randint
from itertools import product

def solve(F,N):
    if len(F) != N:
        raise

    B = []
    height = 0
    for i,n in enumerate(F):
        B += [i]*n
        if i < len(B):
            height = max(height,len(B)-i)
        else:
            height = max(height,i-len(B)+2)
    #     print(B)
    # print(B)
    # return
    
    #for i,n in enumerate(F):
        
    print(B)
    if B[0] != 0 or B[N-1] != N-1:
        return ""IMPOSSIBLE"", []
    
    S = ['.']*N
    for i,n in enumerate(B):
        if i < n:
            S[i] = '\\'
        if i > n:
            S[i] = '/'
            
    print(S)
    print(height)
    X = [['.']*N for i in range(height)]
    Y = list(range(N))
    
    for i in range(height):
        for j in range(N):
            if B[j] < Y[j]:
                X[i][Y[j]] = '/'
                Y[j] -= 1
            elif B[j] > Y[j]:
                X[i][Y[j]] = '\\'
                Y[j] += 1
        #print(Y)
        

    #for s in X[::]:
    #    print(s)
    
    return height, X

#raise
# raise

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N, = list(map(int,input().split()))
    F = list(map(int,input().split()))
    
    #print('N,F=', (N,L))
    answer, X = solve(F, N)
    output('Case #%d:'%(1+i), answer)
    for x in X:
        output(''.join(x))

",,2407,127,300,Python,7706,0000000000047c94,00000000000459f2,oonishi,2018
17232,0000000000047c03.PYTHON3,"r'''
s = """"""
import pdb
d = pdb.Pdb(stdin=open('/dev/tty'), stdout=open('/dev/tty', 'w'))
pdb.set_trace = d.set_trace
code = compile(open('{0}').read(), '{0}', 'exec')
#d.run(code)
_debug = 1
exec(code)
"""""".format(__file__)

import os, sys
p = os.popen(f'{sys.executable} -c ""{s}"" ', 'w')

s = """"""
code = compile(open('{0}').read(), '{0}', 'exec')
exec(code, {{'_debug':1}})
"""""".format(__file__)
#p = os.popen(f'{sys.executable} -u -c ""{s}"" ', 'w')
#p = os.popen(f'{sys.executable} -u {__file__}', 'w')

p.write(""""""\
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1
"""""")
code = p.close()
exit(code)
#'''


import sys
_print = print

#def print(*args, file=sys.stderr, flush=True, **argv):
#    _print(*args, file=file, flush=flush, **argv)

def print(*args, file=sys.stderr, **argv):
    if globals().get('_debug'):
        _print(*args, file=file, **argv)
    return

def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

from math import *
from functools import reduce
from random import randint
from itertools import product

def solve(F,N):
    if len(F) != N:
        raise

    B = []
    height = 0
    for i,n in enumerate(F):
        B += [i]*n
        if i < len(B):
            height = max(height,len(B)-i)
        else:
            height = max(height,i-len(B)+2)
    #     print(B)
    # print(B)
    # return
    
    #for i,n in enumerate(F):
        
    print(B)
    if B[0] != 0 or B[N-1] != N-1:
        return ""IMPOSSIBLE"", []
    
    S = ['.']*N
    for i,n in enumerate(B):
        if i < n:
            S[i] = '\\'
        if i > n:
            S[i] = '/'
            
    print(S)
    print(height)
    X = [['.']*N for i in range(height)]
    Y = list(range(N))
    
    for i in range(height):
        for j in range(N):
            if B[j] < Y[j]:
                X[i][Y[j]] = '/'
                Y[j] -= 1
            elif B[j] > Y[j]:
                X[i][Y[j]] = '\\'
                Y[j] += 1
        #print(Y)
        

    #for s in X[::]:
    #    print(s)
    
    return height, X

x,a = solve([5,0,0,5,0,0,0,0,0,0,0,2][::-1], 12)
for s in a:
    print(''.join(s))

x,a = solve([5,0,0,5,0,0,0,0,0,0,0,2], 12)
for s in a:
    print(''.join(s))
raise
#raise
# raise

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N, = list(map(int,input().split()))
    F = list(map(int,input().split()))
    
    #print('N,F=', (N,L))
    answer, X = solve(F, N)
    output('Case #%d:'%(1+i), answer)
    for x in X:
        output(''.join(x))

",,2574,135,319,Python,7706,0000000000047c03,00000000000459f2,oonishi,2018
17233,00000000000479b9.PYTHON3,"r'''
s = """"""
import pdb
d = pdb.Pdb(stdin=open('/dev/tty'), stdout=open('/dev/tty', 'w'))
pdb.set_trace = d.set_trace
code = compile(open('{0}').read(), '{0}', 'exec')
#d.run(code)
_debug = 1
exec(code)
"""""".format(__file__)

import os, sys
p = os.popen(f'{sys.executable} -c ""{s}"" ', 'w')

s = """"""
code = compile(open('{0}').read(), '{0}', 'exec')
exec(code, {{'_debug':1}})
"""""".format(__file__)
#p = os.popen(f'{sys.executable} -u -c ""{s}"" ', 'w')
#p = os.popen(f'{sys.executable} -u {__file__}', 'w')

p.write(""""""\
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1
"""""")
code = p.close()
exit(code)
#'''


import sys
_print = print

#def print(*args, file=sys.stderr, flush=True, **argv):
#    _print(*args, file=file, flush=flush, **argv)

def print(*args, file=sys.stderr, **argv):
    if globals().get('_debug'):
        _print(*args, file=file, **argv)
    return

def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

from math import *
from functools import reduce
from random import randint
from itertools import product

def solve(F,N):
    if len(F) != N:
        raise

    B = []
    height = 0
    for i,n in enumerate(F):
        B += [i]*n
        height = max(height,abs(i-len(B)))
    #     print(B)
    # print(B)
    # return
    
    #for i,n in enumerate(F):
        
    print(B)
    if B[0] != 0 or B[N-1] != N-1:
        return ""IMPOSSIBLE"", []
    
    S = ['.']*N
    for i,n in enumerate(B):
        if i < n:
            S[i] = '\\'
        if i > n:
            S[i] = '/'
            
    print(S)
    print(height)
    X = [['.']*N for i in range(height)]
    Y = list(range(N))
    
    for i in range(height):
        for j in range(N):
            if B[j] < Y[j]:
                X[i][Y[j]] = '/'
                Y[j] -= 1
            elif B[j] > Y[j]:
                X[i][Y[j]] = '\\'
                Y[j] += 1
        #print(Y)
        

    #for s in X[::]:
    #    print(s)
    
    return height, X

x,a = solve([5,0,0,4,0,0,0,0,0,0,2], 11)
for s in a:
    print(''.join(s))
#raise
# raise

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N, = list(map(int,input().split()))
    F = list(map(int,input().split()))
    
    #print('N,F=', (N,L))
    answer, X = solve(F, N)
    output('Case #%d:'%(1+i), answer)
    for x in X:
        output(''.join(x))

",,2402,127,301,Python,7706,00000000000479b9,00000000000459f2,oonishi,2018
17234,00000000000476fe.PYTHON3,"r'''
s = """"""
import pdb
d = pdb.Pdb(stdin=open('/dev/tty'), stdout=open('/dev/tty', 'w'))
pdb.set_trace = d.set_trace
code = compile(open('{0}').read(), '{0}', 'exec')
#d.run(code)
_debug = 1
exec(code)
"""""".format(__file__)

import os, sys
p = os.popen(f'{sys.executable} -c ""{s}"" ', 'w')

s = """"""
code = compile(open('{0}').read(), '{0}', 'exec')
exec(code, {{'_debug':1}})
"""""".format(__file__)
#p = os.popen(f'{sys.executable} -u -c ""{s}"" ', 'w')
#p = os.popen(f'{sys.executable} -u {__file__}', 'w')

p.write(""""""\
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1
"""""")
code = p.close()
exit(code)
#'''


import sys
_print = print

#def print(*args, file=sys.stderr, flush=True, **argv):
#    _print(*args, file=file, flush=flush, **argv)

def print(*args, file=sys.stderr, **argv):
    if globals().get('_debug'):
        _print(*args, file=file, **argv)
    return

def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

from math import *
from functools import reduce
from random import randint
from itertools import product

def solve(F,N):
    if len(F) != N:
        raise

    B = []
    height = 0
    for i,n in enumerate(F):
        B += [i]*n
        height = max(height,n)
    #     print(B)
    # print(B)
    # return
    
    #for i,n in enumerate(F):
        
    print(B)
    if B[0] != 0 or B[N-1] != N-1:
        return ""IMPOSSIBLE"", []
    
    S = ['.']*N
    for i,n in enumerate(B):
        if i < n:
            S[i] = '\\'
        if i > n:
            S[i] = '/'
            
    print(S)
    print(height)
    X = [['.']*N for i in range(height)]
    Y = list(range(N))
    
    for i in range(height):
        for j in range(N):
            if B[j] < Y[j]:
                X[i][Y[j]] = '/'
                Y[j] -= 1
            elif B[j] > Y[j]:
                X[i][Y[j]] = '\\'
                Y[j] += 1
        #print(Y)
        

    #for s in X[::]:
    #    print(s)
    
    return height, X

# x,a = solve([5,0,0,3,0,0,0,0,0,2], 10)
# for s in a:
#     print(''.join(s))
# raise
# raise

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N, = list(map(int,input().split()))
    F = list(map(int,input().split()))
    
    #print('N,F=', (N,L))
    answer, X = solve(F, N)
    output('Case #%d:'%(1+i), answer)
    for x in X:
        output(''.join(x))

",,2395,127,305,Python,7706,00000000000476fe,00000000000459f2,oonishi,2018
17235,0000000000047262.PYTHON3,"r'''
s = """"""
import pdb
d = pdb.Pdb(stdin=open('/dev/tty'), stdout=open('/dev/tty', 'w'))
pdb.set_trace = d.set_trace
code = compile(open('{0}').read(), '{0}', 'exec')
#d.run(code)
_debug = 1
exec(code)
"""""".format(__file__)

import os, sys
p = os.popen(f'{sys.executable} -c ""{s}"" ', 'w')

s = """"""
code = compile(open('{0}').read(), '{0}', 'exec')
exec(code, {{'_debug':1}})
"""""".format(__file__)
#p = os.popen(f'{sys.executable} -u -c ""{s}"" ', 'w')
#p = os.popen(f'{sys.executable} -u {__file__}', 'w')

p.write(""""""\
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1
"""""")
code = p.close()
exit(code)
#'''


import sys
_print = print

#def print(*args, file=sys.stderr, flush=True, **argv):
#    _print(*args, file=file, flush=flush, **argv)

def print(*args, file=sys.stderr, **argv):
    if globals().get('_debug'):
        _print(*args, file=file, **argv)
    return

def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

from math import *
from functools import reduce
from random import randint
from itertools import product

def solve(F,N):
    if len(F) != N:
        raise

    B = []
    height = 0
    for i,n in enumerate(F):
        B += [i]*n
        height = max(height,n)
    #     print(B)
    # print(B)
    # return
    
    #for i,n in enumerate(F):
        
    print(B)
    if B[0] != 0 or B[N-1] != N-1:
        return ""IMPOSSIBLE"", []
    
    S = ['.']*N
    for i,n in enumerate(B):
        if i < n:
            S[i] = '\\'
        if i > n:
            S[i] = '/'
            
    print(S)
    print(height)
    X = [['.']*N for i in range(height)]
    Y = [1]*N
    for i in range(height):
        for j in range(N):
            if Y[j]:
                if B[j] < j:
                    X[i][j] = '/'
                    Y[j-1] += Y[j]
                    Y[j] = 0
                elif B[j] > j:
                    X[i][j] = '\\'
                    Y[j+1] += Y[j]
                    Y[j] = 0

    #for s in X[::]:
    #    print(s)
    
    return height, X

# x,a = solve([5,0,0,3,0,0,0,0,0,2], 10)
# raise

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N, = list(map(int,input().split()))
    F = list(map(int,input().split()))
    
    #print('N,F=', (N,L))
    answer, X = solve(F, N)
    output('Case #%d:'%(1+i), answer)
    for x in X:
        output(''.join(x))

",,2409,124,303,Python,7706,0000000000047262,00000000000459f2,oonishi,2018
17236,000000000004733a.PYTHON3,"r'''
s = """"""
import pdb
d = pdb.Pdb(stdin=open('/dev/tty'), stdout=open('/dev/tty', 'w'))
pdb.set_trace = d.set_trace
code = compile(open('{0}').read(), '{0}', 'exec')
#d.run(code)
_debug = 1
exec(code)
"""""".format(__file__)

import os, sys
p = os.popen(f'{sys.executable} -c ""{s}"" ', 'w')

s = """"""
code = compile(open('{0}').read(), '{0}', 'exec')
exec(code, {{'_debug':1}})
"""""".format(__file__)
#p = os.popen(f'{sys.executable} -u -c ""{s}"" ', 'w')
#p = os.popen(f'{sys.executable} -u {__file__}', 'w')

p.write(""""""\
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1
"""""")
code = p.close()
exit(code)
#'''


import sys
_print = print

#def print(*args, file=sys.stderr, flush=True, **argv):
#    _print(*args, file=file, flush=flush, **argv)

def print(*args, file=sys.stderr, **argv):
    if globals().get('_debug'):
        _print(*args, file=file, **argv)
    return

def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

from math import *
from functools import reduce
from random import randint
from itertools import product

def solve(F,N):
    if len(F) != N:
        raise

    B = []
    height = 0
    for i,n in enumerate(F):
        B += [i]*n
        height = max(height,n)
    #     print(B)
    # print(B)
    # return
    
    #for i,n in enumerate(F):
        
    print(B)
    if B[0] != 0 or B[N-1] != N-1:
        return ""IMPOSSIBLE"", []
    
    S = ['.']*N
    for i,n in enumerate(B):
        if i < n:
            S[i] = '\\'
        if i > n:
            S[i] = '/'
            
    print(S)
    print(height)
    X = [['.']*N for i in range(height)]
    Y = [1]*N
    for i in range(height):
        for j in range(N):
            if Y[j]:
                if B[j] < j:
                    X[i][j] = '/'
                    Y[j-1] += Y[j]
                    Y[j] = 0
                elif B[j] > j:
                    X[i][j] = '\\'
                    Y[j+1] += Y[j]
                    Y[j] = 0

    #for s in X[::]:
    #    print(s)
    
    return height, X

print(solve([5,0,0,3,0,0,0,0,0,2], 10))
# raise

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N, = list(map(int,input().split()))
    F = list(map(int,input().split()))
    
    #print('N,F=', (N,L))
    answer, X = solve(F, N)
    output('Case #%d:'%(1+i), answer)
    for x in X:
        output(''.join(x))

",,2408,124,300,Python,7706,000000000004733a,00000000000459f2,oonishi,2018
70836,0000000000034630.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


from math import *

def solve(F,P,N):
    
    F.sort(key=lambda e:e[0]**2+e[1]**2)
    s = sum([h*2+v*2 for h,v in F])

    x = sum(sqrt(h**2+v**2)*2 for h,v in F)
    if s+x < P:
        return s+x

    D = {s:s}
    for h,v in F:
        w = min(h,v)
        for mini in D:
            if mini+2*w > P: continue
            x = D[mini]+sqrt(h**2+v**2)*2
            if x>=P:
                return P
            D[mini+2*w] = max(D.get(mini+2*w, x), x)

    return max(D.values())
    

def _solve(F,P,N):
    w,h = F[0]
    if w>h:
        w,h = h,w

    s = h*2*N + w*2*N
    mini,maxi = s,s
    
    for i in range(N):
        if mini+w*2 <= P:
            mini += w*2
            maxi += sqrt(w**2+h**2)*2
    return min(maxi,P)

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N,P = list(map(int,input().split()))

    F = []
    for r in range(N):
        h,v = list(map(int,input().split()))
        F += [(h,v)]
    #print('N,F=', (N,L))
    answer = solve(F, P, N)
    output('Case #%d:'%(1+i), '%0.6lf'%answer)
",,1415,70,163,Python,0000000000007883,0000000000034630,000000000002fff7,oonishi,2018
70837,00000000000331c4.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


from math import *

def solve(F,P,N):
    F.sort(key=lambda e:e[0]**2+e[1]**2)
    s = sum([h*2+v*2 for h,v in F])
    
    mini,maxi = s,s
    
    for h,v in F:
        if mini+min(h,v)*2 < P:
            mini += min(h*2,v*2)
            maxi += sqrt(h**2+v**2)*2
    return min(maxi,P)

def solve(F,P,N):
    w,h = F[0]
    if w>h:
        w,h = h,w

    s = h*2*N + w*2*N
    mini,maxi = s,s
    
    for i in range(N):
        if mini+w*2 <= P:
            mini += w*2
            maxi += sqrt(w**2+h**2)*2
    return min(maxi,P)

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N,P = list(map(int,input().split()))

    F = []
    for r in range(N):
        h,v = list(map(int,input().split()))
        F += [(h,v)]
    #print('N,F=', (N,L))
    answer = solve(F, P, N)
    output('Case #%d:'%(1+i), '%0.6lf'%answer)
",,1204,60,136,Python,0000000000007883,00000000000331c4,000000000002fff7,oonishi,2018
70838,000000000003283f.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


from math import *

def solve(F,P,N):
    F.sort(key=lambda e:e[0]**2+e[1]**2)
    s = sum([h*2+v*2 for h,v in F])
    
    mini,maxi = s,s
    
    for h,v in F:
        if mini+min(h,v) < P:
            mini += min(h*2,v*2)
            maxi += sqrt(h**2+v**2)*2
    return min(maxi,P)

def solve(F,P,N):
    w,h = F[0]
    if w>h:
        w,h = h,w

    s = h*2*N + w*2*N
    mini,maxi = s,s
    for i in range(N):
        if mini+w*2 < P:
            mini += w*2
            maxi += sqrt(w**2+h**2)*2
    return min(maxi,P)

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N,P = list(map(int,input().split()))

    F = []
    for r in range(N):
        h,v = list(map(int,input().split()))
        F += [(h,v)]
    #print('N,F=', (N,L))
    answer = solve(F, P, N)
    output('Case #%d:'%(1+i), '%0.6lf'%answer)
",,1195,59,136,Python,0000000000007883,000000000003283f,000000000002fff7,oonishi,2018
70839,000000000003281a.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


from math import *

def solve(F,P,N):
    F.sort(key=lambda e:e[0]**2+e[1]**2)
    s = sum([h*2+v*2 for h,v in F])
    
    mini,maxi = s,s
    
    for h,v in F:
        if mini+min(h,v) < P:
            mini += min(h*2,v*2)
            maxi += sqrt(h**2+v**2)*2
    return min(maxi,P)

def solve(F,P,N):
    w,h = F[0]
    if w>h:
        w,h = h,w

    s = h*2*N + w*2*N
    mini,maxi = s,s
    for i in range(N):
        if maxi < P:
            mini += w*2
            maxi += sqrt(w**2+h**2)*2
    return min(maxi,P)

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N,P = list(map(int,input().split()))

    F = []
    for r in range(N):
        h,v = list(map(int,input().split()))
        F += [(h,v)]
    #print('N,F=', (N,L))
    answer = solve(F, P, N)
    output('Case #%d:'%(1+i), '%0.6lf'%answer)
",,1191,59,136,Python,0000000000007883,000000000003281a,000000000002fff7,oonishi,2018
70840,000000000003232f.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


from math import *

def solve(F,P):
    F.sort(key=lambda e:e[0]**2+e[1]**2)
    s = sum([h*2+v*2 for h,v in F])
    
    mini,maxi = s,s
    
    for h,v in F:
        if mini+min(h,v) < P:
            mini += min(h*2,v*2)
            maxi += sqrt(h**2+v**2)*2
    return min(maxi,P)

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    N,P = list(map(int,input().split()))

    F = []
    for r in range(N):
        h,v = list(map(int,input().split()))
        F += [(h,v)]
    #print('N,F=', (N,L))
    answer = solve(F, P)
    output('Case #%d:'%(1+i), '%0.6lf'%answer)",,935,45,101,Python,0000000000007883,000000000003232f,000000000002fff7,oonishi,2018
70841,000000000003186e.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


def check(F,t,R):
    L = []
    for m,s,p in F:
        n = (t-p)//s
        L += [min(max(n,0),m)]
    L.sort(reverse=True)
    return sum(L[:R])


def solve(F,R,B,C):

    right = sum([(m*s + p)for m,s,p in F])*100
    left = 0

    while right-left>1:
        mid = (right+left)//2
        n = check(F,mid,R)
        
        if n>=B:
            right = mid
        else:
            left = mid
    return right

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    R,B,C = list(map(int,input().split()))

    F = []
    for r in range(C):
        m,s,p = list(map(int,input().split()))
        F += [(m,s,p)]
    #print('N,F=', (N,L))
    answer = solve(F, R, B, C)
    output('Case #%d:'%(1+i), answer)
",,1082,56,119,Python,0000000000007883,000000000003186e,000000000002fff6,oonishi,2018
70842,0000000000031a13.PYTHON3,"def solve(F,R,B,C):

    right = sum([(m*s + p)for m,s,p in F])*100
    left = 0

    while right-left>1:
        mid = (right+left)//2
        n = check(F,mid,R)
        
        if n>=B:
            right = mid
        else:
            left = mid
    return right

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    R,B,C = list(map(int,input().split()))

    F = []
    for r in range(C):
        m,s,p = list(map(int,input().split()))
        F += [(m,s,p)]
    #print('N,F=', (N,L))
    answer = solve(F, R, B, C)
    output('Case #%d:'%(1+i), answer)
",,636,30,73,Python,0000000000007883,0000000000031a13,000000000002fff6,oonishi,2018
70843,0000000000031461.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)


def check(F,t,R):
    L = []
    for m,s,p in F:
        n = (t-p)//s
        L += [min(n,m)]
    L.sort(reverse=True)
    return sum(L[:R])


def solve(F,R,B,C):

    right = sum([(m*s + p)for m,s,p in F])
    left = 0

    while right-left>1:
        mid = (right+left)//2
        n = check(F,mid,R)
        if n<B:
            left = mid
        else:
            right = mid
    return right

## import pdb;pdb.set_trace()
## solve([[1,2,3],[2,1,2]], 2, 2, 2)
## raise

for i in range(T):
    R,B,C = list(map(int,input().split()))

    F = []
    for r in range(C):
        m,s,p = list(map(int,input().split()))
        F += [(m,s,p)]
    #print('N,F=', (N,L))
    answer = solve(F, R, B, C)
    output('Case #%d:'%(1+i), answer)
",,1060,55,119,Python,0000000000007883,0000000000031461,000000000002fff6,oonishi,2018
70844,000000000003074b.PYTHON3,"import sys
_print = print

def print(*args, file=sys.stderr, flush=True, **argv):
    _print(*args, file=file, flush=flush, **argv)
    return


def output(*args, flush=True, **argv):
    _print(*args, flush=flush, **argv)
    return


T = int(input())
print('T=', T)

I = 0

def count(F,H):
    cnt = 0
    for s in F:
        cnt += s.count('@')
    
    c = cnt // (H+1)
    div = []
    a = 0
    for i,s in enumerate(F):
        a += s.count('@')
        if a == c:
            div += [i+1]
            a = 0
        elif a > c:
            return []
        if len(div) == H:
            break

    div += [len(F)]

    print(div)
    ## global I
    ## if I:
    ##     raise
    ## I += 1
    ## if div[-1] != len(div):
    ##     return []
    

    return div

def solve(F,H,V): 
    cnt = 0
    for s in F:
        cnt += s.count('@')
    d = (H+1)*(V+1)
    if cnt%d:
        return 'IMPOSSIBLE'
    
    D = count(F,H)
    if not D:
        return 'IMPOSSIBLE'

    d = cnt // (H+1) // (V+1)

    I = [0]*(V+1)

    F = [''.join(c) for c in zip(*F)]
    #print(F)
    for i,s in enumerate(F):
        p = 0
        for j,k in enumerate(D):
            I[j] += s[p:k].count('@')
            p = k
            
        if I == [d]*(V+1):
            I = [0]*(V+1)
        #print('I',I)
        if max(I) > d:
            return 'IMPOSSIBLE'
        
        
    return 'POSSIBLE'


for i in range(T):
    R,C,H,V = list(map(int,input().split()))

    F = []
    for r in range(R):
        s = input().rstrip('\t')
        F += [s]
    #print('N,F=', (N,L))
    answer = solve(F, H, V)
    output('Case #%d:'%(1+i), answer)
",,1728,94,216,Python,0000000000007883,000000000003074b,000000000003005a,oonishi,2018
92499,0000000000013912.PYTHON3,"import sys
_print  = print
def print(*args, file=sys.stderr, **argv):
    _print(*args, file=file, **argv)

def output(*args, **argv):
    _print(*args, **argv, flush=True, file=sys.stdout)
    

T = int(input())
print('T=', T, flush=True, file=sys.stderr)

def solve(A):
    x=y=100

    S = set()
    for _ in range(1000):
        output(x,y)
        X,Y = map(int, input().split())
        print('x,y,X,Y=',(x,y), (X,Y))
        if X==Y==0:
            break
        S.add((X-x,Y-y))
        if len(S) == 9:
            x += 3
            S = set()

    else:
        raise


for i in range(T):
    A = int(input())
    print('A=', A, flush=True, file=sys.stderr)
    solve(A)

#raise
",,725,38,72,Python,00000000000000cb,0000000000013912,0000000000007a30,oonishi,2018
92500,00000000000133d8.CPP,"import sys
_print  = print
def print(*args, file=sys.stderr, **argv):
    _print(*args, file=file, **argv)

def output(*args, **argv):
    _print(*args, **argv, flush=True, file=sys.stdout)
    

T = int(input())
print('T=', T, flush=True, file=sys.stderr)

def solve(A):
    x=y=100

    S = set()
    for _ in range(1000):
        output(x,y)
        X,Y = map(int, input().split())
        print('X,Y=', (X,Y))
        if X==Y==0:
            break
        S.add((X-x,Y-y))
        if len(S) == 9:
            A -= 9
            S = set()
            if A>=9:
                x += 3
            elif A >= 6:
                x += 2
            else:
                x += 1

    else:
        raise


for i in range(T):
    A = int(input())
    print('A=', A, flush=True, file=sys.stderr)
    solve(A)",,842,41,87,Python,00000000000000cb,00000000000133d8,0000000000007a30,oonishi,2018
92501,0000000000012b35.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)

def eval(S):
    a = 1
    s = 0
    for c in S:
        if c == 'C':
            a *= 2
        else:
            s += a
    return s

def solve(A,S):
    #S = list(S)
    count = 0
    while eval(S)>A:
        count += 1
        while S[-1] == 'C':
            S = S[:-1]
        pos = S.rfind('C')
        if pos == -1:
            return 'IMPOSSIBLE'
        S = list(S)
        S[pos],S[pos+1] = S[pos+1],S[pos]
        S = ''.join(S)
        
    return count
    


for i in range(T):
    A,S = input().split()
    print('A,S=', (A,S), flush=True, file=sys.stderr)
    A = int(A)
    answer = solve(A,S)
    print('Case #%d:'%(1+i), answer)

#raise
",,769,41,95,Python,00000000000000cb,0000000000012b35,0000000000007966,oonishi,2018
92503,0000000000012a05.PYTHON3,"
import sys
output = print
def print(*args, file=sys.stderr, **argv):
    output(*args, file=file, **argv)

T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)
print(degrees(asin((2/3)**0.5)), file=sys.stderr)
## print(acos(2/3))
## print(eval(pi/3))
## print(eval(asin((2/3)**0.5)))
## raise
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]

def eval_(r):
    return cos(r) + sin(r)



def V_(r):
    print(r, file=sys.stderr)
    v1 = [0.5, 0.0, 0.0]
    v2 = [0.0, cos(r)*0.5, -sin(r)*0.5]
    v3 = [0.0, sin(r)*0.5, cos(r)*0.5]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]
    
    

def solve(A):
    left = 0.0
    right = asin((2/3)**0.5)
    #right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    output('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    output('Case #%d:'%(1+i))
    for a in answer:
        output(*['%0.15lf'%e for e in a])",,2024,77,220,Python,00000000000000cb,0000000000012a05,00000000000079cc,oonishi,2018
92504,000000000001235b.PYTHON3,"
import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)
#print(degrees(asin((2/3)**0.5)))
## print(acos(2/3))
## print(eval(pi/3))
## print(eval(asin((2/3)**0.5)))
## raise
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]

def eval(r):
    return cos(r) + sin(r)

def V(r):
    v1 = [0.5, 0.0, 0.0]
    v2 = [0.0, cos(r)*0.5, -sin(r)*0.5]
    v3 = [0.0, sin(r)*0.5, cos(r)*0.5]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]
    
    

def solve(A):
        
    left = 0.0
    #right = asin((2/3)**0.5)
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%0.15lf'%e for e in a])
    

#raise
",,1896,75,208,Python,00000000000000cb,000000000001235b,0000000000007966,oonishi,2018
92505,0000000000012100.PYTHON3,"
import sys
T = int(input())


from math import *

R2 = sqrt(2.0)

def eval(r):
    return cos(r) + sin(r)

def V(r):
    v1 = [0.5, 0.0, 0.0]
    v2 = [0.0, cos(r)*0.5, -sin(r)*0.5]
    v3 = [0.0, sin(r)*0.5, cos(r)*0.5]
    return [v1,v2,v3]
    
    

def solve(A):
        
    left = 0.0
    #right = asin((2/3)**0.5)
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%0.15lf'%e for e in a])
    

#raise
",,769,48,94,Python,00000000000000cb,0000000000012100,00000000000079cc,oonishi,2018
92506,00000000000118c9.PYTHON3,"
import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)
print(degrees(asin((2/3)**0.5)))
## print(acos(2/3))
## print(eval(pi/3))
## print(eval(asin((2/3)**0.5)))
## raise
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]

def eval(r):
    return cos(r) + sin(r)

def V(r):
    v1 = [0.5, 0.0, 0.0]
    v2 = [0.0, cos(r)*0.5, -sin(r)*0.5]
    v3 = [0.0, sin(r)*0.5, cos(r)*0.5]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]
    
    

def solve(A):
        
    left = 0.0
    #right = asin((2/3)**0.5)
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%0.15lf'%e for e in a])
    

#raise
",,1895,75,208,Python,00000000000000cb,00000000000118c9,00000000000079cc,oonishi,2018
92508,000000000001185f.PYTHON3,"
import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)
print(degrees(asin((2/3)**0.5)))
## print(acos(2/3))
## print(eval(pi/3))
## print(eval(asin((2/3)**0.5)))
## raise
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]

def eval(r):
    return cos(r) + sin(r)

def V(r):
    v1 = [0.5, 0.0, 0.0]
    v2 = [0.0, cos(r)*0.5, -sin(r)*0.5]
    v3 = [0.0, sin(r)*0.5, cos(r)*0.5]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]
    
    

def solve(A):
        
    left = 0.0
    #right = asin((2/3)**0.5)
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1817,75,208,Python,00000000000000cb,000000000001185f,00000000000079cc,oonishi,2018
92509,0000000000010f9d.PYTHON3,"
import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)
## print(acos(2/3))
## print(eval(pi/3))
## print(eval(asin((2/3)**0.5)))
## raise
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    print(sum([v**2 for v in v1]), file=sys.stderr)
    print(sum([v**2 for v in v2]), file=sys.stderr)
    print(sum([v**2 for v in v3]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v2)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v1,v3)]), file=sys.stderr)
    print(sum([a*b for a,b in zip(v3,v2)]), file=sys.stderr)
    return [v1,v2,v3]


def solve(A):
        
    left = 0.0
    right = asin((2/3)**0.5)

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1296,57,143,Python,00000000000000cb,0000000000010f9d,00000000000079cc,oonishi,2018
92512,0000000000010d00.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)
## print(acos(2/3))
## print(eval(pi/3))
## print(eval(asin((2/3)**0.5)))
## raise
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    print(sum([v**2 for v in v1]))
    print(sum([v**2 for v in v2]))
    print(sum([v**2 for v in v3]))
    print(sum([a*b for a,b in zip(v1,v2)]))
    print(sum([a*b for a,b in zip(v1,v3)]))
    print(sum([a*b for a,b in zip(v3,v2)]))
    return [v1,v2,v3]


def solve(A):
        
    left = 0.0
    right = asin((2/3)**0.5)

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1192,56,137,Python,00000000000000cb,0000000000010d00,00000000000079cc,oonishi,2018
92513,0000000000010387.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)


def V(r):
    M0  = [
        [-sin(pi/4), 0.0, cos(pi/4)],
        [      0.0,  1.0,       0.0],
        [cos(pi/4),  0.0, sin(pi/4)],
        ]
        
    M  = [
        [1.0, 0.0,       0.0],
        [cos(r), 0.0, sin(r)],
        [-sin(r),0.0, cos(r)],
        ]

    m = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
    for i in range(3):
        for j in range(3):
            for k in range(3):
                m[i][j] += M[i][k]*M0[k][j]

    v = [
        [0.5,0.0,0.0],
        [0.0,0.5,0.0],
        [0.0,0.0,0.5],
        ]

    a = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
        
    for i in range(3):
        for j in range(3):
            for k in range(3):
                a[i][j] += m[i][k]*v[k][j]
    return a
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), -R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), -R2/4*cos(r)]
    ## print(sum([v**2 for v in v1]))
    ## print(sum([v**2 for v in v2]))
    ## print(sum([v**2 for v in v3]))
    ## print(sum([a*b for a,b in zip(v1,v2)]))
    ## print(sum([a*b for a,b in zip(v1,v3)]))
    ## print(sum([a*b for a,b in zip(v3,v2)]))
    return [v1,v2,v3]


def solve(A):
        
    left = 0.0
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    
",,1879,88,211,Python,00000000000000cb,0000000000010387,00000000000079cc,oonishi,2018
92514,000000000000ff5e.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)


def V(r):
    M0  = [
        [-sin(pi/4), 0.0, cos(pi/4)],
        [      0.0,  1.0,       0.0],
        [cos(pi/4),  0.0, sin(pi/4)],
        ]
        
    M  = [
        [1.0, 0.0,       0.0],
        [cos(r), 0.0, sin(r)],
        [-sin(r),0.0, cos(r)],
        ]

    m = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
    for i in range(3):
        for j in range(3):
            for k in range(3):
                m[i][j] += M[i][k]*M0[k][j]

    v = [
        [0.5,0.0,0.0],
        [0.0,0.5,0.0],
        [0.0,0.0,0.5],
        ]

    a = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
        
    for i in range(3):
        for j in range(3):
            for k in range(3):
                a[i][j] += m[i][k]*v[k][j]
    return a
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), R2/4*cos(r)]
    ## print(sum([v**2 for v in v1]))
    ## print(sum([v**2 for v in v2]))
    ## print(sum([v**2 for v in v3]))
    ## print(sum([a*b for a,b in zip(v1,v2)]))
    ## print(sum([a*b for a,b in zip(v1,v3)]))
    ## print(sum([a*b for a,b in zip(v3,v2)]))
    return [v1,v2,v3]

def solve(A):
        
    left = 0.0
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-14:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1885,89,212,Python,00000000000000cb,000000000000ff5e,00000000000079cc,oonishi,2018
92515,000000000000ff0b.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)


def V(r):
    M0  = [
        [-sin(pi/4), 0.0, cos(pi/4)],
        [      0.0,  1.0,       0.0],
        [cos(pi/4),  0.0, sin(pi/4)],
        ]
        
    M  = [
        [1.0, 0.0,       0.0],
        [cos(r), 0.0, sin(r)],
        [-sin(r),0.0, cos(r)],
        ]

    m = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
    for i in range(3):
        for j in range(3):
            for k in range(3):
                m[i][j] += M[i][k]*M0[k][j]

    v = [
        [0.5,0.0,0.0],
        [0.0,0.5,0.0],
        [0.0,0.0,0.5],
        ]

    a = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
        
    for i in range(3):
        for j in range(3):
            for k in range(3):
                a[i][j] += m[i][k]*v[k][j]
    return a
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/4, R2/4*sin(r), R2/4*cos(r)]
    v3 = [-R2/4, R2/4*sin(r), R2/4*cos(r)]
    ## print(sum([v**2 for v in v1]))
    ## print(sum([v**2 for v in v2]))
    ## print(sum([v**2 for v in v3]))
    return [v1,v2,v3]

def solve(A):
        
    left = 0.0
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-8:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1740,86,194,Python,00000000000000cb,000000000000ff0b,00000000000079cc,oonishi,2018
92516,000000000000febc.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)


def V(r):
    M0  = [
        [-sin(pi/4), 0.0, cos(pi/4)],
        [      0.0,  1.0,       0.0],
        [cos(pi/4),  0.0, sin(pi/4)],
        ]
        
    M  = [
        [1.0, 0.0,       0.0],
        [cos(r), 0.0, sin(r)],
        [-sin(r),0.0, cos(r)],
        ]

    m = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
    for i in range(3):
        for j in range(3):
            for k in range(3):
                m[i][j] += M[i][k]*M0[k][j]

    v = [
        [0.5,0.0,0.0],
        [0.0,0.5,0.0],
        [0.0,0.0,0.5],
        ]

    a = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
        
    for i in range(3):
        for j in range(3):
            for k in range(3):
                a[i][j] += m[i][k]*v[k][j]
    return a
    
def V(r):
    v1 = [0.0, 0.5*cos(r), 0.5*sin(r)]
    v2 = [R2/2, R2/2*sin(r), R2/2*cos(r)]
    v3 = [-R2/2, R2/2*sin(r), R2/2*cos(r)]
    return [v1,v2,v3]

def solve(A):
        
    left = 0.0
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-8:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1623,83,176,Python,00000000000000cb,000000000000febc,00000000000079cc,oonishi,2018
92517,000000000000fa5b.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)


from math import *

R2 = sqrt(2.0)
def eval(r):
    return 1.0*cos(r) + R2*sin(r)


def V(r):
    M0  = [
        [-sin(pi/4), 0.0, cos(pi/4)],
        [      0.0,  1.0,       0.0],
        [cos(pi/4),  0.0, sin(pi/4)],
        ]
        
    M  = [
        [      1.0, 0.0,       0.0],
        [cos(r), 0.0, sin(r)],
        [-sin(r),0.0, cos(r)],
        ]

    m = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
    for i in range(3):
        for j in range(3):
            for k in range(3):
                m[i][j] += M[i][k]*M0[k][j]

    v = [
        [0.5,0.0,0.0],
        [0.0,0.5,0.0],
        [0.0,0.0,0.5],
        ]

    a = [
        [0.0]*3,[0.0]*3,[0.0]*3,
        ]
        
    for i in range(3):
        for j in range(3):
            for k in range(3):
                a[i][j] += m[i][k]*v[k][j]
    return a
    
    
    

def solve(A):
        
    left = 0.0
    right = pi/4

    for i in range(100000):
        r = (left+right)/2
        a = eval(r)
        if abs(A-a)<1.0e-8:
            return V(r)
        if a<A:
            left = r
        else:
            right = r
    raise


for i in range(T):
    A = float(input())
    print('A=', (A,), flush=True, file=sys.stderr)
    answer = solve(A)
    print('Case #%d:'%(1+i))
    for a in answer:
        print(*['%lf'%e for e in a])
    

#raise
",,1480,80,158,Python,00000000000000cb,000000000000fa5b,00000000000079cc,oonishi,2018
92519,000000000000ee8f.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)

def eval(S):
    a = 1
    s = 0
    for c in S:
        if c == 'C':
            a *= 2
        else:
            s += a
    return s

def solve(L):
    #S = list(S)
    E = L[::2]
    O = L[1::2]
    E.sort()
    O.sort()
    
    if len(E)>len(O):
        R = [E[-1], float('inf')]
    else:
        R = [float('inf')]
        
    L = sum([[e,o] for e,o in zip(E,O)], []) + R
    
    for i,v in enumerate(L[:-1]):
        if L[i]>L[i+1]:
            return i
    return 'OK'
    


for i in range(T):
    N = int(input())
    L = list(map(int,input().split()))
    print('N,L=', (N,L), flush=True, file=sys.stderr)
    answer = solve(L)
    print('Case #%d:'%(1+i), answer)

#raise
",,803,44,98,Python,00000000000000cb,000000000000ee8f,00000000000079cb,oonishi,2018
92520,000000000000eb39.PYTHON3,"
import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)

def eval(S):
    a = 1
    s = 0
    for c in S:
        if c == 'C':
            a *= 2
        else:
            s += a
    return s

def solve(A,S):
    #S = list(S)
    count = 0
    while eval(S)>A:
        count += 1
        while S[-1] == 'C':
            S = S[:-1]
        pos = S.rfind('C')
        if pos == -1:
            return 'IMPOSSIBLE'
        S = list(S)
        S[pos],S[pos+1] = S[pos+1],S[pos]
        S = ''.join(S)
        
    return count
    


for i in range(T):
    A,S = input().split()
    print('A,S=', (A,S), flush=True, file=sys.stderr)
    A = int(A)
    answer = solve(A,S)
    print('Case #%d:'%(1+i), answer)
",,761,40,94,Python,00000000000000cb,000000000000eb39,0000000000007966,oonishi,2018
260337,0000000000005bb6.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
       
        print(chr(A+j), end=end)
        #if i%2==1 and max(l)>sum(l)/2:
        #    print(l, file=sys.stderr)
        #    raise
    print()
        

import sys
T = int(input())
#print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    #print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    #print(f'Case #{i+1}: ', end='')
    print(""Case #%d: ""%(i+1), end='')
    solve(l)",,852,36,98,Python,0000000000000130,0000000000005bb6,00000000000004c0,oonishi,2018
260338,0000000000005b30.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
       
        print(chr(A+j), end=end)
        #if i%2==1 and max(l)>sum(l)/2:
        #    print(l, file=sys.stderr)
        #    raise
    print()
        

import sys
T = int(input())
#print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    #print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    #print(f'Case #{i+1}: ', end='')
    print(""Case #%d""%(i+1), end='')
    solve(l)",,850,36,97,Python,0000000000000130,0000000000005b30,00000000000004c0,oonishi,2018
260339,0000000000005bb1.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
       
        #print(chr(A+j), end=end)
        #if i%2==1 and max(l)>sum(l)/2:
        #    print(l, file=sys.stderr)
        #    raise
    print()
        

import sys
T = int(input())
#print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    #print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    print(f'Case #{i+1}: ', end='')
    solve(l)",,813,35,94,Python,0000000000000130,0000000000005bb1,00000000000004c0,oonishi,2018
260340,0000000000005ad5.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
       
        print(chr(A+j), end=end)
        #if i%2==1 and max(l)>sum(l)/2:
        #    print(l, file=sys.stderr)
        #    raise
    print()
        

import sys
T = int(input())
#print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    #print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    print(f'Case #{i+1}: ', end='')
    solve(l)",,812,35,94,Python,0000000000000130,0000000000005ad5,00000000000004c0,oonishi,2018
260341,0000000000002f58.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
       
        print(chr(A+j), end=end)
        if i%2==1 and max(l)>sum(l)/2:
            print(l, file=sys.stderr)
            raise
    print()
        

import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    print(f'Case #{i+1}: ', end='')
    solve(l)",,807,35,92,Python,0000000000000130,0000000000002f58,00000000000004c0,oonishi,2018
260342,0000000000002fe8.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
       
        print(chr(A+j), end=end)
        if i%2==1 and max(l)>sum(l)/2:
            print(l, file=sys.stderr)
            raise
    print()
        

import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    print('Case #{i+1}: ')
    solve(l)
    
    #raise
",,818,38,92,Python,0000000000000130,0000000000002fe8,00000000000004c0,oonishi,2018
260343,00000000000030ff.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    if M%2:
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        print(chr(A+j), end=' ')
        M -= 1
        
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
        print(chr(A+j), end=end)
    print()
        

import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    solve(l)
    
    #raise
",,683,33,82,Python,0000000000000130,00000000000030ff,00000000000004c0,oonishi,2018
260344,0000000000002f09.PYTHON3,"def solve(l):
    N = len(l)
    M = sum(l)
    A = ord('A')
    I = list(range(N))
    for i in range(M):
        j = max(I, key=lambda j:l[j])
        l[j] -= 1
        end = ' ' if i%2 else ''
        print(chr(A+j), end=end)
    print()
        

import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)   

for i in range(T):
    N = int(input())
    *l, = map(int, input().split())

    print('N,l=', (N,l), flush=True, file=sys.stderr)
    #print('N,l=', (N,l), flush=True,)
    solve(l)
    
    #raise
",,552,27,66,Python,0000000000000130,0000000000002f09,00000000000004c0,oonishi,2018
260345,0000000000002ec5.PYTHON3,"import sys
T = int(input())
print('T=', T, flush=True, file=sys.stderr)

def solve(left, right, N):
    right += 1
    for _ in range(N):
        n = (right + left)//2
        print(n, flush=True)
        s = input()
        print('n,s=', n, s, flush=True, file=sys.stderr)
        if s == 'CORRECT':
            return
        if s == 'TOO_BIG':
            right = n
        else:
            left = n
            
    else:
        raise
    

for i in range(T):
    A,B= map(int, input().split())
    N = int(input())
    print('a,b,N=', (A,B,N), flush=True, file=sys.stderr)
    solve(A,B,N)
    
    #raise
",,642,30,69,Python,0000000000000130,0000000000002ec5,0000000000000523,oonishi,2018
16792,000000000014bd22.PYTHON3,"
import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(4, 2)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):
    #print(Min, Max, file=sys.stderr)
    # for i in range(1, 10000):
    #     R = fractions.Fraction(i*Min.denominator, Min.numerator)
    #     L = fractions.Fraction(i*Max.denominator, Max.numerator)
    #     ans = int(L) + 1
        
    #     if ans < R:
    #         return i, ans
    # raise

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(2, 3), fractions.Fraction(11, 15))
# print(a)
# raise

def solve(M):

    
    Min = fractions.Fraction(1, 10**9 + 100)
    Max = fractions.Fraction(10**9 + 100, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if M[i][0] >= M[j][0] and M[i][1] >= M[j][1]:
            return ""IMPOSSIBLE""
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    print(Min, Max, file=sys.stderr)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1986,85,238,Python,0000000000051679,000000000014bd22,0000000000146184,oonishi,2019
16793,000000000014ba81.PYTHON3,"import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(4, 2)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):
    #print(Min, Max, file=sys.stderr)
    for i in range(1, 10000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans < R:
            return i, ans
    raise

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(2, 3), fractions.Fraction(11, 15))
# print(a)
# raise

def solve(M):

    
    Min = fractions.Fraction(1, 10**9 + 100)
    Max = fractions.Fraction(10**9 + 100, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if M[i][0] >= M[j][0] and M[i][1] >= M[j][1]:
            return ""IMPOSSIBLE""
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    print(Min, Max, file=sys.stderr)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)
",,1972,85,231,Python,0000000000051679,000000000014ba81,0000000000146184,oonishi,2019
16794,000000000014af29.PYTHON3,"


import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):
    print(Min, Max, file=sys.stderr)
    for i in range(1, 100000):
        #R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if fractions.Fraction(i,ans) > Min:
            f = fractions.Fraction(i,ans)
            return f.numerator, f.denominator
    raise

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(5, 2), fractions.Fraction(13, 4))
# print(a)
# raise

def solve(M):

    
    Min = fractions.Fraction(1, 10**9 + 1)
    Max = fractions.Fraction(10**9 + 1, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1956,86,223,Python,0000000000051679,000000000014af29,0000000000146184,oonishi,2019
16795,000000000014ad63.PYTHON3,"


import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):
    print(Min, Max, file=sys.stderr)
    for i in range(1, 100000):
        #R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if fractions.Fraction(i,ans) > Min:
            return i, ans
    raise

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(5, 2), fractions.Fraction(13, 4))
# print(a)
# raise

def solve(M):

    
    Min = fractions.Fraction(1, 10**9 + 1)
    Max = fractions.Fraction(10**9 + 1, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1894,85,220,Python,0000000000051679,000000000014ad63,0000000000146184,oonishi,2019
16796,000000000014a465.PYTHON3,"


import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):
    print(Min, Max, file=sys.stderr)
    for i in range(1, 100000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans < R:
            return i, ans
    raise

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(5, 2), fractions.Fraction(13, 4))
# print(a)
# raise

def solve(M):

    
    Min = fractions.Fraction(1, 10**9 + 1)
    Max = fractions.Fraction(10**9 + 1, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1869,85,220,Python,0000000000051679,000000000014a465,0000000000146184,oonishi,2019
16797,000000000014a2f9.PYTHON3,"


import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):
    print(Min, Max, file=sys.stderr)
    for i in range(1, 10000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans <= R:
            return i, ans
    raise

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(5, 2), fractions.Fraction(13, 4))
# print(a)
# raise

def solve(M):

    
    Min = fractions.Fraction(1, 10**9 + 1)
    Max = fractions.Fraction(10**9 + 1, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1869,85,220,Python,0000000000051679,000000000014a2f9,0000000000146184,oonishi,2019
16798,000000000014a0f0.PYTHON3,"
import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise
def solve2(Min, Max):

    for i in range(1, 10000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans <= R:
            return i, ans
    raise


    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(1, 2), fractions.Fraction(3, 2))
# print(a)

# raise
def solve(M):

    
    Min = fractions.Fraction(1, 10**9+1)
    Max = fractions.Fraction(10**9+1, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1826,83,213,Python,0000000000051679,000000000014a0f0,0000000000146184,oonishi,2019
16799,0000000000149660.PYTHON3,"
import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise
def solve2(Min, Max):

    for i in range(1, 10000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans < R:
            return i, ans
    raise


    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(1, 2), fractions.Fraction(3, 2))
# print(a)

# raise
def solve(M):

    
    Min = fractions.Fraction(0, 1)
    Max = fractions.Fraction(10**9, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1817,83,213,Python,0000000000051679,0000000000149660,0000000000146184,oonishi,2019
16800,000000000014969b.PYTHON3,"
import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise
def solve2(Min, Max):

    for i in range(1, 10000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans < R:
            return i, ans
    raise


    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(1, 2), fractions.Fraction(3, 2))
# print(a)

# raise
def solve(M):

    
    Min = 0#fractions.Fraction(1, 10**9)
    Max = fractions.Fraction(10**9, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1823,83,213,Python,0000000000051679,000000000014969b,0000000000146184,oonishi,2019
16801,00000000001495e6.PYTHON3,"
import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise
def solve2(Min, Max):

    for i in range(1, 10000):
        R = fractions.Fraction(i*Min.denominator, Min.numerator)
        L = fractions.Fraction(i*Max.denominator, Max.numerator)
        ans = int(L) + 1
        
        if ans < R:
            return i, ans
    raise


    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(1, 2), fractions.Fraction(3, 2))
# print(a)

# raise
def solve(M):

    
    Min = fractions.Fraction(1, 10**9)
    Max = fractions.Fraction(10**9, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1821,83,213,Python,0000000000051679,00000000001495e6,0000000000146184,oonishi,2019
16802,0000000000149243.PYTHON3,"
import numpy as np
import sys
import itertools
import fractions
T = int(input())

# f = fractions.Fraction(40, 30)
# print(int(f))
# raise


# f.nume

# print(dir(f))
# print(f.denominator)
# print(f.numerator)
# raise

def solve2(Min, Max):

    left = 0
    right = 10**9
    #print('yes', Min, Max)
    while right - left > 1:
        mid = (right+left) // 2
        R = fractions.Fraction(mid*Min.denominator, Min.numerator)
        L = fractions.Fraction(mid*Max.denominator, Max.numerator)
        ans = int(L) + 1
        #print(left, right, mid, L, R)
        if ans < R:
            right = mid
        else:
            left = mid
            
    L = fractions.Fraction(right*Max.denominator, Max.numerator)
    #print(L)
    return right, int(L)+1
    
# a = solve2(fractions.Fraction(1, 2), fractions.Fraction(3, 2))
# print(a)

# raise
def solve(M):

    
    Min = fractions.Fraction(1, 10**9)
    Max = fractions.Fraction(10**9, 1)
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        
        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))

        if M[i][0] - M[j][0] < 0:
            Min = max(t, Min)
        else:
            Max = min(t, Max)

    if Min >= Max:
        return ""IMPOSSIBLE""

    #print(Min, Max)
    return ""%d %d""%solve2(Min, Max)

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)",,1570,74,187,Python,0000000000051679,0000000000149243,0000000000146184,oonishi,2019
16803,0000000000146cb6.PYTHON3,"import numpy as np
import sys
import itertools
import fractions
T = int(input())

def solve(M):

    D = set()
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue

        t = fractions.Fraction((M[j][1] - M[i][1]), (M[i][0]-M[j][0]))
        #print(t)
        d = (M[j][1] - M[i][1]), (M[i][0]-M[j][0])
        #print(M[i], M[j], d)
        #print(d, file=sys.stderr)
        #M2 = sorted(M, key=lambda t:t[0]*d+t[1])
        #print(M2)
        D.add(t)
    
    return len(D)+1

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)
",,754,33,86,Python,0000000000051679,0000000000146cb6,0000000000146183,oonishi,2019
16804,000000000014698b.PYTHON3,"import numpy as np
import sys
import itertools

T = int(input())

def solve(M):

    D = set()
    for i,j in itertools.combinations(range(len(M)), 2):
        if (M[i][0] - M[j][0])*(M[i][1] - M[j][1]) >= 0:
            continue
        
        d = (M[j][1] - M[i][1])/(M[i][0]-M[j][0])
        #print(M[i], M[j], d)
        D.add(d)
    
    return len(D)+1

for i in range(T):
    N = int(input())
    M = []
    for j in range(N):
        *m, = map(int, input().split())
        M += [m]
    answer = solve(M)
    print('Case #%d:'%(i+1), answer)
",,552,28,68,Python,0000000000051679,000000000014698b,0000000000146183,oonishi,2019
100681,00000000001114ac.PYTHON3,""""""":""
echo ""\
4
2
TARPOL
PROL
3
TARPOR
PROL
TARPRO
6
CODEJAM
JAM
HAM
NALAM
HUM
NOLOM
4
PI
HI
WI
FI"" > .1
time python $0 .1 
exit 
""""""

        
# import random
# for i in range(100):
#     r = random.randint(1, 50)
#     b = random.randint(1, 50)
#     print(r, b)
# raise
import sys



    
import itertools

def dfs(G, k, depth=0):
    if depth == 2:
        #import pdb;pdb.set_trace()
        return [k]
    for next in G[k]:
        if G[k][next] == 1:
            L = dfs(G, next, depth+1)
            if L:
                G[k][next] = 0
                G[next][k] = 1
                return [k] + L
    return []

def solve(W):

    G = {}

    for i,w in enumerate(W):
        d = G.setdefault(w, {})
        for j,w2 in enumerate(W[i+1:], i+1):
            for k in range(1, min(len(w), len(w2))):
                if w[-k:] == w2[-k:]:
                    d = G.setdefault(w, {})
                    d[w[-k:]] = 1
                    d = G.setdefault(w[-k:], {})
                    d[w2] = 1
    
    for w in W:
        L = dfs(G, w)
        print(w, L)
    print(G)
    print()
    
    return

def solve(W):

    D = {}
    for w in W:
        for i in range(len(w)):
            D[w[i:]] = D.get(w[i:], 0)+1

    # for k in D:
    #     print(k, D[k])
    # print()
    # raise

    cnt = 0
    for w in sorted(D.keys(), key=lambda k:-len(k)):
        if D[w] < 2:
            continue

        cnt += 1
        #print(w)
        for i in range(1, len(w)):
            D[w[i:]] -= 2
    
            
    
            
    
    return cnt * 2


stdin = sys.stdin if not sys.argv[1:] else open(sys.argv[1])
T = int(stdin.readline())
for case, s in enumerate(stdin, 1):
    N = int(s)
    W = []
    for i in range(N):
        W += [stdin.readline().strip()]
    n = solve(W)
    print('Case #{}:'.format(case), n)",,1827,113,247,Python,51635,00000000001114ac,0000000000104e05,oonishi,2019
100682,000000000010a64b.PYTHON3,""""""":""
echo ""\
2
2 2
2 5"" > .1
time python $0 .1 
exit 
""""""

        
# import random
# for i in range(100):
#     r = random.randint(1, 50)
#     b = random.randint(1, 50)
#     print(r, b)
# raise
import sys



    
import itertools

def dfs(G, k, used):
    if len(used|{k}) == len(G):
        return [k]
    
    for next in G[k]:
        if next in used: continue
        route = dfs(G, next, used | {k})
        if route:
            return [k] + route
    return []

def path(G):
    for k in G:
        L = dfs(G, k, set())
        if L:
            return L

    return []
            

def solve(R,C):

    G={}
    for r,c in itertools.product(range(R), range(C)):
        for r2,c2 in itertools.product(range(R), range(C)):
            s = G.setdefault((r,c), set())
            
            if r == r2: continue
            if c == c2: continue
            if r-c == r2-c2: continue
            if r+c == r2+c2: continue

            s = G.setdefault((r,c), set())
            s.add((r2,c2))
    
    # for k in G:
    #     print(k, len(G[k]), G[k])
        
    # if len([v for v in G.values() if len(v)%2 == 1]) > 2:
    #     return []
    
    L = path(G)
    return L

stdin = sys.stdin if not sys.argv[1:] else open(sys.argv[1])
T = int(stdin.readline())
for case, s in enumerate(stdin, 1):
    R,C = map(int, s.split())
    answer = solve(R,C)
    if not answer:
        print('Case #{}:'.format(case), 'IMPOSSIBLE')
    else:
        print('Case #{}:'.format(case), 'POSSIBLE')
        for r,c in answer:
            print(r+1,c+1)
            
",,1566,80,205,Python,51635,000000000010a64b,0000000000104e03,oonishi,2019
137593,00000000000e3137.PYTHON3,"import sys
def check(L, B, N):
    print(B, file=sys.stderr)
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        if b == 0:
            L2 += [1]*n
            B2 += [0]*n
            continue
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)
       

#L = check([5], [2], 5)
    
    

T = int(input())
for case in range(1, T+1):
    n,b,f = map(int, input().split())

    L = [16]*(n//16) + ([n%16] if n % 16 else [])
    s = ''.join(['01'[i%2]*x for i,x in enumerate(L)])
    print(s, flush=True)
    s2 = input()
    B = []
    while s2:
        B += [(len(s) - len(s.lstrip(s[0])))- (len(s2) - len(s2.lstrip(s2[0])))]
        s2 = s2.lstrip(s2[0])
        s = s.lstrip(s[0])
    
    if len(B) < len(L):
        B += [L[-1]]
    #B = check([n],[b],n)
    B = check(L,B,n)
    L = [i for i in range(n) if B[i] == 1]
    print(*L, flush=True)
    input()",,1317,63,193,Python,51705,00000000000e3137,00000000000881de,oonishi,2019
137594,00000000000e1bd1.PYTHON3,"import sys
def check(L, B, N):
    #print(B, file=sys.stderr)
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        if b == 0:
            L2 += [1]*n
            B2 += [0]*n
            continue
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)
    
T = int(input())
for case in range(1, T+1):
    n,b,f = map(int, input().split())

    L = [16]*(n//16) + ([n%16] if n % 16 else [])
    s = ''.join(['01'[i%2]*x for i,x in enumerate(L)])
    print(s, flush=True)
    s2 = input()
    B = []
    while s2:
        B += [(len(s) - len(s.lstrip(s[0])))- (len(s2) - len(s2.lstrip(s2[0])))]
        s2 = s2.lstrip(s2[0])
        s = s.lstrip(s[0])
    
    if len(B) < len(L):
        B += [L[-1]]
    #B = check([n],[b],n)
    B = check(L,B,n)
    L = [i for i in range(n) if B[i] == 1]
    print(*L, flush=True)
    input()
",,1280,59,188,Python,51705,00000000000e1bd1,00000000000881de,oonishi,2019
137595,00000000000e19b8.PYTHON3,"import sys
def check(L, B, N):
    #print(B, file=sys.stderr)
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        if b == 0:
            L2 += [1]*n
            B2 += [0]*n
            continue
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)",,703,36,107,Python,51705,00000000000e19b8,00000000000881de,oonishi,2019
137596,00000000000e195a.PYTHON3,"import sys
def check(L, B, N):
    print(B, file=sys.stderr)
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        if b == 0:
            L2 += [1]*n
            B2 += [0]*n
            continue
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)",,702,36,107,Python,51705,00000000000e195a,00000000000881de,oonishi,2019
137597,00000000000e049c.PYTHON3,"
def check(L, B, N):
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)
       

#L = check([5], [2], 5)
    
    

T = int(input())
for case in range(1, T+1):
    n,b,f = map(int, input().split())

    L = [16]*(n//16) + ([n%16] if n % 16 else [])
    s = ''.join(['01'[i%2]*n for i,n in enumerate(L)])
    print(s, flush=True)
    s2 = input()
    B = []
    while s2:
        B += [(len(s2) - len(s2.lstrip(s2[0])))]
        s2 = s2.lstrip(s2[0])
    if len(B) < len(L):
        B += [L[-1]]
    
    #B = check([n],[b],n)
    B = check(L,B,n)
    L = [i for i in range(n) if B[i] == 1]
    print(*L, flush=True)
    input()",,1130,57,172,Python,51705,00000000000e049c,00000000000881de,oonishi,2019
137598,00000000000de3c6.PYTHON3,"import sys
def check(L, B, N):
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)
       

#L = check([5], [2], 5)
    
    

T = int(input())
for case in range(1, T+1):
    n,b,f = map(int, input().split())
    B = check([n],[b],n)
    L = [i for i in range(n) if B[i] == 1]
    print(*L, flush=True)
    input()",,816,44,128,Python,51705,00000000000de3c6,00000000000881de,oonishi,2019
137599,00000000000dde35.PYTHON3,"import sys
def check(L, B, N):
    if len(L) == N:
        return B
    s = ''
    for n in L:
        n2 = n//2
        n1 = n - n2
        s += '0'*n1 + '1'*n2

        
    print(s, flush=True)
    s2 = input().rstrip('\n')
    B2 = []
    L2 = []
    for n,b in zip(L,B):
        s3 = s2[:n-b]
        s2 = s2[n-b:]
        n2 = n//2
        n1 = n - n2
        b1 = n1 - s3.count('0')
        b2 = n2 - s3.count('1')

        if n2 > 0:
            B2 += [b1, b2]
            L2 += [n1, n2]
        else:
            B2 += [b1]
            L2 += [n1]

    return check(L2, B2, N)
       

#L = check([5], [2], 5)
    
    

T = int(input())
for case in range(1, T+1):
    n,b,f = map(int, input().split())
    B = check([n],[b],n)
    L = [i for i in range(n) if B[i] == 1]
    print(*L, flush=True)",,804,43,127,Python,51705,00000000000dde35,00000000000881de,oonishi,2019
137600,00000000000d528f.PYTHON3,"import sys
import itertools as it
N = int(input())
for i,s in enumerate(sys.stdin, 1):
    N, M = map(int, s.split())
    *L, = map(int, input().split())

    D = [0] * (M+1)
    for j,(n0, m0) in enumerate(zip(L[:-1], L[1:]), 1):
        if n0 == m0: continue
        n,m = n0,m0
        r = 0
        while m:
            n,m = m, n % m
        D[j] = n
        D[j-1] = n0 // n
        D[j+1] = m0 // n
        break

    for k in range(j-2, -1, -1):
        D[k] = L[k]//D[k+1]
        
    for k in range(j+2, M+1):
        D[k] = L[k-1]//D[k-1]
    
    P = sorted(list(set(D)))
    A = [chr(ord('A') + i) for i in range(26)]
    P = [A[P.index(n)] for n in D]
    print('Case #{i}: {s}'.format(i=i,s=''.join(P)))
",,720,30,107,Python,51705,00000000000d528f,000000000008830b,oonishi,2019
137601,00000000000b62c2.PYTHON3,"
N = int(input())
import sys

for i in range(1, N+1):
    S = int(input())
    s = input().rstrip('\n')
    s = ''.join(['S' if c == 'E' else 'E' for c in s])
    print('Case #{i}: {s}'.format(i=i,s=s))",,202,9,32,Python,51705,00000000000b62c2,00000000000881da,oonishi,2019
137602,00000000000b5a25.PYTHON3,"N = int(input())
import sys

for i,s in enumerate(sys.stdin, 1):
    #s = input()
    s = s.rstrip('\n')

    a = []
    b = []
    for c in s:
        if c == '4':
            a += ['2']
            b += ['2']
        else:
            a += [c]
            b += ['0']

    a = ''.join(a)
    b = ''.join(b)
    b = b.lstrip('0')
    print('Case #{i}: {a} {b}'.format(i=i,a=a,b=b))",,381,21,56,Python,51705,00000000000b5a25,0000000000088231,oonishi,2019
164016,000000000027842c,"import sys,os
Case = int(sys.stdin.readline())

for no in range(1, Case+1):
    N = int(sys.stdin.readline().strip())
    L2 = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
    L = sorted(range(N), key=lambda i:L2[i])
    J = [[0,0]]
    C = [[0,0]]
    result = {}
    answer = 'IMPOSSIBLE'
    for i in L:
        e = L2[i]
        if J[-1][1] > C[-1][1]:
            if C[-1][1] > e[0]:
                break
            C += [e]
            result[i] = 'C'
        else:
            if J[-1][1] > e[0]:
                break
            J += [e]
            result[i] = 'J'
    else:
        answer = ''.join(result[i] for i in range(N))
    print('Case #%d:'%no, answer)",000000000027842c.PYTHON3,694,26,83,Python,000000000019fd27,000000000027842c,000000000020bdf9,oonishi,2020
164017,00000000002744d0,"import sys,os
Case = int(sys.stdin.readline())

for no in range(1, Case+1):
    s = sys.stdin.readline().strip()
    result = ''
    L = list(map(int, '0'+s+'0'))
    for a,b in zip(L[:-1], L[1:]):
        result += '('*(b-a)
        result += ')'*(a-b)
        result += str(b)
    print('Case #%d:'%no, result[:-1])",00000000002744d0.PYTHON3,317,12,37,Python,000000000019fd27,00000000002744d0,0000000000209a9f,oonishi,2020
164018,0000000000273957,"import sys,os
Case = int(sys.stdin.readline())

for no in range(1, Case+1):
    N = int(sys.stdin.readline())
    L = [list(map(int, sys.stdin.readline().split())) for i in range(N)]
    d = sum(L[i][i] for i in range(N))
    r = sum(len(set(L[i])) != N for i in range(N))
    c = sum(len(set(l[i] for l in L)) != N for i in range(N))
    print('Case #%d:'%no, d, r, c)",0000000000273957.PYTHON3,369,10,55,Python,000000000019fd27,0000000000273957,000000000020993c,oonishi,2020
357739,00000000002c4b6c,"#coding: utf-8

import sys,os
Case = int(sys.stdin.readline())

def dfs(s1, s2):
    print('dfs', s1, s2)
    if s1 == s2 == '':
        return True, ''
    if s1 == '' or s2 == '':
        return False, ''

    if s1[:1] != '*' and s2[:1] != '*':
        if s1[:1] != s2[:1]:
            return False, ''
        else:
            res,pat = dfs(s1[1:], s2[1:])
            return res,s1[:1] + pat
    
    if s1[:1] == '*':
        res,pat = dfs(s1[1:], s2)
        if res:
            return res, pat
        res,pat = dfs(s1, s2[1:])
        if res:
            return res, s2[:1].strip('*') + pat
        
    if s2[:1] == '*':
        res,pat = dfs(s1, s2[1:])
        if res:
            return res, pat
        res,pat = dfs(s1[1:], s2)
        if res:
            return res, s1[:1].strip('*') + pat
    return False, ''
        
    
def match(s1, s2):
    res,pat = dfs(s1, s2)
    return res, pat

def solve(L):
    LL = [s.split('*') for s in L]
    
    head = [L[0] for L in LL]
    head.sort(key=lambda s:len(s))
    if any([not head[-1].startswith(s) for s in head[:-1]]):
        return '*'
    h = head[-1]
    head = [L[-1] for L in LL]
    head.sort(key=lambda s:len(s))
    if any([not head[-1].endswith(s) for s in head[:-1]]):
        return '*'
    t = head[-1]
    res = ''
    for L in LL:
        res += ''.join(L[1:-1])
    return (h+res+t)[1:-1]
    

for no in range(1, Case+1):
    N = int(sys.stdin.readline())
    L = ['^' + sys.stdin.readline().strip() + '$' for i in range(N)]
    s = solve(L)
    print('Case #%d:'%no, s)",00000000002c4b6c.PYTHON3,1557,65,206,Python,000000000019fd74,00000000002c4b6c,00000000002b3034,oonishi,2020
357740,00000000002c1d72,"#coding: utf-8

import sys,os
Case = int(sys.stdin.readline())

def dfs(s1, s2):
    #print('dfs', s1, s2)
    if s1 == s2 == '':
        return True, ''
    if s1 == '' or s2 == '':
        return False, ''

    if s1[:1] != '*' and s2[:1] != '*':
        if s1[:1] != s2[:1]:
            return False, ''
        else:
            res,pat = dfs(s1[1:], s2[1:])
            return res,s1[:1] + pat
    
    if s1[:1] == '*':
        res,pat = dfs(s1[1:], s2)
        if res:
            return res, pat
        res,pat = dfs(s1, s2[1:])
        if res:
            return res, s2[:1].strip('*') + pat
        
    if s2[:1] == '*':
        res,pat = dfs(s1, s2[1:])
        if res:
            return res, pat
        res,pat = dfs(s1[1:], s2)
        if res:
            return res, s1[:1].strip('*') + pat
    return False, ''
        
    
def match(s1, s2):
    res,pat = dfs(s1, s2)
    return res, pat

def solve(L):
    res, ans = True, L[0]
    for s in L[1:]:
        res, ans = match(ans, s)
        if not res:
            return '*'
    return ans[1:-1]
    

for no in range(1, Case+1):
    N = int(sys.stdin.readline())
    L = ['^' + sys.stdin.readline().strip() + '$' for i in range(N)]
    s = solve(L)
    print('Case #%d:'%no, s)
        
",00000000002c1d72.PYTHON3,1259,57,166,Python,000000000019fd74,00000000002c1d72,00000000002b3034,oonishi,2020
357741,00000000002c0b50,"#coding: utf-8

import sys,os
Case = int(sys.stdin.readline())

def dfs(s1, s2):
    if s1 == s2 == '':
        return True, ''
    if s1 == '' or s2 == '':
        return False, ''

    if s1[:1] != '*' and s2[:1] != '*':
        if s1[:1] != s2[:1]:
            return False, ''
        else:
            res,pat = dfs(s1[1:], s2[1:])
            return res,s1[:1] + pat
    
    if s1[:1] == '*':
        res,pat = dfs(s1[1:], s2)
        if res:
            return res, pat
        res,pat = dfs(s1, s2[1:])
        if res:
            return res, s2[:1] + pat
        
    if s2[:1] == '*':
        res,pat = dfs(s1, s2[1:])
        if res:
            return res, pat
        res,pat = dfs(s1[1:], s2)
        if res:
            return res, s1[:1] + pat
    return False, ''
        
    
def match(s1, s2):
    res,pat = dfs(s1, s2)
    return res, pat

def solve(L):
    res, ans = True, L[0]
    for s in L[1:]:
        res, ans = match(ans, s)
        if not res:
            return '*'
    return ans[1:-1]
    

for no in range(1, Case+1):
    N = int(sys.stdin.readline())
    L = ['^' + sys.stdin.readline().strip() + '$' for i in range(N)]
    s = solve(L)
    print('Case #%d:'%no, s)
        
",00000000002c0b50.PYTHON3,1211,56,163,Python,000000000019fd74,00000000002c0b50,00000000002b3034,oonishi,2020
400144,00000000002fc311,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    

def solve(X,Y):
    n = log2(max(abs(X),abs(Y)))
    try:
        return dfs(X,Y,2**n)
    except StopIteration:
        try:
            #print('--')
            return dfs(X,Y,2**(n+1))
        except StopIteration:
            pass
    return 'IMPOSSIBLE'
def dfs(X,Y,n):
    #print(X,Y,n)
    if X == 0 and Y == 0 and n == 0:
        return ''
    elif n == 0:
        raise StopIteration()
    
    
    try:
        if X>0:
            return dfs(X-n,Y, n//2) + 'E'
        else:
            return dfs(X+n,Y,n//2) + 'W'
    except StopIteration:
        pass
    
    # try:
    #     return dfs(X+n,Y,n//2) + 'W'
    # except StopIteration:
    #     pass
    
    try:
        if Y>0:
            return dfs(X,Y-n,n//2) + 'N'
        else:
            return dfs(X,Y+n,n//2) + 'S'
    except StopIteration:
        pass
    raise StopIteration()
    
    # try:
    #     return dfs(X,Y-n,n//2) + 'S'
    # except StopIteration:
    #     raise
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    x,y = map(int, sys.stdin.readline().split())
    s = solve(x,y)
    print('Case #%d:'%no, s)",00000000002fc311.PYTHON3,2392,107,301,Python,000000000019fef2,00000000002fc311,00000000002d5b62,oonishi,2020
400145,00000000002fc18f,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    

def solve(X,Y):
    n = log2(max(abs(X),abs(Y)))
    try:
        return dfs(X,Y,2**n)
    except StopIteration:
        try:
            print('--')
            return dfs(X,Y,2**(n+1))
        except StopIteration:
            pass
    return 'IMPOSSIBLE'
def dfs(X,Y,n):
    #print(X,Y,n)
    if X == 0 and Y == 0 and n == 0:
        return ''
    elif n == 0:
        raise StopIteration()
    
    
    try:
        if X>0:
            return dfs(X-n,Y, n//2) + 'E'
        else:
            return dfs(X+n,Y,n//2) + 'W'
    except StopIteration:
        pass
    
    # try:
    #     return dfs(X+n,Y,n//2) + 'W'
    # except StopIteration:
    #     pass
    
    try:
        if Y>0:
            return dfs(X,Y-n,n//2) + 'N'
        else:
            return dfs(X,Y+n,n//2) + 'S'
    except StopIteration:
        pass
    raise StopIteration()
    
    # try:
    #     return dfs(X,Y-n,n//2) + 'S'
    # except StopIteration:
    #     raise
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    x,y = map(int, sys.stdin.readline().split())
    s = solve(x,y)
    print('Case #%d:'%no, s)",00000000002fc18f.PYTHON3,2391,107,301,Python,000000000019fef2,00000000002fc18f,00000000002d5b62,oonishi,2020
400146,00000000002f93c3,"#coding: utf-8


import sys,os
Case = int(sys.stdin.readline())

def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise
    


for no in range(1, Case+1):
    x,y = map(int, sys.stdin.readline().split())
    s = solve(x,y)
    print('Case #%d:'%no, s)
        
",00000000002f93c3.PYTHON3,1141,45,157,Python,000000000019fef2,00000000002f93c3,00000000002d5b62,oonishi,2020
468420,00000000003296e0,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    
from fractions import Fraction
import copy
def solve(N,D,S):
    S = sorted(S)
    X = {}
    for c in range(1,10000):
        prev = copy.deepcopy(X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            
            # if L[1] + c >= D:
            #     if D == L[1] + c:
            #         return L[0] + c - 1
            #     else:
            #         return L[0] + (D - L[1])
            L[0] += c - 1
            L[1] += c
        #sorted(X[Fraction(s, c)] for s in S)
        #print(c, X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            if L[1] >= D:
                break
    key = Fraction(s, c)

    
def frac(m, d):
    m0,d0 = m,d
    while m % d :
        d2 = m % d
        m = d
        d = d2
    return m0//d,d0//d
def solve(N,D,S):

    SS = {}
    for s in S:
        for div in range(1, 50):
            key = frac(s, div)  # 
            L = SS.setdefault(key, [])
            L += [div]
            
    

    ans = float('inf')
    for mm in SS.values():
        #mm = sorted([sl//size for sl in S if sl % size == 0])
        #print(size, mm[:100])
        a = 0
        ms = 0
        for m in mm:
            if ms + m >= D:
                if ms + m == D:
                    ans = min(ans, a + m-1)
                else:
                    ans = min(ans, a + (D-ms))
                #print('ans', ans, size, a, m, ms, D)
                break
            ms += m
            a += m - 1
    return ans
            
            
        
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    N,D = map(int, sys.stdin.readline().split())

    S = list(map(int, sys.stdin.readline().split()))
        
    s = solve(N,D,S)
    print('Case #%d:'%no, s)
        
def frac(m, d):
    m0,d0 = m,d
    while m % d :
        d2 = m % d
        m = d
        d = d2
    return m0//d,d0//d
",00000000003296e0.PYTHON3,3171,137,451,Python,000000000019fef4,00000000003296e0,00000000003172d1,oonishi,2020
468421,0000000000329b1c,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    
from fractions import Fraction
import copy
def solve(N,D,S):
    S = sorted(S)
    X = {}
    for c in range(1,10000):
        prev = copy.deepcopy(X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            
            # if L[1] + c >= D:
            #     if D == L[1] + c:
            #         return L[0] + c - 1
            #     else:
            #         return L[0] + (D - L[1])
            L[0] += c - 1
            L[1] += c
        #sorted(X[Fraction(s, c)] for s in S)
        #print(c, X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            if L[1] >= D:
                break
    key = Fraction(s, c)

    
def frac(m, d):
    m0,d0 = m,d
    while m % d :
        d2 = m % d
        m = d
        d = d2
    return m0//d,d0//d
def solve(N,D,S):
    L = set(frac(s, div) for s in set(S) for div in range(1, 50))

    SS = {}
    for s in S:
        for div in range(1, 10001):
            key = frac(s, div)  # 
            L = SS.setdefault(key, [])
            L += [div]
            
    

    ans = float('inf')
    for mm in SS.values():
        #mm = sorted([sl//size for sl in S if sl % size == 0])
        #print(size, mm[:100])
        a = 0
        ms = 0
        for m in mm:
            if ms + m >= D:
                if ms + m == D:
                    ans = min(ans, a + m-1)
                else:
                    ans = min(ans, a + (D-ms))
                #print('ans', ans, size, a, m, ms, D)
                break
            ms += m
            a += m - 1
    return ans
            
            
        
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    N,D = map(int, sys.stdin.readline().split())

    S = list(map(int, sys.stdin.readline().split()))
        
    s = solve(N,D,S)
    print('Case #%d:'%no, s)
        
def frac(m, d):
    m0,d0 = m,d
    while m % d :
        d2 = m % d
        m = d
        d = d2
    return m0//d,d0//d
",0000000000329b1c.PYTHON3,3240,138,464,Python,000000000019fef4,0000000000329b1c,00000000003172d1,oonishi,2020
468422,0000000000328f52,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    
from fractions import Fraction
import copy
def solve(N,D,S):
    S = sorted(S)
    X = {}
    for c in range(1,10000):
        prev = copy.deepcopy(X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            
            # if L[1] + c >= D:
            #     if D == L[1] + c:
            #         return L[0] + c - 1
            #     else:
            #         return L[0] + (D - L[1])
            L[0] += c - 1
            L[1] += c
        #sorted(X[Fraction(s, c)] for s in S)
        #print(c, X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            if L[1] >= D:
                break
    key = Fraction(s, c)

def solve(N,D,S):
    L = set(Fraction(s, div) for s in set(S) for div in range(1, 10001))

    SS = {}
    for s in S:
        for div in range(1, 10001):
            key = Fraction(s, div)
            L = SS.setdefault(key, [])
            L += [div]
            
    

    ans = float('inf')
    for mm in SS.values():
        #mm = sorted([sl//size for sl in S if sl % size == 0])
        #print(size, mm[:100])
        a = 0
        ms = 0
        for m in mm:
            if ms + m >= D:
                if ms + m == D:
                    ans = min(ans, a + m-1)
                else:
                    ans = min(ans, a + (D-ms))
                #print('ans', ans, size, a, m, ms, D)
                break
            ms += m
            a += m - 1
    return ans
            
            
        
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    N,D = map(int, sys.stdin.readline().split())

    S = list(map(int, sys.stdin.readline().split()))
        
    s = solve(N,D,S)
    print('Case #%d:'%no, s)
        
",0000000000328f52.PYTHON3,3000,123,415,Python,000000000019fef4,0000000000328f52,00000000003172d1,oonishi,2020
468423,0000000000327f98,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    
from fractions import Fraction
import copy
def solve(N,D,S):
    S = sorted(S)
    X = {}
    for c in range(1,10000):
        prev = copy.deepcopy(X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            
            # if L[1] + c >= D:
            #     if D == L[1] + c:
            #         return L[0] + c - 1
            #     else:
            #         return L[0] + (D - L[1])
            L[0] += c - 1
            L[1] += c
        #sorted(X[Fraction(s, c)] for s in S)
        #print(c, X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            if L[1] >= D:
                break
    key = Fraction(s, c)

def solve(N,D,S):
    #L = set(Fraction(s, div) for s in set(S) for div in range(1, 10001))
    L = set(Fraction(s, div) for s in set(S) for div in range(1, 3))

    ans = float('inf')
    for size in L:
        mm = sorted([sl//size for sl in S if sl % size == 0])
        #print(size, mm[:100])
        a = 0
        ms = 0
        for m in mm:
            if ms + m >= D:
                if ms + m == D:
                    ans = min(ans, a + m-1)
                else:
                    ans = min(ans, a + (D-ms))
                #print('ans', ans, size, a, m, ms, D)
                break
            ms += m
            a += m - 1
    return ans
            
            
        
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    N,D = map(int, sys.stdin.readline().split())

    S = list(map(int, sys.stdin.readline().split()))
        
    s = solve(N,D,S)
    print('Case #%d:'%no, s)
        
",0000000000327f98.PYTHON3,2881,115,405,Python,000000000019fef4,0000000000327f98,00000000003172d1,oonishi,2020
468424,0000000000327536,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    
from fractions import Fraction
import copy
def solve(N,D,S):
    S = sorted(S)
    X = {}
    for c in range(1,10000):
        prev = copy.deepcopy(X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            
            # if L[1] + c >= D:
            #     if D == L[1] + c:
            #         return L[0] + c - 1
            #     else:
            #         return L[0] + (D - L[1])
            L[0] += c - 1
            L[1] += c
        #sorted(X[Fraction(s, c)] for s in S)
        #print(c, X)
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            if L[1] >= D:
                break
    key = Fraction(s, c)

def solve(N,D,S):
    #L = set(Fraction(s, div) for s in set(S) for div in range(1, 10001))
    L = set(Fraction(s, div) for s in set(S) for div in range(1, 4))

    ans = float('inf')
    for size in L:
        mm = sorted([sl//size for sl in S if sl % size == 0])
        #print(size, mm[:100])
        a = 0
        ms = 0
        for m in mm:
            if ms + m >= D:
                if ms + m == D:
                    ans = min(ans, a + m-1)
                else:
                    ans = min(ans, a + (D-ms))
                #print('ans', ans, size, a, m, ms, D)
                break
            ms += m
            a += m - 1
    return ans
            
            
        
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    N,D = map(int, sys.stdin.readline().split())

    S = list(map(int, sys.stdin.readline().split()))
        
    s = solve(N,D,S)
    print('Case #%d:'%no, s)
        
",0000000000327536.PYTHON3,2881,115,405,Python,000000000019fef4,0000000000327536,00000000003172d1,oonishi,2020
468425,00000000003208a0,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    
from fractions import Fraction
def solve(N,D,S):
    S = sorted(S)
    X = {}
    for c in range(1,10000):
        for s in S:
            L = X.setdefault(Fraction(s, c), [0, 0])
            
            if L[1] + c >= D:
                if D == L[1] + c:
                    return L[0] + c - 1
                else:
                    return L[0] + (D - L[1])
            L[0] += c - 1
            L[1] += c
        #sorted(X[Fraction(s, c)] for s in S)
        #print(c, X)
        
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    N,D = map(int, sys.stdin.readline().split())

    S = list(map(int, sys.stdin.readline().split()))
        
    s = solve(N,D,S)
    print('Case #%d:'%no, s)
        
",00000000003208a0.PYTHON3,2000,84,273,Python,000000000019fef4,00000000003208a0,00000000003172d1,oonishi,2020
468426,0000000000318b78,"#coding: utf-8


def log2(N):
    left = 0
    right = 50
    while right - left > 1:
        mid = (right + left)//2
        n = 2**mid
        if n > N:
            right = mid
        else:
            left = mid
    return left
# print(log2(10))
# print(log2(1000))
# print(log2(124))
# print(log2(1023))
# raise
import sys,os


def solve(X,Y):
    if X%2 and Y%2:
        return 'IMPOSSIBLE'
    Q = [(0,0,'')]
    D = {(0,0):''}
    while Q:
        x,y,path = Q.pop()
        #print(path)
        if x == X and y == Y:
            return path
        d = 2**len(path)
        dx = x + d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'E'
            Q += [(dx, y, path+'E')]
        dx = x - d
        if (dx,y) not in D or len(D[(dx,y)]) > len(path):
            D[(dx,y)] = path + 'W'
            Q += [(dx, y, path+'W')]
        dy = y + d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'N'
            Q += [(x, dy, path+'N')]
        dy = y - d
        if (x,dy) not in D or len(D[(x,dy)]) > len(path):
            D[(x,dy)] = path + 'S'
            Q += [(x, dy, path+'S')]
        Q.sort(key=lambda e:(len(e[2]), (X-e[0])**2+(Y-e[1])**2) )
        Q.reverse()
    raise


    

def solve(X,Y,S):
    
    for m,c in enumerate(S+'.'):
        L = abs(X) + abs(Y)
        #print(m,L,c)
        if m>=L:
            return m
        if c == 'S':
            Y -= 1
        if c == 'W':
            X -= 1
        if c == 'N':
            Y += 1
        if c == 'E':
            X += 1
        
    return 'IMPOSSIBLE'
    
Case = int(sys.stdin.readline())
for no in range(1, Case+1):
    x,y,T = sys.stdin.readline().split()
    x,y = int(x), int(y)
    s = solve(x,y, T)
    print('Case #%d:'%no, s)",0000000000318b78.PYTHON3,1795,80,252,Python,000000000019fef4,0000000000318b78,0000000000317409,oonishi,2020
1728,a.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
     # naive solution
     # because I suck.
 
 def ctv(s, n): # contains three vowels
     vow = ""aeiou""
     row = 0
     for c in s:
         if c not in vow:
             row += 1
             if row == n:
                 return True
         else:
             row = 0
     return False        
 
 def run(data):
     s, n = data
     ls = len(s)
     ss = 0
     for i in range(n, ls+1):
         for j in range(0, ls-i+1):
             if ctv(s[j:j+i], n):
                 ss += 1
     return ss
 
 #---------------------------------------------
 
 def read_case(f):
     s, n = read_strs(f)
     return [s, int(n)]
     return 42
 
 def write_case(f, i, sol):
     f.writelines(""Case #%d: %s\n"" % (i+1, sol))
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2437488/xjcl/2751486/0/extracted/a.py,2071,94,231,Python,2437488,0,2751486,xjcl,2013
1729,c.py,"from time import clock
 from sys import argv
 from copy import deepcopy
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 class Attack(object):
     def __init__(self, t, wm, em, h):
         self.t = t
         self.wm = wm
         self.em = em
         self.h = h
 
 def iss(a):
     # insertion sorts a list of objects by self.t
     # losely based on http://en.wikipedia.org/wiki/Insertion_sort
     for i in range(1, len(a)):
         to_ins = a[i]
         hole_pos = i
         while hole_pos > 0 and to_ins.t < a[hole_pos-1].t:
             a[hole_pos] = a[hole_pos-1]
             hole_pos -= 1
         a[hole_pos] = to_ins
     # is probably in-place
     #return a
 
 def build_in_head(at, lw):
     for k in range(at.wm, at.em):
         try:
             if at.h > lw[k]:
                 lw[k] = at.h
         except:
             lw[k] = at.h
     return lw
 
 def tack(at, wall, lw):
     global sses
     if 1:
         if 1:
             for j in range(at.wm, at.em):
                 if j in wall:
                     if at.h > wall[j]:
                         sses += 1
                         lw = build_in_head(at, lw)
                         break
                 else:
                     sses += 1
                     lw = build_in_head(at, lw)
                     break
     return lw
         
 def run(data):
     attacks = []
     for mongol in data: # shut up I want to call them mongols
         t0, n, wm, em, h, dt, dd, dh = mongol
         for i in range(n):
             attacks.append( Attack(t0+i*dt, wm+dd*i, em+dd*i, h+dh*i) )
     iss(attacks)
     lw = {}
     wall = {}
     today = -1
     global sses
     sses = 0
     for at in attacks:
         if at.t > today:
             # repair wall # wall = lw
             wall = deepcopy(lw)
             # change today
             today = at.t
             print ""New day:"", today
             print wall
             # then proceed
             lw = tack(at, wall, lw)
             print sses
             print
         else:
             # destroy wall
             print ""Still"", today
             lw = tack(at, wall, lw)
             print sses
     return sses
 
 #---------------------------------------------
 
 def read_case(f):
     n = read_int(f)
     return read_lines(f, n)
 
 def write_case(f, i, sol):
     f.writelines(""Case #%d: %s\n"" % (i+1, sol))
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2437488/xjcl/2755486/0/extracted/c.py,3627,145,402,Python,2437488,0,2755486,xjcl,2013
1730,b.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
     # strategy: jump up and down until desired y-value is achieved
     # then jump in the opposite direction of the one in which you want to go and return until
     # x, y is matches
 
 def is_pos(n):
     if n > 0: # this is for the case in which y is zero
         return 1
     return 0
 
 def run(data):
     x, y = data
     s = """"
     # calculate hopping n/s:
     hops_ns = abs(y)
     s = ""NS"" * (hops_ns)
     if is_pos(y):
         s = s[:-1]
     if x == 0:
         return s
         
     # good. now for the tricky part
     #hopped = 2*hops_ns - is_pos(y)
     # next hop has length (hopped+1) # no wait that's completely independent
     # first determine in which direction I want to hop
     hop_east = True
     if x > 0:
         hop_east = False # hop_east describes initial hop, not general direction.
     hops_ew = abs(x)
     if hop_east == True:
         s += ""EW""*hops_ew
     else:
         s += ""WE""*hops_ew
     return s
 
 #---------------------------------------------
 
 def read_case(f):
     x, y = read_ints(f)
     return [x, y]
 
 def write_case(f, i, sol):
     f.writelines(""Case #%d: %s\n"" % (i+1, sol))
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2437488/xjcl/2749486/0/extracted/b.py,2501,102,311,Python,2437488,0,2749486,xjcl,2013
31164,b.py,"from sys import argv
 import math
 import itertools
 import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     a, vi = data
     e, r, v = a
     if r>=e:
         sum = 0
         for i in vi:
             sum += i*e
         return sum
     gains = 0
     curr_e = e
     for i in range(len(vi)):
         if vi[i] == max(vi):
             gains += vi[i]*curr_e
             curr_e = 0
         else:
             for test in range(0, r+1):
                 if vi[i]*(r-test) < curr_e:
                     gains += (r-test)*vi[i]
             #if r*vi[i] < e:
     return gains            
 
 #---------------------------------------------
 
 def read_case(f):
     a = read_ints(f)
     v = read_ints(f)
     return [a, v]
 
 def write_case(f, i, sol):
     f.writelines(""Case #%d: %s\n"" % (i+1, sol))
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         write_case(f2, i, run(read_case(f)))
     f.close()
     f2.close()
         
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2418487/xjcl/2645486/0/extracted/b.py,1961,88,211,Python,2418487,0,2645486,xjcl,2013
31165,c.py,"from sys import argv
 import math
 import itertools
 import numpy
 import copy
 import random
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     #r = 100
     n = 3# no of to guess
     m = 5 # max
     k = 7 # number of products
     sorted_data = copy.deepcopy(data)
     sorted_data.sort()
     sorted_data = sorted_data[::-1]
     for i in range(n+1):
         print
         print sorted_data[0]
         print (m-1)**i
         print m**(n-i)
         if sorted_data[0] == (m-1)**i * m**(n-i):
             return str(m)*(n-i) + str(m-1)*i
         if sorted_data[0] == m**i * (m-1)**(n-i):
             return str(m)*(i) + str(m-1)*(n-i)
     
     s = """"
     
     for l in range(2, m+1):
         if l**n in sorted_data:
             return str(l)*n
         if l**(n-1) in sorted_data:
             if l != 2:
                 s += str(l)*(n-1)
     
     if 5 in sorted_data:
         s += ""5""
     if 3 in sorted_data:
         s += ""3""
     if 2 in sorted_data:
         s += ""2""
     if 4 in sorted_data:
         s += random.choice([""22"", ""4""])
     
     if len(s)>n:
         return s[:n]
     
     #panic
     global fail
     for j in range(n-len(s)):
         fail += 1
         s += random.choice([""2"",""2"",""2"",""2"",""2"",""2"", ""3"",""3"",""3"",""3"", ""4"",""4"", ""5""])
     return s
 
 #---------------------------------------------
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(sol+""\n"")
 
 #---------------------------------------------
 
 def main():
     global fail
     fail = 0
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     read_int(f)
     read_ints(f)
     f2.writelines(""Case #1:\n"")
     for i in range(100):#100): #8000 for small 2
         write_case(f2, i, run(read_case(f)))
     f.close()
     f2.close()
     print ""\n\n\n""+str(fail)
         
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2418487/xjcl/2652486/0/extracted/c.py,2740,119,292,Python,2418487,0,2652486,xjcl,2013
31166,a.py,"from sys import argv
 import math
 import itertools
 import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     r, t = data
     #return 1 +   (t/pi - 2*r - 1) / 4
     # diff is uneven**2-even**2
     #return (-r/2 -3/4 + (r**2/4 + 3*r/4 + 9/16 + t/(2*pi))**0.5)*(49/16)
     
     # ""naive"" solution for small:
     i = 0
     print t
     while t>=0:
         t -= (2*r + 1 + 4*i)
         print t
         i += 1
     return i-1
 
 #---------------------------------------------
 
 def read_case(f):
     global pi
     pi = 3.14159265359
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #%d: %s\n"" % (i+1, sol))
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         write_case(f2, i, run(read_case(f)))
     f.close()
     f2.close()
         
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2418487/xjcl/2464487/0/extracted/a.py,1801,82,202,Python,2418487,0,2464487,xjcl,2013
60060,qa.py,"import copy
 
 def read_file():
     f = open(""qa_in.txt"")
     global a
     a = f.readlines()
     global test_cases
     assert int(a[0])
     test_cases = int(a.pop(0))
     a = [s.strip(""\n"") for s in a]
     f.close()
     
 def convert_data():
     global data
     data = []
     for i in range(test_cases):
         data.append([])
         data[i] = a[5*i : 5*i+4]
 
 def single_check_completion(b):
     for line in b:
         for char in line:
             if char == ""."":
                 return False
     return True
                     
 def check_completion():
     global completions
     completions = []
     for d in data:
         completions.append(single_check_completion(d))
     
 def single_check_for_lines(b):
     p_lines = [] # possible rows
     # rows
     for row in b:
         p_lines.append(row)
     # columns
     for i in range(4):
         p_lines.append("""")
         for j in range(4):
             p_lines[-1] += b[j][i]
     # both diagonals
     p_lines.append(b[0][0]+b[1][1]+b[2][2]+b[3][3])
     p_lines.append(b[0][3]+b[1][2]+b[2][1]+b[3][0])
     # check
     for line in p_lines:
         if line == ""XXXX"" or line == ""XXXT"" or line == ""XXTX"" or line == ""XTXX"" or line == ""TXXX"":
             return ""X"" # assert there is always only one line
         elif line == ""OOOO"" or line == ""OOOT"" or line == ""OOTO"" or line == ""OTOO"" or line == ""TOOO"":
             return ""O"" # assert there is always only one line
     return None
 
 def check_for_lines():
     global lines
     lines = []
     for d in data:
         lines.append(single_check_for_lines(d))
            
 def write_to_file():
     f2 = open(""qa_out.txt"", 'wt') 
     for i in range(len(data)):
         result = """"
         if lines[i] == None and completions[i] == True:
             result = ""Draw""
         elif lines[i] == None and completions[i] == False:
             result = ""Game has not completed""
         elif (lines[i] == ""X"" or lines[i] == ""O""):
             result = lines[i]+"" won""
         f2.writelines(""Case #""+str(i+1)+"": ""+str(result)+""\n"")   
     f2.close()
 
 def debug():
     print data
     print completions
     print lines
 
 def main():    
     read_file()
     convert_data()
     check_completion()
     check_for_lines()
     write_to_file() # < check first for rows, then completion
     #debug()
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2270488/xjcl/2453486/1/extracted/qa.py,2390,88,271,Python,2270488,1,2453486,xjcl,2013
60062,qc.py,"from shlex import split
 
 def read_file():
     f = open(""qc_in.txt"")
     global a
     a = f.readlines()
     global test_cases
     assert int(a[0])
     test_cases = int(a.pop(0))
     a = [s.strip(""\n"") for s in a]
     f.close()
     
 def convert_data():
     global starts
     starts = []
     global ends
     ends = []
     for i in range(test_cases):
         nums = split(a[i])
         starts.append(int(nums[0]))
         ends.append(int(nums[1])+1)
 
 def is_palindrome(num):
     nstr = str(num)
     pal = nstr[::-1]
     return int(pal) == num
 
 def find_fasnos():
     global results
     results = []
     for i in range(test_cases):
         found = 0
         for n in range(starts[i], ends[i]):
             # optimization: range is sqrts of ns
             if n == round(n**0.5, 8)**2:
                 if is_palindrome(n) and is_palindrome(int(round(n**0.5, 8))):
                     found += 1
         results.append(found)
     
 def write_to_file():
     f2 = open(""qc_out.txt"", 'wt') 
     for i in range(len(results)):
         f2.writelines(""Case #""+str(i+1)+"": ""+str(results[i])+""\n"")   
     f2.close()
 
 def debug():
     print starts
     print ends
     print results
 
 def main():   
     read_file()
     convert_data()
     find_fasnos()
     write_to_file()
     debug()
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2270488/xjcl/2463486/0/extracted/qc.py,1360,60,136,Python,2270488,0,2463486,xjcl,2013
60063,qb.py,"from shlex import split
 
 def read_file():
     f = open(""qb_in.txt"")
     global a
     a = f.readlines()
     global test_cases
     assert int(a[0])
     test_cases = int(a.pop(0))
     a = [s.strip(""\n"") for s in a]
     f.close()
     
 def convert_data():
     global data
     data = []
     global sims
     sims = []
     global results
     results = []
     curr_line = -1 # popped the first one
     for i in range(test_cases):
         data.append([])
         sims.append([])
         curr_line += 1
         if int(split(a[curr_line])[0]) == 0 or int(split(a[curr_line])[1]) == 0:
             results.append(""YES"")
             continue
         for j in range(int(split(a[curr_line])[0])): # assume Google doesn't fsck up
             curr_line += 1
             num_array = split(a[curr_line])
             num_array = [int(s) for s in num_array]
             data[i].append(num_array)
             sims[i].append([])
             for k in range(len(num_array)):
                 sims[i][j].append(100)
 
 def make_value_list(d):
     global value_list
     value_list = []
     for row in d:
         for point in row:
             value_list.append(point)
     value_list = list(set(value_list))
     value_list.sort()
     value_list = value_list[::-1]
 
 def find_lower_maxi():
     global maxi_index
     global maxi
     if maxi_index < len(value_list):
         maxi = value_list[maxi_index]
         maxi_index += 1
         return True
 
 def cut_single(s, d, ly, lx):
     lrow = []
     lcol = []
     for y in range(len(d)):
         for x in range(len(d[y])):
             if y == ly:
                 lrow.append(d[y][x])
             if x == lx:
                 lcol.append(d[y][x])
                 
     to_cut = [""x-axis"", ""y-axis""]
     for num in lrow:
         if maxi < num:
             to_cut.pop(0)
             break
     for num in lcol:
         if maxi < num:
             to_cut.pop(to_cut.index(""y-axis""))
             break
             
     for cut in to_cut:
         if cut == ""x-axis"":
             for oxo in range(len(s[ly])):
                 if s[ly][oxo] > maxi:
                     s[ly][oxo] = maxi
         if cut == ""y-axis"":
             for y in range(len(s)):
                 if s[y][lx] > maxi:
                     s[y][lx] = maxi
             
             
             
 
 def cut_all(s, d):
     for y in range(len(s)):
         for x in range(len(s[y])):
             if s[y][x] > maxi >= d[y][x]:
                 cut_single(s, d, y, x)
 
 def is_done(s, d):
     if s == d:
         return True      
 
 """"""def check_grass():
         maxi = 100
         for y in range(len(data[d])):
             sols[d].append([])
             for x in range(len(data[d][y])):
                 sols[d][y].append(check_neighbours(data[d], y, x))""""""
     
 
 def write_to_file():
     f2 = open(""qb_out.txt"", 'wt') 
     for i in range(len(results)):
         f2.writelines(""Case #""+str(i+1)+"": ""+str(results[i])+""\n"")   
     f2.close()
 
 def debug():
     print data
     print sims # simulations
     print results
 
 def main():
     global results
     read_file()
     convert_data()
     for d in data:
         s = sims[data.index(d)]
         make_value_list(d)
         global maxi
         maxi = 101
         global maxi_index
         maxi_index = 0
         while find_lower_maxi() and s != d:
             cut_all(s, d)
         if s == d:
             results.append(""YES"")
         else:
             results.append(""NO"")      
     write_to_file() # < check first for rows, then completion
     #debug()
 
 if __name__ == ""__main__"":
     main()
",gcj/2013/2270488/xjcl/2449486/0/extracted/qb.py,3629,139,356,Python,2270488,0,2449486,xjcl,2013
1796,c.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     """"""Using heavily optimised binary search""""""
     from random import choice
     """"""Perform heroic database operation""""""
     return choice([""GOOD"", ""BAD""])
     """"""WHAT YOU REALLY SOLVED THIS BY CHANCE?""""""
     # yessssss
     # IF I CANT BE THE BEST
     # I SURE AS HELL CAN BE THE WORST
     
 
 #---------------------------------------------
 
 def read_case(f):
     pass
     # super awesome code goes here
     return 42
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2984486/xjcl/5752104073297920/0/extracted/c.py,1952,81,204,Python,2984486,0,5752104073297920,xjcl,2014
1798,a.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 import itertools
 #import numpy
 from copy import deepcopy as dc
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def change_bit(s, place):
     if s[place] == ""0"":
         return s[:place]+""1""+s[place+1:]
     else:
         return s[:place]+""0""+s[place+1:]
 
 
 def switch_lever(list1, place):
     pass
     
 
 def get_combinations(l):
     """"""Source: http://stackoverflow.com/questions/464864
     /python-code-to-pick-out-all-possible-combinations-from-a-list""""""
     for length in range(1, l+1):
         for subset in itertools.combinations(range(l), length):
             yield subset
 
 def run(data):
     list1 = data[0]
     set2 = set(data[1])
     n = len(list1)
     l = len(list1[0])
     """"""Naive solution.""""""
     if set(list1) == set2:
         return ""0""
     for combo in get_combinations(l):
         list1_modified = dc(list1)
         for i in range(l):
             if i in combo:
                 for j in range(n):
                     list1_modified[j] = (change_bit(list1_modified[j], i))
         set1 = set(list1_modified)
         if set1 == set2:
             return len(combo)
     return ""NOT POSSIBLE""
 
 #---------------------------------------------
 
 def read_case(f):
     read(f)
     return [read_strs(f), read_strs(f)]
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2984486/xjcl/5634947029139456/0/extracted/a.py,2687,107,252,Python,2984486,0,5634947029139456,xjcl,2014
27679,d.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 from copy import deepcopy as dc
 #import math #import itertools #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def optimal_war(naomi, ken):
     points = 0
     for i in range(len(naomi)):
         """"""If Naomi plays a tile larger than all of Ken's: Ken throws
             away his smallest one. Else: Ken wins.""""""
         if naomi[0] > ken[0]:
             points += 1
             naomi.pop(0)
             ken.pop() # ken.pop() == ken.pop(-1)
         else:
             naomi.pop(0)
             ken.pop(0)
     return points
 
 def optimal_d_war(naomi, ken):
     points = 0
     for i in range(len(naomi)-1, -1, -1):
         """"""Naomi tries to play the smallest tile that is larger than
             Ken's smallest and then tells him an enormous number. Repeat.""""""
         if naomi[i] > ken[-1]:
             points += 1
             naomi.pop(i)
             ken.pop()
     return points
 
 def run(data):
     naomi, ken = sorted(data[0]), sorted(data[1])
     naomi.reverse()
     ken.reverse() # high -> low
     """"""Deepcopy (dc) is needed here else optimal_d_war will alter the list permanently!""""""
     return str(optimal_d_war(dc(naomi), dc(ken)))+"" ""+str(optimal_war(naomi, ken))
 
 #---------------------------------------------
 
 def read_case(f):
     read_int(f)
     return read_lines(f, 2, read_floats)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2974486/xjcl/5644738749267968/1/extracted/d.py,2750,100,284,Python,2974486,1,5644738749267968,xjcl,2014
27680,d.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 from copy import deepcopy as dc
 #import math #import itertools #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def optimal_war(naomi, ken):
     points = 0
     for i in range(len(naomi)):
         """"""If Naomi plays a tile larger than all of
             Ken's: Ken throws away his smallest one.""""""
         if naomi[0] > ken[0]:
             points += 1
             naomi.pop(0)
             ken.pop()
         else:
             naomi.pop(0)
             ken.pop(0)
     return points
 
 def optimal_d_war(naomi, ken):
     n = len(naomi)
     points = 0
     for i in range(n-1, -1, -1):
         if naomi[i] > ken[-1]:
             points += 1
             naomi.pop(i)
             ken.pop()
     return points
 
 def run(data):
     naomi, ken = data
     naomi, ken = sorted(naomi), sorted(ken)
     naomi.reverse()
     ken.reverse() # high -> low
     """"""Deepcopy is needed here else optimal_d_war will alter the list permanently!""""""
     return str(optimal_d_war(dc(naomi), dc(ken)))+"" ""+str(optimal_war(naomi, ken))
 
 #---------------------------------------------
 
 def read_case(f):
     read_int(f)
     return read_lines(f, 2, read_floats)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2974486/xjcl/5644738749267968/0/extracted/d.py,2582,100,262,Python,2974486,0,5644738749267968,xjcl,2014
27681,b.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     """"""farm_rate: Rate at which a farm produces""""""
     farm_cost, farm_rate, goal = data
     total_rate = 2
     """"""time_until_goal: Time LEFT until goal, NOT TOTAL time until goal!""""""
     farms = 0
     total_time = 0
     old_time_until_goal = goal / total_rate
     time_until_farm = farm_cost / total_rate
     time_until_goal = goal / (total_rate + farm_rate*(farms+1))
     while time_until_farm + time_until_goal < old_time_until_goal:
         """"""Dynamically: First examine the null option (no farms),
             then look if progressively adding one farm yields a
             more desirable (=lower) result (tested with the while-statement).
             Stop if it doesn't. Result: Now you know how many farms to buy!""""""
         total_time += time_until_farm # already saving up for the result!
         farms += 1
         total_rate += farm_rate
         """"""above: farm bought! below: what if we bought another one?""""""
         old_time_until_goal = time_until_goal # == goal / total_rate
         time_until_farm = farm_cost / total_rate
         time_until_goal = goal / (total_rate + farm_rate)
     """"""total_time = 0
     total_rate = 2 # I'm doing things twice here I know. :(
     for i in range(farms):
         total_time += farm_cost / total_rate
         total_rate += farm_rate""""""
     total_time += goal / total_rate
     return str(total_time)
 
 #---------------------------------------------
 
 def read_case(f):
     return read_floats(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2974486/xjcl/5709773144064000/1/extracted/b.py,2994,98,328,Python,2974486,1,5709773144064000,xjcl,2014
27683,c.py,"""""""Python2- and Python3-compatible. That's all.""""""
 """"""Explanation: I tried to analyze the problem (see run()
     and is_divisible() for notes), but failed to find a
     strategy (yes I spotted the word recursive in the ex-
     planation thank you). My best guess for now would be
     that you have to find the solution gradually using
     some kind of dynamic programming magic.
     What I instead did here was implementing a brute-
     force algorithm that checks every possibility that
     has five 0-centers on its path.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 
 #---------------------------------------------
 # Code I'm not proud of goes here. :/
 # Come on it's Google's fault; (R, C is <= 5)!
 #---------------------------------------------
 
 from copy import deepcopy as dc
 
 def punch(grid, x, y, rows, cols, last=False):
     if grid:
         for xi in range(x-1, x+2):
             for yi in range(y-1, y+2):
                if yi > -1 and xi > -1:
                     if yi < rows and xi < cols:
                         grid[yi][xi] = "".""
         if last==True:
             grid[y][x] = ""c""
         return grid
     return None
 
 def count(grid):
     ret = 0
     for row in grid:
         for x in row:
             if x == ""*"":
                 ret += 1
     return ret
 
 def brute_force(i, rows, cols):
     grid = []
     for y0 in range(rows):
         grid.append([])
         for x0 in range(cols):
             grid[y0].append(""*"")
             
     for y1 in range(rows):
         for x1 in range(cols):
             for y2 in range(y1-1, y1+2):
                 for x2 in range(x1-1, x1+2):
                     for y3 in range(y2-1, y2+2):
                         for x3 in range(x2-1, x2+2):
                             if y2 > -1 and x2 > -1 and y2 < rows and x2 < cols:
                                 if y3 > -1 and x3 > -1 and y3 < rows and x3 < cols:
                                     lgrid = dc(grid)
                                     lgrid = punch(lgrid, x1, y1, rows, cols)
                                     lgrid = punch(lgrid, x2, y2, rows, cols)
                                     lgrid = punch(lgrid, x3, y3, rows, cols, last=True)
                                     if lgrid:
                                         if count(lgrid) == i:
                                             return lgrid
     print(""uff"")
     for y1 in range(rows):
         for x1 in range(cols):
             for y2 in [y1-1, y1, y1+1]:
                 for x2 in [x1-1, x1, x1+1]:
                     for y3 in [y2-1, y2, y2+1]:
                         for x3 in [x2-1, x2, x2+1]:
                             for y4 in [y3-1, y3, y3+1]:
                                 for x4 in [x3-1, x3, x3+1]:
                                     if y2 > -1 and x2 > -1 and y2 < rows and x2 < cols:
                                         if y3 > -1 and x3 > -1 and y3 < rows and x3 < cols:
                                             if y4 > -1 and x4 > -1 and y4 < rows and x4 < cols:
                                                 lgrid = dc(grid)
                                                 lgrid = punch(lgrid, x1, y1, rows, cols)
                                                 lgrid = punch(lgrid, x2, y2, rows, cols)
                                                 lgrid = punch(lgrid, x3, y3, rows, cols)
                                                 lgrid = punch(lgrid, x4, y4, rows, cols, last=True)
                                                 if lgrid:
                                                     if count(lgrid) == i:
                                                         return lgrid
     print(""uffuff"")
     for y1 in range(rows):
         for x1 in range(cols):
             for y2 in [y1-1, y1, y1+1]:
                 for x2 in [x1-1, x1, x1+1]:
                     for y3 in [y2-1, y2, y2+1]:
                         for x3 in [x2-1, x2, x2+1]:
                             for y4 in [y3-1, y3, y3+1]:
                                 for x4 in [x3-1, x3, x3+1]:
                                     for y5 in [y4-1, y4, y4+1]:
                                         for x5 in [x4-1, x4, x4+1]:
                                             if y2 > -1 and x2 > -1 and y2 < rows and x2 < cols:
                                                 if y3 > -1 and x3 > -1 and y3 < rows and x3 < cols:
                                                     if y4 > -1 and x4 > -1 and y4 < rows and x4 < cols:
                                                         if y5 > -1 and x5 > -1 and y5 < rows and x5 < cols:
                                                             lgrid = dc(grid)
                                                             lgrid = punch(lgrid, x1, y1, rows, cols)
                                                             lgrid = punch(lgrid, x2, y2, rows, cols)
                                                             lgrid = punch(lgrid, x3, y3, rows, cols)
                                                             lgrid = punch(lgrid, x4, y4, rows, cols)
                                                             lgrid = punch(lgrid,x5,y5,rows,cols,last=True)
                                                             if lgrid:
                                                                 if count(lgrid) == i:
                                                                     return lgrid
     print(""uffuffuff"")
     for y1 in range(rows):
         for x1 in range(cols):
             for y2 in [y1-1, y1, y1+1]:
                 for x2 in [x1-1, x1, x1+1]:
                     for y3 in [y2-1, y2, y2+1]:
                         for x3 in [x2-1, x2, x2+1]:
                             for y4 in [y3-1, y3, y3+1]:
                                 for x4 in [x3-1, x3, x3+1]:
                                   for y5 in [y4-1, y4, y4+1]:
                                     for x5 in [x4-1, x4, x4+1]:
                                       for y6 in [y5-1, y5, y5+1]:
                                         for x6 in [x5-1, x5, x5+1]:
                                           if y2 > -1 and x2 > -1 and y2 < rows and x2 < cols:
                                             if y3 > -1 and x3 > -1 and y3 < rows and x3 < cols:
                                               if y4 > -1 and x4 > -1 and y4 < rows and x4 < cols:
                                                 if y5 > -1 and x5 > -1 and y5 < rows and x5 < cols:
                                                   if y6 > -1 and x6 > -1 and y6 < rows and x6 < cols:
                                                             lgrid = dc(grid)
                                                             lgrid = punch(lgrid, x1, y1, rows, cols)
                                                             lgrid = punch(lgrid, x2, y2, rows, cols)
                                                             lgrid = punch(lgrid, x3, y3, rows, cols)
                                                             lgrid = punch(lgrid, x4, y4, rows, cols)
                                                             lgrid = punch(lgrid, x5, y5, rows, cols)
                                                             lgrid = punch(lgrid,x6,y6,rows,cols,last=True)
                                                             if lgrid:
                                                                 if count(lgrid) == i:
                                                                     return lgrid
     print(""Not possible"")
     return None
 
 #---------------------------------------------
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def is_divisible(mines, rows, cols):
     """"""Checks if pattern can be achieved using 'punchouts' (see below)""""""
     """"""edit: just using to cut down on trivial cases
         to improve the brute force now :(""""""
     cells = rows*cols
     if rows>=3 and cols>=3:
         # if rows<3 and cols<3 brute force is fast anyway
         """"""Can punch out:
         4, 6, 8(6+(6-4)), 9, 10(6+4), 11(9+(4-2)/9+(6-4)),
         12(9+6-3/9+4-1), 13(9+4), 14(9+(9-4)), 15(9+6)...
         negatives: 1, 2, 3, 5, 7 -> 1 invalid (instant win)
         """"""
         for target in [2, 3, 5, 7]:
             if mines+target == cells:
                 return ""impossible""
     if mines == 0:
         null_sol = []
         for y in range(rows):
             null_sol.append([])
             for x in range(cols):
                 null_sol[y].append(""."")
         null_sol[0][0] = ""c""
         return null_sol
     elif mines == cells-1:
         one_sol = []
         for y in range(rows):
             one_sol.append([])
             for x in range(cols):
                 one_sol[y].append(""*"")
         one_sol[0][0] = ""c""
         return one_sol
     """"""These three lines are super effective! 277s->93s!""""""
     if (cols==2 and rows>=3) or (rows==2 and cols>=3):
         if mines%2 != 0:
             return ""impossible""
     return ""permission""
 
 def run(data):
     rows, cols, mines = data
     """"""So this problem is essentially asking:
         Construct a field using only 3x3-grids as punchouts.
         The grids' centers must be within the minefield (i.e.
         allows for 2x2 at the corners, 2x3 and 3x2 at the edges).""""""
     cells = rows*cols
     pre_judgement = is_divisible(mines, rows, cols)
     if pre_judgement == ""impossible"":
         return None
     elif pre_judgement == ""permission"":
         return brute_force(mines, rows, cols)
     else:
         return pre_judgement
         
 
 #---------------------------------------------
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, sol, last=False):
     f.writelines(""Case #""+str(i+1)+"":\n"")
     addendum = ""\n""
     if last==True:
         addendum = """"
     if sol:
         for row in sol:
             sol_string = """"
             for element in row:
                 sol_string += element
             f.writelines(sol_string+""\n"")
     else:
         f.writelines(""Impossible""+addendum)
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)-1):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)), last=False)
         print(""Finished in ""+str(clock())+""."")
     write_case(f2, i+1, run(read_case(f)), last=True)
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2974486/xjcl/5690574640250880/0/extracted/c.py,11407,269,1186,Python,2974486,0,5690574640250880,xjcl,2014
27684,a.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def get_overlap(a1, a2):
     """"""Overlap of 0: No possibilities; volunteer cheated.
        Overlap of 1: That's the chosen number!
        Overlap of >2: Too many possibilities; bad magician.""""""
     overlap = []
     for i in a1:
         if i in a2:
             overlap.append(i)
     return overlap
 
 def run(data):
     guesses, fields = data
     first_guess = guesses[0]
     second_guess = guesses[1]
     first_field = fields[0]
     second_field = fields[1]
     first_possible_nums = []
     second_possible_nums = []
     """"""get numbers the parcipitant could have chosen 
        - this refers to all numbers in the chosen row.
        '-1' is necessary because python's indices start at 0.""""""
     first_possible_nums = first_field[first_guess-1]
     second_possible_nums = second_field[second_guess-1]
     overlap = get_overlap(first_possible_nums, second_possible_nums)
     if len(overlap):
         if len(overlap) == 1:
             return str(overlap[0])
         else:
             return ""Bad magician!""
     else:
         return ""Volunteer cheated!""
 
 #---------------------------------------------
 
 def read_case(f):
     guesses = []
     fields = []
     guesses.append( read_int(f)                 )
     fields.append(  read_lines(f, 4, read_ints) )
     guesses.append( read_int(f)                 )
     fields.append(  read_lines(f, 4, read_ints) )
     return [guesses, fields]
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/2974486/xjcl/5756407898963968/0/extracted/a.py,2921,106,292,Python,2974486,0,5756407898963968,xjcl,2014
134118,c.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     n, m, k = data
     if min(n,m) <= 2:
         return k # no enclosings possible -> only stones can count
     if k <= 4:
         return k
     if k >= 4:
         # 4 stones enclose a fifth field
         # and further 2 stones enclose one further field
         # BUT WHAT IF THE DIMENSIONS DON'T MATCH UP
         # this is the minesweepershit all over again
         pass #...
     # ok here is how we do it
     # we start with a 
     # .x.
     # x_x
     # .x.
     # configuration.
     # then we attempt to bump it up/outwards:
     # .xx.
     # x__x
     # x_x.
     # .x..
     # which adds (last_add+1) fields and 3 stones
     # until we hit a wall...
     # .xx.
     # x__x
     # x__x
     # x_x.
     # .x..
     # which adds (last_add) fields and 2 stones
     # after hitting both walls we'll add (last_add-1) fields and 1 stone
     # .xx.
     # x__x
     # x__x
     # x__x
     # .xx.
     # and finally fill the corners with stones
     last_add = 1
     fields = 1
     stones = 4
     total = fields+stones
     curr_width = 3
     curr_height = 3
     while curr_width < min(n,m):
         if 3 < k-total: # if it is more optimal to add a diagonal
                         # rather than individual stones
             last_add += 1
             fields += last_add
             stones += 3
             total = fields+stones
             curr_width += 1
             curr_height += 1
         else:
             break
     while curr_width < max(n,m): # NOTE: curr_width might be width OR height
         if 2 < k-total:
             fields += last_add
             stones += 2
             total = fields+stones
             curr_width += 1
         else:
             break
     while last_add > 0:
         # assert field (width, height) is maxed out
         if 1 < k-total:
             last_add -= 1
             fields += last_add
             stones += 1
             total = fields+stones
         else:
             break
     ret = stones + (k-total) # covers corners and leftovers
     #if ret >= total:
     #    return stones
     return ret
 
 #---------------------------------------------
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/3004486/xjcl/5658068650033152/1/extracted/c.py,3705,145,460,Python,3004486,1,5658068650033152,xjcl,2014
134120,a.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 from fractions import gcd
 from decimal import Decimal
 from math import log2
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     p, q = int(data[0]), int(data[1])
     reduce_by = gcd(p, q)
     p, q = p/reduce_by, q/reduce_by
     
     if q%2!=0:
         return ""impossible""
     dec = Decimal(p)/Decimal(q)
     if len(str(dec)) > 20:
         """"""Is a repeating fraction, not a multiple
             of 1/2**40""""""
         return ""impossible""
     count = 0
     while p/q * 2 <= 1:
         p *= 2
         count += 1
     moar = 0
     if p/q != 1:
         """"""After reducing to find where the earliest
             1/1 is, now enhance back up to see when
             only 0/1s and 1/1s are reached""""""
         count += 1
         moar = log2(q)
         if moar%1 != 0:
             print(""imp"")
             return ""impossible"" # should be caught by >15.
     if count + int(moar) > 40:
         return ""impossible""
     return str(count)
 #---------------------------------------------
 
 def read_case(f):
     return read(f).split(""/"")
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/3004486/xjcl/5706278382862336/1/extracted/a.py,2522,100,277,Python,3004486,1,5706278382862336,xjcl,2014
134121,a.py,"""""""Python2- and Python3-compatible. That's all.""""""
 from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 from fractions import gcd
 from decimal import Decimal
 
 def read(f):
     return next(f).strip(""\n"")
     
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
     
 def read_int(f, b=10):
     return int(read(f), b)
  
 def read_float(f):
     return float(read(f))
  
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
     
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
                
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 def run(data):
     p, q = int(data[0]), int(data[1])
     reduce_by = gcd(p, q)
     p, q = p/reduce_by, q/reduce_by
     
     if q%2!=0:
         return ""impossible""
     dec = Decimal(p)/Decimal(q)
     if len(str(dec)) > 15:
         return ""impossible""
     count = 0
     while p/q * 2 <= 1:
         p *= 2
         count += 1
     if p/q != 1:
         count += 1
     if count > 40:
         return ""impossible""
     return str(count)
 
 #---------------------------------------------
 
 def read_case(f):
     return read(f).split(""/"")
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2014/3004486/xjcl/5706278382862336/0/extracted/a.py,2107,90,221,Python,3004486,0,5706278382862336,xjcl,2014
1674,b.py,"from time import clock
 import sys
 import numpy as np
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 
 for n = 2, we have to solve the formulas given in the problem statement
 
     V0+V1 = V
     (V0X0 + V1X1) / (V0 + V1) = X
 
     OMG! SYSTEM OF EQUATIONS! :O
         OMG! my linear algebra course is useful!
 
     well, sort of.
 
     V0+V1 = V
     (V0X0 + V1X1) = (V0 + V1) X
     V0 X0 + V1 X1 = V0 X + V1 X
     V0 X0 - V0 X + V1 X1 - V1 X = 0
     V0 (X0-X) + V1 (X1-X) = 0
 
     and we know all X's! perfect!
 
 
 hm, for bigger n this might not be a linalg problem
     but an optimisation problem
 
 well, are there multiple solutions for bigger ns?
     yes. consider two fast 20, 40 pumps and a slow 30 one when X = 30
 
 """"""
 
 def run(data):
 
     v, x, pumps = data
     print(v, x, pumps)
 
     # we only have one pump
     try:
         pumps[1]
     except:
         print(""  ONE PUMP  "")
         if x - 0.0000001 < pumps[0][1] < x + 0.0000001:
             return ""%.9f"" % (v / pumps[0][0])
         return ""IMPOSSIBLE""
 
     # both can pump
     if pumps[0][1] == pumps[1][1]:
         print("" THAT         CASE              "")
         if (x - 0.0000001 < pumps[0][1] < x + 0.0000001):
             return ""%.9f"" % (v / (pumps[0][0]+pumps[1][0]))
         return ""IMPOSSIBLE""
 
 
     # ""normal"" case
     a = np.array( [[1,1], [ pumps[0][1] - x, pumps[1][1] - x]] )
     b = np.array( [v,0] )
 
     sol = np.linalg.solve(a, b)
 
     if sol[0] < 0 or sol[1] < 0:
         return ""IMPOSSIBLE""
 
     return ""%.9f"" % max(sol[0] / pumps[0][0], sol[1] / pumps[1][0])
 
 
 #---------------------------------------------
 
 def read_case():
 
     cnt, v, x = [float(n) for n in input().split()]
 
     pumps = []
     for i in range(int(cnt+.1)):
         pumps.append([float(n) for n in input().split()])
 
     return (v, x, pumps)
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr+"" @ t=""+str(clock()))
     sys.stdout.write(outstr+""\n"")
",gcj/2015/8234486/xjcl/5750872826970112/0/extracted/b.py,2181,88,322,Python,8234486,0,5750872826970112,xjcl,2015
1675,a.py,"from time import clock
 import sys
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 lemma:
     in an ideal config every arrow has to point to another arrow
 proof:
     if an arrow does not satisfy that, it would point to an edge
     and is an instant loss
 
 in fact, this might be the only condition we have to satisfy.
     and because we cannot place/remove arrows, this would make
     the problem easy! (O(R*C))
 
 well, per arrow we also have to search the corresponding row
     and column, so we have O(R+C) effort per cell,
     in total O((R*C)*(R+C))
 
 we could do clever caching, but i think this suffices for the big case. :)
 
 """"""
 
 
 
 def run(superdata):
 
     r,c,data = superdata
     cnt = 0
 
     for i in range(r):
         for j in range(c):
 
             # no arrow: nothing to do
             if data[i][j] == ""."":
                 continue
 
             # arrow pointing to arrow: nothing to do
 
             if data[i][j] == ""^"":
                 if any([ data[y][j] != ""."" for y in range(i-1,-1,-1) ]):
                     continue
 
             if data[i][j] == ""v"":
                 if any([ data[y][j] != ""."" for y in range(i+1,r) ]):
                     continue
 
             if data[i][j] == ""<"":
                 if any([ data[i][x] != ""."" for x in range(j-1,-1,-1) ]):
                     continue
 
             if data[i][j] == "">"":
                 if any([ data[i][x] != ""."" for x in range(j+1,c) ]):
                     continue
 
             # arrow pointing to not arrow:
             #   find another arrow to point to
             #   if none found, ret IMPOSSIBLE
 
             if (any([ data[i][x] != ""."" for x in range(c) if j != x ])
                     or any([ data[y][j] != ""."" for y in range(r) if i != y ])):
                 cnt += 1
                 continue
 
             return ""IMPOSSIBLE""
 
     return cnt
 
 #---------------------------------------------
 
 def read_case():
 
     r,c = [int(n) for n in input().split()]
     a = []
     for i in range(r):
         a.append(input())
 
     return (r, c, a)
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr+"" @ t=""+str(clock()))
     sys.stdout.write(outstr+""\n"")
",gcj/2015/8234486/xjcl/5708208098246656/1/extracted/a.py,2407,87,314,Python,8234486,1,5708208098246656,xjcl,2015
33545,d.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 if x>=7 Richard immediately wins
     (see the 2nd example of the 7-ominoes -> impossible-to-fill hole)
     ###
     # # << no one's getting in there now
     ##
 Idea: take the tile you're given and expand it into a rectangular area
     as small as possible. then fill the rest up with #### or so tiles
 
 x=1 and x=2 are equally trivial
 x=3: we have tiles
     ## (notation: #/##) and ###
     #
     hm, Richard shouldn't be able to do much by choosing.
     hypothesis: Gabriel's optimal answer to #/## is #/##
         right next to it to make a 2x3
     if I could prove Richard is always better off choosing
         #/## over ### that would help a lot
     (that's probably the case but I don't need it anymore)
 
 
 """"""
 def run(data):
     x, gr, sm = data
 
     Win = ""GABRIEL""
     Fail = ""RICHARD""
 
     # first if: cell number and area covered by ominoes don't match
     if gr * sm % x:
         return Fail
 
     if gr < sm:
         gr,sm = sm,gr
 
     # hole, see above
     if x > 6:
         return Fail
 
     if x == 3:
         if sm == 1:
             return Fail
 
     if x == 4:
         if sm == 1 or sm == 2:
             return Fail
 
     if x == 5:
         if sm == 1 or sm == 2 or sm == 3:  # 3: #../##./.##
             return Fail
 
     if x == 6:
         # not only 1x6 but also 2x3 etc
         # 3: .##/##./#../#..  can never happen since we separate a field
         # but it will always have 3n+1 fields (we need 6n)
         # seems to work for 4xN...
         if sm == 1 or sm == 2 or sm == 3:
             return Fail
 
     return Win
 
 #---------------------------------------------
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5658571765186560/1/extracted/d.py,3113,128,425,Python,6224486,1,5658571765186560,xjcl,2015
33546,d.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 if x>=7 Richard immediately wins
     (see the 2nd example of the 7-ominoes -> impossible-to-fill hole)
     ###
     # # << no one's getting in there now
     ##
 Idea: take the tile you're given and expand it into a rectangular area
     as small as possible. then fill the rest up with #### or so tiles
 
 x=1 and x=2 are equally trivial
 x=3: we have tiles
     ## (notation: #/##) and ###
     #
     hm, Richard shouldn't be able to do much by choosing.
     hypothesis: Gabriel's optimal answer to #/## is #/##
         right next to it to make a 2x3
     if I could prove Richard is always better off choosing
         #/## over ### that would help a lot
 
 
 """"""
 def run(data):
     x, gr, sm = data
 
     Win = ""GABRIEL""
     Fail = ""RICHARD""
 
     # first if: cell number and area covered by ominoes don't match
     if gr * sm % x:
         return Fail
 
     if gr < sm:
         gr,sm = sm,gr
 
     # hole, see above
     if x > 6:
         return Fail
 
     """"""
     cases failing for x=2 are caught in first if
     if x == 1 or x == 2:
         return Win
     """"""
 
     if x == 3:
         # choose #/## -> spill
         if sm == 1:
             return Fail
         """"""
         I think I'll just hardcode for the small case
           as I simply can't see the 'catch' in here
           From what I'm seeing atm any field greaterequal 3x4
           for x=4 seems to work out (given first-if)
         sm == 2 and gr in [2,4]  already caught in first if
         4x4 caught in first if
           3x4 can be reduced to 3x3, which can obvs be won
         """"""
 
     if x == 4:
         """"""
         if sm == 1:
             return Fail
         # gr is in [2,4]. always choose #/##/#
         if sm == 2:
             return Fail
         # sm=3 implies gr=4 (first if)
         if sm == 3:
             return Win
         # left: 4x4
         return Win
         """"""
         if sm == 1 or sm == 2:
             return Fail
 
     return Win
 
 #---------------------------------------------
 
 def read_case(f):
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5658571765186560/0/extracted/d.py,3496,143,470,Python,6224486,0,5658571765186560,xjcl,2015
33547,b.py,"from time import clock
 from sys import argv
 
 from math import ceil, floor, log
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 ok, so obviously we only want to interrupt if we gain more minutes
     (through better partitioned pancakes) than we lose
     (though ALL OTHER PEOPLE not eating)
 
 for an uneven number 2n+1 it is more ideal to
     partition (n,n+1) first and then eat (n-1,n)  compared to
     eating first (2n) and then partition (n,n)
 
 since gcj loves dynamic programming: one should compute the case of
     <<no interrupts>> first and then add one in an 'optimal' position
     and see if that improves the result
 what's the optimal position? naively, I'd say it's interrupting at
     minute 1 and moving half of the biggest pile to an empty one
 ok there's my algorithm let's do this :D
 
 ok my algorithm got a bit messier than I hoped but does the job
     and does it in one loop (i.e. few enough cycles to be fast,
     even though it does a lot of BS per cycle, like horribly slow
     list concatenation)
 I also made a mistake in my thinking earlier: one has to look
     at all possible number of pancake additions, not just at
     current+1. consider [8,8] for example. [8,4,4] is not better
     but [4,4,4,4] (4+2=6 min) is
 
 incorrect? I already did ten cases by hand and all seems right
     I must've missed an edge case I think
 
 ooohh I haven't considered lifting the pancakes onto a non-empty plate
     but that can't be more optimal can it?
     I can't come up with a scenario where it is
 
 ok came up with the solution after FOREVER and brute-forcing it
     9 is in an optimal case not 9 -> 1+ 5,4 -> 2+ 4,3,2 -> 6
     but 9 -> 1+ 6,3 -> 2+ 3,3,3 -> 5!
 
 the max n for which 2 <= log(pancakes,n) holds is the no of div we want
     n=3: 9 -> 3 3 3 -> 3+2=5
          12 -> 4 4 4 -> 4+2=6
          13 -> 5 4 4 -> 5+2=7
     n=4: 16 -> 4 4 4 4 -> 4+3=7
 except sometimes it's better to divide it evenly...
     9,5,5 -> 1+ 5,5,5,4 -> 6
     9,5,5 -> 2+ 5,5,3,3,3 -> 7
 
 ---
 
 ok I had a stroke of inspiration and something that might work
     what if we carried a value to undercut (and the start the eating)
     and decreased that by one every time?
     so for 9 6 3 we would so
         9: 9 6 3 -> 9
         8: 9 6 3 -> 1+ 5 4 6 3 -> 7
         7: see 8
         6: see 7
         5: 9 6 3 -> 2+ 5 4 3 3 3 -> 7
         4: 9 6 3 -> 3+ 3 3 3 3 3 3 -> 6
         3: see 4
         2: ...
         1: case we can ignore
 only downside is it does get hairy for n=2,3,4
 oh maybe we don't need n=2. consider 4 -> 1+ 2 2 -> 3
     it can readily be achieved with n=3
     however we certainly cannot throw out n=3
 
 ok NICE I actually solved this newbie-someone-did-it-in-brainfuck
     problem. it's so incredibly hard to change your outlook on a
     problem after it solidified in your mind.
 I wish there was a way to force out-of-box thinking. I was walking
     around and have already given up on this problem (->less stress)
     so that might be a good start
 anyway, here's hoping I made no blunders. see myself on the other side!
 
 ok that actually took quite some time (23s) but the .out seems fine :)
 """"""
 
 def run(data):
     print(""in(""+str(data)+"")"")
 
     min = 1000
     # ops ^= operations ^= special minutes
     # optimal: we do all of these at the start
     md = max(data)
     if md == 1 or md == 2:
         return str(md)
 
     # we do have to include n=2 bc of 4 -> 2 2 (where upbound=3)
     for upbound in range(md,1,-1):
         ops = 0
         for n in data:
             plates = 1
             while ceil(n/plates) > upbound:
                 plates += 1
             # one transport per plate minus initial plate
             ops += (plates - 1)
 
         candidate = ops + upbound
         if candidate < min:
             min = candidate
 
 
     print(""ret(""+str(min)+"")"")
     return str(min)
 
 #---------------------------------------------
 
 def read_case(f):
     next(f)
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5686275109552128/1/extracted/b.py,5341,174,824,Python,6224486,1,5686275109552128,xjcl,2015
33548,b.py,"from time import clock
 from sys import argv
 
 from math import ceil, floor
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 ok, so obviously we only want to interrupt if we gain more minutes
     (through better partitioned pancakes) than we lose
     (though ALL OTHER PEOPLE not eating)
 
 for an uneven number 2n+1 it is more ideal to
     partition (n,n+1) first and then eat (n-1,n)  compared to
     eating first (2n) and then partition (n,n)
 
 since gcj loves dynamic programming: one should compute the case of
     <<no interrupts>> first and then add one in an 'optimal' position
     and see if that improves the result
 what's the optimal position? naively, I'd say it's interrupting at
     minute 1 and moving half of the biggest pile to an empty one
 ok there's my algorithm let's do this :D
 
 ok my algorithm got a bit messier than I hoped but does the job
     and does it in one loop (i.e. few enough cycles to be fast,
     even though it does a lot of BS per cycle, like horribly slow
     list concatenation)
 I also made a mistake in my thinking earlier: one has to look
     at all possible number of pancake additions, not just at
     current+1. consider [8,8] for example. [8,4,4] is not better
     but [4,4,4,4] (4+2=6 min) is
 
 incorrect? I already did ten cases by hand and all seems right
     I must've missed an edge case I think
 
 ooohh I haven't considered lifting the pancakes onto a non-empty plate
     but that can't be more optimal can it?
     I can't come up with a scenario where it is
 
 ok came up with the solution after FOREVER and brute-forcing it
     9 is in an optimal case not 9 -> 1+ 5,4 -> 2+ 4,3,2 -> 6
     but 9 -> 1+ 6,3 -> 2+ 3,3,3 -> 5!
 
 the max n for which 2 <= log(pancakes,n) holds is the no of div we want
     n=3: 9 -> 3 3 3 -> 3+2=5
          12 -> 4 4 4 -> 4+2=6
          13 -> 5 4 4 -> 5+2=7
     n=4: 16 -> 4 4 4 4 -> 4+3=7
 except sometimes it's better to divide it evenly...
     9,5,5 -> 1+ 5,5,5,4 -> 6
     9,5,5 -> 2+ 5,5,3,3,3 -> 7
 """"""
 
 def insert(data, new_member):
     for j in range(len(data)):
         if new_member >= data[j]:
             return data[:j] + [new_member] + data[j:]
     return data + [new_member]
 
 
 def consider(data, t):
 
     val = data[0] + t  # takes as long as the slowest eater
     top = data[0]
 
     data = data[1:]
 
     if top <= 3:
         return top + t
 
     val2 = 9
     if top == 9:
         val2 = consider( insert(insert(insert(data,3),3),3) , t+2 )
 
     for d in [ceil(top/2), floor(top/2)]:
         data = insert(data, d)
 
     if top + t < val:
         val = top + t
 
     if val2 < val:
         val = val2
 
     val3 = consider(data, t+1)
     if val3 < val:
         val = val3
 
     return val
 
 
 
 def run(data):
     print(""in(""+str(data)+"")"")
     data.sort()
     data.reverse()
 
     val = consider(data, 0)
 
     print(data)
     print(""ret(""+str(val)+"")"")
     return str(val)
 
 """"""
 def run(data):
     print(""in(""+str(data)+"")"")
     data.sort()
     data.reverse()
     val = data[0]  # takes as long as the slowest eater
     top = val
     t = 0
 
     # i: number of interruptions
     for i in range(1, (val+1)):
 
         print(data,t)
         data = data[1:]
 
         if top <= 3:
             break
 
         newd, add = partition(data, top)
         t += add
 
         for d in newd:
             data = insert(data, d)
 
         top = data[0]
 
         if top + t < val:
             val = top + t
 
     print(data)
     print(""ret(""+str(val)+"")"")
     return str(val)
 """"""
 
 """"""
 def run(data):
     print(""in(""+str(data)+"")"")
     data.sort()
     data.reverse()
     val = data[0]  # takes as long as the slowest eater
 
     # i: number of interruptions
     # maybe val+1 is a bad upper limit for the range; maybe we need higher
     for i in range(1, (val+1)):
 
         # optimization that can be removed
         if data[0] <= 3:
             break
 
         # halve the slowest eater and 'insert' them into their new place
         new_slowest2 = floor(data[0]/2)
         new_slowest = ceil(data[0]/2)
         print(data)
 
         for j in range(1, len(data)):
             if (new_slowest <= data[j-1]) and (new_slowest2 >= data[j]):
                 data = data[1:j] + [new_slowest, new_slowest2] + data[j:]
                 break
         else:
             data = data[1:] + [new_slowest, new_slowest2]
         #assert(data == list(reversed(sorted(data)))) #where is my bug? :(
 
         print(data[0] + i, val)
         if data[0] + i < val:
             val = data[0] + i
 
     print(data)
     print(""ret(""+str(val)+"")"")
     return str(val)
 """"""
 
 #---------------------------------------------
 
 def read_case(f):
     next(f)
     return read_ints(f)
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5686275109552128/0/extracted/b.py,6104,236,825,Python,6224486,0,5686275109552128,xjcl,2015
33549,c.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 This problem sounds like it would be well-suited to Haskell actually
 """"""
 
 mul = {
     ""1"": {""1"": ""1"", ""i"": ""i"",  ""j"": ""j"",  ""k"": ""k"" },
     ""i"": {""1"": ""i"", ""i"": ""-1"", ""j"": ""k"",  ""k"": ""-j""},
     ""j"": {""1"": ""j"", ""i"": ""-k"", ""j"": ""-1"", ""k"": ""i"" },
     ""k"": {""1"": ""k"", ""i"": ""j"",  ""j"": ""-i"", ""k"": ""-1""},
        }
 
 def mult(a, b):
     sign = a[0]==""-"" and b[0]==""-"" or a[0]!=""-"" and b[0]!=""-""
     ret = mul[a.strip(""-"")][b.strip(""-"")]
     if sign:
         return ret
     if ret[0]==""-"":
         return ret[1]
     return ""-""+ret
 
 def eval_str(s):
     run = ""1""
     for c in s:
         run = mult(run, c)
     return run
 
 def eval_times(c, n):
     run = ""1""
     for i in range(n):
         run = mult(run, c)
     return run
 
 """"""
 idea: we found a and b such that:
     dfijoidfjejdwiwjdioiaiokiaklsdkl
     ----i----|             |---k----
             a^            b^
 squeeze_j returns True iff the middle
     (string between a and b) evaluates to ""j""
 
 Oh I'm just now realizing we don't need to check
     for every a and b. because if
     dfijoidfjejdwiwjdioiaiokiaklsdkl
     ----i----|          |------k----
             a^        b'^
     is an alternate solution, the string from
         b to b' evaluates to 1 anyway!
 
 Yeah so don't be irritated by the code in run(data);
     cutoff_i and cutoff_k will only ever have one element
 """"""
 def squeeze_j(a, b, s, rep):
 
     diff = a[0] - b[0]
 
     if diff > rep:
         return False
     if diff == rep:
         return eval_str( s[ a[1]+1 : b[1] ] ) == ""j""
 
     front = eval_str( s[ a[1]+1 : ] )
     back = eval_str( s[ : b[1] ] )  # ok if str empty
     middle = eval_str(s)
 
     #[mult(mult(mult(x,x),x),x) for x in [""1"",""i"",""j"",""k"",""-1"",""-i"",""-j"",""-k""]]
     return mult(mult(front, eval_times(middle, (rep-diff-1) % 4)), back) == ""j""
 
 
 # find possible position for the i
 # WARNING! we record the closed interval, not the half-open one
 #   so we will need to add +1 later on
 # only check the first 4, then they repeat (see above)
 def find_cutoff_i(s):
     res = ""1""
     for i in range(4):
         for j in range(len(s)):
             res = mult(res, s[j])
             if res == ""i"":
                 return (i, j)
 
 # find possible position for the k
 def find_cutoff_k(s):
     res = ""1""
     for i in range(-1,-5,-1):
         for j in range(len(s)-1,-1,-1):
             res = mult(s[j], res)
             if res == ""k"":
                 return (i, j)
 
 def run(data):
     rep, s = data
 
     cutoff_i = find_cutoff_i(s)
     if cutoff_i:
         cutoff_k = find_cutoff_k(s)
         if cutoff_k:
             if squeeze_j(cutoff_i,cutoff_k,s,rep):
                 return ""YES""
 
     return ""NO""
 
 #---------------------------------------------
 
 def read_case(f):
     _, rep = read_ints(f)
     return (rep, read_singles(f))
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5670465267826688/1/extracted/c.py,4277,169,533,Python,6224486,1,5670465267826688,xjcl,2015
33550,c.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 This problem sounds well-suited to Haskell actually
 """"""
 
 mul = {
     ""1"": {""1"": ""1"", ""i"": ""i"",  ""j"": ""j"",  ""k"": ""k"" },
     ""i"": {""1"": ""i"", ""i"": ""-1"", ""j"": ""k"",  ""k"": ""-j""},
     ""j"": {""1"": ""j"", ""i"": ""-k"", ""j"": ""-1"", ""k"": ""i"" },
     ""k"": {""1"": ""k"", ""i"": ""j"",  ""j"": ""-i"", ""k"": ""-1""},
        }
 
 def mult(a, b):
     sign = a[0]==""-"" and b[0]==""-"" or a[0]!=""-"" and b[0]!=""-""
     ret = mul[a.strip(""-"")][b.strip(""-"")]
     if sign:
         return ret
     if ret[0]==""-"":
         return ret[1]
     return ""-""+ret
 
 def eval_str(s):
     run = ""1""
     for c in s:
         run = mult(run, c)
     return run
 
 def eval_times(c, n):
     run = ""1""
     for i in range(n):
         run = mult(run, c)
     return run
 
 
 def squeeze_j(a, b, s, rep):
 
     diff = a[0] - b[0]
 
     if diff > rep:
         return False
     if diff == rep:
         return eval_str( s[ a[1]+1 : b[1] ] ) == ""j""
 
     front = eval_str( s[ a[1]+1 : ] )
     back = eval_str( s[ : b[1] ] )  # ok if str empty
     middle = eval_str(s)
     print(front, middle, back)
 
     #[mult(mult(mult(x,x),x),x) for x in [""1"",""i"",""j"",""k"",""-1"",""-i"",""-j"",""-k""]]
     return mult(mult(front, eval_times(middle, (rep-diff-1) % 4)), back) == ""j""
 
 
 def run(data):
     rep, s = data
     cutoff_i = []
     cutoff_k = []
 
     # find possible positions for the i
     # WARNING! we record the closed interval, not the half-open one
     #   so we will need to add +1 later on
     # check the first 4, then they should repeat
     res = ""1""
     for i in range(4):
         for j in range(len(s)):
             res = mult(res, s[j])
             if res == ""i"":
                 cutoff_i.append((i, j))
                 break
         if cutoff_i:
             break
 
     # find possible positions for the k
     res = ""1""
     for i in range(-1,-5,-1):
         for j in range(len(s)-1,-1,-1):
             res = mult(s[j], res)
             if res == ""k"":
                 cutoff_k.append((i, j))
                 break
         if cutoff_k:
             break
 
     print(cutoff_i, cutoff_k)
     for a in cutoff_i:
         for b in cutoff_k:
             if squeeze_j(a,b,s,rep):
                 return ""YES""
 
     return ""NO""
 
 #---------------------------------------------
 
 def read_case(f):
     _, rep = read_ints(f)
     return (rep, read_singles(f))
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5670465267826688/0/extracted/c.py,3776,157,454,Python,6224486,0,5670465267826688,xjcl,2015
33551,a.py,"from time import clock
 from sys import argv
 #import math
 #import itertools
 #import numpy
 
 def read(f):
     return next(f).strip(""\n"")
 
 def read_singles(f):
     # returns chars of a word
     # or digits (as strings) of an int
     return list(read(f))
 
 def read_int(f, b=10):
     return int(read(f), b)
 
 def read_float(f):
     return float(read(f))
 
 def read_digits(f, b=10):
     return [int(n, b) for n in read_singles(f)]
 
 #---------------------------------------------
 
 def read_strs(f, s="" ""):
     return read(f).split(s)
 
 def read_ints(f, b=10, s="" ""):
     return [int(n, b) for n in read_strs(f, s)]
 
 def read_floats(f, s="" ""):
     return [float(n) for n in read_strs(f, s)]
 
 #---------------------------------------------
 
 def read_lines(f, n, reader=read_ints, *args, **kwargs):
     ret = []
     for i in range(n):
         ret.append(reader(f, *args, **kwargs))
     return ret
 
 #---------------------------------------------
 
 """"""
 obvious: when inviting friends, always pick Si=0
 
 hm. looks like you just have to take the prefixsum (people clapping)
     and subtract from it the index (people we need to have clapping
     at this point)
     (index starting at 1)
 if it is always >=0: no one needs to be invited
     if it is <0 sometimes: take their minimum and invite -min friends
 this plays well with the guarantee that aud_list[-1] > 0
     and should finish in O(n) time
 """"""
 
 def run(data):
     aud_cnt, aud_list = data
     print(aud_cnt)
     print(aud_list)
 
     prefsum = 0
     min = 0
     for (i,a) in enumerate(aud_list):
         prefsum += a
         deficit = prefsum - i - 1  # -1 bc we started indexing at 0 not 1
         if deficit < min:
             min = deficit
 
     return str(-min)
 
 #---------------------------------------------
 
 def read_case(f):
     aud_cnt, aud_list = read_strs(f)
     return (aud_cnt, [int(a) for a in aud_list])
 
 def write_case(f, i, sol):
     f.writelines(""Case #""+str(i+1)+"": ""+str(sol)+""\n"")
 
 #---------------------------------------------
 
 def main():
     f = open(argv[1])
     f2 = open(argv[2], ""wt"")
     for i in range(read_int(f)):
         print(""Init case ""+str(i+1)+""."")
         write_case(f2, i, run(read_case(f)))
         print(""Finished in ""+str(clock())+""."")
     f.close()
     f2.close()
 
 if __name__ == ""__main__"":
     main()
",gcj/2015/6224486/xjcl/5639104758808576/1/extracted/a.py,2378,96,284,Python,6224486,1,5639104758808576,xjcl,2015
113555,a.py,"from time import clock
 import sys
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write(str(s[0])+""\n"") if len(s)==1 else print(s)
 
 #---------------------------------------------
 
 """"""
 
 method b: it's obvious we minimize by putting the mushrooms on at
     the end of the 10s-interval just as Bartholomew did
 first figure out the max positive difference between two consecutive
     (i.e. make two passes through the list)
 
 method a: sum up all positive differences
 
 """"""
 
 def run(a):
 
     method_a = 0
     lamo = len(a)-1
     for i in range(lamo):
         diff = a[i] - a[i+1]
         if diff > 0:
             method_a += diff
 
     method_b = 0
     maxdiff = max(a[i] - a[i+1] for i in range(lamo))
     print(maxdiff)
     if maxdiff < 0:  maxdiff = 0
     for i in range(lamo):
         ai = a[i]
         diff = ai - a[i+1]
         if ai < maxdiff:
             method_b += ai
         else:
             method_b += maxdiff
 
     return str(method_a)+"" ""+str(method_b)
 
 #---------------------------------------------
 
 def read_case():
     input()
     return [int(n) for n in input().split()]
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4224486/xjcl/6404600001200128/1/extracted/a.py,1392,54,175,Python,4224486,1,6404600001200128,xjcl,2015
113557,b.py,"from time import clock
 import sys
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write(str(s[0])+""\n"") if len(s)==1 else print(s)
 import math
 import sys
 
 sys.setrecursionlimit(100000)
 
 #---------------------------------------------
 
 """"""
 ""numbered 1 thorugh B"" now isn't this problem friendly to lua users
 
 i think this is to be solved like the pancake pronlem:
     /assume/ a number of minutes and then calculate whether
     it is possible to make it in that number
 hmm maybe add some binary search to it?
     e.g. if 1000 min is too few and 1500 too much do 1250
 
 hm, shouldn't be possible as we have 100000 possible values per barber
 
 one could convert it into a float (cuts/minute) and then
     guess based off that
 yes this will definitely give us a good approx. let's try!
 
 
 """"""
 
 
 def test_time(people, m, t, cache, fast):
 
     served = 0
     for mi in m:
         served += math.ceil(t/mi)
 
     #print(""tt"", people, m, t, cache, served)
 
     if served >= people:
         if fast:
             return test_time(people, m, t-100, served, fast)
         return test_time(people, m, t-1, served, fast)
 
     # found the minute -> determine exact barber
     if served < people and cache >= people:
         cntdown = people - served
         i = 0
         for i in range(len(m)):
             if t % m[i] == 0:
                 cntdown -= 1
                 if cntdown == 0:
                     return (i+1)
 
     return test_time(people, m, t+100, served, False)
 
 
 def approx(people, m):
 
     cpm = sum(1/mi for mi in m)
     return math.floor(people/cpm)
 
 
 def run(data):
     l1, m = data
     b, n = l1
 
     x = approx(n-1, m)
 
     ret = test_time(n, m, x+1002, 0, True)
 
     return str(ret)
 
 #---------------------------------------------
 
 def read_case():
     return [[int(n) for n in input().split()] for i in range(2)]
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4224486/xjcl/5765824346324992/1/extracted/b.py,2154,84,291,Python,4224486,1,5765824346324992,xjcl,2015
113558,b.py,"from time import clock
 import sys
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write(str(s[0])+""\n"") if len(s)==1 else print(s)
 import math
 import sys
 
 sys.setrecursionlimit(100000)
 
 #---------------------------------------------
 
 """"""
 ""numbered 1 thorugh B"" now isn't this problem friendly to lua users
 
 i think this is to be solved like the pancake pronlem:
     /assume/ a number of minutes and then calculate whether
     it is possible to make it in that number
 hmm maybe add some binary search to it?
     e.g. if 1000 min is too few and 1500 too much do 1250
 
 hm, shouldn't be possible as we have 100000 possible values per barber
 
 one could convert it into a float (cuts/minute) and then
     guess based off that
 yes this will definitely give us a good approx. let's try!
 
 
 """"""
 
 
 def test_time(people, m, t, cache):
 
     served = 0
     for mi in m:
         served += math.ceil(t/mi)
 
     print(""tt"", people, m, t, cache, served)
 
     if served >= people:
         return test_time(people, m, t-1, served)
 
     # found the minute -> determine exact barber
     if served < people and cache >= people:
         cntdown = people - served
         print(cntdown)
         i = 0
         for i in range(len(m)):
             print(cntdown, t, m[i])
             if t % m[i] == 0:
                 cntdown -= 1
                 if cntdown == 0:
                     return (i+1)
 
 
 def approx(people, m):
 
     cpm = sum(1/mi for mi in m)
     return math.floor(people/cpm)
 
 
 def run(data):
     l1, m = data
     b, n = l1
 
     x = approx(n-1, m)
 
     print(""x"", x)
 
     ret = test_time(n, m, x+2, 0)
 
     return str(ret)
 
 #---------------------------------------------
 
 def read_case():
     return [[int(n) for n in input().split()] for i in range(2)]
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4224486/xjcl/5765824346324992/0/extracted/b.py,2077,84,280,Python,4224486,0,5765824346324992,xjcl,2015
131112,c.py,"from time import clock
 import sys
 import math
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 idea: keep the maximum amount we can make as prefsum
     so if we had C=2, coins 1 2 3 5, prefsum is 2+4+6+10
     then see if the next coin in a can already be made*, else add it
         *: prefsum+1 >= a[i]
 
 we consider the case a[0] != 1 separately
     (i.e. we pre-calculate newcoins and prefsum in O(1))
     we don't need case analysis: log(1,x)==0==newcoins as intended
 
 i'm skeptical as to whether this will work for the large input.
 my solution isn't a cheap shot, but all that differs from my
     small solution is me adding a 'times c' everywhere :/
     (actually all c*2's in the log should've been 1+c, d'oh)
     (change of plan, do a[0] != 1 via looop)
 
 plus this solution is in O(n), which is too good to be true
 """"""
 
 def run(data):
 
     c, v, a = data
 
     i = 1
     n = len(a)
 
     newcoins = math.ceil(math.log(a[0], 1+c))
     print(newcoins)
 
 
     prefsum = 0
     for k in range(newcoins):
         prefsum += c * int((1+c)**k)
 
     prefsum += c * a[0]
 
 
     while prefsum < v:
 
         #print(prefsum, a[i] if i<n else ""xxx"", newcoins)
 
         # case we cannot reach next coin -> add new one
         if (i >= n or prefsum+1 < a[i]):
             assert i != 0
             #a = a[:i] + [prefsum+1] + a[i:]
             newcoins += 1
             #print(""mint of value "", prefsum+1)
             prefsum += c * (prefsum+1)
 
         else:
             prefsum += c*a[i]
             i += 1
 
 
     return str(newcoins)
 
 #---------------------------------------------
 
 def read_case():
     c, _, v = [int(n) for n in input().split()]
     a = [int(n) for n in input().split()]
     return (c, v, a)
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4244486/xjcl/5646553574277120/1/extracted/c.py,2122,78,306,Python,4244486,1,5646553574277120,xjcl,2015
131113,c.py,"from time import clock
 import sys
 import math
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 1 4 30
 1 5 10 17
 
 """"""
 
 def run(data):
 
     c, v, a = data
 
     i = 1
     n = len(a)
 
     newcoins = math.ceil(math.log(a[0], c*2))
     print(newcoins)
 
     prefsum = int((c*2)**newcoins - 1 + c*a[0])
 
     while prefsum < v:
 
         print(prefsum, a[i] if i<n else ""xxx"", newcoins)
 
         # case we cannot reach next coin -> add new one
         if (i >= n or prefsum+1 < a[i]):
             assert i != 0
             #a = a[:i] + [prefsum+1] + a[i:]
             newcoins += 1
             print(""mint of value "", prefsum+1)
             prefsum += c * (prefsum+1)
 
         else:
             prefsum += c*a[i]
             i += 1
 
 
     return str(newcoins)
 
 #---------------------------------------------
 
 def read_case():
     c, _, v = [int(n) for n in input().split()]
     a = [int(n) for n in input().split()]
     return (c, v, a)
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4244486/xjcl/5646553574277120/0/extracted/c.py,1331,59,171,Python,4244486,0,5646553574277120,xjcl,2015
131114,b.py,"from time import clock
 import sys
 import itertools
 
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 bla brute force
 
 faster with pypy3 ;)
 """"""
 
 # http://stackoverflow.com/questions/2970520
 def occurrences(string, sub):
     count = start = 0
     while True:
         start = string.find(sub, start) + 1
         if start > 0:
             count+=1
         else:
             return count
 
 
 
 def run(data):
 
     it, keys, target = data
 
     cases = 0
     maxi = 0
     sumval = 0
 
     for s in itertools.product(keys, repeat=it):
 
         val = occurrences("""".join(s), target)
 
         cases += 1
         sumval += val
         maxi = max(val, maxi)
 
 
     avg = sumval / cases
 
     return maxi - avg
 
 #---------------------------------------------
 
 def read_case():
     _, _, it = [int(n) for n in input().split()]
     keys = input()
     target = input()
     return (it, keys, target)
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4244486/xjcl/5708284669460480/0/extracted/b.py,1286,63,152,Python,4244486,0,5708284669460480,xjcl,2015
131115,a.py,"from time import clock
 import sys
 import math
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 
 """"""
 
 def run(data):
 
     r, c, w = data
 
     # if w == 1:
     #     return r*c
 
     guesses = 0
 
     # OOOOH THE PROBLEM STATEMENT SAID HORIZONTALLY
 
     for i in range(r-1):
         guesses += math.floor(c/w)
 
     # optimal: is on last row
     guesses += (w-1) + math.ceil(c/w)
 
     return guesses
 
 #---------------------------------------------
 
 def read_case():
     return [int(n) for n in input().split()]
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4244486/xjcl/5640146288377856/1/extracted/a.py,895,43,107,Python,4244486,1,5640146288377856,xjcl,2015
131116,a.py,"from time import clock
 import sys
 import math
 # stderr isn't piped to a.out when we do  (py3 a.py < a.in) > a.out
 print = lambda *s: sys.stderr.write("" "".join(str(m) for m in s)+""\n"")
 
 #---------------------------------------------
 
 """"""
 
 """"""
 
 def run(data):
 
     _, c, w = data
 
     return (w-1) + math.ceil(c/w)
 
 #---------------------------------------------
 
 def read_case():
     return [int(n) for n in input().split()]
 
 if __name__ == ""__main__"":
     for i in range(int(input())):
         outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
         print(outstr+"" @ t=""+str(clock()))
         sys.stdout.write(outstr+""\n"")
 
",gcj/2015/4244486/xjcl/5640146288377856/0/extracted/a.py,658,30,73,Python,4244486,0,5640146288377856,xjcl,2015
5797,b.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from copy import deepcopy
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 
 """"""
 
 
 def deduce(field, data, k, n):
 
     if k == n:
         for row in field:
             if None in row:
                 return None
         return field
 
     m = min(d[k] for d in data)
 
     bb = []
     for yy,d in enumerate(data):
         if d[k] == m:
             bb.append(d)
 
     assert len(bb) <= 2
 
 
     f1, d1 = deepcopy(field), deepcopy(data)
     f2, d2 = deepcopy(field), deepcopy(data)
     found1 = found2 = False
 
     for d in bb:
 
         fit1 = 100 * sum(d[j] == f1[k][j] for j in range(k)) + sum(None == f1[k][j] for j in range(k))
         fit2 = 100 * sum(d[j] == f1[j][k] for j in range(k)) + sum(None == f1[j][k] for j in range(k))
         # print(field, fit1, fit2, d)
 
         if (fit1 >= 100*(k-1) + 1 or (fit1 == 100*k - 99 and fit1 >= fit2)) and not found1:
             f1[k] = d
             d1.remove(d)
             found1 = True
         elif (fit2 >= 100*(k-1) + 1 or (fit2 == 100*k - 99 and fit2 >= fit1)) and not found2:
             for i in range(n):
                 f1[i][k] = d[i]
             d1.remove(d)
             found2 = True
 
     found1 = found2 = False
 
     for d in bb:
 
         fit1 = 100 * sum(d[j] == f2[k][j] for j in range(k)) + sum(None == f2[k][j] for j in range(k))
         fit2 = 100 * sum(d[j] == f2[j][k] for j in range(k)) + sum(None == f2[j][k] for j in range(k))
         # print(field, fit1, fit2, d)
 
         if (fit2 >= 100*(k-1) + 1 or (fit2 == 100*k - 99 and fit2 >= fit1)) and not found2:
             for i in range(n):
                 f2[i][k] = d[i]
             d2.remove(d)
             found2 = True
         elif (fit1 >= 100*(k-1) + 1 or (fit1 == 100*k - 99 and fit1 >= fit2)) and not found1:
             f2[k] = d
             d2.remove(d)
             found1 = True
 
 
     return deduce(f1, d1, k+1, n) or deduce(f2, d2, k+1, n)
 
 
 
 def find_missing_index(field, data, n):
 
     for i in range(n):
         for d in data:
             if d == field[i]:
                 data.remove(d)
                 break
         else:
             return field[i]
 
     for i in range(n):
         for d in data:
             if all(d[j] == field[j][i] for j in range(n)):
                 data.remove(d)
                 break
         else:
             ret = []
             for j in range(n):
                 ret.append( field[j][i] )
             return ret
 
 
 def run(data):
 
     n = round( (len(data)+1) / 2 )
 
     # alle = sum(data, [])
     # alle.sort()
 
     field = []
     for i in range(n):
         field.append([None] * n)
 
     field = deduce(field, deepcopy(data), 0, n)
 
     return ' '.join( [str(x) for x in find_missing_index(field, deepcopy(data), n)] )
 
 #---------------------------------------------
 
 def read_case():
     n = int(input())
     return [[int(k) for k in input().split()] for i in range(2*n-1)]
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/4304486/xjcl/5630113748090880/0/extracted/b.py,3390,128,444,Python,4304486,0,5630113748090880,xjcl,2016
5798,a.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 my solution is O(n^2) in worst case -> should be ok for n = 1000
 """"""
 
 def run(data):
 
     # print(map(int, ['1', '2']))
 
     out = data[0]
 
     for c in data[1:]:
         if c + out > out:
             out = c + out
         else:
             out = out + c
 
     return out
 
 #---------------------------------------------
 
 def read_case():
     return input()
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/4304486/xjcl/5631989306621952/1/extracted/a.py,872,41,101,Python,4304486,1,5631989306621952,xjcl,2016
5799,a.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 
 """"""
 
 def run(data):
 
     # print(map(int, ['1', '2']))
 
     out = data[0]
 
     for c in data[1:]:
         # print(data)
         # if c < out[0]:
         #     out += c
         # if c > out[0]:
         #     out = c + out
         if c + out > out:
             out = c + out
         else:
             out = out + c
 
     return out
 
 #---------------------------------------------
 
 def read_case():
     return input()
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/4304486/xjcl/5631989306621952/0/extracted/a.py,936,46,108,Python,4304486,0,5631989306621952,xjcl,2016
56235,a.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 do we have to do simulation?
     we can test feasibility of that by pre-computing all 10**6 cases
 
 when does it cycle?
     is 0 only number that cycles?
     can we detect cycling?
 
 yup, simulation stays easily within the time limit and only 0 cycles
 
 reason: 0 will be last digit for 10*n (10*n ends in 0)
     1..9 will be leading digit for k-digit multiples
         where k is the smallest number such that  10**k >= n
     since  10**k + n <= 10**k + 10**k = 2 * 10**k
     eg: for numbers between 10 and 100 we are guaranteed 3-digit
         multiples of the form 1xx, 2xx, 3xx, .., 9xx
         simply because 10..100 are less then 100!
 
 """"""
 
 def run(n):
 
     if n == 0:
         return ""INSOMNIA""
 
     unseen = [str(x) for x in range(10)]
     cur = 0
     while unseen:
         cur += n
         for c in str(cur):
             if c in unseen:
                 unseen.remove(c)
 
     return cur
 
 #---------------------------------------------
 
 def read_case():
     return int(input())
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/6254486/xjcl/5652388522229760/1/extracted/a.py,1514,58,201,Python,6254486,1,5652388522229760,xjcl,2016
56237,d.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect, math
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 is it enough to compare only sequences with one G to the all-L's one?
     so only look at GLLL, LGLL, LLGL, LLLG
         omg a lattice!!  they only become 'more golden'
     we must then 'cover' (as in the set cover problem) these sequences
     such that in at least one of the indices we have G
 
 we definitely can't construct K^C
     small dataset is  S = K ... how does that simplify things?
     maybe all are possible? but what if C > K ?
 
 looks very 'tree-like'
     eg GLL: we find G by branching right (L), right (L), left (G)
         or right, middle, left  or left, *, *
     one could iterate over all indices and decide whether they are in
         the GLLL, LGLL, LLGL, LLLG
         but we would have 100^100 indices
 
 ----
 
 hmmm, having drawn sketches for n = 4 i see more clearly
     especially a simple solution for the small (S=K) case: 1..K :D
     (or any K ascending indeces.
     reason: length of original sequence, which gets copied or golded)
 
 equivalent problem:
     we have all C-digit numbers in base K  (including those with zeros)
     can you pick S of those such that all numbers are represented?
 
 eg for K=4 and C=2 and S=2 we can choose {01,32} which contains all numbers 0..3
     and our solution indeces are their base-10 equivalents:
         01_4 = 1, 32_4 = 14
     geez google is into converting between bases today :^)
 
 this leads us to the following ideal choice of indeces:
     demonstrated on K=16 and C=4
         0123, 4567, 89AB, CDEF
     you get the idea
 
 feasibility:
     input is feasible iff  S >= K / C
     follows directly from the ideal choice above
 
 """"""
 
 def run(data):
     K, C, S = data
 
     if S < K / C:
         return ""IMPOSSIBLE""
 
     ret = []
     for i in range(math.ceil(K/C)):
         # this actually goes 3210 7654...  and fills up with (K-1)'s if digits are left
         ret.append(1 + sum(min(i*C+j, K-1) * K**j for j in range(C)))
 
     return ' '.join([str(x) for x in ret])
 
 #---------------------------------------------
 
 def read_case():
     return [int(n) for n in input().split()]
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/6254486/xjcl/5636311922769920/1/extracted/d.py,2602,81,386,Python,6254486,1,5636311922769920,xjcl,2016
56238,d.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 is it enough to compare only sequences with one G to the all-L's one?
     so only look at GLLL, LGLL, LLGL, LLLG
         omg a lattice!!  they only become 'more golden'
     we must then 'cover' (as in the set cover problem) these sequences
     such that in at least one of the indices we have G
 
 we definitely can't construct K^C
     small dataset is  S = K ... how does that simplify things?
     maybe all are possible? but what if C > K ?
 
 looks very 'tree-like'
     eg GLL: we find G by branching right (L), right (L), left (G)
         or right, middle, left  or left, *, *
     one could iterate over all indices and decide whether they are in
         the GLLL, LGLL, LLGL, LLLG
         but we would have 100^100 indices
 
 ----
 
 hmmm, having drawn sketches for n = 4 i see more clearly
     especially a simple solution for the small (S=K) case: 1..K :D
 
 """"""
 
 def run(data):
     s, c, k = data
     return ' '.join([str(x) for x in range(1,k+1)])
 
 #---------------------------------------------
 
 def read_case():
     return [int(n) for n in input().split()]
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/6254486/xjcl/5636311922769920/0/extracted/d.py,1585,52,225,Python,6254486,0,5636311922769920,xjcl,2016
56239,c.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 call this script interactively
     python3 -i c.py > c.out
     >>> precompute(6,8)
     >>> main()
 """"""
 
 d = {}
 
 def precompute(n, j):
     coin = 2**(n-1) + 1
 
     while j != 0:
 
         coinstr = bin(coin)[2:]
         certs = [0] * 9
 
         for base in range(2, 11):
 
             n = int(coinstr, base)
 
             # for f in range(2, int(n**.5)+1):
             for f in range(2, min(100, int(n**.5)+1)):
                 if n % f == 0:
                     certs[base-2] = str(f)
                     break
             else:
                 break
 
         if all([x != 0 for x in certs]):
             print(coinstr, certs)
             d[coinstr] = certs
             j -= 1
 
         # guaranteed by problem to be a candidate => coin will never be a digit too long
         coin += 2
 
 def run():
     ret = '\n'
     for coinstr in d:
         ret += coinstr + ' ' + ' '.join(d[coinstr]) + '\n'
     return ret
 
 #---------------------------------------------
 
 def main():
     outstr = ""Case #1: ""+str(run())
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr, end='')
 
 
 
",gcj/2016/6254486/xjcl/5738606668808192/1/extracted/c.py,1458,63,176,Python,6254486,1,5738606668808192,xjcl,2016
56240,c.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 call this script interactively
     python3 -i c.py > c.out
     >>> precompute(6,8)
     >>> main()
 """"""
 
 d = {}
 
 def precompute(n, j):
     coin = 2**(n-1) + 1
 
     while j != 0:
 
         coinstr = bin(coin)[2:]
         certs = [0] * 9
 
         for base in range(2, 11):
 
             n = int(coinstr, base)
 
             for f in range(2, int(n**.5)+1):
                 if n % f == 0:
                     certs[base-2] = str(f)
                     break
             else:
                 break
 
         if all([x != 0 for x in certs]):
             print(coinstr, certs)
             d[coinstr] = certs
             j -= 1
 
         # guaranteed by problem to be a candidate => coin will never be a digit too long
         coin += 2
 
 def run():
     ret = '\n'
     for coinstr in d:
         ret += coinstr + ' ' + ' '.join(d[coinstr]) + '\n'
     return ret
 
 #---------------------------------------------
 
 def main():
     outstr = ""Case #1: ""+str(run())
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr, end='')
 
 
 
",gcj/2016/6254486/xjcl/5738606668808192/0/extracted/c.py,1400,62,169,Python,6254486,0,5738606668808192,xjcl,2016
56241,b.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+"":"", *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 
 #---------------------------------------------
 
 """"""
 intuitive optimal solution:
     'homogenize' pancakes from top to bottom by flipping equal-sided pancakes. eg
         --+-
         +++-
         ----
         ++++ (and one additional if we have all bottoms)
     so we just count number of changes and add one if final pancake is '-'
 
 """"""
 
 def run(data):
 
     prev = data[0]
     flips = 0
 
     for c in data:
         if prev == c:
             continue
         prev = c
         flips += 1
 
     return flips + (data[-1] == '-')
 
 #---------------------------------------------
 
 def read_case():
     return input()
 
 for i in range(int(input())):
     outstr = ""Case #""+str(i+1)+"": ""+str(run(read_case()))
     print(outstr, "" @ t ="", time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/6254486/xjcl/5634697451274240/1/extracted/b.py,1080,47,124,Python,6254486,1,5634697451274240,xjcl,2016
183476,a.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 
 Z -> ZERO
 W -> TWO
 U -> FOUR
 X -> SIX
 ----
 F -> FIVE (after rm 4)
 R -> THREE (after rm 0,4)
 O -> ONE (after rm 0,2,4)
 S -> SEVEN (after rm 6)
 T -> EIGHT (after rm 2,3)
 I -> NINE (after rm 5,6,8)
 
 ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 
 then just sort (since monotonically increasing)
 
 '''
 
 from collections import *
 
 def count_and_rm(d, c, k, indic, rmlist):
 
     how_many_ks = c[indic]
     d[k] = how_many_ks
 
     for r in rmlist:
         c[r] -= how_many_ks
 
 
 def run(data):
 
     counts = Counter(data)
     # print(counts)
 
     num = dict()
 
     count_and_rm(num, counts, 0, 'Z', 'ZERO')
     count_and_rm(num, counts, 2, 'W', 'TWO')
     count_and_rm(num, counts, 4, 'U', 'FOUR')
     count_and_rm(num, counts, 6, 'X', 'SIX')
     count_and_rm(num, counts, 5, 'F', 'FIVE')
     count_and_rm(num, counts, 3, 'R', 'THREE')
     count_and_rm(num, counts, 1, 'O', 'ONE')
     count_and_rm(num, counts, 7, 'S', 'SEVEN')
     count_and_rm(num, counts, 8, 'T', 'EIGHT')
     count_and_rm(num, counts, 9, 'I', 'NINE')
 
     ret = []
     for i in range(10):
         ret += [str(i)] * num[i]
 
     return ''.join(ret)
 
 #---------------------------------------------
 
 def read_case():
     return input()
     #return [[int(n) for n in input().split()] for i in range(4)]
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
 
 
",gcj/2016/11254486/xjcl/5648941810974720/1/extracted/a.py,1899,79,231,Python,11254486,1,5648941810974720,xjcl,2016
183478,c.py,"
 # usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from hopcroftkarp import HopcroftKarp
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 
 so we have tuples of numbers
     (a1, b1)
     (a2, b2)
     (a2, b1)
     with left and right numbers non-overlapping
     -> bipartite undirected graph
 
 'longest-path-algorithm?'
     crossing from RTL
 
 uses one unique word => is real!
     we can do an implication chain to find out rite!?
 
 what if we have all duplicates?
     real
         (1,2)
         (3,4)
     fake
         (1,4)
         (3,2)
     impossible to find fake
     ((1,4),(3,2) could be orig and others fake)
     => non-constructive task
 
 wait
     paths of len 3 or more imply at least one fake
     (but len 4 doesn't imply 2 fakes)
 
 omg
     maximum matching in bipartite graph!!
     we had this in discrete structures :D
 
 '''
 
 def run(data):
 
     graph = dict()
 
     # build graph for bipartite maximum-matching
     for a,b in data:
         a = 'A_' + a
         b = 'B_' + b
 
         if a not in graph:
             graph[a] = set([b])
         else:
             graph[a] |= set([b])
 
         # if b not in graph:
         #     graph[b] = set([a])
         # else:
         #     graph[b] |= set([a])
 
     # number of edges in left / right half of graph
     left = set()
     right = set()
     for a,b in data:
         left |= set([a])
         right |= set([b])
 
     x = HopcroftKarp(graph).maximum_matching()
     num_optimal = round(len(x) / 2)
     num_real_topics = num_optimal + (len(left) - num_optimal) + (len(right) - num_optimal)
 
     return len(data) - num_real_topics
 
 #---------------------------------------------
 
 def read_case():
     m = int(input())
     return [input().split() for i in range(m)]
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
 
 
 
",gcj/2016/11254486/xjcl/5686313294495744/1/extracted/c.py,2232,95,274,Python,11254486,1,5686313294495744,xjcl,2016
2395,c.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 obvs
     - all debuffs before buffs
     - all buffs before attacks
     - healing might be necessary during buffing phase
 
 so just do brute force of
     (D, B) tuples?
         ie search  [0,100] x [0,100]  space
     then simulate that with healings if necessary
         else attack
 
 '''
 
 def moves_plan(hd, ad, hk, ak, b, d, num_b, num_d):
 
     ihd = hd
 
     for i in range(200):
         if hk <= ad:
             # kill
             return i+1
 
         # heal
         elif hd - ak <= 0 and num_d == 0:
             hd = ihd
         elif hd - (ak-d) <= 0:
             hd = ihd
 
         # do normal
         elif num_d > 0:
             num_d -= 1
             ak -= d
         elif num_b > 0:
             num_b -= 1
             ad += b
 
         else:
             hk -= ad
 
         hd -= ak
 
     return float('inf')
 
 def run(data):
     hd, ad, hk, ak, b, d = data
     print(data)
 
     r = min(moves_plan(hd, ad, hk, ak, b, d, num_b, num_d)
         for num_b in range(0,80) for num_d in range(0,80-num_b))
 
     if r == float('inf'):
         return 'IMPOSSIBLE'
 
     return r
 
 #---------------------------------------------
 
 def read_case():
     return [int(k) for k in list(input().split())]
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5304486/xjcl/5719039502450688/0/extracted/c.py,1687,74,213,Python,5304486,0,5719039502450688,xjcl,2017
2396,b.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 n ingreds
 p packages per ingred
 r ratatouille  (recipe)
 q quantities
 
 connect two quantities if they could make rata together
     for n = 2 this is obvs just max-match
 
 obvs sort quantities
     somehow add dynamic programming
     ----
     hm we already know from the FIRST INGREDIENT QUANTITY
         how many servings it will be
     so we just need to hold 50 pointers which we gradually advance!
     tfw greedy solution is best solution
 
     print()
     print(q)
         print()
             print(j, q[j], bnd_low, bnd_hi, indexes)
                 print('add ingred')
                 print('overfill')
 
         print(bnd_low, bnd_hi, indexes)
 
 '''
 
 import math
 
 def run(data):
     n, p, r, q = data
     for qi in q:
         qi.sort()
 
     indexes = [0] * n
 
     ret = 0
     for i in range(p):
 
         servings = q[0][i] / r[0]
         bnd_low = math.ceil(servings/1.1)
         bnd_hi  = math.floor(servings/.9)
 
         if bnd_low > bnd_hi:
             continue
 
         # greedily add lowest-valued ingredient at each step, if possible
         # nb: important to update bounds (possible #servings) at each step!
         for j in range(1, n):
             ij = indexes[j]
             if ij >= p:  return ret
             while q[j][ij] < (.9*bnd_low*r[j]):
                 ij += 1
                 if ij >= p:  return ret
             indexes[j] = ij
             if q[j][ij] <= (1.1*bnd_hi*r[j]):
                 lservs = q[j][ij] / r[j]
                 bnd_low = max(bnd_low, math.ceil(lservs/1.1))
                 bnd_hi  = min(bnd_hi,  math.floor(lservs/.9))
                 indexes[j] = ij+1
             else:
                 break
         # else = nobreak
         else:
             ret += 1
 
     return ret
 
 #---------------------------------------------
 
 def read_case():
     n, p = [int(k) for k in list(input().split())]
     r = [int(k) for k in list(input().split())]
     return (n, p, r, [[int(k) for k in list(input().split())] for i in range(n)])
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5304486/xjcl/5697460110360576/1/extracted/b.py,2478,89,285,Python,5304486,1,5697460110360576,xjcl,2017
2397,b.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 n ingreds
 p packages per ingred
 r ratatouille  (recipe)
 q quantities
 
 connect two quantities if they could make rata together
     for n = 2 this is obvs just max-match
 
 obvs sort quantities
     somehow add dynamic programming
     ----
     hm we already know from the FIRST INGREDIENT QUANTITY
         how many servings it will be
     so we just need to hold 50 pointers which we gradually advance!
     tfw greedy solution is best solution
 '''
 
 import math
 
 def run(data):
     n, p, r, q = data
     for qi in q:
         qi.sort()
 
     indexes = [0] * n
     print()
     print(q)
 
     ret = 0
     for i in range(p):
 
         servings = q[0][i] / r[0]
         bnd_low = math.ceil(servings/1.1)
         bnd_hi = math.floor(servings/.9)
 
         # print(servings)
         # print(q[0][i], r[0])
         # print((9*r[0]*servings)//10, q[0][i], (9*r[0]*servings)//10)
 
         if bnd_low > bnd_hi:
             continue
 
         # print(i, r, indexes, bnd_low, bnd_hi)
 
         for j in range(1, n):
             # print(q[j], bnd_low, bnd_hi)
             ij = indexes[j]
             if ij >= p:  break
             while q[j][ij] < (.9*bnd_low*r[j]):
                 ij += 1
                 if ij >= p:  break
             indexes[j] = ij
             if ij >= p:  break
             # if q[j][ij] <= (11*r[j]*servings)//10:
             if q[j][ij] <= (1.1*bnd_hi*r[j]):
                 lservs = q[j][ij] / r[j]
                 # print(lservs)
                 bnd_low = max(bnd_low, math.ceil(lservs/1.1))
                 bnd_hi  = min(bnd_hi,  math.floor(lservs/.9))
                 # print('added ingred')
                 pass
             else:
                 # print('too full break')
                 break
         # else = nobreak
         else:
             ret += 1
 
     return ret
 
 #---------------------------------------------
 
 def read_case():
     n, p = [int(k) for k in list(input().split())]
     r = [int(k) for k in list(input().split())]
     return (n, p, r, [[int(k) for k in list(input().split())] for i in range(n)])
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5304486/xjcl/5697460110360576/0/extracted/b.py,2543,91,286,Python,5304486,0,5697460110360576,xjcl,2017
2398,a.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 
 '''
 
 def run(data):
     r, c, data = data
     print(data)
 
     # fill a single row naturally
 
     for i in range(r):
         if data[i] == '?' * c:
             continue
         default_char = [x for x in data[i] if x != '?'][0]
         for j in range(c):
             if data[i][j] != '?':
                 continue
             # find char to place at (i,j)
             prev_char = ([default_char] + [x for x in data[i][:j] if x != '?'])[-1]
             data[i] = data[i][:j] + prev_char + data[i][j+1:]
 
     # fill in empty rows by dupe-ing neighs
     for i in range(r):
         if data[i] == '?' * c:
             for j in range(i+1, r):
                 if data[j] != '?' * c:
                     data[i] = data[j]
                     break
             for j in range(i-1, -1, -1):
                 if data[j] != '?' * c:
                     data[i] = data[j]
                     break
 
     return '\n' + '\n'.join(data)
 
 #---------------------------------------------
 
 def read_case():
     r, c = [int(k) for k in list(input().split())]
     return (r, c, [input() for i in range(r)])
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5304486/xjcl/5760761888505856/1/extracted/a.py,1569,54,188,Python,5304486,1,5760761888505856,xjcl,2017
17507,a.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 how many get
     1 + num(Gi is mul of P) + num(multiple Gi make multiple of P)
 '''
 
 def run(data):
     p, data = data
     data = [d%p for d in data]
     print(data)
 
     if p == 2:
         # -1//2 = -1  but ok
         return 1 + data.count(0) + (data.count(1)-1)//2
 
     if p == 3:
         match0 = min(1 + data.count(0), len(data))
         n1 = data.count(1)
         n2 = data.count(2)
         min12 = min(n1, n2)
         match12 = max(min12 - (1 if n1 == n2 else 0), 0)
         n1 -= min12
         n2 -= min12
         match111 = max((n1-1)//3, 0)
         match222 = max((n2-1)//3, 0)
         print(match111, match12, match222)
         return match0 + match12 + match111 + match222
 
     if p == 4:
         match0 = min(1 + data.count(0), len(data))
         n1 = data.count(1)
         n2 = data.count(2)
         n3 = data.count(3)
         #
         min13 = min(n1, n3)
         match13 = max(min13 - (1 if n1 == n3 and n2 == 0 else 0), 0)
         n1 -= min13
         n3 -= min13
         match22 = max(n2//2 - (1 if n2%2 == 0 and n1 == n3 == 0 else 0), 0)
         n2 %= 2
         #
         min112 = min(n1//2, n2)
         min332 = min(n3//2, n2)
         # only one of [n1,n3] nonzero so ok
         match112 = max(min112 - (1 if 2*min112 == n1 and min112 == n2 else 0), 0)
         match332 = max(min332 - (1 if 2*min332 == n3 and min332 == n2 else 0), 0)
         n1 -= 2*match112
         n3 -= 2*match332
         n2 -= match112 + match332
         #
         match1111 = max((n1-1)//4, 0)  # only one of these nonzero so ok
         match3333 = max((n3-1)//4, 0)
         ret = [match0, match13, match22, match112, match332, match1111, match3333]
         print(ret)
         return sum(ret)
 
 
 import itertools, random
 
 def bf_sol(data):
     p, a = data
     print(data)
     maxi = 0
     for m in itertools.permutations(a):
         pp = [None] * (len(m)-1)
         tot = 0
         for i in range(len(m)-1):
             tot += m[i]
             tot %= p
             pp[i] = tot
         maxi = max(maxi, pp.count(0))
         # print(m, pp, pp.count(0))
     return 1+maxi
 
 def test():
     for l in range(1, 10):
         for _ in range(20):
             a = [random.randint(0, 3) for _ in range(l)]
             print(a)
             print(bf_sol([4, a]), run([4, a]))
             assert bf_sol([4, a]) == run([4, a])
 
 #---------------------------------------------
 
 def read_case():
     n, p = [int(k) for k in list(input().split())]
     return (p, [int(k) for k in list(input().split())])
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5314486/xjcl/5700919488413696/1/extracted/a.py,3004,100,400,Python,5314486,1,5700919488413696,xjcl,2017
17508,a.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 how many get
     1 + num(Gi is mul of P) + num(multiple Gi make multiple of P)
 '''
 
 def run(data):
     p, data = data
     data = [d%p for d in data]
     print(data)
     if p == 2:
         # -1//2 = -1  but ok
         return 1 + data.count(0) + (data.count(1)-1)//2
     if p == 3:
         match0 = min(1 + data.count(0), len(data))
         n1 = data.count(1)
         n2 = data.count(2)
         min12 = min(n1, n2)
         match12 = max(min12 - (1 if n1 == n2 else 0), 0)
         n1 -= min12
         n2 -= min12
         match11 = max((n1-1)//3, 0)
         match22 = max((n2-1)//3, 0)
         print(match11, match12, match22)
         return match0 + match12 + match11 + match22
 
 #---------------------------------------------
 
 def read_case():
     n, p = [int(k) for k in list(input().split())]
     return (p, [int(k) for k in list(input().split())])
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5314486/xjcl/5700919488413696/0/extracted/a.py,1323,44,166,Python,5314486,0,5700919488413696,xjcl,2017
17509,b.py,"# usage:  (python3 a.py < a.in) > a.out
 import time, sys, inspect
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 
 #---------------------------------------------
 
 '''
 
 '''
 
 from hopcroftkarp import HopcroftKarp
 
 def run(data):
 
     c1 = []
     c2 = []
     for t in data:
         if t[1] == 1:
             c1.append(t[0])
         else:
             c2.append(t[0])
 
     c1.sort()
     c2.sort()
     c1 += [float('inf')] * max(len(c2)-len(c1), 0)
     c2 += [float('inf')] * max(len(c1)-len(c2), 0)
     n = len(c1)
 
     # print(c1, c2)
     graph = dict()
     c1h = list()
     for i,c in enumerate(c1):
         graph[(1,i,c)] = {(2,j,d) for j,d in enumerate(c2) if c != d}
         c1h.append((1,i,c))
 
     mm = HopcroftKarp(graph).maximum_matching()
     # print(mm)
     # print(c1h)
     diff = [c[2] for c in c1h if c not in mm]
 
     cars = diff.count(1)
     prom = len(diff) - cars
 
     return str(n + cars) + ' ' + str(prom)
 
 
 
 
 
     # # grid = []
     # # for c in c1:
     # #     grid.append([(c,d) for d in c2])
     # cars = n
     # prom = 0
 
     # for it in range(n):
 
     #     print(grid)
 
     #     min_i = None
     #     min_i_val = float('inf')
     #     for i in range(n):
     #         lval = len([x for x in grid[i] if x[0] != x[1]])
     #         if lval < min_i_val:
     #             min_i_val = lval
     #             min_i = i
 
     #     min_j = None
     #     min_j_val = float('inf')
     #     for j in range(n):
     #         lval = len([grid[k][j] for k in range(n) if grid[k][j][0] != grid[k][j][1]])
     #         if lval < min_j_val:
     #             min_j_val = lval
     #             min_j = j
 
     #     print(min_i, min_j)
     #     if min_i < min_j:
     #         for j0 in range
     #         j0 = 0
 
 #---------------------------------------------
 
 def read_case():
     _, _, m = [int(k) for k in list(input().split())]
     return [[int(k) for k in list(input().split())] for i in range(m)]
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/5314486/xjcl/5687148430753792/0/extracted/b.py,2274,93,293,Python,5314486,0,5687148430753792,xjcl,2017
44986,b.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from itertools import combinations
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 
 '''
 
 def find_rightmost_violation(s):
     #
     for i in range(len(s) - 1):
         if s[-i-1] < s[-i-2]:
             return i
 
     return None
 
 
 def run(data):
     num = list(data)
 
     i = find_rightmost_violation(num)
 
     while i is not None:
         num[-i-2] = str((int(num[-i-2]) - 1) % 10)
         num[-i-1:] = (i+1) * '9'
         i = find_rightmost_violation(num)
 
     return int(''.join(num))
 
 #---------------------------------------------
 
 def read_case():
     return input()
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/3264486/xjcl/5633382285312000/1/extracted/b.py,1097,47,110,Python,3264486,1,5633382285312000,xjcl,2017
44988,d.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from itertools import combinations
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 basic algo
     treat diag and row/col problem independently
     solve both (greedily) and if there is overlap combine '+' and 'x' into 'o'
 
 placing 'x's
     obviously we can always place n 'x's
         (including the ones already there at the beginning)
 placing '+'s
     small case
         we can always place 2n-2 '+'s
             (including the ones already there at the beginning)
         one strategy is to fill up first row with '+'s
         and then fill the final row from index [1:-1]
             (ie all but the first and last one)
         so we for example know the final style points
             will always be 3n-2
             (except for n=1 where it will be 2)
         (the solution i submitted for that was needlessly complicated, lol)
     big case
         uh...
         i'm not sure but my guess would be to place it like in the small case
             but check for occupancy first
             this might be it for almost everyone who solved small submitted large
             i wouldn't have any formal proof for this tho
         note that 2n-2 isn't always possible. for example in
             ...
             .x.
             ...
         our best bet is to place two additional 'x's
             ...
             xxx
             ...
         the global optimum would however be
             xxx
             ...
             .x.
 
 assert for small case
     if n != 1:
         assert style(grid) + len(p_added) + len(x_added) == 3*n-2
     else:
         assert style(grid) + len(p_added) + len(x_added) == 2
 '''
 
 def style(grid):
     return sum(sum((2 if e == 'o' else 1 if e == 'x' or e == '+' else 0) for e in row) for row in grid)
 
 def run(data):
     m, n, grid = data
 
     x_added = []  # positions of 'x's added
     p_added = []  # positions of '+'s added
 
     # place 'x's
     free_ys = list(range(n))
     free_xs = list(range(n))
 
     for y in range(n):
         for x in range(n):
             if grid[y][x] in ['x', 'o']:
                 free_ys.remove(y)
                 free_xs.remove(x)
                 continue
 
     for y, x in zip(free_ys, free_xs):
         x_added.append((y, x))
 
     # place '+'s
     for i in range(n):
         if  grid[0][i] not in ['+', 'o'] \
         and all(grid[k+1][i-k-1] not in ['+', 'o'] for k in range(i)) \
         and all(grid[k+1][i+k+1] not in ['+', 'o'] for k in range(n-i-1)):
             p_added.append((0, i))
 
     if n != 1:
         for i in range(1, n-1):
             if  grid[n-1][i] not in ['+', 'o'] \
             and all(grid[n-k-2][i-k-1] not in ['+', 'o'] for k in range(i)) \
             and all(grid[n-k-2][i+k+1] not in ['+', 'o'] for k in range(n-i-1)):
                 p_added.append((n-1, i))
 
     # format output
     ret = ''
     for p in p_added:
         y, x = p
         if (y, x) in x_added:
             ret += 'o ' + str(y+1) + ' ' + str(x+1) + '\n'
         elif grid[y][x] == 'x':
             ret += 'o ' + str(y+1) + ' ' + str(x+1) + '\n'
         else:
             ret += '+ ' + str(y+1) + ' ' + str(x+1) + '\n'
 
     cnt = len(p_added)
     for ex in x_added:
         y, x = ex
         if (y, x) in p_added:
             pass  # already handled above!
         elif grid[y][x] == '+':
             ret += 'o ' + str(y+1) + ' ' + str(x+1) + '\n'
             cnt += 1
         else:
             ret += 'x ' + str(y+1) + ' ' + str(x+1) + '\n'
             cnt += 1
 
     ret = str(style(grid) + len(p_added) + len(x_added)) + ' ' + str(cnt) + '\n' + ret
 
     return ret[:-1]
 
 
 #---------------------------------------------
 
 def read_case():
     n, m = [int(k) for k in list(input().split())]
     grid = []
     for i in range(n):
         grid.append([''] * n)
     for i in range(m):
         m, y, x = list(input().split())
         y, x = int(y), int(x)
         grid[y-1][x-1] = m
     return (m, n, grid)
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/3264486/xjcl/5719854539603968/1/extracted/d.py,4473,140,617,Python,3264486,1,5719854539603968,xjcl,2017
44989,d.small.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from itertools import combinations
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 max one non-'+' per row and col
     ie  count('x') + count('o') <= 1  per row and col
     ie  count('+') + count('o') <= 1  per diag
 
 we have a max of
     2n-2 '+'s  (tho actual bound is tighter)
       n  'x's
       n  'o's
 
 simplify without 'o's mb?
     ie  count('x') <= 1  per row and col
     ie  count('+') <= 1  per diag
     try to do one '+' into every diag
     try to do one 'x' into every row/col
             8-queens-puzzle like
 
 an algorithm
     1. guess model 'o' position -> O(n^2)
     2. run greedy 'x'- and '+'-fill algo on that
         O(n^2) ?
     O(n^4) seems a bit slow, even for this small n
     plus, algo only for small i think
 
     not convinced that 'greedy' thing works at all
 
 i think i have found a different algo
     for a restricted version with 'x's and '+'s
     but the 'o's are causing problems..
     luckily only one 'o' can possibly be in the first row
 
 FINAL ALGO
     treat diag and row/col problem independently
     solve both (greedily) and if there is overlap combine '+' and 'x' into 'o'
 
 '''
 
 def style(grid):
     return sum(sum((2 if e == 'o' else 1 if e == 'x' or e == '+' else 0) for e in row) for row in grid)
 
 def run(data):
     m, n, grid = data
     # print(grid)
 
     x_added = []
     p_added = []
 
     j = int(any(grid[0][i] == 'x' or grid[0][i] == 'o' for i in range(n)))
 
     if n == 1:
         if grid[0][0] != 'x' and grid[0][0] != 'o':
             x_added.append((0, 0))
         if grid[0][0] != '+' and grid[0][0] != 'o':
             p_added.append((0, 0))
     else:
         for i in range(n):
             if grid[0][i] == '+' or grid[0][i] == 'o':
                 if i != 0 and i != n-1:
                     p_added.append((n-1, n-1-i))
             else:
                 p_added.append((i, 0))
                 if i != 0 and i != n-1:
                     p_added.append((n-1-i, n-1))
 
             if grid[0][i] != 'x' and grid[0][i] != 'o':
                 x_added.append((j, i))
                 j += 1
 
     ret = ''
     for p in p_added:
         y, x = p
         if (y, x) in x_added:
             ret += 'o ' + str(y+1) + ' ' + str(x+1) + '\n'
         elif grid[y][x] == 'x':
             ret += 'o ' + str(y+1) + ' ' + str(x+1) + '\n'
         else:
             ret += '+ ' + str(y+1) + ' ' + str(x+1) + '\n'
 
     cnt = len(p_added)
     for ex in x_added:
         y, x = ex
         if (y, x) in p_added:
             pass  # already handled above!
         elif grid[y][x] == '+':
             ret += 'o ' + str(y+1) + ' ' + str(x+1) + '\n'
             cnt += 1
         else:
             ret += 'x ' + str(y+1) + ' ' + str(x+1) + '\n'
             cnt += 1
 
     print(p_added, x_added)
     ret = str(style(grid) + len(p_added) + len(x_added)) + ' ' + str(cnt) + '\n' + ret
 
     return ret[:-1]
 
 
 #---------------------------------------------
 
 def read_case():
     n, m = [int(k) for k in list(input().split())]
     grid = []
     for i in range(n):
         grid.append([''] * n)
     for i in range(m):
         m, y, x = list(input().split())
         y, x = int(y), int(x)
         grid[y-1][x-1] = m
     return (m, n, grid)
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/3264486/xjcl/5719854539603968/0/extracted/d.small.py,3759,126,544,Python,3264486,0,5719854539603968,xjcl,2017
44990,a.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from itertools import combinations
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 
 '''
 
 flip = lambda s: ''.join('+' if c == '-' else '-' for c in s)
 
 def run(data):
     s, k = data
     cnt = 0
 
     for i in range(len(s) - k + 1):
         if s[0] == '-':
             s = flip(s[1:k]) + s[k:]
             cnt += 1
         else:
             s = s[1:]
 
     if not all(c == '+' for c in s):
         return ""IMPOSSIBLE""
 
     return cnt
 
 #---------------------------------------------
 
 def read_case():
     a = input().split()
     return (a[0], int(a[1]))
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/3264486/xjcl/5736519012712448/1/extracted/a.py,1074,45,128,Python,3264486,1,5736519012712448,xjcl,2017
44992,c.py,"# usage:  (py3 a.py < a.in) > a.out
 
 import time, sys, inspect
 from itertools import combinations
 
 lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
 print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
 map = lambda *a: list(__builtins__.map(*a))
 reversed = lambda *a: list(__builtins__.reversed(*a))
 
 #---------------------------------------------
 
 '''
 side condition means we always fill the biggest gap
     then break ties by leftmostedness
 '''
 
 import math
 
 def run(data):
     n, k = data
     ret = n
 
     for c in reversed(str(bin(k))[3:]):
         if c == '0':
             ret = math.ceil((ret-1)/2)
         else:
             ret = math.floor((ret-1)/2)
 
     return str(math.ceil((ret-1)/2)) + ' ' + str(math.floor((ret-1)/2))
 
 #---------------------------------------------
 
 def read_case():
     return [int(k) for k in list(input().split())]
 
 for i in range(int(input())):
     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
     print(outstr, ' @ t =', time.clock())
     __builtins__.print(outstr)
",gcj/2017/3264486/xjcl/5654742835396608/2/extracted/c.py,1098,41,114,Python,3264486,2,5654742835396608,xjcl,2017
32760,000000000004377b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

#---------------------------------------------


def run(ants):

    weight_limit = min(sum(ants), 1000*7)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = max(DP[i][max(0,j-a)] + (1 if j >= a else 0), DP[i][j])
        maxi = max(DP[i+1])
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(maxi, DP[i][j])

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,891,34,95,Python,7765,000000000004377b,000000000003e0a8,xjcl,2018
32761,0000000000043546.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = max(DP[i][max(0,j-a)] + (1 if j >= a else 0), DP[i][j])
        maxi = max(DP[i+1])
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(maxi, DP[i][j])

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,878,34,94,Python,7765,0000000000043546,000000000003e0a8,xjcl,2018
32762,00000000000434a0.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
        maxi = max(DP[i+1])
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = maxi
        for j in range(weight_limit+1):
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,939,36,100,Python,7765,00000000000434a0,000000000003e0a8,xjcl,2018
32763,000000000004339e.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(DP[i+1])
        for j in range(weight_limit+1):
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,919,35,97,Python,7765,000000000004339e,000000000003e0a8,xjcl,2018
32764,00000000000433bd.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(DP[i+1])
        for j in range(weight_limit+1):
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])

    # for row in DP:
    #     print(row)

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1173,42,125,Python,7765,00000000000433bd,000000000003e0a8,xjcl,2018
32765,0000000000043284.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(DP[i+1])
        for j in range(weight_limit+1):
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])

    for row in DP:
        print(row)

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1169,42,123,Python,7765,0000000000043284,000000000003e0a8,xjcl,2018
32766,0000000000043109.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(DP[i+1])
        for j in range(weight_limit+1):
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])

    for row in DP:
        print(row)

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

# for i in range(int(input())):
#     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
#     # print(outstr, ' @ t =', time.clock())
#     __builtins__.print(outstr)
",,1177,42,127,Python,7765,0000000000043109,000000000003e0a8,xjcl,2018
32767,000000000004292b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])
        for j in range(min(7*a+1, weight_limit+1), weight_limit+1):
            DP[i+1][j] = max(DP[i+1])

    for row in DP:
        print(row)

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1129,41,119,Python,7765,000000000004292b,000000000003e0a8,xjcl,2018
32768,00000000000429eb.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
            DP[i+1][j] = max(DP[i][j], DP[i+1][j])
        # for j in range(min(7*a+1, weight_limit+1)+1, weight_limit+1):
        #     DP[i+1][j] = DP[i+1][min(7*a+1, weight_limit+1)]

    for row in DP:
        print(row)

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1158,41,122,Python,7765,00000000000429eb,000000000003e0a8,xjcl,2018
32769,00000000000426a0.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)
        for j in range(min(7*a, weight_limit+1)+1, weight_limit+1):
            DP[i+1][j] = DP[i+1][min(7*a, weight_limit+1)]

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1060,37,111,Python,7765,00000000000426a0,000000000003e0a8,xjcl,2018
32770,00000000000425aa.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------


def run(ants):

    weight_limit = sum(ants)

    DP = []
    DP.append([0] * (weight_limit+1))
    for i,a in enumerate(ants):
        DP.append([0] * (weight_limit+1))

    for i,a in enumerate(ants):
        for j in range(min(7*a+1, weight_limit+1)):
            DP[i+1][j] = DP[i][max(0,j-a)] + (1 if j >= a else 0)

    return max(max(row) for row in DP)

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,933,35,101,Python,7765,00000000000425aa,000000000003e0a8,xjcl,2018
32772,0000000000040af1.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, itertools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def evaluate(ants):
    for i in range(len(ants)):
        if sum(ants[:i]) > 6 * ants[i]:
            return False
    return True

def run(ants):
    # cm = crude_max(ants)
    # print(cm, evaluate(ants))
    for r in range(len(ants), 0, -1):
        for comb in itertools.combinations(ants, r):
            if evaluate(comb):
                return r

#---------------------------------------------

def read_case():
    _ = input()
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,925,33,97,Python,7765,0000000000040af1,000000000003e0a8,xjcl,2018
32773,000000000003fc87.PYTHON3,"import functools, sys
from collections import defaultdict

print = functools.partial(print, flush=True)

#---------------------------------------------

'''
simple: always sell the lollipop we've seen requested the least
'''

def run(n):

    if n == -1:
        exit()

    global_prefs = defaultdict(int)  # could also be a list of len n

    for c in range(n):

        prefs = [int(k) for k in input().split()][1:]
        # print(global_prefs, file=sys.stderr, flush=True)

        min_p = None
        min_p_val = float('inf')
        for p in prefs:
            if global_prefs[p] < min_p_val:
                min_p_val = global_prefs[p]
                min_p = p

        if min_p_val < float('inf'):
            print(min_p)
            global_prefs[min_p] = float('inf')  # do not sell again
        else:
            print(-1)

        for p in prefs:
            global_prefs[p] += 1


#---------------------------------------------

for i in range(int(input())):
    run(int(input()))
",,998,45,106,Python,7765,000000000003fc87,000000000003e068,xjcl,2018
32774,000000000003e778.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

'''
goal: find an unused 'edge' (= transition between two adjacent letters)

UNSAT (unsatisfiable) cases represent a complete graph
eg {AA,AB,BA,BB}
    A - A
      x
    B - B

SAT {AA,AB,BA}
    A - A
      x
    B   B
    ..since the bottom edge is still unused

how to find an edge?
    brute-force lol

'''

def run(words):
    n = len(words)
    l = len(words[0])

    if l == 1:
        return '-'

    letters = []
    edges = set()

    for i in range(l):
        letters.append(set())
        for w in words:
            letters[i].add(w[i])

    for i in range(l-1):
        for w in words:
            edges.add((i, w[i], w[i+1]))

    # print(words, letters, edges)

    for i in range(l-1):
        for l1 in letters[i]:
            for l2 in letters[i+1]:
                if (i, l1, l2) not in edges:
                    return words[0][:i] + l1 + l2 + words[0][i+2:]

    return '-'


#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    return [input() for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,1488,69,184,Python,7765,000000000003e778,000000000003e064,xjcl,2018
32775,000000000003e468.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

'''
goal: find an unused 'edge' (= transition between two adjacent letters)

UNSAT (unsatisfiable) cases represent a complete graph
eg {AA,AB,BA,BB}
    A - A
      x
    B - B

SAT {AA,AB,BA}
    A - A
      x
    B   B
    ..since the bottom edge is still unused

how to find an edge?
    brute-force lol

'''

def run(words):
    n = len(words)
    l = len(words[0])

    if l == 1:
        return '-'

    letters = []
    edges = set()

    for i in range(l):
        letters.append(set())
        for w in words:
            letters[i].add(w[i])

    for i in range(l-1):
        for w in words:
            edges.add((i, w[i], w[i+1]))

    # print(words, letters, edges)

    for i in range(l-1):
        for l1 in letters[i]:
            for l2 in letters[i+1]:
                if (i, l1, l2) not in edges:
                    return words[0][:i] + l1 + l2 + words[0][i+2:]

    return '-'


#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    return [input() for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1543,70,190,Python,7765,000000000003e468,000000000003e064,xjcl,2018
56201,000000000003b78b.PYTHON3,"# https://github.com/dmishin/pylinprog

from fractions import Fraction
class NumberTypeclass:
    def zero(self): return 0
    def one(self): return 1
    def positive(self,x): return x > 0
    def iszero(self,x): return x == 0
    def nonnegative(self,x): return self.positive(x) or self.iszero(x)
    def coerce(self, x): return x
    def coerce_vec(self, x): return [self.coerce(xi) for xi in x]
    def coerce_mtx(self, x): return [self.coerce_vec(xi) for xi in x]


class RealFiniteTolerance(NumberTypeclass):
    def __init__(self, eps=1e-6):
        super(RealFiniteTolerance, self).__init__()
        self.eps = eps
        assert eps >= 0

    def zero(self): return 0.0
    def one(self): return 1.0
    def iszero(self,x): return abs(x) < self.eps
    def coerce(self, x): return float(x)

class RationalNumbers(NumberTypeclass):
    def __init__(self):
        super(RationalNumbers, self).__init__()
        self._one = Fraction(1)
        self._zero = Fraction(0)
    def one(self): return self._one
    def zero(self): return self._zero
    def nonnegative(self,x): return x >= 0
    def coerce(self, x): return Fraction(x)

def _subtract_scaled_row(row1, row2, k, numclass):
    """"""row1 -= k*row2""""""
    if numclass.iszero(k): return
    for i, row2_i in enumerate(row2):
        row1[i] -= k*row2_i

RESOLUTION_NO = ""no""
RESOLUTION_SOLVED = ""solved""
RESOLUTION_UNBOUNDED = ""unbounded""
RESOLUTION_INCOMPATIBLE = ""incompatible""


class SimplexSolver:
    def __init__(self, a, b, c, basis, numclass, clean_c_row=False ):
        assert len(a) == len(b) #number of rows of A must be the same as number of elements of b
        for aj in a:
            assert len(aj) == len(c) #each row of A must have the same len as c

        self.numclass = numclass
        self.a = a
        self.b = b
        self.c = c
        self.basis = basis
        self.n = len(c)
        self.m = len(b)
        self.resolution = RESOLUTION_NO
        if clean_c_row: self._diagonalize_c_row()
        self._validate_diagonzlized()

    def _diagonalize_c_row(self):
        #diagonalize it (it has nonzero values now)
        c = self.c
        for j, i in enumerate(self.basis):
            if not self.numclass.iszero(c[i]):
                _subtract_scaled_row( c, self.a[j], c[i], self.numclass)
                assert self.numclass.iszero( c[i] )
                c[i] = self.numclass.zero()


    def vertex(self):
        v = [self.numclass.zero()] * self.n
        for i ,val in zip(self.basis, self.b):
            v[i] = val
        return v
    def _validate_diagonzlized(self):
        for i in self.basis:
            assert self.numclass.iszero(self.c[i])

        for j, a_j in enumerate(self.a):
            for j1, i in enumerate(self.basis):
                if j1 == j:
                    assert self.numclass.iszero( a_j[i] - self.numclass.one() )
                else:
                    if not self.numclass.iszero( a_j[i] ): raise AssertionError(""A: column {i} row {j} must be 0"".format(**locals()))
        for bi in self.b:
            assert self.numclass.nonnegative(bi)

    def _find_leading_column(self):
        imin = min(range(self.n), key=lambda i: self.c[i])
        if self.numclass.nonnegative(self.c[imin]):
            return None
        else:
            return imin

    def step(self):
        #determine leading column
        #index of a minimal value
        i_lead = self._find_leading_column()

        if i_lead is None:
            self.resolution = RESOLUTION_SOLVED
            return False

        assert i_lead not in self.basis

        #now find the leading row
        best_ratio = None
        best_row = None

        for j, b_j in enumerate(self.b):
            a_ji = self.a[j][i_lead]

            #treat special case when A contains zeros
            if self.numclass.iszero(a_ji):
                continue

            #zeros in B are special. They mean coinciding vertices.
            #Treat such ratios as positive if A element is positive.
            if self.numclass.iszero(b_j):
                #print(""b_j is zero:"", b_j)
                if not self.numclass.positive(a_ji):
                    continue
            ratio = b_j / a_ji
            if not self.numclass.nonnegative(ratio): continue

            if best_ratio is None or ratio < best_ratio:
                best_ratio = ratio
                best_row = j
        if best_row is None:
            self.resolution = RESOLUTION_UNBOUNDED
            return False
        #print(""### col:"",i_lead, ""row:"", best_row, ""ratio"", best_ratio)
        #best row and column defined
        self._diagonalize_by_row_col( best_row, i_lead )
        #Update basis
        self.basis[best_row] = i_lead
        self._validate_diagonzlized()
        return True

    def _diagonalize_by_row_col( self, j, i ):
        """"""Diagonalize problem relatively to given row and column
        j - row
        j - col
        """"""
        a_ji = self.a[j][i]
        assert not self.numclass.iszero(a_ji)


        #normalie j'th row
        self.b[j] /= a_ji
        aj = self.a[j]
        for i1 in range(self.n):
            if i1 != i:
                aj[i1] /= a_ji
            else:
                aj[i1] = self.numclass.one()


        #clear other rows
        _subtract_scaled_row( self.c, aj, self.c[i], self.numclass)
        self.c[i] = self.numclass.zero()

        for j1, a_j1 in enumerate(self.a):
            if j1 == j: continue
            k = a_j1[i]
            _subtract_scaled_row( a_j1, aj, k, self.numclass)
            assert self.numclass.iszero(a_j1[i])
            a_j1[i] = self.numclass.zero() #enforce zero
            self.b[j1] -= self.b[j] * k


    def _show_row(self, first, row):
        print( str(first) + '\t|' + ""\t"".join(map(str, row)))

    def show(self):
        print( ""Resolution:"", self.resolution)
        print( ""Basis:"", "", "".join('x{}'.format(i) for i in self.basis))
        self._show_row('', ('x{}'.format(i) for i in range(self.n)))
        self._show_row(' C', self.c)
        for j in range(self.m):
            self._show_row(self.b[j], self.a[j])

def simplex_canonical( a, b, c, basis, num, verbose=False, do_coerce = True):
    """"""Simplex method in canonical form, when initial basis is fully known""""""
    if do_coerce:
        a = num.coerce_mtx(a)
        b = num.coerce_vec(b)
        c = num.coerce_vec(c)

    solver = SimplexSolver(a, b, c, basis, numclass=num, clean_c_row = True)
    if verbose:
        print(""############ Regular simplex:#############"")
        solver.show()
    while solver.resolution == RESOLUTION_NO:
        solver.step()
        if verbose:
            print(""############ Regular step:#############"")
            solver.show()

    return solver.resolution, solver.vertex()

def simplex_canonical_m( a, b, c, basis, num, verbose=False, do_coerce = True):
    """"""Simplex method in canonical form, when initial basis is not fully known.
    Some or all elements of 'basis' can be None
    """"""
    #apply artificial basis method.
    if do_coerce:
        a = num.coerce_mtx(a)
        b = num.coerce_vec(b)
        c = num.coerce_vec(c)
    n_artificial = sum( int(bi is None) for bi in basis )
    n = len(c)
    if n_artificial == 0:
        return simplex_canonical(a,b,c,basis, num, verbose=verbose, do_coerce=False)

    #Expand the problem with artificial variables
    zeros = [num.zero()]*n_artificial
    a = [ a_j+zeros for a_j in a ]

    i_next = n #next artificial variable
    m_basis = basis[:]
    for j, bi in enumerate(basis):
        if bi is None:
            a[j][i_next] = num.one()
            m_basis[j] = i_next
            i_next += 1
    assert i_next == n + n_artificial

    #modified C vector for M-problem.
    cm = [num.zero()]*n+[num.one()]*n_artificial

    #Now solve M-problem step by step, until all artificial variables not in the basis
    m_solver = SimplexSolver(a, b, cm, m_basis, num, clean_c_row=True)
    real_vertex_reached = False
    if verbose:
        print(""########### M-problem: #############"")
        m_solver.show()
    while m_solver.resolution == RESOLUTION_NO:
        m_solver.step()
        if verbose:
            print(""########### M-step: #############"")
            m_solver.show()

        if all( bi < n for bi in m_solver.basis):
            #m-problem solved!
            if verbose:
                print(""### Real vertex reached"")
            real_vertex_reached = True
            break

    if not real_vertex_reached:
        #M-problem solved, but no real vertex.
        if verbose:
            print(""### Empty simplex"")
        return RESOLUTION_INCOMPATIBLE, None

    #truncate m-problem back
    a = [a_row[:n] for a_row in m_solver.a]

    return simplex_canonical(a, m_solver.b, c, m_solver.basis, num = num, verbose=verbose, do_coerce=False)

def linsolve( objective,
              ineq_left=(), ineq_right=(),
              eq_left=(), eq_right=(),
              nonneg_variables = (),
              num=RealFiniteTolerance(),
              verbose=False, do_coerce=True):
    """""" Solve arbitrary linear programming problem:
    Minimize linear function Cx -> min under set of conditions:
         Ax <= B
         A'x == B'
    Arguments:
      ineq_left : MxN matrix A
      ineq_right: M-vector B
      eq_left: M'xN matrix A'
      eq_right: M'-vector B'
      nonneg_variables: list of variables (their 0-based indices) that are >= 0
      num: instance of NumberTypeclass, defining numeric implementation to be used. Default is RealFiniteTolerance().
      do_coerce: if True, all provided values are converted by the 'coerce' method of the typeclass before solving the problem. Added for testing convenience.
      verbose: if True, then solver prints solution steps to the console. Added for debug.
    Returns tuple: (resulution, x).
    Where resolution is one of RESOLUTION_SOLVED, RESOLUTION_INCOMPATIBLE, RESOLUTION_UNBOUNDED
    If resolution is RESOLUTION_SOLVED, then x contains solution vector (list). Othervise, value of x is not defined.
    """"""
    nonneg_variables = set(nonneg_variables)
    n = len(objective)
    assert all( len(aj) == n for aj in ineq_left )
    assert all( len(aj) == n for aj in eq_left )

    #we will add several artificial variables: negative parts of variables, inequality-to-equality artificial variables
    #This stores index of the next fgree variable to add
    next_variable = n

    #first, create variables to map nonpositive variables
    #  x -> x1 - x2
    #  after substitution, x1 gets the same index as X, x2 gets new index

    #map variable index -> variable index, maps x1 to x2.
    negative_part2positive_part = {}

    for var in range(n):
        if var not in nonneg_variables:
            var_neg = next_variable
            next_variable += 1
            negative_part2positive_part[var_neg] = var

    n_nonneg = next_variable
    if verbose:
        print (""Created"", n_nonneg-n, ""new varables to get rid of variables with unknown sign"")

    def positivise_row( row ):
        #map row of A pr C matrix to positive variables
        return [ row[i] if i not in negative_part2positive_part else -row[negative_part2positive_part[i]]
                 for i in range(n_nonneg) ]

    #Get rid of nonpositive variablesby substitution
    c_nonneg = positivise_row(objective)
    ineq_left_nonneg = list(map(positivise_row, ineq_left))
    eq_left_nonneg = list(map(positivise_row, eq_left))

    def negate_row( row ): return [-ri for ri in row]

    #Number of artificial Z variables is the same as number of inequalities
    num_inequalities = len(ineq_left)
    assert len(ineq_right) == num_inequalities

    a_extended = []
    b_extended = []
    basis = []

    #Get rid of inequalities
    for a_row, bi in zip(ineq_left_nonneg, ineq_right):
        # Inequality (Ai, x) <= bi
        a_row_extended = a_row + [num.zero()]*num_inequalities
        artificial_var = next_variable
        next_variable += 1
        a_row_extended[artificial_var] = num.one()
        #changed Ax <= b
        # to Ax + z <= b

        #Now ensure that b >= 0
        if not num.nonnegative( bi ):
            bi = -bi
            a_row_extended = negate_row(a_row_extended)
            #Since this row was negated, this artificial variable can't be added to the basis.
            basis.append(None)
        else:
            #if the variable is not negated, then it can be added to the basis.
            basis.append(artificial_var)
        a_extended.append( a_row_extended )
        b_extended.append( bi )

    #And copy equalities, as-is, extending with zeros.
    for a_row, bi in zip(eq_left_nonneg, eq_right):
        if not num.nonnegative( bi ):
            bi = -bi
            a_row = negate_row(a_row)
        a_extended.append( a_row + [num.zero()]*num_inequalities )
        b_extended.append( bi )
        basis.append(None)

    #Phew! DOne!
    #Now a_extended, b_extended, c_nonneg describe the problem.
    #basis stores indices of varaibles that are already diagonalized.
    #Solve it!

    resolution, solution = simplex_canonical_m(a_extended,
                                               b_extended,
                                               c_nonneg+[num.zero()]*num_inequalities,
                                               basis,
                                               num=num,
                                               verbose=verbose,
                                               do_coerce = do_coerce)

    if resolution == RESOLUTION_SOLVED:
        #Remove artificial variables
        orig_solution = solution[:n]

        #then fold back positive-negative pairs
        for negative_var, positive_var in negative_part2positive_part.items():
            orig_solution[positive_var] -= solution[negative_var]

        return resolution, orig_solution
    else:
        return resolution, solution












# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

# ahhhh this is tricky for n = 8 because
#  mults == [0, 12, 25, 38, 50, 62, 75, 88, 100]  results in
#  diffs == [12, 13, 13, 12, 12, 13, 13, 12]  ! meaning two 13s in sequence
# possible with linprog (x = the O(n^2) possible upgrades?)

def run(data):
    n, _, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)
    diffs0 = [f-e-lo for e,f in zip(mults, mults[1:])]

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]

    print()
    print(mults)
    print(diffs)
    print(diffs0)
    print(c)
    print(optimal_is)
    print()

    # ret = 0
    n_free = n - sum(k*v for k,v in c.items())

    # for maxs in range(0, n+2):
    #     for i in optimal_is:
    #         for s in range(0, maxs):

    #             if i-s < 0 or n_free == 0:
    #                 break

    #             ppl_needed_each = s
    #             num_promotions = c[i-s]
    #             if ppl_needed_each != 0:
    #                 num_promotions = min(c[i-s], n_free // ppl_needed_each)
    #             ppl_needed_total = ppl_needed_each * num_promotions

    #             n_free -= ppl_needed_total
    #             c[i-s] -= num_promotions
    #             c[i] += num_promotions

    #             print(i, s, i-s, n_free, ret)

    # print('RET', ret, n_free, mults[n_free], c)
    # return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]


    cc = []

    for i in range(n+1):
        for j in range(i):
            m2 = mults[i] - mults[j]   # j < i
            cc.append(-m2)


    a = []

    for i in range(n+1):
        for j in range(i):
            m2 = i - j   # j < i
            a.append(m2)

    a = [a]

    b = [n_free]

    print(cc, a, b)
    resolution, sol = linsolve(cc, ineq_left = a, ineq_right = b, nonneg_variables = list(range(len(cc))))
    print(resolution, sol)

    ret = 0
    for k,s in enumerate(sol):
        ret += s * -cc[k]
        # if s > 0:
        # print(s, cc[k])


    return round(ret + sum(mults[k]*v for k,v in c.items()))



#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(int(k) for k in list(input().split()))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,16789,514,1839,Python,7764,000000000003b78b,0000000000036601,xjcl,2018
56202,00000000000394d0.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

# ahhhh this is tricky for n = 8 because
#  mults == [0, 12, 25, 38, 50, 62, 75, 88, 100]  results in
#  diffs == [12, 13, 13, 12, 12, 13, 13, 12]  ! meaning two 13s in sequence

def run(data):
    n, _, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]

    print()
    print(mults)
    print(diffs)
    print(c)
    print(optimal_is)
    print()

    n_free = n - sum(k*v for k,v in c.items())

    for maxs in range(0, n+2):
        for s in range(0, maxs):
            for i in optimal_is:

                if i-s < 0 or n_free == 0:
                    continue

                ppl_needed_each = s
                num_promotions = c[i-s]
                if ppl_needed_each != 0:
                    num_promotions = min(c[i-s], n_free // ppl_needed_each)
                ppl_needed_total = ppl_needed_each * num_promotions

                n_free -= ppl_needed_total
                c[i-s] -= num_promotions
                c[i] += num_promotions

                print(i, s, i-s, n_free)

    print('RET', n_free, mults[n_free], c)
    return sum(mults[k]*v for k,v in c.items()) + mults[n_free]

#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(int(k) for k in list(input().split()))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2051,73,251,Python,7764,00000000000394d0,0000000000036601,xjcl,2018
56203,0000000000039596.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

# ahhhh this is tricky for n = 8 because
#  mults == [0, 12, 25, 38, 50, 62, 75, 88, 100]  results in
#  diffs == [12, 13, 13, 12, 12, 13, 13, 12]  ! meaning two 13s in sequence

def run(data):
    n, _, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]

    print()
    print(mults)
    print(diffs)
    print(c)
    print(optimal_is)
    print()

    n_free = n - sum(k*v for k,v in c.items())

    for maxs in range(0, n+2):
        for s in range(0, maxs):
            for i in optimal_is:

                if i-s < 0 or n_free == 0:
                    break

                ppl_needed_each = s
                num_promotions = c[i-s]
                if ppl_needed_each != 0:
                    num_promotions = min(c[i-s], n_free // ppl_needed_each)
                ppl_needed_total = ppl_needed_each * num_promotions

                n_free -= ppl_needed_total
                c[i-s] -= num_promotions
                c[i] += num_promotions

                print(i, s, i-s, n_free)

    print('RET', n_free, mults[n_free], c)
    return sum(mults[k]*v for k,v in c.items()) + mults[n_free]

#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(int(k) for k in list(input().split()))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2048,73,251,Python,7764,0000000000039596,0000000000036601,xjcl,2018
56204,000000000003952f.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

# ahhhh this is tricky for n = 8 because
#  mults == [0, 12, 25, 38, 50, 62, 75, 88, 100]  results in
#  diffs == [12, 13, 13, 12, 12, 13, 13, 12]  ! meaning two 13s in sequence

def run(data):
    n, _, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]

    print()
    print(mults)
    print(diffs)
    print(c)
    print(optimal_is)
    print()

    ret = 0
    n_free = n - sum(k*v for k,v in c.items())

    for maxs in range(0, n+2):
        for i in optimal_is:
            for s in range(0, maxs):

                if i-s < 0 or n_free == 0:
                    break

                ppl_needed_each = s
                num_promotions = c[i-s]
                if ppl_needed_each != 0:
                    num_promotions = min(c[i-s], n_free // ppl_needed_each)
                ppl_needed_total = ppl_needed_each * num_promotions

                n_free -= ppl_needed_total
                c[i-s] -= num_promotions
                c[i] += num_promotions
                # ret += num_promotions * mults[i]

                print(i, s, i-s, n_free, ret)

    print('RET', ret, n_free, mults[n_free], c)
    return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]

#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(int(k) for k in list(input().split()))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2127,75,264,Python,7764,000000000003952f,0000000000036601,xjcl,2018
56205,0000000000037d3b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

'''

'''

def run(data):
    n, _, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    # diffs = [f-e for e,f in zip(mults, mults[1:])]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]
    assert len(optimal_is)

    print()
    print(mults)
    print(diffs)
    print(c)
    print(optimal_is)
    print()

    ret = 0
    n_free = n - sum(k*v for k,v in c.items())

    # for i in optimal_is:
    #     /

    # for s in range(1, n+1):
    for s in range(0, n+1):
        for i in optimal_is:

            if i-s < 0 or n_free == 0:
                print('STUFF LEFT', ret, n_free, mults[n_free], c)
                return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]

            ppl_needed_each = s
            num_promotions = c[i-s]
            if ppl_needed_each != 0:
                num_promotions = min(c[i-s], n_free // ppl_needed_each)
            ppl_needed_total = ppl_needed_each * num_promotions

            n_free -= ppl_needed_total
            c[i-s] -= num_promotions
            ret += num_promotions * mults[i]

            print(i, s, i-s, n_free, ret)

    # return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]
    assert False


#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(sorted(int(k) for k in list(input().split())))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2090,81,253,Python,7764,0000000000037d3b,0000000000036601,xjcl,2018
56206,0000000000037c40.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

'''

'''

def run(data):
    n, _, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    # diffs = [f-e for e,f in zip(mults, mults[1:])]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]

    print()
    print(mults)
    print(diffs)
    print(c)
    print(optimal_is)
    print()

    ret = 0
    n_free = n - sum(k*v for k,v in c.items())

    # for i in optimal_is:
    #     /

    # for s in range(1, n+1):
    for s in range(0, n+1):
        for i in optimal_is:

            if i-s < 0 or n_free == 0:
                print('STUFF LEFT', ret, n_free, mults[n_free], c)
                return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]

            ppl_needed_each = s
            num_promotions = c[i-s]
            if ppl_needed_each != 0:
                num_promotions = min(c[i-s], n_free // ppl_needed_each)
            ppl_needed_total = ppl_needed_each * num_promotions

            n_free -= ppl_needed_total
            c[i-s] -= num_promotions
            ret += num_promotions * mults[i]

            print(i, s, i-s, n_free, ret)

    print('DANK')
    return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]


#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(sorted(int(k) for k in list(input().split())))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2062,80,249,Python,7764,0000000000037c40,0000000000036601,xjcl,2018
56207,00000000000375c5.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools
from collections import Counter

#---------------------------------------------

def run(data):
    n, l, c = data
    c[0] = n

    mults = [round(i*100/n) for i in range(n+1)]
    diffs = [f-e for e,f in zip(mults, mults[1:])]
    lo = min(diffs)
    hi = max(diffs)

    if lo == hi:
        return 100

    assert lo+1 == hi

    optimal_is = [i+1 for i,x in enumerate(diffs) if x == hi]

    ret = 0
    n_free = n - sum(k*v for k,v in c.items())

    for s in range(0, n+1):
        for i in optimal_is:

            if n_free == 0:
                return ret + sum(mults[k]*v for k,v in c.items())
            if n_free < 0:
                assert False

            if i-s < 0:
                return ret + sum(mults[k]*v for k,v in c.items()) + mults[n_free]

            ppl_needed_each = s
            num_promotions = c[i-s]
            if ppl_needed_each != 0:
                num_promotions = min(c[i-s], n_free // ppl_needed_each)
            ppl_needed_total = ppl_needed_each * num_promotions

            n_free -= ppl_needed_total
            c[i-s] -= num_promotions
            ret += num_promotions * mults[i]

    return ret


#---------------------------------------------

def read_case():
    n, l = [int(k) for k in list(input().split())]
    c = Counter(sorted(int(k) for k in list(input().split())))
    return (n, l, c)

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    __builtins__.print(outstr)
",,1547,60,189,Python,7764,00000000000375c5,0000000000036601,xjcl,2018
89520,00000000000278fd.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
# print = functools.partial(print, flush=True)

#---------------------------------------------

'''
trouble sort is implicitly sorting 2 lists with bubble sort
    the even indices and the odd indices
'''

# fuck how awesome is python
def optimized_trouble_sort(a):
    a[::2] = sorted(a[::2])
    a[1::2] = sorted(a[1::2])

def run(data):
    optimized_trouble_sort(data)
    for i in range(len(data)-1):
        if data[i] > data[i+1]:
            return i
    return 'OK'

#---------------------------------------------

def read_case():
    n = int(input())
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,998,37,108,Python,00000000000000cb,00000000000278fd,00000000000079cb,xjcl,2018
89521,000000000000b752.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
# print = functools.partial(print, flush=True)

#---------------------------------------------

'''
extremely lazy binary search solution because i can

visible set: optimal to create a rectangle as shown in the example
hidden set: optimal to then also 'tilt forward' cube so that it
    - resembles a hexagon
    - both vertices not involved in the hexagon line up with the origin (x=0 z=0)
        - which doesn't happen at pi/4! but .61548

except i forgot the judge system doesnt have numpy... RIP me lmfao
    the easy solution became the much-harder solution
'''

import math
from itertools import starmap
from operator import mul

# https://stackoverflow.com/q/6802577/2111778
def M(axis, theta):
    a = math.cos(theta/2.0)
    b, c, d = -axis[0]*math.sin(theta/2.0), -axis[1]*math.sin(theta/2.0), -axis[2]*math.sin(theta/2.0)
    aa, bb, cc, dd = a*a, b*b, c*c, d*d
    bc, ad, ac, ab, bd, cd = b*c, a*d, a*c, a*b, b*d, c*d
    return [[aa+bb-cc-dd, 2*(bc+ad), 2*(bd-ac)],
            [2*(bc-ad), aa+cc-bb-dd, 2*(cd+ab)],
            [2*(bd+ac), 2*(cd-ab), aa+dd-bb-cc]]

# https://stackoverflow.com/q/28253102/2111778
dot = lambda mat, vec: [sum(starmap(mul, zip(vec, col))) for col in zip(*mat)]
vector_avg_of_4 = lambda e,f,g,h: [(a+b+c+d)/4 for a,b,c,d in zip(e,f,g,h)]


def simulate(roll1, roll2):

    v = [[x,y,z] for x in [-.5,.5] for y in [-.5,.5] for z in [-.5,.5]]

    M1 = M([0,0,-1], roll1)
    M2 = M([-1,0,0], roll2)

    v = [dot(M2, dot(M1, vi)) for vi in v]

    w = [(vi[0], vi[2]) for vi in v]
    area = 2*w[5][0]* (w[5][1] + w[7][1])

    return area, v


def binary_search(target, lo, hi):

    while lo < hi:
        mid = (lo+hi)/2
        midval, v = simulate(mid if target <= 2**.5 else math.pi/4, 0 if target <= 2**.5 else mid)
        # print(lo, hi, mid, midval, target)
        if midval+1e-13 < target:
            lo = mid
        elif midval-1e-13 > target:
            hi = mid
        else:
            # print(mid, midval, mid if target <= 2**.5 else np.pi/4, 0 if target <= 2**.5 else mid)
            a = vector_avg_of_4(v[0], v[1], v[2], v[3])
            c = vector_avg_of_4(v[0], v[1], v[4], v[5])
            b = vector_avg_of_4(v[0], v[2], v[4], v[6])
            return '\n'.join(' '.join(str(e) for e in f) for f in (a,b,c))
            # return 'bla'

    assert False


def run(data):
    return binary_search(data, 0, math.pi/4 if data <= 2**.5 else .61548)

#---------------------------------------------

def read_case():
    return float(input())

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+':\n'+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2902,90,376,Python,00000000000000cb,000000000000b752,00000000000079cc,xjcl,2018
89522,000000000000b2f2.PYTHON3,"#!/usr/bin/env python3

import time, sys, inspect, functools, math

print = functools.partial(print, flush=True)

#---------------------------------------------

'''
'''

def run(a):

    targets = [(2+d, 2) for d in range(math.ceil((a-6)/3))]
    maxi = max(targets)
    s = set((2+d+dx, 2+dy) for dx in (-1,0,1) for dy in (-1,0,1) for d in range(math.ceil((a-6)/3)))

    while s:
        m = min(s)
        print(min(m[0]+1, maxi[0]), 2)
        x, y = map(int, input().split())
        if x == y == 0:
            return
        s.discard((x,y))

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    run(read_case())
",,692,33,75,Python,00000000000000cb,000000000000b2f2,0000000000007a30,xjcl,2018
89523,000000000000b15b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
# print = functools.partial(print, flush=True)

#---------------------------------------------

'''
extremely lazy binary search solution because i can

visible set: optimal to create a rectangle as shown in the example
hidden set: optimal to then also 'tilt forward' cube so that it
    - resembles a hexagon
    - both vertices not involved in the hexagon line up with the origin (x=0 z=0)
        - which doesn't happen at pi/4! but .61548

'''

import numpy as np
from numpy import cross, eye, dot
from scipy.linalg import expm3, norm

# https://stackoverflow.com/a/25709323/2111778
def M(axis, theta):
    return expm3(cross(eye(3), axis/norm(axis)*theta))


def simulate(roll1, roll2):

    v = [np.array([x,y,z]) for x in [-.5,.5] for y in [-.5,.5] for z in [-.5,.5]]

    M1 = M([0,0,1], roll1)
    M2 = M([1,0,0], roll2)

    v = [dot(M2, dot(M1, vi)) for vi in v]

    w = [np.array([vi[0], vi[2]]) for vi in v]
    area = 2*w[5][0]* (w[5][1] + w[7][1])

    return area, v


def binary_search(target, lo, hi):

    while lo < hi:
        mid = (lo+hi)/2
        midval, v = simulate(mid if target <= 2**.5 else np.pi/4, 0 if target <= 2**.5 else mid)
        if midval+1e-13 < target:
            lo = mid
        elif midval-1e-13 > target:
            hi = mid
        else:
            # print(mid, midval, mid if target <= 2**.5 else np.pi/4, 0 if target <= 2**.5 else mid)
            a = (v[0] + v[1] + v[2] + v[3])/4
            c = (v[0] + v[1] + v[4] + v[5])/4
            b = (v[0] + v[2] + v[4] + v[6])/4
            return '\n'.join(' '.join(str(e) for e in f) for f in (a,b,c))

    assert False


def run(data):
    return binary_search(data, 0, np.pi/4 if data <= 2**.5 else .61548)

#---------------------------------------------

def read_case():
    return float(input())

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+':\n'+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2193,76,300,Python,00000000000000cb,000000000000b15b,00000000000079cc,xjcl,2018
89524,0000000000008b15.PYTHON3,"#!/usr/bin/env python3

import time, sys, inspect, functools, math

print = functools.partial(print, flush=True)

#---------------------------------------------

'''
this one is only for a=20
'''

def run(a):

    targets = [(2,2+3*d) for d in range(math.ceil(a/9))]

    for x0,y0 in [(2,2), (2,5), (2,8)]:
        s = set((x0+dx, y0+dy) for dx in (-1,0,1) for dy in (-1,0,1))
        i = 0
        while s:
            print(x0,y0)
            x, y = map(int, input().split())
            if x == y == 0:
                return
            s.discard((x,y))
            i += 1
            print(i, s, file=sys.stderr)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    print(i, file=sys.stderr)
    run(read_case())
",,791,37,85,Python,00000000000000cb,0000000000008b15,0000000000007a30,xjcl,2018
89525,000000000000897c.PYTHON3,"#!/usr/bin/env python3

# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

# lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
print = functools.partial(print, flush=True)

#---------------------------------------------

'''
this one is only for a=20
'''

def run(a):
    for x0,y0 in [(2,2), (5,5), (8,8)]:
        s = set((x0+dx, y0+dy) for dx in (-1,0,1) for dy in (-1,0,1))
        i = 0
        while s:
            print(x0,y0)
            x, y = map(int, input().split())
            if x == y == 0:
                return
            s.discard((x,y))
            i += 1
            print(i, s, file=sys.stderr)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    print(i, file=sys.stderr)
    run(read_case())

# print(input(), file=sys.stderr)
# run(read_case())
# print('0 done', file=sys.stderr)
# print(int(input()))
# print(int(input()))
# print(int(input()))
# print(int(input()))
# print(int(input()))
# print(int(input()))

# run(read_case())

# why isnt it continuing after the first test case? isn't the judge sending output?

",,1248,52,138,Python,00000000000000cb,000000000000897c,0000000000007a30,xjcl,2018
89526,0000000000007dee.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
# print = functools.partial(print, flush=True)

#---------------------------------------------

'''

'''

# copying? me? never.

def trouble_sort(a):
    done = False
    while not done:
        done = True
        for i in range(len(a)-2):
            if a[i] > a[i+2]:
                done = False
                a[i], a[i+2] = a[i+2], a[i]

def run(data):
    trouble_sort(data)
    for i in range(len(data)-1):
        if data[i] > data[i+1]:
            return i
    return 'OK'

#---------------------------------------------

def read_case():
    n = int(input())
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1008,42,108,Python,00000000000000cb,0000000000007dee,00000000000079cb,xjcl,2018
89527,0000000000007d6f.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)
# print = functools.partial(print, flush=True)

#---------------------------------------------

'''

'''

def simulate(program):

    strength = 1
    total_dmg = 0

    for c in program:
        if c == 'C':
            strength *= 2
        else:
            total_dmg += strength

    return total_dmg


def run(data):

    shield, program = data

    damage = simulate(program)
    swaps = 0

    while damage > shield:
        swap_at_index = program.rfind('CS')

        if swap_at_index == -1:
            return 'IMPOSSIBLE'

        program = program[:swap_at_index] + 'SC' + program[swap_at_index+2:]
        damage = simulate(program)
        swaps += 1
        print(damage, shield, program)

    return swaps


#---------------------------------------------

def read_case():
    i = input().split()
    return int(i[0]), i[1]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1231,59,127,Python,00000000000000cb,0000000000007d6f,0000000000007966,xjcl,2018
1577,00000000001597cb.PYTHON3,"'''
oh boi

ok this is zillion + nim
    but basically discrete nim lol

but through smart blocking you can, if the max is n (here n=100)
    only be able to take for 50 moves

how to solve nim
    minimax search
    -> maybe do minimax here on just qualitatively different moves
    -> actually maybe not even needed

if 2 * 10**10 coins left
    take from the middle
    [2] -> [0] [0]
if 3 * 10**10 coins left
    take middle 10**10
    [3] -> [1] [1]
if 4 * 10**10 coins left
    take first 10**10
    this maximizes chance of other player not doing the optimal move
if 5 * 10**10 coins left
    take middle 10**10

strategy
    ward off a 10**10 section at the beginning or end
    chance of computer hitting that is basically 0
    unless it is the only legal move... oops

    ward off 3 * 10**10
    not possible...
    but if we could, then we could play in the middle
    and the opponent would very likely not
    => create size 3 * 10**10 gaps for most flexibility ?
    nah i feel like this is wrong

okay
possible moves
    1 <= n < 2
        1 possible move: block [0]
    2 <= n < 3
        either allow [1] or block [0]
    3 <= n < 4
        either allow [1 1] or block [0 2]

okay
maybe
expectiminimax ?
expectimax ?
    but we would have 10**10 children ...
    maybe only look at 10 ?
    nodes: children**100 yikes

how tf is the perfect strategy here only 6 pts ??
i mean the above search can beat it >80% of the time probably
    if we do a shallow search

this problem isnt even worth thinking about based on the points...

maybe it really is just as simple as trying to create as many gaps of size
    exactly 2 * 10**10 as possible ?
    => 'mode2' once we only have those gaps

    => destroy everything between 2 and 3 ?
    => turn every gap >= 3 * 10**10 into a 2 * 10**10 gap
    => in mode2, turns into a variant of standard nim
'''

import sys, random

wins = 0

t, w = [int(x) for x in input().split()]

for _ in range(t):

    moves = [-10**10+1, 10**12+1]  # dummy moves to repr boundary conditions

    while True:
        p = int(input())

        # options = []
        # moves.sort()
        # print(moves)
        # import random
        # for m, n in zip(moves, moves[1:]):
        #     if n - m >= 2 * 10**10:
        #         for i in range(100):
        #             options.append(m + 10**10 + random.randint(0, n - m - 2 * 10**10))
        #             # options.append(n - 10**10)
        # p = None
        # if len(options) == 0:
        #     p = -2
        # else:
        #     p = random.choice(options)

        # print('moves', moves, 'len', len(moves))
        # print('opts', options)
        # print('p', p)

        if p == -1:  exit()
        if p == -2:  wins += 1; break  # win
        if p == -3:  break  # loss

        moves.append(p)
        moves.sort()

        # destroy (2,3) gaps
        for m, n in zip(moves, moves[1:]):
            if 3 * 10**10 < n - m < 4 * 10**10:
                move = (n+m)//2
                print(move); moves.append(move); break

        # optimize >=3 gaps
        else:
            for m, n in zip(moves, moves[1:]):
                if n - m >= 4 * 10**10:
                    move = m + 3 * 10**10
                    print(move); moves.append(move); break

        # play endgame on remaining gaps
        # essentially normal nim but only we can do the 2-move
            else:
                size1 = []
                size2exact = []
                for m, n in zip(moves, moves[1:]):
                    if 2 * 10**10 <= n - m < 3 * 10**10:
                        size1.append(m + 10**10)
                    elif 3 * 10**10 == n - m:
                        size2exact.append(m + 10**10)
                    else:
                        # print('mv', moves, 'n - m', n - m)
                        assert n - m < 2 * 10**10

                move = None

                # we want an even number of moves left
                if len(size2exact):
                    if (len(size1) + len(size2exact)) % 2 == 0:
                        # turn 1 move into 2  => keeps it even!
                        move = random.choice(size2exact)
                    else:
                        # on the path to win. now destroy cpu-winning opportunities !
                        move = random.choice(size2exact) + 1

                else:
                    move = random.choice(size1)

                print(move); moves.append(move)



print('wins: ' + str(wins), file=sys.stderr)
",,4489,156,679,Python,0000000000051707,00000000001597cb,0000000000158f1a,xjcl,2019
1578,00000000001597ed.PYTHON3,"'''
oh boi

ok this is zillion + nim
    but basically discrete nim lol

but through smart blocking you can, if the max is n (here n=100)
    only be able to take for 50 moves

how to solve nim
    minimax search
    -> maybe do minimax here on just qualitatively different moves
    -> actually maybe not even needed

if 2 * 10**10 coins left
    take from the middle
    [2] -> [0] [0]
if 3 * 10**10 coins left
    take middle 10**10
    [3] -> [1] [1]
if 4 * 10**10 coins left
    take first 10**10
    this maximizes chance of other player not doing the optimal move
if 5 * 10**10 coins left
    take middle 10**10

strategy
    ward off a 10**10 section at the beginning or end
    chance of computer hitting that is basically 0
    unless it is the only legal move... oops

    ward off 3 * 10**10
    not possible...
    but if we could, then we could play in the middle
    and the opponent would very likely not
    => create size 3 * 10**10 gaps for most flexibility ?
    nah i feel like this is wrong

okay
possible moves
    1 <= n < 2
        1 possible move: block [0]
    2 <= n < 3
        either allow [1] or block [0]
    3 <= n < 4
        either allow [1 1] or block [0 2]

okay
maybe
expectiminimax ?
expectimax ?
    but we would have 10**10 children ...
    maybe only look at 10 ?
    nodes: children**100 yikes

how tf is the perfect strategy here only 6 pts ??
i mean the above search can beat it >80% of the time probably
    if we do a shallow search

this problem isnt even worth thinking about based on the points...

maybe it really is just as simple as trying to create as many gaps of size
    exactly 2 * 10**10 as possible ?
    => 'mode2' once we only have those gaps

    => destroy everything between 2 and 3 ?
    => turn every gap >= 3 * 10**10 into a 2 * 10**10 gap
    => in mode2, turns into a variant of standard nim
'''

import sys, random

wins = 0

t, w = [int(x) for x in input().split()]

for _ in range(t):

    moves = [-10**10+1, 10**12+1]  # dummy moves to repr boundary conditions

    while True:
        p = int(input())

        # options = []
        # moves.sort()
        # print(moves)
        # import random
        # for m, n in zip(moves, moves[1:]):
        #     if n - m >= 2 * 10**10:
        #         for i in range(100):
        #             options.append(m + 10**10 + random.randint(0, n - m - 2 * 10**10))
        #             # options.append(n - 10**10)
        # p = None
        # if len(options) == 0:
        #     p = -2
        # else:
        #     p = random.choice(options)

        # print('moves', moves, 'len', len(moves))
        # print('opts', options)
        # print('p', p)

        if p == -1:  exit()
        if p == -2:  wins += 1; break  # win
        if p == -3:  break  # loss

        moves.append(p)
        moves.sort()

        # destroy (2,3) gaps
        for m, n in zip(moves, moves[1:]):
            if 3 * 10**10 < n - m < 4 * 10**10:
                move = (n+m)//2
                print(move); moves.append(move); break

        # optimize >=3 gaps
        else:
            for m, n in zip(moves, moves[1:]):
                if n - m >= 4 * 10**10:
                    move = m + 3 * 10**10
                    print(move); moves.append(move); break

        # play endgame on remaining gaps
        # essentially normal nim but only we can do the 2-move
            else:
                size1 = []
                size2exact = []
                for m, n in zip(moves, moves[1:]):
                    print(n - m)
                    if 2 * 10**10 <= n - m < 3 * 10**10:
                        size1.append(m + 10**10)
                    elif 3 * 10**10 == n - m:
                        size2exact.append(m + 10**10)
                    else:
                        # print('mv', moves, 'n - m', n - m)
                        assert n - m < 2 * 10**10

                move = None

                # we want an even number of moves left
                if len(size2exact):
                    if (len(size1) + len(size2exact)) % 2 == 0:
                        # turn 1 move into 2  => keeps it even!
                        move = random.choice(size2exact)
                    else:
                        # on the path to win. now destroy cpu-winning opportunities !
                        move = random.choice(size2exact) + 1

                else:
                    move = random.choice(size1)

                print(move); moves.append(move)



print('wins: ' + str(wins), file=sys.stderr)
",,4522,157,682,Python,0000000000051707,00000000001597ed,0000000000158f1a,xjcl,2019
1579,0000000000159708.PYTHON3,"'''
oh boi

ok this is zillion + nim
    but basically discrete nim lol

but through smart blocking you can, if the max is n (here n=100)
    only be able to take for 50 moves

how to solve nim
    minimax search
    -> maybe do minimax here on just qualitatively different moves
    -> actually maybe not even needed

if 2 * 10**10 coins left
    take from the middle
    [2] -> [0] [0]
if 3 * 10**10 coins left
    take middle 10**10
    [3] -> [1] [1]
if 4 * 10**10 coins left
    take first 10**10
    this maximizes chance of other player not doing the optimal move
if 5 * 10**10 coins left
    take middle 10**10

strategy
    ward off a 10**10 section at the beginning or end
    chance of computer hitting that is basically 0
    unless it is the only legal move... oops

    ward off 3 * 10**10
    not possible...
    but if we could, then we could play in the middle
    and the opponent would very likely not
    => create size 3 * 10**10 gaps for most flexibility ?
    nah i feel like this is wrong

okay
possible moves
    1 <= n < 2
        1 possible move: block [0]
    2 <= n < 3
        either allow [1] or block [0]
    3 <= n < 4
        either allow [1 1] or block [0 2]

okay
maybe
expectiminimax ?
expectimax ?
    but we would have 10**10 children ...
    maybe only look at 10 ?
    nodes: children**100 yikes

how tf is the perfect strategy here only 6 pts ??
i mean the above search can beat it >80% of the time probably
    if we do a shallow search

this problem isnt even worth thinking about based on the points...

maybe it really is just as simple as trying to create as many gaps of size
    exactly 2 * 10**10 as possible ?
    => 'mode2' once we only have those gaps

    => destroy everything between 2 and 3 ?
    => turn every gap >= 3 * 10**10 into a 2 * 10**10 gap
    => in mode2, turns into a variant of standard nim
'''

import sys

wins = 0

t, w = [int(x) for x in input().split()]

for _ in range(t):

    moves = [-10**10+1, 10**12+1]  # dummy moves to repr boundary conditions

    while True:
        p = int(input())

        # options = []
        # moves.sort()
        # print(moves)
        # import random
        # for m, n in zip(moves, moves[1:]):
        #     if n - m >= 2 * 10**10:
        #         for i in range(100):
        #             options.append(m + 10**10 + random.randint(0, n - m - 2 * 10**10))
        #             # options.append(n - 10**10)
        # p = None
        # if len(options) == 0:
        #     p = -2
        # else:
        #     p = random.choice(options)

        # print('moves', moves, 'len', len(moves))
        # print('opts', options)
        # print('p', p)

        if p == -1:  exit()
        if p == -2:  wins += 1; break  # win
        if p == -3:  break  # loss

        moves.append(p)
        moves.sort()

        # destroy (2,3) gaps
        for m, n in zip(moves, moves[1:]):
            if 3 * 10**10 < n - m < 4 * 10**10:
                move = (n+m)//2
                print(move); moves.append(move); break

        # optimize >=3 gaps
        else:
            for m, n in zip(moves, moves[1:]):
                if n - m >= 4 * 10**10:
                    move = m + 3 * 10**10
                    print(move); moves.append(move); break

        # play endgame on remaining gaps
        # essentially normal nim but only we can do the 2-move
            else:
                size1 = []
                size2exact = []
                for m, n in zip(moves, moves[1:]):
                    print(n - m)
                    if 2 * 10**10 <= n - m < 3 * 10**10:
                        size1.append(m + 10**10)
                    elif 3 * 10**10 == n - m:
                        size2exact.append(m + 10**10)
                    else:
                        # print('mv', moves, 'n - m', n - m)
                        if not n - m < 2 * 10**10:
                            list(range(9999999999999999))
                        assert n - m < 2 * 10**10

                move = None

                # we want an even number of moves left
                if len(size2exact):
                    if (len(size1) + len(size2exact)) % 2 == 0:
                        # turn 1 move into 2  => keeps it even!
                        move = random.choice(size2exact)
                    else:
                        # on the path to win. now destroy cpu-winning opportunities !
                        move = random.choice(size2exact) + 1

                else:
                    move = random.choice(size1)

                print(move); moves.append(move)



print('wins: ' + str(wins), file=sys.stderr)
",,4623,159,691,Python,0000000000051707,0000000000159708,0000000000158f1a,xjcl,2019
1580,000000000015966f.PYTHON3,"'''
oh boi

ok this is zillion + nim
    but basically discrete nim lol

but through smart blocking you can, if the max is n (here n=100)
    only be able to take for 50 moves

how to solve nim
    minimax search
    -> maybe do minimax here on just qualitatively different moves
    -> actually maybe not even needed

if 2 * 10**10 coins left
    take from the middle
    [2] -> [0] [0]
if 3 * 10**10 coins left
    take middle 10**10
    [3] -> [1] [1]
if 4 * 10**10 coins left
    take first 10**10
    this maximizes chance of other player not doing the optimal move
if 5 * 10**10 coins left
    take middle 10**10

strategy
    ward off a 10**10 section at the beginning or end
    chance of computer hitting that is basically 0
    unless it is the only legal move... oops

    ward off 3 * 10**10
    not possible...
    but if we could, then we could play in the middle
    and the opponent would very likely not
    => create size 3 * 10**10 gaps for most flexibility ?
    nah i feel like this is wrong

okay
possible moves
    1 <= n < 2
        1 possible move: block [0]
    2 <= n < 3
        either allow [1] or block [0]
    3 <= n < 4
        either allow [1 1] or block [0 2]

okay
maybe
expectiminimax ?
expectimax ?
    but we would have 10**10 children ...
    maybe only look at 10 ?
    nodes: children**100 yikes

how tf is the perfect strategy here only 6 pts ??
i mean the above search can beat it >80% of the time probably
    if we do a shallow search

this problem isnt even worth thinking about based on the points...

maybe it really is just as simple as trying to create as many gaps of size
    exactly 2 * 10**10 as possible ?
    => 'mode2' once we only have those gaps

    => destroy everything between 2 and 3 ?
    => turn every gap >= 3 * 10**10 into a 2 * 10**10 gap
    => in mode2, turns into a variant of standard nim
'''

import sys

wins = 0

t, w = [int(x) for x in input().split()]

for _ in range(t):

    moves = [-10**10+1, 10**12+1]  # dummy moves to repr boundary conditions

    while True:
        p = int(input())

        # options = []
        # moves.sort()
        # print(moves)
        # import random
        # for m, n in zip(moves, moves[1:]):
        #     if n - m >= 2 * 10**10:
        #         for i in range(100):
        #             # options.append(m + 10**10 + random.randint(0, n - m - 2 * 10**10))
        #             options.append(n - 10**10)
        # p = None
        # if len(options) == 0:
        #     p = -2
        # else:
        #     p = random.choice(options)

        # print('moves', moves, 'len', len(moves))
        # print('opts', options)
        # print('p', p)

        if p == -1:  exit()
        if p == -2:  wins += 1; break  # win
        if p == -3:  break  # loss

        moves.append(p)
        moves.sort()

        # destroy (2,3) gaps
        for m, n in zip(moves, moves[1:]):
            if 3 * 10**10 < n - m < 4 * 10**10:
                move = (n+m)//2
                print(move); moves.append(move); break

        # optimize >=3 gaps
        else:
            for m, n in zip(moves, moves[1:]):
                if n - m >= 4 * 10**10:
                    move = m + 3 * 10**10
                    print(move); moves.append(move); break

        # play endgame on remaining gaps
        # essentially normal nim but only we can do the 2-move
            else:
                size1 = []
                size2exact = []
                for m, n in zip(moves, moves[1:]):
                    print(n - m)
                    if 2 * 10**10 <= n - m < 3 * 10**10:
                        size1.append(m + 10**10)
                    elif 3 * 10**10 == n - m:
                        size2exact.append(m + 10**10)
                    else:
                        # assert n - m < 2 * 10**10
                        list(range(9999999999999999999999999999999999999))

                move = None

                # we want an even number of moves left
                if len(size2exact):
                    if (len(size1) + len(size2exact)) % 2 == 0:
                        # turn 1 move into 2  => keeps it even!
                        move = random.choice(size2exact)
                    else:
                        # on the path to win. now destroy cpu-winning opportunities !
                        move = random.choice(size2exact) + 1

                else:
                    move = random.choice(size1)

                print(move); moves.append(move)



print('wins: ' + str(wins), file=sys.stderr)
",,4530,157,674,Python,0000000000051707,000000000015966f,0000000000158f1a,xjcl,2019
1581,00000000001597d2.PYTHON3,"
import sys

wins = 0

t, w = [int(x) for x in input().split()]

for _ in range(t):

    moves = [-10**10+1, 10**12+1]  # dummy moves to repr boundary conditions

    while True:
        p = int(input())

        if p == -1:  exit()
        if p == -2:  wins += 1; break  # win
        if p == -3:  break  # loss

        options = []
        moves.sort()
        import random
        for m, n in zip(moves, moves[1:]):
            if n - m >= 2 * 10**10:
                for i in range(100):
                    # options.append(m + 10**10 + random.randint(0, n - m - 2 * 10**10))
                    options.append(n - 10**10)
        p = random.choice(options)

        print(p)
        moves.append(p)


print('wins: ' + str(wins), file=sys.stderr)

# test to see why i get runtime error
",,793,36,114,Python,0000000000051707,00000000001597d2,0000000000158f1a,xjcl,2019
1582,0000000000159600.PYTHON3,"'''
oh boi

ok this is zillion + nim
    but basically discrete nim lol

but through smart blocking you can, if the max is n (here n=100)
    only be able to take for 50 moves

how to solve nim
    minimax search
    -> maybe do minimax here on just qualitatively different moves
    -> actually maybe not even needed

if 2 * 10**10 coins left
    take from the middle
    [2] -> [0] [0]
if 3 * 10**10 coins left
    take middle 10**10
    [3] -> [1] [1]
if 4 * 10**10 coins left
    take first 10**10
    this maximizes chance of other player not doing the optimal move
if 5 * 10**10 coins left
    take middle 10**10

strategy
    ward off a 10**10 section at the beginning or end
    chance of computer hitting that is basically 0
    unless it is the only legal move... oops

    ward off 3 * 10**10
    not possible...
    but if we could, then we could play in the middle
    and the opponent would very likely not
    => create size 3 * 10**10 gaps for most flexibility ?
    nah i feel like this is wrong

okay
possible moves
    1 <= n < 2
        1 possible move: block [0]
    2 <= n < 3
        either allow [1] or block [0]
    3 <= n < 4
        either allow [1 1] or block [0 2]

okay
maybe
expectiminimax ?
expectimax ?
    but we would have 10**10 children ...
    maybe only look at 10 ?
    nodes: children**100 yikes

how tf is the perfect strategy here only 6 pts ??
i mean the above search can beat it >80% of the time probably
    if we do a shallow search

this problem isnt even worth thinking about based on the points...

maybe it really is just as simple as trying to create as many gaps of size
    exactly 2 * 10**10 as possible ?
    => 'mode2' once we only have those gaps

    => destroy everything between 2 and 3 ?
    => turn every gap >= 3 * 10**10 into a 2 * 10**10 gap
    => in mode2, turns into a variant of standard nim
'''

import sys

wins = 0

t, w = [int(x) for x in input().split()]

for _ in range(t):

    moves = [-10**10+1, 10**12+1]  # dummy moves to repr boundary conditions

    while True:
        p = int(input())

        # options = []
        # moves.sort()
        # print(moves)
        # for m, n in zip(moves, moves[1:]):
        #     if n - m >= 2 * 10**10 + 10**9:
        #         for i in range(100):
        #             options.append(m + 10**10 + i)
        #     elif n - m >= 2 * 10**10:
        #         options.append(m + 10**10)
        # import random
        # p = None
        # if len(options) == 0:
        #     p = -2
        # else:
        #     p = random.choice(options)

        # print('moves', moves, 'len', len(moves))
        # print('opts', options)
        # print('p', p)

        if p == -1:  exit()
        if p == -2:  wins += 1; break  # win
        if p == -3:  break  # loss

        moves.append(p)
        moves.sort()

        # destroy (2,3) gaps
        for m, n in zip(moves, moves[1:]):
            if 3 * 10**10 < n - m < 4 * 10**10:
                move = (n+m)//2
                print(move); moves.append(move); break

        # optimize >=3 gaps
        else:
            for m, n in zip(moves, moves[1:]):
                if n - m >= 4 * 10**10:
                    move = m + 3 * 10**10
                    print(move); moves.append(move); break

        # play endgame on remaining gaps
        # essentially normal nim but only we can do the 2-move
            else:
                size1 = []
                size2exact = []
                for m, n in zip(moves, moves[1:]):
                    print(n - m)
                    if 2 * 10**10 <= n - m < 3 * 10**10:
                        size1.append(m + 10**10)
                    elif 3 * 10**10 == n - m:
                        size2exact.append(m + 10**10)
                    else:
                        assert n - m < 2 * 10**10

                move = None

                # we want an even number of moves left
                if len(size2exact):
                    if (len(size1) + len(size2exact)) % 2 == 0:
                        # turn 1 move into 2  => keeps it even!
                        move = random.choice(size2exact)
                    else:
                        # on the path to win. now destroy cpu-winning opportunities !
                        move = random.choice(size2exact) + 1

                else:
                    move = random.choice(size1)

                print(move); moves.append(move)



print('wins: ' + str(wins), file=sys.stderr)
",,4459,157,675,Python,0000000000051707,0000000000159600,0000000000158f1a,xjcl,2019
4641,000000000014cd95.PYTHON3,"

SWITCH_DAY = 80
NUM_VASES = 14

for i in range(int(input())):

    vases = [None] * (20 - NUM_VASES)
    min_index = 0

    for day in range(99):
        input()

        if day == SWITCH_DAY + (20 - NUM_VASES):
            min_len = min(len(v) for v in vases)
            min_index = [i for i in range(len(vases)) if len(vases[i]) == min_len][0]


        if day < SWITCH_DAY:
            print(1 + (day % (NUM_VASES)), 1)

        elif day < SWITCH_DAY + (20 - NUM_VASES):
            # inspect vases 17 18 19 20
            print(day - SWITCH_DAY + NUM_VASES + 1, 0)
            vases[day - SWITCH_DAY] = [int(x) for x in input().split()]

        else:
            min_len2 = min([len(vases[i]), i] for i in range(len(vases)) if i != min_index)
            min_len2, min_index2 = min_len2

            print(NUM_VASES + 1 + min_index2, 1)
            vases[min_index2].append(None)

    input()
    print(NUM_VASES + 1 + min_index, 100)

",,944,37,124,Python,0000000000051679,000000000014cd95,00000000001461c8,xjcl,2019
4642,000000000014ca66.PYTHON3,"

SWITCH_DAY = 80
NUM_VASES = 14

for i in range(int(input())):

    vases = [None] * 4
    min_index = 0

    for day in range(99):
        input()

        if day == SWITCH_DAY + (20 - NUM_VASES):
            min_len = min(len(v) for v in vases)
            min_index = [i for i in range(len(vases)) if len(vases[i]) == min_len][0]


        if day < SWITCH_DAY:
            print(1 + (day % (NUM_VASES)), 1)

        elif day < SWITCH_DAY + (20 - NUM_VASES):
            # inspect vases 17 18 19 20
            print(day - SWITCH_DAY + NUM_VASES + 1, 0)
            vases[day - SWITCH_DAY] = [int(x) for x in input().split()]

        else:
            min_len2 = min([len(vases[i]), i] for i in range(len(vases)) if i != min_index)
            min_len2, min_index2 = min_len2

            print(NUM_VASES + 1 + min_index2, 1)
            vases[min_index2].append(None)

    input()
    print(NUM_VASES + 1 + min_index, 100)

",,929,37,122,Python,0000000000051679,000000000014ca66,00000000001461c8,xjcl,2019
4643,000000000014c85d.PYTHON3,"

SWITCH_DAY = 80

for i in range(int(input())):

    vases = [None] * 4
    min_index = 0

    for day in range(99):
        input()

        if day == SWITCH_DAY + 4:
            min_len = min(len(v) for v in vases)
            min_index = [i for i in range(len(vases)) if len(vases[i]) == min_len][0]


        if day < SWITCH_DAY:
            print(1 + (day % 16), 1)

        elif day < SWITCH_DAY + 4:
            # inspect vases 17 18 19 20
            print(day - SWITCH_DAY + 17, 0)
            vases[day - SWITCH_DAY] = [int(x) for x in input().split()]

        else:
            min_len2 = min([len(vases[i]), i] for i in range(len(vases)) if i != min_index)
            min_len2, min_index2 = min_len2

            print(17 + min_index2, 1)
            vases[min_index2].append(None)

    input()
    print(17 + min_index, 100)

",,842,36,109,Python,0000000000051679,000000000014c85d,00000000001461c8,xjcl,2019
4644,000000000014be35.PYTHON3,"

SWITCH_DAY = 80

for i in range(int(input())):

    vases = [None] * 4
    min_index = 0

    for day in range(99):
        input()

        if day < SWITCH_DAY:
            print(1 + (day % 16), 1)

        elif day < SWITCH_DAY + 4:
            # inspect vases 17 18 19 20
            print(day - SWITCH_DAY + 17, 0)
            vases[day - SWITCH_DAY] = [int(x) for x in input().split()]

        else:
            min_len = min(len(v) for v in vases)
            min_index = [i for i in range(len(vases)) if len(vases[i]) == min_len][0]

            add_index = day % 3

            if add_index >= min_index:  add_index += 1

            print(17 + add_index, 1)

    input()
    print(17 + min_index, 100)

",,715,34,98,Python,0000000000051679,000000000014be35,00000000001461c8,xjcl,2019
4645,000000000014bbb6.PYTHON3,"

SWITCH_DAY = 80

for i in range(int(input())):

    vases = [None] * 4
    min_index = 0

    for day in range(99):
        input()


        if day < SWITCH_DAY:
            print(1 + (day % 16), 1)

        elif day < SWITCH_DAY + 4:
            # inspect vases 17 18 19 20
            print(day - SWITCH_DAY + 17, 0)
            vases[day - SWITCH_DAY] = [int(x) for x in input()]

        else:
            min_len = min(len(v) for v in vases)
            min_index = [i for i in range(len(vases)) if len(vases[i]) == min_len][0]

            add_index = day % 3

            if add_index >= min_index:  add_index += 1

            print(17 + add_index, 1)

    input()
    print(17 + min_index, 100)

    if int(input()) == -1:
        exit()

",,751,38,103,Python,0000000000051679,000000000014bbb6,00000000001461c8,xjcl,2019
4646,000000000014bb0c.PYTHON3,"

SWITCH_DAY = 80

for i in range(int(input())):

    vases = [None] * 4
    min_index = 0

    for day in range(99):
        input()


        if day < SWITCH_DAY:
            print(1 + (day % 16), 1)

        elif day < SWITCH_DAY + 4:
            # inspect vases 17 18 19 20
            print(day - SWITCH_DAY + 17, 0)
            vases[day - SWITCH_DAY] = [int(x) for x in input()]

        else:
            min_len = min(len(v) for v in vases)
            min_index = [i for i in range(len(vases)) if len(vases[i]) == min_len][0]

            add_index = day % 3

            if add_index >= min_index:  add_index += 1

            print(17 + add_index, 1)

    input()
    print(17 + min_index, 100)

",,708,35,98,Python,0000000000051679,000000000014bb0c,00000000001461c8,xjcl,2019
4647,0000000000149b36.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(case):
    print(case)

    for x in range(1, 501):
        for y in range(1, 501):

            for i in range(len(case)-1):
                if case[i][0]*x + case[i][1]*y >= case[i+1][0]*x + case[i+1][1]*y:
                    break

            else:
                return str(x) + ' ' + str(y)

    return 'IMPOSSIBLE'

#---------------------------------------------

def read_case():
    num_molecules = int(input())
    ret = []
    for i in range(num_molecules):
        ret.append([int(x) for x in input().split()])
    return ret

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,998,41,101,Python,0000000000051679,0000000000149b36,0000000000146184,xjcl,2019
4648,0000000000149bbc.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(case):
    print(case)

    for x in range(1, 1001):
        for y in range(1, 1001):

            for i in range(len(case)-1):
                if case[i][0]*x + case[i][1]*y >= case[i+1][0]*x + case[i+1][1]*y:
                    break

            else:
                return str(x) + ' ' + str(y)

    return 'IMPOSSIBLE'

#---------------------------------------------

def read_case():
    num_molecules = int(input())
    ret = []
    for i in range(num_molecules):
        ret.append([int(x) for x in input().split()])
    return ret

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1000,41,101,Python,0000000000051679,0000000000149bbc,0000000000146184,xjcl,2019
4649,0000000000149986.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(case):
    print(case)

    for x in range(1, 101):
        for y in range(1, 101):

            for i in range(len(case)-1):
                if case[i][0]*x + case[i][1]*y >= case[i+1][0]*x + case[i+1][1]*y:
                    break

            else:
                return str(x) + ' ' + str(y)

    return 'IMPOSSIBLE'

#---------------------------------------------

def read_case():
    num_molecules = int(input())
    ret = []
    for i in range(num_molecules):
        ret.append([int(x) for x in input().split()])
    return ret

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,998,41,101,Python,0000000000051679,0000000000149986,0000000000146184,xjcl,2019
4650,00000000001490fb.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
- STRICTLY increasing weights
- think of these as 2D grid
- same row or same col: def less
- and we can pick any combination for the remaining ones
=> toposort algorihtm ??
- no, eg 4 1, 2 2, 1 4 counterexample
- el can only be first if in the bottom-left quadrant of it there is nothing
    => recursive algorithm ?
just try to do a sort with every multiple we see ?
    y = 1x, y = 2x, etc
    but i think we have O(n^2) multiples .... oof
    O(n^3 log n)

num permutations of n elements is n! -> too many too list

oh i know
we should probably make a 2D table of slopes
    oh or even better of 'y < ? x' and 'y > ? x'
hmm i made the table now
    if we look at the upper-right half of the table
    we have to count the assignments of {True, False} to the variables that produce a truth
i feel like im so close
    but i still do not know the number of T/F assignments
    have i just transformed the problem =(
actually
    the > and < is irrelevant for the number of T/F
    OH!
    i think it's just the number of distinct slopes plus 1
    omfg
    it's minute 70 and i'm starting to code. good work bro
'''

from fractions import gcd

def run(case):
    slopes = set()

    for i in range(len(case)):
        for j in range(i+1, len(case)):

            x, y = case[i]
            x2, y2 = case[j]

            diffs = x2-x, y2-y
            diffs = [abs(diffs[0]), abs(diffs[1])]
            print(case[i], case[j], diffs)
            if min(diffs) == 0: continue
            if x2 > x and y2 > y: continue
            if x > x2 and y > y2: continue

            my_gcd = gcd(*diffs)
            diffs = (diffs[0]//my_gcd, diffs[1]//my_gcd)
            slopes.add(diffs)

    print(slopes)
    return len(slopes) + 1  # actually +1 but we also have superfluous Frac(0,0)

#---------------------------------------------

def read_case():
    num_molecules = int(input())
    ret = []
    for i in range(num_molecules):
        ret.append([int(x) for x in input().split()])
    return ret

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2442,80,372,Python,0000000000051679,00000000001490fb,0000000000146183,xjcl,2019
4651,0000000000148ff3.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
- STRICTLY increasing weights
- think of these as 2D grid
- same row or same col: def less
- and we can pick any combination for the remaining ones
=> toposort algorihtm ??
- no, eg 4 1, 2 2, 1 4 counterexample
- el can only be first if in the bottom-left quadrant of it there is nothing
    => recursive algorithm ?
just try to do a sort with every multiple we see ?
    y = 1x, y = 2x, etc
    but i think we have O(n^2) multiples .... oof
    O(n^3 log n)

num permutations of n elements is n! -> too many too list

oh i know
we should probably make a 2D table of slopes
    oh or even better of 'y < ? x' and 'y > ? x'
hmm i made the table now
    if we look at the upper-right half of the table
    we have to count the assignments of {True, False} to the variables that produce a truth
i feel like im so close
    but i still do not know the number of T/F assignments
    have i just transformed the problem =(
actually
    the > and < is irrelevant for the number of T/F
    OH!
    i think it's just the number of distinct slopes plus 1
    omfg
    it's minute 70 and i'm starting to code. good work bro
'''

from fractions import gcd

def run(case):
    slopes = set()

    for i in range(len(case)):
        for j in range(i+1, len(case)):

            x, y = case[i]
            x2, y2 = case[j]

            diffs = x2-x, y2-y
            diffs = [abs(diffs[0]), abs(diffs[1])]
            print(case[i], case[j], diffs)
            if min(diffs) == 0: continue
            if x2 > x and y2 > y: continue
            if x > x2 and y > y2: continue

            diffs = (diffs[0]//gcd(*diffs), diffs[1]//gcd(*diffs))
            slopes.add(diffs)

    print(slopes)
    return len(slopes) + 1  # actually +1 but we also have superfluous Frac(0,0)

#---------------------------------------------

def read_case():
    num_molecules = int(input())
    ret = []
    for i in range(num_molecules):
        ret.append([int(x) for x in input().split()])
    return ret

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2419,79,369,Python,0000000000051679,0000000000148ff3,0000000000146183,xjcl,2019
99273,0000000000111ecd.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

i'm sorry

'''

import queue

def matching_chars_right(a, b):
    out = 0
    for i in range(min(len(a), len(b))):
        if a[-i-1] == b[-i-1]:
            out += 1
        else:
            break
    return out

def run(words):
    BIG_CONST = 999999

    n = len(words)
    p = queue.PriorityQueue()
    for i in range(n):
        for j in range(i+1, n):
            val = matching_chars_right(words[i], words[j])
            if val >= 1:
                entry = (BIG_CONST - val, i, j, words[i][-val:])
                p.put(entry)

    used = set()
    used_matches = set()
    last_val = 0
    rhymes = 0
    while not p.empty():
        val, i, j, match = p.get()
        if i not in used and j not in used and match not in used_matches:
            rhymes += 2
            used.add(i)
            used.add(j)
            used_matches.add(match)

    return rhymes

#---------------------------------------------

def read_case():
    n_lines = int(input())
    words = []
    for _ in range(n_lines):
        words.append(input())
    return words

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1502,65,168,Python,51635,0000000000111ecd,0000000000104e05,xjcl,2019
99274,0000000000111a69.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

i'm sorry

'''

import queue

def matching_chars_right(a, b):
    out = 0
    for i in range(min(len(a), len(b))):
        if a[-i-1] == b[-i-1]:
            out += 1
        else:
            break
    return out

def run(words):
    BIG_CONST = 999999

    n = len(words)
    p = queue.PriorityQueue()
    for i in range(n):
        for j in range(i+1, n):
            val = matching_chars_right(words[i], words[j])
            if val >= 1:
                entry = (BIG_CONST - val, i, j, words[i][-val:])
                p.put(entry)

    used = set()
    used_matches = set()
    last_val = 0
    rhymes = 0
    while not p.empty():
        val, i, j, match = p.get()
        print(val, i, j, match)
        if i not in used and j not in used and match not in used_matches:
            rhymes += 2
            used.add(i)
            used.add(j)
            used_matches.add(match)

    return rhymes

#---------------------------------------------

def read_case():
    n_lines = int(input())
    words = []
    for _ in range(n_lines):
        words.append(input())
    return words

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1534,66,172,Python,51635,0000000000111a69,0000000000104e05,xjcl,2019
99275,0000000000111874.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

i'm sorry

'''

import queue

def matching_chars_right(a, b):
    out = 0
    for i in range(min(len(a), len(b))):
        if a[-i-1] == b[-i-1]:
            out += 1
        else:
            break
    return out

def run(words):
    BIG_CONST = 999999

    n = len(words)
    p = queue.PriorityQueue()
    for i in range(n):
        for j in range(i+1, n):
            val = matching_chars_right(words[i], words[j])
            if val >= 1:
                entry = (BIG_CONST - val, i, j, words[i][-val:])
                p.put(entry)

    used = set()
    used_matches = set()
    last_val = 0
    rhymes = 0
    while not p.empty():
        val, i, j, match = p.get()
        if i not in used and j not in used and match not in used_matches:
            actual_val = max(last_val+1, val)
            if actual_val >= BIG_CONST:
                break
            last_val = actual_val
            rhymes += 2
            used.add(i)
            used.add(j)

    return rhymes

#---------------------------------------------

def read_case():
    n_lines = int(input())
    words = []
    for _ in range(n_lines):
        words.append(input())
    return words

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1608,68,179,Python,51635,0000000000111874,0000000000104e05,xjcl,2019
99276,0000000000110da2.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

i'm sorry

'''

import queue

def matching_chars_right(a, b):
    out = 0
    for i in range(min(len(a), len(b))):
        if a[-i-1] == b[-i-1]:
            out += 1
        else:
            break
    return out

def run(words):
    n = len(words)
    p = queue.PriorityQueue()
    for i in range(n):
        for j in range(i+1, n):
            val = matching_chars_right(words[i], words[j])
            if val >= 1:
                entry = (999999 - val, i, j)
                p.put(entry)

    used = set()
    last_val = 0
    rhymes = 0
    while not p.empty():
        val, i, j = p.get()
        if i not in used and j not in used:
            actual_val = max(last_val+1, val)
            if actual_val >= 999999:
                break
            last_val = actual_val
            rhymes += 2
            used.add(i)
            used.add(j)

    return rhymes

#---------------------------------------------

def read_case():
    n_lines = int(input())
    words = []
    for _ in range(n_lines):
        words.append(input())
    return words

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,1499,65,166,Python,51635,0000000000110da2,0000000000104e05,xjcl,2019
99277,000000000010e916.PYTHON3,"'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades


Small Dataset: Just re-run until <17 gophers on each hole

Large Dataset:
If we choose the same num_of_blades on each hole (eg 18)
    and add them all together we do know the total number of gophers modulo 18
Maybe we can test the prime factors this way?
        2, 3, 5, 7, 11, 13, 17
    it's exactly n=7 which would help my case
    nb we could even test them together:
        15 -> tests 3 and 5
        14 -> tests 2 and 7
    but we have 10**6 so prime factors up to 10**3 (1000) possible...
    but cant we conclude eg 21 from the other factors ?
        19 % 2 = 1
        19 % 3 = 1
        19 % 5 = 4
        19 % 7 = 5
    goddamn i wish there was a formalism for this
    so do we just precompute this pattern for every prime under 1000?
    what if there are clashes?
    and wouldnt [18, 17, .., 12] be better ?
        => Yes!
        I ran a test with 10**6 and this method and there were no collisions!
        So we can identify a prime by its fingerprint!

'''

def run(n, m, fingerprint_to_gopher_number):

    fingerprint = []

    for i in range(7):
        blades = [18-i] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        gopher_number_modulo_i = sum(new_blades) % (18-i)
        fingerprint.append(gopher_number_modulo_i)

    guess_gophers = fingerprint_to_gopher_number[tuple(fingerprint)]
    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()



def run_small(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

d = dict()
for i in range(1000001):
    fingerprint = (i%18, i%17, i%16, i%15, i%14, i%13, i%12)
    if fingerprint in d:
        print(i, d[fingerprint])
        assert False
    d[fingerprint] = i

# !! No AssertionError !

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m, d)

",,2365,87,344,Python,51635,000000000010e916,0000000000104f1a,xjcl,2019
99279,000000000010e3f8.PYTHON3,"'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades


Small Dataset: Just re-run until <17 gophers on each hole

Large Dataset:
If we choose the same num_of_blades on each hole (eg 18)
    and add them all together we do know the total number of gophers modulo 18
Maybe we can test the prime factors this way?
        2, 3, 5, 7, 11, 13, 17
    it's exactly n=7 which would help my case
    nb we could even test them together:
        15 -> tests 3 and 5
        14 -> tests 2 and 7
    but we have 10**6 so prime factors up to 10**3 (1000) possible...
    but cant we conclude eg 21 from the other factors ?
        19 % 2 = 1
        19 % 3 = 1
        19 % 5 = 4
        19 % 7 = 5
    goddamn i wish there was a formalism for this
    so do we just precompute this pattern for every prime under 1000?
    what if there are clashes?
    and wouldnt [18, 17, .., 12] be better ?
        => Yes!
        I ran a test with 10**6 and this method and there were no collisions!
        So we can identify a prime by its fingerprint!

'''

def run(n, m, fingerprint_to_gopher_number):

    fingerprint = []

    for i in range(7):
        blades = [18-i] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        gopher_number_modulo_i = sum(new_blades)
        fingerprint.append(gopher_number_modulo_i)

    if tuple(fingerprint) not in fingerprint_to_gopher_number:
        while True:
            pass
    guess_gophers = fingerprint_to_gopher_number[tuple(fingerprint)]
    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()



def run_small(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

d = dict()
for i in range(1000001):
    fingerprint = (i%18, i%17, i%16, i%15, i%14, i%13, i%12)
    if fingerprint in d:
        print(i, d[fingerprint])
        assert False
    d[fingerprint] = i

# !! No AssertionError !

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m, d)

",,2456,90,350,Python,51635,000000000010e3f8,0000000000104f1a,xjcl,2019
99280,000000000010d4b6.PYTHON3,"'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades


Small Dataset: Just re-run until <17 gophers on each hole

Large Dataset:
If we choose the same num_of_blades on each hole (eg 18)
    and add them all together we do know the total number of gophers modulo 18
Maybe we can test the prime factors this way?
        2, 3, 5, 7, 11, 13, 17
    it's exactly n=7 which would help my case
    nb we could even test them together:
        15 -> tests 3 and 5
        14 -> tests 2 and 7
    but we have 10**6 so prime factors up to 10**3 (1000) possible...
    but cant we conclude eg 21 from the other factors ?
        19 % 2 = 1
        19 % 3 = 1
        19 % 5 = 4
        19 % 7 = 5
    goddamn i wish there was a formalism for this
    so do we just precompute this pattern for every prime under 1000?
    what if there are clashes?
    and wouldnt [18, 17, .., 12] be better ?
        => Yes!
        I ran a test with 10**6 and this method and there were no collisions!
        So we can identify a prime by its fingerprint!

'''

def run(n, m, fingerprint_to_gopher_number):

    fingerprint = []

    for i in range(7):
        blades = [18-i] * 18
        print(' '.join(str(b) for b in blades))
        gopher_number_modulo_i = sum(int(k) for k in list(input().split()))
        fingerprint.append(gopher_number_modulo_i)

    if tuple(fingerprint) not in fingerprint_to_gopher_number:
        while True:
            pass
    guess_gophers = fingerprint_to_gopher_number[tuple(fingerprint)]
    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()



def run_small(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

d = dict()
for i in range(1000001):
    fingerprint = (i%18, i%17, i%16, i%15, i%14, i%13, i%12)
    if fingerprint in d:
        print(i, d[fingerprint])
        assert False
    d[fingerprint] = i

# !! No AssertionError !

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m, d)

",,2422,89,347,Python,51635,000000000010d4b6,0000000000104f1a,xjcl,2019
99281,000000000010ca3d.PYTHON3,"'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades


Small Dataset: Just re-run until <17 gophers on each hole

Large Dataset:
If we choose the same num_of_blades on each hole (eg 18)
    and add them all together we do know the total number of gophers modulo 18
Maybe we can test the prime factors this way?
        2, 3, 5, 7, 11, 13, 17
    it's exactly n=7 which would help my case
    nb we could even test them together:
        15 -> tests 3 and 5
        14 -> tests 2 and 7
    but we have 10**6 so prime factors up to 10**3 (1000) possible...
    but cant we conclude eg 21 from the other factors ?
        19 % 2 = 1
        19 % 3 = 1
        19 % 5 = 4
        19 % 7 = 5
    goddamn i wish there was a formalism for this
    so do we just precompute this pattern for every prime under 1000?
    what if there are clashes?
    and wouldnt [18, 17, .., 12] be better ?
        => Yes!
        I ran a test with 10**6 and this method and there were no collisions!
        So we can identify a prime by its fingerprint!

'''

def run(n, m, fingerprint_to_gopher_number):

    fingerprint = []

    for i in range(7):
        blades = [18-i] * 18
        print(' '.join(str(b) for b in blades))
        gopher_number_modulo_i = sum(int(k) for k in list(input().split()))
        fingerprint.append(gopher_number_modulo_i)

    guess_gophers = fingerprint_to_gopher_number[tuple(fingerprint)]
    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()



def run_small(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

d = dict()
for i in range(1000001):
    fingerprint = (i%18, i%17, i%16, i%15, i%14, i%13, i%12)
    if fingerprint in d:
        print(i, d[fingerprint])
        assert False
    d[fingerprint] = i

# !! No AssertionError !

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m, d)

",,2322,86,339,Python,51635,000000000010ca3d,0000000000104f1a,xjcl,2019
99282,000000000010c7bd.PYTHON3,"'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades


Small Dataset: Just re-run until <17 gophers on each hole

Large Dataset:
If we choose the same num_of_blades on each hole (eg 18)
    and add them all together we do know the total number of gophers modulo 18
Maybe we can test the prime factors this way?
        2, 3, 5, 7, 11, 13, 17
    it's exactly n=7 which would help my case
    nb we could even test them together:
        15 -> tests 3 and 5
        14 -> tests 2 and 7
    but we have 10**6 so prime factors up to 10**3 (1000) possible...
    but cant we conclude eg 21 from the other factors ?
        19 % 2 = 1
        19 % 3 = 1
        19 % 5 = 4
        19 % 7 = 5
    goddamn i wish there was a formalism for this
    so do we just precompute this pattern for every prime under 1000?
    what if there are clashes?
    and wouldnt [18, 17, .., 12] be better ?
        => Yes!
        I ran a test with 10**6 and this method and there were no collisions!
        So we can identify a prime by its fingerprint!

'''

def run(n, m, fingerprint_to_gopher_number):

    fingerprint = []

    for i in range(7):
        blades = [18-i] * 18
        print(' '.join(str(b) for b in blades))
        gopher_number_modulo_i = sum(int(k) for k in list(input().split()))
        fingerprint.append(gopher_number_modulo_i)

    guess_gophers = fingerprint_to_gopher_number[tuple(fingerprint)]
    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()



def run_small(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

d = dict()
for i in range(100001):
    fingerprint = (i%18, i%17, i%16, i%15, i%14, i%13, i%12)
    if fingerprint in d:
        print(i, d[fingerprint])
        assert False
    d[fingerprint] = i

# !! No AssertionError !

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m, d)

",,2321,86,339,Python,51635,000000000010c7bd,0000000000104f1a,xjcl,2019
99283,000000000010c417.PYTHON3,"'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades


Small Dataset: Just re-run until <17 gophers on each hole

Large Dataset:
If we choose the same num_of_blades on each hole (eg 18)
    and add them all together we do know the total number of gophers modulo 18
Maybe we can test the prime factors this way?
        2, 3, 5, 7, 11, 13, 17
    it's exactly n=7 which would help my case
    nb we could even test them together:
        15 -> tests 3 and 5
        14 -> tests 2 and 7
    but we have 10**6 so prime factors up to 10**3 (1000) possible...
    but cant we conclude eg 21 from the other factors ?
        19 % 2 = 1
        19 % 3 = 1
        19 % 5 = 4
        19 % 7 = 5
    goddamn i wish there was a formalism for this
    so do we just precompute this pattern for every prime under 1000?
    what if there are clashes?
    and wouldnt [18, 17, .., 12] be better ?
        => Yes!
        I ran a test with 10**6 and this method and there were no collisions!
        So we can identify a prime by its fingerprint!

'''

def run(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999
    fingerprint = []

    for i in range(7):
        blades = [18-i] * 18
        print(' '.join(str(b) for b in blades))
        gopher_number_modulo_i = sum(int(k) for k in list(input().split()))
        fingerprint.append(gopher_number_modulo_i)

    guess_gophers = fingerprint_to_gopher_number[tuple(fingerprint)]
    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()



def run_small(n, m, fingerprint_to_gopher_number):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

d = dict()
for i in range(100001):
    fingerprint = (i%18, i%17, i%16, i%15, i%14, i%13, i%12)
    if fingerprint in d:
        print(i, d[fingerprint])
        assert False
    d[fingerprint] = i

# !! No AssertionError !

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m, d)

",,2351,87,342,Python,51635,000000000010c417,0000000000104f1a,xjcl,2019
99284,0000000000109c28.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

# lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades

'''

def run(n, m):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

t, n, m = [int(k) for k in list(input().split())]

for i in range(t):
    run(n, m)

# def read_case():
#     n, l = [int(k) for k in list(input().split())]
#     return [input() for i in range(n)]

# for i in range(int(input())):
#     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
#     print(outstr, ' @ t =', time.clock())
#     __builtins__.print(outstr)
",,1186,48,147,Python,51635,0000000000109c28,0000000000104f1a,xjcl,2019
99285,00000000001099a1.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

# lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
p interactive_runner.py python3 ./testing_tool.py 1 -- python3 b.py

- betw 1 and m gophers
- 18 holes with 18 blades

'''

def run(n, m):

    guess_gophers = 999999999

    for i in range(365):
        blades = [18] * 18
        print(' '.join(str(b) for b in blades))
        new_blades = [int(k) for k in list(input().split())]
        guess_gophers = min(guess_gophers, sum(new_blades))

    print(guess_gophers)
    verdict = int(input())
    if verdict == -1:
        exit()


#---------------------------------------------

t, n, m = [int(k) for k in list(input().split())]

print('FUCK')
for i in range(t):
    import sys
    print(i, file=sys.stderr)
    run(n, m)

# def read_case():
#     n, l = [int(k) for k in list(input().split())]
#     return [input() for i in range(n)]

# for i in range(int(input())):
#     outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
#     print(outstr, ' @ t =', time.clock())
#     __builtins__.print(outstr)
",,1245,51,152,Python,51635,00000000001099a1,0000000000104f1a,xjcl,2019
99286,0000000000107b25.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
if R even and C>=5 odd:
    just go 2 right 1 down in each step
    => works cos 2 and odd numbers coprime?

if R even and C>=6 odd:
    use above strategy twice, once from (0 0) and from (0 1)

R=2 C>=5
    possible, just repeat this pattern C times:
    (move all Xs one to the right each iteration)
    (go row by row)
        x . . . .
        . . . x .
    C=4 confirmed impossible

R=3 C>=4
    possible, just repeat this pattern four times:
    (move all Xs one to the right each iteration)
    (go row by row)
        x . . .
        . . x .
        x . . .
    C=3 confirmed impossible (ship can never enter center)

R=4 C>=3
        x . .
        . . x
        x . .
        . . x
    BAD!!! this leads to a clash
    HAVE TO solve the 3x4 case with above method

R=5
    C>=3: keep going in above zig-zag pattern
    C=2: see R=2 C>=5, no way to go row-wise here


big oof my strategy fails for R=4 C=4 cos of the diagonal
        . . O N
        O . . .
        . . O .
        O . . .
    solution: if r==c just start in top-right corner???
        i know we can't just start there always

nope. for R=5 C=5 we get
        O . . . N
        . N . . .
        . . . . N
        . N . . .
        . . . . N
    so let us only do it if r==c is even...

'''

def run(case):
    print(case)
    r, c = case
    sol = []
    if r*c <= 9:
        return 'IMPOSSIBLE'

    if c == 2 or r == 2:

        for x in range(max(c,r)):
            sol.append( (0, x) )
            sol.append( (1, (x+3) % max(c,r)) )

        if c == 2:
            sol = [(x,y) for y,x in sol]

    # r == 3 is actually fine in the 'else' so we can let it fall through
    elif c == 3:

        for x in range(max(c,r)):
            sol.append( (0, x) )
            sol.append( (1, (x+2) % max(c,r)) )
            sol.append( (2, x) )

        if c == 3:
            sol = [(x,y) for y,x in sol]

    else:
        xrange = [c-1] + list(range(c-1)) if r == c and r % 2 == 0 else range(c)  # funny Python2 joke
        for x in xrange:
            for y in range(r):
                if y % 2 == 0:
                    sol.append( (y, x) )
                else:
                    sol.append( (y, (x+2) % c ) )

    for old,new in zip(sol, sol[1::]):
        assert old[0] != new[0] and old[1] != new[1] and old[0] - old[1] != new[0] - new[1] and old[0] + old[1] != new[0] + new[1]

    return 'POSSIBLE\n' + '\n'.join(str(y+1) + ' ' + str(x+1) for y,x in sol)

#---------------------------------------------

def read_case():
    return [int(i) for i in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2997,115,493,Python,51635,0000000000107b25,0000000000104e03,xjcl,2019
99287,0000000000106a3e.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
if R even and C>=5 odd:
    just go 2 right 1 down in each step
    => works cos 2 and odd numbers coprime?

if R even and C>=6 odd:
    use above strategy twice, once from (0 0) and from (0 1)

R=2 C>=5
    possible, just repeat this pattern C times:
    (move all Xs one to the right each iteration)
    (go row by row)
        x . . . .
        . . . x .
    C=4 confirmed impossible

R=3 C>=4
    possible, just repeat this pattern four times:
    (move all Xs one to the right each iteration)
    (go row by row)
        x . . .
        . . x .
        x . . .
    C=3 confirmed impossible (ship can never enter center)

R=4 C>=3
        x . .
        . . x
        x . .
        . . x
    nope this leads to a clash
    HAVE TO solve the 3x4 case with above method

R=5
    C>=3: keep going in above zig-zag pattern
    C=2: see R=2 C>=5, no way to go row-wise here

'''

def run(case):
    print(case)
    r, c = case
    sol = []
    if r*c <= 9:
        return 'IMPOSSIBLE'

    if c == 2 or r == 2:

        for x in range(max(c,r)):
            sol.append( (0, x) )
            sol.append( (1, (x+3) % max(c,r)) )

        if c == 2:
            sol = [(x,y) for y,x in sol]

    # r == 3 is actually fine in the 'else' so we can let it fall through
    elif c == 3:

        for x in range(max(c,r)):
            sol.append( (0, x) )
            sol.append( (1, (x+2) % max(c,r)) )
            sol.append( (2, x) )

        if c == 3:
            sol = [(x,y) for y,x in sol]

    else:
        for x in range(c):
            for y in range(r):
                if y % 2 == 0:
                    sol.append( (y, x) )
                else:
                    sol.append( (y, (x+2) % c ) )

    return 'POSSIBLE\n' + '\n'.join(str(y+1) + ' ' + str(x+1) for y,x in sol)

#---------------------------------------------

def read_case():
    return [int(i) for i in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",,2335,94,358,Python,51635,0000000000106a3e,0000000000104e03,xjcl,2019
131296,0000000000095690.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools, math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
each original prime is included in the two neighboring letters

algorithm 1
    calculate gcd of each pair in the input  => original letters
    then calculate both ""corner"" primes (only appear in one product!) using division

problem 1
    what if we eg have A=2 B=3 and ABA in the original text
        and 66 in the ciphertext, then we cant tell if ABA or BAB
    => have to do a sort of second induction-like step? (based on following letters)
    => example input: [6, 6, 10] on alphabet ABC

solution to problem 1
    solve with gcd, but if any 2 adjacent inputs are the same replace them with a placeholder
    then propagate primes from adjacent solved ones

'''

def run_bad(msg):
    gcds = [math.gcd(a,b) for a,b in zip(msg[:-1], msg[1:])]
    plain = [msg[0]/gcds[0]] + gcds + [msg[-1]/gcds[-1]]
    decode_dict = dict(zip(sorted(set(plain)), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'))
    return ''.join(decode_dict[p] for p in plain)

def run(msg):
    plain = [(math.gcd(a,b) if a != b else None) for a,b in zip(msg[:-1], msg[1:])]

    # induction -- forward pass
    for i in range(1, len(plain)):
        if plain[i] is None and plain[i-1]:
            plain[i] = msg[i]//plain[i-1]

    # induction -- backward pass
    for i in range(len(plain)-2, -1, -1):
        if plain[i] is None and plain[i+1]:
            plain[i] = msg[i]//plain[i+1]

    plain = [msg[0]//plain[0]] + plain + [msg[-1]//plain[-1]]
    decode_dict = dict(zip(sorted(set(plain)), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'))
    return ''.join(decode_dict[p] for p in plain)

#---------------------------------------------

def read_case():
    input()
    return [int(x) for x in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,2062,60,264,Python,51705,0000000000095690,000000000008830b,xjcl,2019
131297,000000000009425b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools, itertools, math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

Visible Case:
    Should be pretty obvious binary search, 2**10 == 1024
    For n=8
        00001111
        00110011
        01010101

Hidden Case:
    if we input 00001111 and get eg 01111 back we only need
        to do further queries on the left half
        => actually i think that doesnt matter as we can't really
        'use' the bits we 'saved' in the right-half anywhere else

    note that if eg B=3 we can safely send
        0000111100001111000011110000111100001111...
        and no group of 4 will disappear

    actually i think we can even send
        000111000111000111000111...
        e.g. output 000111111000...
        => just detect missing groups of 0s by the overabundance of 1s!

    1 <= B <= min(15, N-1)
        i feel like this should be a clue. why 15?
        maybe send  8*[0] 8*[1] 8*[0] 8*[1] ...  on the first iteration?
        actually starting at 16* should be enough (5 its) and easier to implement
        i wonder if my 8* approach is possible at all

'''

def run(args):
    num_machines, num_broken = args

    aa = [[], [], [], [], []]

    send = 1024 * (16*'0' + 16*'1')
    print(send[:num_machines])
    reply = input()

    aa[-1] = [16 - len(list(g)) for k,g in itertools.groupby(reply)]
    if num_machines % 16:
        aa[-1][-1] = (num_machines % 16) - (16 - aa[-1][-1])

    # print('aa', aa)

    for i in reversed(range(4)):

        bucket_size = 2**i

        send = 1024 * (bucket_size*'0' + bucket_size*'1')
        print(send[:num_machines])
        reply = input()

        prev_broken_index = 0
        num_zeros = 0
        j = 0

        final_bucket_size_x2 = num_machines % (2 * bucket_size)

        # - num_broken
        # while j < num_machines - prev_broken_index * 2 * bucket_size - final_bucket_size_x2:
        while 0 < num_machines - prev_broken_index * 2 * bucket_size - final_bucket_size_x2:

            # print('pbi', prev_broken_index, aa)

            prev_broken = aa[i+1][prev_broken_index]

            if prev_broken == 2*bucket_size:
                aa[i].append(bucket_size)
                aa[i].append(bucket_size)
                prev_broken_index += 1
                continue

            # print('j', j, aa)

            if reply[j] == '0':
                num_zeros += 1
                j += 1

                if num_zeros == 2*bucket_size - prev_broken:
                    broken_zeros = bucket_size - num_zeros
                    aa[i].append(broken_zeros)
                    aa[i].append(bucket_size)
                    prev_broken_index += 1
                    num_zeros = 0
            else:
                broken_zeros = bucket_size - num_zeros
                broken_ones = prev_broken - broken_zeros
                aa[i].append(broken_zeros)
                aa[i].append(broken_ones)
                prev_broken_index += 1
                j += (bucket_size - broken_ones)
                num_zeros = 0


        # remain = num_machines - num_broken - j
        final_bucket_size_x2 = num_machines % (2 * bucket_size)
        final_bucket_size_0  = min(bucket_size, final_bucket_size_x2)
        final_bucket_size_1  = final_bucket_size_x2 - final_bucket_size_0
        if final_bucket_size_0:
            aa[i].append(final_bucket_size_0 - reply[j:].count('0'))
        if final_bucket_size_1:
            aa[i].append(final_bucket_size_1 - reply[j:].count('1'))

        # print('aa', aa)

    print(' '.join(str(i) for i in range(len(aa[0])) if aa[0][i]))
    assert input() == '1'

# TODO: bucket skipping if bucket_size == prev_broken !

#---------------------------------------------

def read_case():
    n, b, f = [int(k) for k in list(input().split())]
    return n, b

for i in range(int(input())):
    run(read_case())
",,4048,130,444,Python,51705,000000000009425b,00000000000881de,xjcl,2019
131298,000000000008ae6b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools, math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
each original prime is included in the two neighboring letters

algorithm 1
    calculate gcd of each pair in the input  => original letters
    then calculate both ""corner"" primes (only appear in one product!) using division

problem 1
    what if we eg have A=2 B=3 and ABA in the original text
        and 66 in the ciphertext, then we cant tell if ABA or BAB
    => have to do a sort of second induction-like step? (based on following letters)
    => example input: [6, 6, 10] on alphabet ABC

solution to problem 1
    solve with gcd, but if any 2 adjacent inputs are the same replace them with a placeholder
    then propagate primes from adjacent solved ones

'''

def run_bad(msg):
    gcds = [math.gcd(a,b) for a,b in zip(msg[:-1], msg[1:])]
    plain = [msg[0]/gcds[0]] + gcds + [msg[-1]/gcds[-1]]
    decode_dict = dict(zip(sorted(set(plain)), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'))
    return ''.join(decode_dict[p] for p in plain)

def run(msg):
    plain = [(math.gcd(a,b) if a != b else None) for a,b in zip(msg[:-1], msg[1:])]

    # induction -- forward pass
    for i in range(1, len(plain)):
        if plain[i] is None and plain[i-1]:
            plain[i] = msg[i]//plain[i-1]

    # induction -- backward pass
    for i in range(len(plain)-2, -1, -1):
        if plain[i] is None and plain[i+1]:
            plain[i] = msg[i]//plain[i+1]

    plain = [msg[0]/plain[0]] + plain + [msg[-1]/plain[-1]]
    decode_dict = dict(zip(sorted(set(plain)), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'))
    return ''.join(decode_dict[p] for p in plain)

#---------------------------------------------

def read_case():
    input()
    return [int(x) for x in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,2060,60,264,Python,51705,000000000008ae6b,000000000008830b,xjcl,2019
131299,000000000008acb8.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools, math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
each original prime is included in the two neighboring letters

algorithm 1
    calculate gcd of each pair in the input  => original letters
    then calculate both ""corner"" primes (only appear in one product!) using division

problem 1
    what if we eg have A=2 B=3 and ABA in the original text
        and 66 in the ciphertext, then we cant tell if ABA or BAB
    => have to do a sort of second induction-like step? (based on following letters)
    => example input: [6, 6, 10] on alphabet ABC

solution to problem 1
    solve with gcd, but if any 2 adjacent inputs are the same replace them with a placeholder
    then propagate primes from adjacent solved ones

'''

def run_bad(msg):
    gcds = [math.gcd(a,b) for a,b in zip(msg[:-1], msg[1:])]
    plain = [msg[0]/gcds[0]] + gcds + [msg[-1]/gcds[-1]]
    decode_dict = dict(zip(sorted(set(plain)), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'))
    return ''.join(decode_dict[p] for p in plain)

def run(msg):
    plain = [(math.gcd(a,b) if a != b else None) for a,b in zip(msg[:-1], msg[1:])]

    # induction -- forward pass
    for i in range(1, len(plain)):
        if plain[i] is None and plain[i-1]:
            plain[i] = msg[i]//plain[i-1]

    print(plain)

    # induction -- backward pass
    for i in range(len(plain)-2, -1, -1):
        if plain[i] is None and plain[i+1]:
            plain[i] = msg[i]//plain[i+1]

    print(plain)

    plain = [msg[0]/plain[0]] + plain + [msg[-1]/plain[-1]]
    decode_dict = dict(zip(sorted(set(plain)), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'))
    return ''.join(decode_dict[p] for p in plain)

#---------------------------------------------

def read_case():
    input()
    return [int(x) for x in input().split()]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,2096,64,266,Python,51705,000000000008acb8,000000000008830b,xjcl,2019
131300,0000000000088a1f.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(path):
    return path.replace('S', 'X').replace('E', 'S').replace('X', 'E')

#---------------------------------------------

def read_case():
    input()
    return input()

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,579,25,53,Python,51705,0000000000088a1f,00000000000881da,xjcl,2019
131301,0000000000088871.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(n):
    check1 = []
    check2 = []

    for c in list(n):
        if c == '4':
            check1.append('3')
            check2.append('1')
        else:
            check1.append(c)
            check2.append('0')

    ans = str(int(''.join(check1))) + ' ' + str(int(''.join(check2)))

    return ans

#---------------------------------------------

def read_case():
    return input()

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,793,37,76,Python,51705,0000000000088871,0000000000088231,xjcl,2019
131302,000000000008874b.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(n):
    check1 = []
    check2 = []

    for c in list(n):
        if c == '4':
            check1.append('3')
            check2.append('1')
        else:
            check1.append(c)
            check2.append('0')

    ans = str(int(''.join(check1))) + ' ' + str(int(''.join(check2)))

    return ans

#---------------------------------------------

def read_case():
    return input()

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,791,37,75,Python,51705,000000000008874b,0000000000088231,xjcl,2019
131303,00000000000885cd.PYTHON3,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, functools

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''

'''

def run(n):
    check1 = []
    check2 = []

    for c in list(n):
        if c == '4':
            check1.append('3')
            check2.append('1')
        else:
            check1.append('4')
            check2.append('0')

    ans = str(int(''.join(check1))) + ' ' + str(int(''.join(check1)))

    return ans

#---------------------------------------------

def read_case():
    return input()

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr)
",,793,37,75,Python,51705,00000000000885cd,0000000000088231,xjcl,2019
13674,000000000027a277,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
import numpy as np
from itertools import *

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def is_valid(a):
    if all(len(set(col)) == len(a) for col in zip(*a)):
        return sum(a[i][i] for i in range(len(a)))

def run(case):
    n, k = case

    if k in [n+1, n*n-1]:
        return 'IMPOSSIBLE'

    if n == 3 and k % 3:
        return 'IMPOSSIBLE'

    # lol
    solution = {
(2, 2): ((0, 1), (1, 0)),
(2, 4): ((1, 0), (0, 1)),
(3, 3): ((0, 2, 1), (1, 0, 2), (2, 1, 0)),
(3, 6): ((2, 1, 0), (1, 0, 2), (0, 2, 1)),
(3, 9): ((2, 1, 0), (0, 2, 1), (1, 0, 2)),
(4, 4): ((0, 3, 2, 1), (3, 0, 1, 2), (2, 1, 0, 3), (1, 2, 3, 0)),
(4, 6): ((1, 3, 2, 0), (3, 0, 1, 2), (2, 1, 0, 3), (0, 2, 3, 1)),
(4, 7): ((2, 3, 1, 0), (1, 0, 2, 3), (3, 1, 0, 2), (0, 2, 3, 1)),
(4, 8): ((3, 2, 1, 0), (1, 0, 3, 2), (2, 1, 0, 3), (0, 3, 2, 1)),
(4, 9): ((3, 2, 1, 0), (1, 0, 2, 3), (2, 3, 0, 1), (0, 1, 3, 2)),
(4, 10): ((3, 2, 1, 0), (2, 0, 3, 1), (1, 3, 0, 2), (0, 1, 2, 3)),
(4, 11): ((3, 2, 1, 0), (2, 0, 3, 1), (0, 1, 2, 3), (1, 3, 0, 2)),
(4, 12): ((3, 2, 1, 0), (2, 1, 0, 3), (1, 0, 3, 2), (0, 3, 2, 1)),
(4, 13): ((3, 2, 1, 0), (1, 3, 0, 2), (0, 1, 2, 3), (2, 0, 3, 1)),
(4, 14): ((3, 2, 1, 0), (2, 3, 0, 1), (1, 0, 2, 3), (0, 1, 3, 2)),
(4, 16): ((3, 2, 1, 0), (2, 3, 0, 1), (1, 0, 3, 2), (0, 1, 2, 3)),
(5, 5): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (4, 2, 0, 1, 3), (1, 3, 2, 0, 4), (3, 4, 1, 2, 0)),
(5, 7): ((0, 1, 3, 4, 2), (2, 0, 4, 1, 3), (4, 2, 1, 3, 0), (1, 3, 2, 0, 4), (3, 4, 0, 2, 1)),
(5, 8): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (4, 2, 1, 0, 3), (1, 3, 0, 2, 4), (3, 4, 2, 1, 0)),
(5, 9): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (3, 4, 1, 2, 0), (1, 3, 2, 0, 4), (4, 2, 0, 1, 3)),
(5, 10): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (4, 3, 2, 1, 0), (3, 2, 1, 0, 4), (1, 4, 0, 2, 3)),
(5, 11): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (4, 2, 1, 0, 3), (3, 4, 2, 1, 0), (1, 3, 0, 2, 4)),
(5, 12): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (3, 4, 2, 1, 0), (1, 3, 0, 2, 4), (4, 2, 1, 0, 3)),
(5, 13): ((0, 1, 3, 4, 2), (2, 0, 4, 3, 1), (4, 3, 2, 1, 0), (1, 4, 0, 2, 3), (3, 2, 1, 0, 4)),
(5, 14): ((0, 1, 3, 4, 2), (2, 0, 4, 1, 3), (3, 4, 2, 0, 1), (4, 2, 1, 3, 0), (1, 3, 0, 2, 4)),
(5, 15): ((0, 1, 3, 4, 2), (1, 4, 2, 3, 0), (4, 2, 0, 1, 3), (3, 0, 4, 2, 1), (2, 3, 1, 0, 4)),
(5, 16): ((0, 1, 3, 4, 2), (1, 4, 2, 3, 0), (4, 2, 1, 0, 3), (3, 0, 4, 2, 1), (2, 3, 0, 1, 4)),
(5, 17): ((0, 1, 3, 4, 2), (1, 4, 2, 3, 0), (3, 2, 4, 0, 1), (2, 3, 0, 1, 4), (4, 0, 1, 2, 3)),
(5, 18): ((0, 1, 3, 4, 2), (1, 4, 2, 3, 0), (3, 0, 4, 2, 1), (4, 2, 0, 1, 3), (2, 3, 1, 0, 4)),
(5, 19): ((0, 1, 3, 4, 2), (1, 4, 2, 3, 0), (3, 2, 4, 0, 1), (4, 0, 1, 2, 3), (2, 3, 0, 1, 4)),
(5, 20): ((0, 1, 3, 4, 2), (1, 4, 2, 0, 3), (3, 0, 4, 2, 1), (4, 2, 1, 3, 0), (2, 3, 0, 1, 4)),
(5, 21): [(3, 0, 1, 2, 4), (1, 4, 2, 0, 3), (0, 3, 4, 1, 2), (2, 1, 3, 4, 0), (4, 2, 0, 3, 1)],
(5, 22): [(3, 0, 1, 2, 4), (1, 4, 2, 0, 3), (0, 2, 4, 3, 1), (2, 1, 3, 4, 0), (4, 3, 0, 1, 2)],
(5, 23): [(3, 0, 1, 2, 4), (1, 4, 0, 3, 2), (2, 3, 4, 1, 0), (0, 2, 3, 4, 1), (4, 1, 2, 0, 3)],
(5, 25): [(4, 3, 2, 1, 0), (0, 4, 1, 3, 2), (3, 2, 4, 0, 1), (2, 1, 0, 4, 3), (1, 0, 3, 2, 4)],
    }[n, k]
    return 'POSSIBLE\n' + '\n'.join(' '.join(str(x+1) for x in row) for row in solution)

def brute():
    d = dict()

    for n in range(2, 6):
        i = 0
        for a in product(permutations(range(n)), repeat=n):
            a = list(a)
            a[0] = (3, 0, 1, 2, 4)
            trace = is_valid(a)
            if trace is not None:
                d[(n, trace + n)] = a
            i += 1
            if i % 50000 == 0:
                print(len(d), d)

    for k in sorted(d):
        print(k, d[k])

#---------------------------------------------

# brute()

# for n in range(2, 5):
#     for k in range(n, n*n+1):
#         print(n, k, run([n, k]))


def read_case():
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)



",000000000027a277.PYTHON3,4249,101,959,Python,000000000019fd27,000000000027a277,0000000000209aa0,xjcl,2020
13675,0000000000259297,"
import sys

printe = lambda *args: print(*args, file=sys.stderr)

def query(i):
    print(i + 1, flush=True)
    return int(input())

def squander_turns(n):
    for _ in range(n):
        query(0)

# Comment on has_complemented and has_reversed:
# If neither footprint is in the state we cannot tell if it has R/C-ed!
# But it does not matter because complemented() would be the identity function!
# However it is important to do a dummy query to keep the query cycle intact

def has_complemented(state):
    if (0,0) in state:
        i = state.index((0,0))
        return query(i) == 1

    if (1,1) in state:
        i = state.index((1,1))
        return query(i) == 0

    return query(0)

def has_reversed(state, _has_complemented):
    if (0,1) in state:
        i = state.index((0,1))
        return query(i) == 1 - _has_complemented

    if (1,0) in state:
        i = state.index((1,0))
        return query(i) == _has_complemented

    return query(0)

def complemented(state):
    return [(1 - el[0], 1 - el[1]) for el in state]

def reversed(state):
    return [(el[1], el[0]) for el in state]

def discover_bit_pair(state, b):
    i = len(state)
    return (query(i), query(b-1 - i))

num_test_cases, b = [int(x) for x in input().split()]

turns_needed = b//8 * 10 + b % 8
turns_allowed = 150

for _ in range(num_test_cases):
    state = []
    squander_turns(turns_allowed - turns_needed)

    # alternate: 2 turns for checking if C/R, 8 for discovering 8 new bits
    for turn_number in range(turns_allowed - turns_needed, turns_allowed, 2):

        if turn_number % 10 == 0:
            _has_complemented = has_complemented(state)
            _has_reversed = has_reversed(state, _has_complemented)

            if _has_complemented:
                state = complemented(state)
            if _has_reversed:
                state = reversed(state)

        else:
            state.append( discover_bit_pair(state, b) )

    front, back = zip(*state)
    answer = list(front) + list(back)[::-1]
    print(''.join(str(x) for x in answer))

    assert 'Y' == input()

",0000000000259297.PYTHON3,2082,81,259,Python,000000000019fd27,0000000000259297,0000000000209a9e,xjcl,2020
13676,0000000000238397,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
from itertools import *

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def run_happy_path(a):
    # hacky: rely on 'busy' being later in the alphabet than 'avail'
    events = sum(([(el[0], 'busy', i), (el[1], 'avail', i)] for i, el in enumerate(a)), [])
    free_parents = set('CJ')
    assigned = [None] * len(a)
    for _, type, i in sorted(events):
        if type == 'busy':
            assigned[i] = free_parents.pop()  # assign parent to shift
        if type == 'avail':
            free_parents.add(assigned[i])
    return ''.join(assigned)

def run(a):
    try:
        return run_happy_path(a)
    except KeyError:
        return 'IMPOSSIBLE'

#---------------------------------------------

def read_case():
    n = int(input())
    return [[int(k) for k in input().split()] for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000238397.PYTHON3,1196,38,139,Python,000000000019fd27,0000000000238397,000000000020bdf9,xjcl,2020
13677,00000000002376b1,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
from itertools import *

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def run_happy_path(a):
    # hacky: store assigned parent in common third element
    # hacky: rely on 'notfree' being later in the alphabet than 'free'
    events = sum(([(el[0], 'notfree', el), (el[1], 'free', el)] for el in a), [])
    events.sort()
    free_parents = set('CJ')
    out = ''
    for event in events:
        if event[1] == 'notfree':
            event[2][0] = free_parents.pop()  # assign parent to shift
            out += event[2][0]
        if event[1] == 'free':
            free_parents.add(event[2][0])
    return out

def run(a):
    try:
        return run_happy_path(a)
    except KeyError:
        return 'IMPOSSIBLE'

#---------------------------------------------

def read_case():
    n = int(input())
    return [[int(k) for k in input().split()] for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000002376b1.PYTHON3,1261,41,147,Python,000000000019fd27,00000000002376b1,000000000020bdf9,xjcl,2020
13678,0000000000234943,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def run(a):
    out = ''
    for prev, this in zip([0] + a, a + [0]):
        out += '(' * (this - prev) + ')' * (prev - this) + str(this)
    return out[:-1]

#---------------------------------------------

def read_case():
    return [int(k) for k in input()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + run(read_case())
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000234943.PYTHON3,694,24,90,Python,000000000019fd27,0000000000234943,0000000000209a9f,xjcl,2020
13679,0000000000231f11,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def run(a):
    a = [0] + a + [0]
    out = ''
    for prev, this in zip([0] + a, a + [0]):
        out += '(' * (this - prev) + ')' * (prev - this) + str(this)
    return out[1:-2]

#---------------------------------------------

def read_case():
    return [int(k) for k in input()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + run(read_case())
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000231f11.PYTHON3,717,25,97,Python,000000000019fd27,0000000000231f11,0000000000209a9f,xjcl,2020
13680,00000000002307df,"for i in range(int(input())):
    print(input().replace('1', '(1)'))
",00000000002307df.PYTHON3,69,3,6,Python,000000000019fd27,00000000002307df,0000000000209a9f,xjcl,2020
13681,0000000000230463,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

def run(a):
    return (
        sum(a[i][i] for i in range(len(a))),
        sum(len(set(row)) != len(a) for row in a),
        sum(len(set(col)) != len(a) for col in zip(*a)),
    )

#---------------------------------------------

def read_case():
    n = int(input())
    return [[int(k) for k in input().split()] for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + ' '.join(str(x) for x in run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000230463.PYTHON3,794,26,94,Python,000000000019fd27,0000000000230463,000000000020993c,xjcl,2020
341337,00000000002c3018,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    Just walk along either the left or right edge of the Pascal Triangle
    in case N = 501 use the 2 in the middle

Visible 2
    Can probably do with the 2 leftmost lanes of the Pascal Triangle
    Just pick 2,3,4,5 and safely escape to the 1s on the left
        to fill up the rest

Visible 3
    ISN'T THIS DYNAMIC PROGRAMMING!?! :O
    Also don't forget you can WALK BACK UP

    Each row has twice the sum as the row before
        -> use binary decomposition
        sum([x for x in range(len(bin(10**9)))]) = 496 < 500 !!
        seems like it could work in our case!!
        => take whole row for 1, take nothing from row for 0

    difficulty with the binary expansion
        we can't just ignore whole rows
        we have to add at least 1 per row
        we COULD skip 1s in rows we fully take to make up for this
            but for this we need the expansion to be at least half 1s
        if we just subtract say 30 (we have 30 bits maximum)
            we might run into paths longer than 500
'''

def run(n):
    if n < 40:
        return ''.join(['\n' + str(1+j) + ' ' + str(1) for j in range(n)])

    out = []
    summy = 0
    from_right = False

    bits = bin(n - 30)[:1:-1]

    for i, b in enumerate(bits):
        if b == '1':
            out += ['\n' + str(i+1) + ' ' + str(c+1) for c in (reversed if from_right else lambda x: x)(range(i+1))]
            summy += 2**i
            from_right = not from_right

        else:
            out += ['\n' + str(i+1) + ' ' + str(i+1 if from_right else 1)]
            summy += 1

    assert summy <= n

    out += ['\n' + str(i+1+j+1) + ' ' + str(i+1+j+1 if from_right else 1) for j in range(n - summy)]

    assert len(out) <= 500

    return ''.join(out)


# # for i in range(536870911 - 50, 536870911 + 50):
# # for i in range(536870911 - 50, 10**9 + 1):
# for i in range(502):
#     print(i, run(i))
#     exit(1)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)

",00000000002c3018.PYTHON3,2435,83,387,Python,000000000019fd74,00000000002c3018,00000000002b1353,xjcl,2020
341338,00000000002c2348,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    Just walk along either the left or right edge of the Pascal Triangle
    in case N = 501 use the 2 in the middle

Visible 2
    Can probably do with the 2 leftmost lanes of the Pascal Triangle
    Just pick 2,3,4,5 and safely escape to the 1s on the left
        to fill up the rest

Visible 3
    ISN'T THIS DYNAMIC PROGRAMMING!?! :O
    Also don't forget you can WALK BACK UP

    Each row has twice the sum as the row before
        -> use binary decomposition
        sum([x for x in range(len(bin(10**9)))]) = 496 < 500 !!
        seems like it could work in our case!!
        => take whole row for 1, take nothing from row for 0

    difficulty with the binary expansion
        we can't just ignore whole rows
        we have to add at least 1 per row
        we COULD skip 1s in rows we fully take to make up for this
            but for this we need the expansion to be at least half 1s
        if we just subtract say 30 (we have 30 bits maximum)
            we might run into paths longer than 500
'''

def run(n):
    if n < 40:
        return ''.join(['\n' + str(1+j) + ' ' + str(1) for j in range(n)])

    out = []
    summy = 0
    from_right = False

    bits = bin(n - 30)[:1:-1]

    for i, b in enumerate(bits):
        if b == '1':
            out += ['\n' + str(i+1) + ' ' + str(c+1) for c in (reversed if from_right else lambda x: x)(range(i+1))]
            summy += 2**i
            from_right = not from_right

        else:
            out += ['\n' + str(i+1) + ' ' + str(i+1 if from_right else 1)]
            summy += 1

    assert summy <= n

    out += ['\n' + str(i+1+j) + ' ' + str(i+1+j if from_right else 1) for j in range(n - summy)]

    assert len(out) <= 500

    return ''.join(out)


for i in range(536870911 - 50, 536870911 + 50):
# for i in range(536870911 - 50, 10**9 + 1):
    run(i)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)

",00000000002c2348.PYTHON3,2376,81,375,Python,000000000019fd74,00000000002c2348,00000000002b1353,xjcl,2020
341339,00000000002b9b9c,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    Just walk along either the left or right edge of the Pascal Triangle
    in case N = 501 use the 2 in the middle

Visible 2
    Can probably do with the 2 leftmost lanes of the Pascal Triangle
    Just pick 2,3,4,5 and safely escape to the 1s on the left
        to fill up the rest

Visible 3
    ISN'T THIS DYNAMIC PROGRAMMING!?! :O
    Also don't forget you can WALK BACK UP
'''

def run(n):
    if n == 1:
        return '\n1 1'

    out = ['\n1 1', '\n2 2']

    cur = n - 2
    next = 2
    while cur - next >= 0:
        out.append('\n' + str(next+1) + ' 2')
        cur -= next
        next += 1

    out += ['\n' + str(next + row) + ' 1' for row in range(cur)]

    return ''.join(out)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)

",00000000002b9b9c.PYTHON3,1241,51,185,Python,000000000019fd74,00000000002b9b9c,00000000002b1353,xjcl,2020
341340,00000000002b98e7,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    Just walk along either the left or right edge of the Pascal Triangle
    in case N = 501 use the 2 in the middle

Visible 2
    Can probably do with the 2 leftmost lanes of the Pascal Triangle
    Just pick 2,3,4,5 and safely escape to the 1s on the left
        to fill up the rest

Visible 3
    ISN'T THIS DYNAMIC PROGRAMMING!?! :O
    Also don't forget you can WALK BACK UP
'''

def run(n):
    if n == 1:
        return '\n1 1'

    out = ['\n1 1', '\n2 1']

    cur = n - 2
    next = 2
    while cur - next >= 0:
        out.append('\n' + str(next+1) + ' 2')
        cur -= next
        next += 1

    out += ['\n' + str(next + row) + ' 1' for row in range(cur)]

    return ''.join(out)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)

# 5 2 last for 11
",00000000002b98e7.PYTHON3,1259,52,191,Python,000000000019fd74,00000000002b98e7,00000000002b1353,xjcl,2020
341341,00000000002b90a2,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    Just walk along either the left or right edge of the Pascal Triangle
    in case N = 501 use the 2 in the middle

Visible 2
    Can probably do with the 2 leftmost lanes of the Pascal Triangle
    Just pick 2,3,4,5 and safely escape to the 1s on the left
        to fill up the rest

Visible 3
    ISN'T THIS DYNAMIC PROGRAMMING!?! :O
    Also don't forget you can WALK BACK UP
'''

def run(n):
    if n == 1:
        return '\n1 1'

    out = ['\n1 1', '\n2 1']

    cur = n - 2
    next = 2
    while cur - next >= 0:
        out.append('\n' + str(next+1) + ' 2')
        cur -= next
        next += 1
        print(cur, next)

    out += ['\n' + str(next + 1 + row) + ' 1' for row in range(cur)]

    return ''.join(out)

#---------------------------------------------

def read_case():
    return int(input())

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)

# 5 2 last for 11
",00000000002b90a2.PYTHON3,1288,53,195,Python,000000000019fd74,00000000002b90a2,00000000002b1353,xjcl,2020
341342,00000000002b5e49,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    They all have to be suffixes of the longest string
    Then just take the longest string

Visible 2
    There is one * per word
        => everything before the * MUST be the start of the word (from first char)
        everything after the * MUST be the end of the word (form last char)
    problem: how to account for overlap betwen start and end?
        e.g.  'a' * 9999 + '*'  and  '*' + 'a' * 9999
        an additional   'a' * 9999 + 'b' + '*'  would break that!
        ok to just do a greedy post-processing step?
            be careful of O(N^2) here...
            only do the step if len(front+back) > 10_000
            ha! because of the constraints we do not even need this!
                => always return  front+back !
                => same algo as Visible 1, just for both ends

Visible 3
    The limits mean each of the 50 patterns cannot add more than 100 chars
        -> 5_000 chars total
    So just like with Visible 2 it should be enough to match on front and back
        then insert middle chars in ANY ORDER!!
    =)
'''

def run(a):
    fronts, mids, backs = zip(*[(groups[0], groups[1:-1], groups[-1]) for groups in a])
    backs = [back[::-1] for back in backs]

    max_front = max(fronts)
    for front in fronts:
        if not max_front.startswith(front):
            return '*'

    max_backs = max(backs)
    for back in backs:
        if not max_backs.startswith(back):
            return '*'

    return max_front + ''.join(sum(mids, [])) + max_backs[::-1]

#---------------------------------------------

def read_case():
    n = int(input())
    return [input().split('*') for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000002b5e49.PYTHON3,2090,62,294,Python,000000000019fd74,00000000002b5e49,00000000002b3034,xjcl,2020
341343,00000000002b498f,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
Visible 1
    They all have to be suffixes of the longest string
    Then just take the longest string

Visible 2
    There is one * per word
        => everything before the * MUST be the start of the word (from first char)
        everything after the * MUST be the end of the word (form last char)
    problem: how to account for overlap betwen start and end?
        e.g.  'a' * 9999 + '*'  and  '*' + 'a' * 9999
        an additional   'a' * 9999 + 'b' + '*'  would break that!
        ok to just do a greedy post-processing step?
            be careful of O(N^2) here...
            only do the step if len(front+back) > 10_000
            ha! because of the constraints we do not even need this!
                => always return  front+back !
                => same algo as Visible 1, just for both ends

Visible 3
    The limits mean each of the 50 patterns cannot add more than 100 chars
        -> 5_000 chars total
    So just like with Visible 2 it should be enough to match on front and back
        then insert middle chars in ANY ORDER!!
'''

def run(a):
    print(a)
    fronts, backs = zip(*a)
    backs = [back[::-1] for back in backs]
    out = ''

    max_front = max(fronts)
    for front in fronts:
        if not max_front.startswith(front):
            return '*'

    max_backs = max(backs)
    for back in backs:
        if not max_backs.startswith(back):
            return '*'

    return max_front + max_backs[::-1]

#---------------------------------------------

def read_case():
    n = int(input())
    return [input().split('*') for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000002b498f.PYTHON3,2024,63,287,Python,000000000019fd74,00000000002b498f,00000000002b3034,xjcl,2020
396627,0000000000307396,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

t, a, b = [int(x) for x in input().split()]

def case():

    for x in range(-6, 7):

        for y in range(-6, 7):

            print(x, y, flush=True)
            answer = input()

            print(x, y, answer, file=sys.stderr)

            if 'CENTER' in answer:
                return


def case():

    x0, y0 = None, None

    for x in range(100):

        print(-10**9 + x, 0, flush=True)

        if input() == 'HIT':
            break


    for y in range(100):

        print(0, y - 10**9, flush=True)

        if input() == 'HIT':
            break

    print(x, y, file=sys.stderr)

    print(x - 50, y - 50, flush=True)

    assert 'CENTER' == input()


for _ in range(t):
    case()
",0000000000307396.PYTHON3,969,54,117,Python,000000000019fef2,0000000000307396,00000000002d5b63,xjcl,2020
396628,0000000000306787,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
# print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

t, a, b = [int(x) for x in input().split()]

def case():

    for x in range(-6, 7):

        for y in range(-6, 7):

            print(x, y, flush=True)
            answer = input()

            print(x, y, answer, file=sys.stderr)

            if 'CENTER' in answer:
                return


for _ in range(t):
    case()
",0000000000306787.PYTHON3,593,28,68,Python,000000000019fef2,0000000000306787,00000000002d5b63,xjcl,2020
396629,0000000000304d86,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
import math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
observations
    - i'm old enough to remember the very similar Pogo from Code Jam 2013
        - that used 1,2,3,4,5, instead of 1,2,4,8,
    - cases are rotationally symmetric to x>=0 y>=0
    - each jump is bigger than all previous jumps combined
        - in fact it is one bigger than the sum of previous
        - so hopefully no tricky solutions like in old pogo?
    - i bet this ends up with the binary repr of those numbers
        - or the negated one?
    - EXACTLY ONLY ONE NUMBER MUST BE ODD
        since we always add even numbers except for 1

ONLY 2 POSSIBILITIES
    - WE CAN MAKE EACH POWER-OF-TWO DIRECTLY
    - WE CAN MAKE EACH INTERMEDIATE NUMBER IN EXACTLY 2 WAYS
        ONE FROM BELOW (only +s), ONE FROM ABOVE (next power-of-two)
        3 --  1+2, -1+4
        5 --  1+4, -1-2+8
        6 --  2+4, -2+8
        7 --  1+2+4, -1+8
        ...
        there are more ways, but only sub-optimal ones
            e.g. 2 as -2+4, 5 as -1-2-8+16
        => match both compositions to see if both numbers are used
            WE CAN USE XOR FOR THIS!!
            just take care to output negative dir for the second decomp

rushed ugly solution sorry =(
    i know C++ bros are laughing rn...

WA Wrong Answer
    looking at the test cases, i get a wrong answer for (1, 4)
    => he cannot see that 1 can be made in two ways
    => special treatment needed for 2^0 = 1  -> max(1, ...)

WA Wrong Answer on Visible 2
    -> e.g. 13 (0b1101) can be made in 3 ways =/
        1+4+8, -1+2+4+8, 16...
    => 13,0 test case
    can we patch the existing approach
        => any 1 can infect any number of 0s to the left of it
            (turns them into 1s)
        => the whole number can be complemented and 1 added ('from_above')

7 ways to make 18
    32 16 8  4  2  1
    ----------------
       1  0  0  1  0  <-- start
       1  0  1 -1  0
       1  1 -1 -1  0
    1  0 -1 -1 -1  0  <-- push the +1 by one to the left, carry the 1...  ('from_above')

    1 -1  0  0  1  0  <-- from 'start' but push the 16s 1 left
    1 -1  0  1 -1  0
    1 -1  1 -1 -1  0  <-- cannot push from +1 into -1 ?

    friick
    18,17

'''

bin = lambda x: __builtins__.bin(x)[2:]  # cut off '0b'

def return_rectified(x, y, x_inverted, y_inverted):
    xs = [{'1':'E', '-1':'W', '0':'0'}[el] for el in x]
    ys = [{'1':'N', '-1':'S', '0':'0'}[el] for el in y]
    if x_inverted:  xs = [{'W':'E', 'E':'W', '0':'0'}[el] for el in xs]
    if y_inverted:  ys = [{'N':'S', 'S':'N', '0':'0'}[el] for el in ys]
    return ''.join(reversed([max(a,b) for a,b in zip(xs,ys) if max(a,b) != '0']))

from copy import deepcopy

solution = None

def add1(ls):
    out = deepcopy(ls)
    for i in reversed(range(len(out))):
        if out[i] == '0':
            out[i] = '1'
            return out
        else:
            out[i] = '0'
    assert False

def _try(xb, yb, i, win):

    if i == 0:
        assert False

    if xb[i] != yb[i]:
        _try(xb, yb, i-1, win)

    if xb[i] == yb[i] == '0':
        if i < win:
            global solution
            solution = (xb, yb)
            return
        if i == 40:  return
        if xb[i+1] == '1':  _try(xb[:i] + ['1', '-1'] + xb[i+2:], yb, i-1, win)
        if yb[i+1] == '1':  _try(xb, yb[:i] + ['1', '-1'] + yb[i+2:], i-1, win)

    if xb[i] == yb[i] == '1':
        if i == 40:  return
        if xb[i+1] == '1':  _try(add1(xb[:i]) + ['0', '-1'] + xb[i+2:], yb, i-1, win)
        if yb[i+1] == '1':  _try(xb, add1(yb[:i]) + ['0', '-1'] + yb[i+2:], i-1, win)


def run(case):
    x, y = case
    xa, ya = abs(x), abs(y)
    xb, yb = list(bin(xa).zfill(41)), list(bin(ya).zfill(41))
    ret = []
    win = min(xb.index('1') if '1' in xb else 999, yb.index('1') if '1' in yb else 999)

    global solution
    solution = None

    _try(xb, yb, 40, win)

    if solution:
        return return_rectified(solution[0], solution[1], x != xa, y != ya)

    return 'IMPOSSIBLE'


#---------------------------------------------

for x in range(20):
    for y in range(5):
        print('----')
        print('Input:', x, y)
        print(run([x,y]))

'''
from itertools import *
a = list(product([-1, 0, 1], repeat=6))
for b in a:
    z = sum(x*y for x,y in zip(b, [32,16,8,4,2,1]))
    if z == 18:
        print(z, b)

print(run([18, 17]))
'''

#---------------------------------------------

def read_case():
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000304d86.PYTHON3,4848,164,747,Python,000000000019fef2,0000000000304d86,00000000002d5b62,xjcl,2020
396630,0000000000304642,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
import math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
observations
    - i'm old enough to remember the very similar Pogo from Code Jam 2013
        - that used 1,2,3,4,5, instead of 1,2,4,8,
    - cases are rotationally symmetric to x>=0 y>=0
    - each jump is bigger than all previous jumps combined
        - in fact it is one bigger than the sum of previous
        - so hopefully no tricky solutions like in old pogo?
    - i bet this ends up with the binary repr of those numbers
        - or the negated one?
    - EXACTLY ONLY ONE NUMBER MUST BE ODD
        since we always add even numbers except for 1

ONLY 2 POSSIBILITIES
    - WE CAN MAKE EACH POWER-OF-TWO DIRECTLY
    - WE CAN MAKE EACH INTERMEDIATE NUMBER IN EXACTLY 2 WAYS
        ONE FROM BELOW (only +s), ONE FROM ABOVE (next power-of-two)
        3 --  1+2, -1+4
        5 --  1+4, -1-2+8
        6 --  2+4, -2+8
        7 --  1+2+4, -1+8
        ...
        there are more ways, but only sub-optimal ones
            e.g. 2 as -2+4, 5 as -1-2-8+16
        => match both compositions to see if both numbers are used
            WE CAN USE XOR FOR THIS!!
            just take care to output negative dir for the second decomp

rushed ugly solution sorry =(
    i know C++ bros are laughing rn...

WA Wrong Answer
    looking at the test cases, i get a wrong answer for (1, 4)
    => he cannot see that 1 can be made in two ways
    => special treatment needed for 2^0 = 1  -> max(1, ...)

WA Wrong Answer on Visible 2
    -> e.g. 13 (0b1101) can be made in 3 ways =/
        1+4+8, -1+2+4+8, 16...
    => 13,0 test case
    can we patch the existing approach
        => any 1 can infect any number of 0s to the left of it
            (turns them into 1s)
        => the whole number can be complemented and 1 added ('from_above')

7 ways to make 18
    32 16 8  4  2  1
    ----------------
       1  0  0  1  0  <-- start
       1  0  1 -1  0
       1  1 -1 -1  0
    1  0 -1 -1 -1  0  <-- push the +1 by one to the left, carry the 1...  ('from_above')

    1 -1  0  0  1  0  <-- from 'start' but push the 16s 1 left
    1 -1  0  1 -1  0
    1 -1  1 -1 -1  0  <-- cannot push from +1 into -1 ?

    friick
    18,17

'''

bin = lambda x: __builtins__.bin(x)[2:]  # cut off '0b'

def return_rectified(x, y, x_inverted, y_inverted):
    xs = [{'1':'E', '-1':'W', '0':'0'}[el] for el in x]
    ys = [{'1':'N', '-1':'S', '0':'0'}[el] for el in y]
    if x_inverted:  xs = [{'W':'E', 'E':'W', '0':'0'}[el] for el in xs]
    if y_inverted:  ys = [{'N':'S', 'S':'N', '0':'0'}[el] for el in ys]
    return ''.join(reversed([max(a,b) for a,b in zip(xs,ys) if max(a,b) != '0']))

from copy import deepcopy

solution = None

def _try(xb, yb, i, win):

    if i == 0:
        assert False

    if xb[i] != yb[i]:
        _try(xb, yb, i-1, win)

    if xb[i] == yb[i] == '0':
        if i < win:
            global solution
            solution = (xb, yb)
            return
        if i == 40:  return
        if xb[i+1] == '1':  _try(xb[:i] + ['1', '-1'] + xb[i+2:], yb, i-1, win)
        if yb[i+1] == '1':  _try(xb, yb[:i] + ['1', '-1'] + yb[i+2:], i-1, win)

    if xb[i] == yb[i] == '1':
        if i == 40:  return
        if xb[i+1] == '1':  _try(xb[:i-1] + ['1', '0', '-1'] + xb[i+2:], yb, i-1, win)
        if yb[i+1] == '1':  _try(xb, yb[:i-1] + ['1', '0', '-1'] + yb[i+2:], i-1, win)


def run(case):
    x, y = case
    xa, ya = abs(x), abs(y)
    xb, yb = list(bin(xa).zfill(41)), list(bin(ya).zfill(41))
    ret = []
    win = min(xb.index('1') if '1' in xb else 999, yb.index('1') if '1' in yb else 999)

    global solution
    solution = None

    _try(xb, yb, 40, win)

    if solution:
        return return_rectified(solution[0], solution[1], x != xa, y != ya)

    return 'IMPOSSIBLE'


#---------------------------------------------

for x in range(20):
    for y in range(5):
        print('----')
        print('Input:', x, y)
        print(run([x,y]))

'''
from itertools import *
a = list(product([-1, 0, 1], repeat=6))
for b in a:
    z = sum(x*y for x,y in zip(b, [32,16,8,4,2,1]))
    if z == 18:
        print(z, b)

print(run([18, 17]))
'''

#---------------------------------------------

def read_case():
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000304642.PYTHON3,4642,154,725,Python,000000000019fef2,0000000000304642,00000000002d5b62,xjcl,2020
396631,00000000002fb9bd,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
import math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
observations
    - i'm old enough to remember the very similar Pogo from Code Jam 2013
        - that used 1,2,3,4,5, instead of 1,2,4,8,
    - cases are rotationally symmetric to x>=0 y>=0
    - each jump is bigger than all previous jumps combined
        - in fact it is one bigger than the sum of previous
        - so hopefully no tricky solutions like in old pogo?
    - i bet this ends up with the binary repr of those numbers
        - or the negated one?
    - EXACTLY ONLY ONE NUMBER MUST BE ODD
        since we always add even numbers except for 1

ONLY 2 POSSIBILITIES
    - WE CAN MAKE EACH POWER-OF-TWO DIRECTLY
    - WE CAN MAKE EACH INTERMEDIATE NUMBER IN EXACTLY 2 WAYS
        ONE FROM BELOW (only +s), ONE FROM ABOVE (next power-of-two)
        3 --  1+2, -1+4
        5 --  1+4, -1-2+8
        6 --  2+4, -2+8
        7 --  1+2+4, -1+8
        ...
        there are more ways, but only sub-optimal ones
            e.g. 2 as -2+4, 5 as -1-2-8+16
        => match both compositions to see if both numbers are used
            WE CAN USE XOR FOR THIS!!
            just take care to output negative dir for the second decomp

rushed ugly solution sorry =(
    i know C++ bros are laughing rn...

WA Wrong Answer
    looking at the test cases, i get a wrong answer for (1, 4)
    => he cannot see that 1 can be made in two ways
    => special treatment needed for 2^0 = 1  -> max(1, ...)
'''

bin = lambda x: __builtins__.bin(x)[2:]  # cut off '0b'

def decompositions(num):
    '''bonus: from_below == from_above for pows of 2 =)'''
    if num == 0:  return (0, 0)
    from_below = num
    next_pow_of_two = 2**math.ceil(max(1, math.log(num, 2)))
    from_above = next_pow_of_two + (next_pow_of_two - num)
    return from_below, from_above

def return_rectified(x, y, x_from_above, y_from_above, x_inverted, y_inverted):
    xs = bin(x).replace('1', 'E').zfill(40)
    ys = bin(y).replace('1', 'N').zfill(40)

    if x_from_above:
        xs = list(xs.replace('E', 'W'))
        xs[xs.index('W')] = 'E'  # only most-significant-digit is positive
        xs = ''.join(xs)
    if y_from_above:
        ys = list(ys.replace('N', 'S'))
        ys[ys.index('S')] = 'N'  # only most-significant-digit is positive
        ys = ''.join(ys)

    if x_inverted:  xs = xs.replace('E', 'X').replace('W', 'E').replace('X', 'W')
    if y_inverted:  ys = ys.replace('N', 'X').replace('S', 'N').replace('X', 'S')
    return ''.join(reversed([max(a,b) for a,b in zip(xs,ys) if max(a,b) != '0']))

def run(case):
    x, y = case
    xa, ya = abs(x), abs(y)

    xad = decompositions(xa)
    yad = decompositions(ya)
    assert xad[0] <= xad[1]
    assert yad[0] <= yad[1]

    # print(xad, yad)
    # print(bin(xad[0]), bin(xad[1]), bin(yad[0]), bin(yad[1]))

    # the first number will be smaller, so preferably choose [0] over [1]!
    for xi in [0, 1]:
        for yi in [0, 1]:
            if '0' not in bin(xad[xi] ^ yad[yi]) and xad[xi] ^ yad[yi] >= max(xad[xi], yad[yi]):
                return return_rectified(xad[xi], yad[yi], xi, yi, xa != x, ya != y)

    return 'IMPOSSIBLE'

'''
for x in range(5):
    for y in range(5):
        print('----')
        print('Input:', x, y)
        print(run([x,y]))
'''

#---------------------------------------------

def read_case():
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000002fb9bd.PYTHON3,3782,111,519,Python,000000000019fef2,00000000002fb9bd,00000000002d5b62,xjcl,2020
396632,00000000002faca2,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect
import math

lineno = lambda: inspect.currentframe().f_back.f_back.f_lineno
print = lambda *a, **k: __builtins__.print(str(lineno())+':', *a, file=sys.stderr, **k)

#---------------------------------------------

'''
observations
    - i'm old enough to remember the very similar Pogo from Code Jam 2013
        - that used 1,2,3,4,5, instead of 1,2,4,8,
    - cases are rotationally symmetric to x>=0 y>=0
    - each jump is bigger than all previous jumps combined
        - in fact it is one bigger than the sum of previous
        - so hopefully no tricky solutions like in old pogo?
    - i bet this ends up with the binary repr of those numbers
        - or the negated one?
    - EXACTLY ONLY ONE NUMBER MUST BE ODD
        since we always add even numbers except for 1

ONLY 2 POSSIBILITIES
    - WE CAN MAKE EACH POWER-OF-TWO DIRECTLY
    - WE CAN MAKE EACH INTERMEDIATE NUMBER IN EXACTLY 2 WAYS
        ONE FROM BELOW (only +s), ONE FROM ABOVE (next power-of-two)
        3 --  1+2, -1+4
        5 --  1+4, -1-2+8
        6 --  2+4, -2+8
        7 --  1+2+4, -1+8
        ...
        there are more ways, but only sub-optimal ones
            e.g. 2 as -2+4, 5 as -1-2-8+16
        => match both compositions to see if both numbers are used
            WE CAN USE XOR FOR THIS!!
            just take care to output negative dir for the second decomp

rushed ugly solution sorry =(
    i know C++ bros are laughing rn...
'''

bin = lambda x: __builtins__.bin(x)[2:]  # cut off '0b'

def decompositions(num):
    '''bonus: from_below == from_above for pows of 2 =)'''
    if num == 0:  return (0, 0)
    from_below = num
    next_pow_of_two = 2**math.ceil(math.log(num, 2))
    from_above = next_pow_of_two + (next_pow_of_two - num)
    return from_below, from_above

def return_rectified(x, y, x_from_above, y_from_above, x_inverted, y_inverted):
    xs = bin(x).replace('1', 'E').zfill(40)
    ys = bin(y).replace('1', 'N').zfill(40)

    if x_from_above:
        xs = list(xs.replace('E', 'W'))
        xs[xs.index('W')] = 'E'  # only most-significant-digit is positive
        xs = ''.join(xs)
    if y_from_above:
        ys = list(ys.replace('N', 'S'))
        ys[ys.index('S')] = 'N'  # only most-significant-digit is positive
        ys = ''.join(ys)

    if x_inverted:  xs = xs.replace('E', 'X').replace('W', 'E').replace('X', 'W')
    if y_inverted:  ys = ys.replace('N', 'X').replace('S', 'N').replace('X', 'S')
    return ''.join(reversed([max(a,b) for a,b in zip(xs,ys) if max(a,b) != '0']))

def run(case):
    x, y = case
    xa, ya = abs(x), abs(y)

    xad = decompositions(xa)
    yad = decompositions(ya)
    assert xad[0] <= xad[1]
    assert yad[0] <= yad[1]

    # print(xad, yad)
    # print(bin(xad[0]), bin(xad[1]), bin(yad[0]), bin(yad[1]))

    # the first number will be smaller, so preferably choose [0] over [1]!
    for xi in [0, 1]:
        for yi in [0, 1]:
            if '0' not in bin(xad[xi] ^ yad[yi]) and xad[xi] ^ yad[yi] >= max(xad[xi], yad[yi]):
                return return_rectified(xad[xi], yad[yi], xi, yi, xa != x, ya != y)

    return 'IMPOSSIBLE'


#---------------------------------------------

def read_case():
    return [int(k) for k in input().split()]

for i in range(int(input())):
    outstr = 'Case #' + str(i+1) + ': ' + str(run(read_case()))
    # print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000002faca2.PYTHON3,3454,99,464,Python,000000000019fef2,00000000002faca2,00000000002d5b62,xjcl,2020
434787,0000000000328833,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options_min = 999999999999999999

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            for j in range(sl_mul):

                total_cuts += 1  # N-1 cuts to cut a slice into N pieces
                if j == sl_mul - 1:  total_cuts -= 1
                total_produced += 1

                print([sl_mul, sl_count], total_cuts, total_produced)

                # optimally divide the identical slices
                divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
                cuts_for_division = total_cuts + diners - diners // divide_into_n
                # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
                options_min = min(options_min, cuts_for_division)

            if total_produced >= diners:
                options_min = min(options_min, old_total_cuts + (diners - old_total_produced))  # NEEDED
                options_min = min(options_min, total_cuts)
                return options_min

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options_min = min(options_min, total_cuts + (diners - total_produced))

    return options_min


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000328833.PYTHON3,3642,106,474,Python,000000000019fef4,0000000000328833,00000000003172d1,xjcl,2020
434788,00000000003280ef,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            for j in range(sl_mul):

                total_cuts += 1  # N-1 cuts to cut a slice into N pieces
                if j == sl_mul - 1:  total_cuts -= 1
                total_produced += 1

                print([sl_mul, sl_count], total_cuts, total_produced)

                # optimally divide the identical slices
                divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
                cuts_for_division = total_cuts + diners - diners // divide_into_n
                # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
                options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))  # NEEDED
                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000003280ef.PYTHON3,3626,108,466,Python,000000000019fef4,00000000003280ef,00000000003172d1,xjcl,2020
434789,00000000003276d9,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))  # NEEDED
                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000003276d9.PYTHON3,3520,105,455,Python,000000000019fef4,00000000003276d9,00000000003172d1,xjcl,2020
434790,000000000032793b,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                # options.append(old_total_cuts + (diners - old_total_produced))  # NEEDED
                free_cuts = sum([x // target for x in slices if x % target != 0]) + \
                    sum([slice // target for slice in slices if slice % target == 0 and slice // target > sl_mul]) + \
                    (sl_count - i) * sl_mul
                if free_cuts >= (diners - old_total_produced):
                    options.append(old_total_cuts + (diners - old_total_produced))
                print('XXXXXXXXX', free_cuts, (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000032793b.PYTHON3,3995,112,515,Python,000000000019fef4,000000000032793b,00000000003172d1,xjcl,2020
434791,0000000000326d36,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))  # NEEDED
                # free_cuts = sum([x // target for x in slices if x % target != 0]) + \
                #     sum([slice // target for slice in slices if slice % target == 0 and slice // target > sl_mul]) + \
                #     (sl_count - 1 - i) * sl_mul
                # if free_cuts >= (diners - old_total_produced):
                #     options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    # free_cuts = sum([x // target for x in slices if x % target != 0])
    # if free_cuts >= (diners - total_produced):
    #     options.append(total_cuts + (diners - total_produced))
    options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000326d36.PYTHON3,3995,112,524,Python,000000000019fef4,0000000000326d36,00000000003172d1,xjcl,2020
434792,0000000000326677,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))
                # free_cuts = sum([x // target for x in slices if x % target != 0]) + \
                #     sum([slice // target for slice in slices if slice % target == 0 and slice // target > sl_mul]) + \
                #     (sl_count - 1 - i) * sl_mul
                # if free_cuts >= (diners - old_total_produced):
                #     options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000326677.PYTHON3,3920,111,514,Python,000000000019fef4,0000000000326677,00000000003172d1,xjcl,2020
434793,0000000000326a1a,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                # options.append(old_total_cuts + (diners - old_total_produced))
                free_cuts = sum([x // target for x in slices if x % target != 0]) + \
                    sum([slice // target for slice in slices if slice % target == 0 and slice // target > sl_mul]) + \
                    (sl_count - 1 - i) * sl_mul
                if free_cuts >= (diners - old_total_produced):
                    options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000326a1a.PYTHON3,3912,111,510,Python,000000000019fef4,0000000000326a1a,00000000003172d1,xjcl,2020
434794,0000000000326906,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for i in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                # options.append(old_total_cuts + (diners - old_total_produced))
                free_cuts = sum([x // target for x in slices if x % target != 0]) + \
                    sum([slice // target for slice in slices if slice % target == 0 and slice // target > sl_mul]) + \
                    (sl_count - 1 - i)
                if free_cuts >= (diners - old_total_produced):
                    options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000326906.PYTHON3,3903,111,508,Python,000000000019fef4,0000000000326906,00000000003172d1,xjcl,2020
434795,0000000000325f92,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                # options.append(old_total_cuts + (diners - old_total_produced))
                free_cuts = sum([x // target for x in slices if x % target != 0])
                if free_cuts >= (diners - old_total_produced):
                    options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000325f92.PYTHON3,3741,109,480,Python,000000000019fef4,0000000000325f92,00000000003172d1,xjcl,2020
434796,0000000000325aa0,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))
                # free_cuts = sum([x // (target * sl_mul) for x in slices if x % target != 0])
                # if free_cuts >= (diners - old_total_produced):
                #     options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000325aa0.PYTHON3,3756,109,484,Python,000000000019fef4,0000000000325aa0,00000000003172d1,xjcl,2020
434797,0000000000325c1b,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                # options.append(old_total_cuts + (diners - old_total_produced))
                free_cuts = sum([x // (target * sl_mul) for x in slices if x % target != 0])
                if free_cuts >= (diners - old_total_produced):
                    options.append(old_total_cuts + (diners - old_total_produced))

                options.append(total_cuts)
                print('RET1', options)
                return min(options)

    # NEEDED
    free_cuts = sum([x // target for x in slices if x % target != 0])
    if free_cuts >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000325c1b.PYTHON3,3752,109,482,Python,000000000019fef4,0000000000325c1b,00000000003172d1,xjcl,2020
434798,00000000003250f1,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))
                options.append(total_cuts)
                print('RET1', options)
                return min(options)


    # left = sum([(x > target and x % target != 0) for x in slices])
    # if left >= (diners - total_produced):
    #     options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000003250f1.PYTHON3,3496,105,454,Python,000000000019fef4,00000000003250f1,00000000003172d1,xjcl,2020
434799,0000000000325581,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                # options.append(old_total_cuts + (diners - old_total_produced))
                options.append(total_cuts)
                print('RET1', options)
                return min(options)


    # left = sum([(x > target and x % target != 0) for x in slices])
    # if left >= (diners - total_produced):
    #     options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000325581.PYTHON3,3498,105,455,Python,000000000019fef4,0000000000325581,00000000003172d1,xjcl,2020
434800,000000000032529e,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced - 1) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))
                options.append(total_cuts)
                print('RET1', options)
                return min(options)


    left = sum([(x > target and x % target != 0) for x in slices])
    if left >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000032529e.PYTHON3,3490,105,451,Python,000000000019fef4,000000000032529e,00000000003172d1,xjcl,2020
434801,00000000003243a7,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)

            # optimally divide the identical slices
            divide_into_n = (diners + total_produced) // total_produced  # math.ceil
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)
            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))
                options.append(total_cuts)
                print('RET1', options)
                return min(options)


    left = sum([(x > target and x % target != 0) for x in slices])
    if left >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000003243a7.PYTHON3,3486,105,449,Python,000000000019fef4,00000000003243a7,00000000003172d1,xjcl,2020
434802,000000000032405c,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        for _ in range(sl_count):

            old_total_cuts = total_cuts
            old_total_produced = total_produced

            total_cuts += (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
            total_produced += sl_mul

            print([sl_mul, sl_count], total_cuts, total_produced)


            # optimally divide the identical slices
            divide_into_n = math.ceil(diners / total_produced)
            cuts_for_division = total_cuts + diners - diners // divide_into_n
            # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)

            options.append(cuts_for_division)

            if total_produced >= diners:
                options.append(old_total_cuts + (diners - old_total_produced))
                options.append(total_cuts)
                print('RET1', options)
                return min(options)


    left = sum([(x > target and x % target != 0) for x in slices])
    if left >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000032405c.PYTHON3,3466,107,445,Python,000000000019fef4,000000000032405c,00000000003172d1,xjcl,2020
434803,0000000000323bd0,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        old_total_cuts = total_cuts
        old_total_produced = total_produced

        total_cuts += sl_count * (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
        total_produced += sl_count * sl_mul

        print([sl_mul, sl_count], total_cuts, total_produced)


        # optimally divide the identical slices
        divide_into_n = math.ceil(diners / total_produced)
        cuts_for_division = total_cuts + diners - diners // divide_into_n
        # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)

        options.append(cuts_for_division)

        if total_produced >= diners:
            options.append(old_total_cuts + (diners - old_total_produced))
            options.append(total_cuts)
            print('RET1', options)
            return min(options)

    left = sum([(x > target and x % target != 0) for x in slices])
    if left >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000323bd0.PYTHON3,3392,104,445,Python,000000000019fef4,0000000000323bd0,00000000003172d1,xjcl,2020
434804,000000000032362c,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        old_total_cuts = total_cuts
        old_total_produced = total_produced

        total_cuts += sl_count * (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
        total_produced += sl_count * sl_mul

        print([sl_mul, sl_count], total_cuts, total_produced)


        # optimally divide the identical slices
        divide_into_n = math.ceil(diners / total_produced)
        cuts_for_division = total_cuts + diners - diners // divide_into_n
        # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)

        options.append(cuts_for_division)

        if total_produced >= diners:
            options.append(old_total_cuts + (diners - old_total_produced))
            options.append(total_cuts)
            print('RET1', options)
            return min(options)

    left = len([(x > target and x % target != 0) for x in slices])
    if left >= (diners - total_produced):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000032362c.PYTHON3,3392,104,445,Python,000000000019fef4,000000000032362c,00000000003172d1,xjcl,2020
434805,0000000000322b6c,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        old_total_cuts = total_cuts
        old_total_produced = total_produced

        total_cuts += sl_count * (sl_mul - 1)  # N-1 cuts to cut a slice into N pieces
        total_produced += sl_count * sl_mul

        print([sl_mul, sl_count], total_cuts, total_produced)


        # optimally divide the identical slices
        divide_into_n = math.ceil(diners / total_produced)
        cuts_for_division = total_cuts + diners - diners // divide_into_n
        # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)

        options.append(cuts_for_division)

        if total_produced >= diners:
            options.append(old_total_cuts + (diners - old_total_produced))
            options.append(total_cuts)
            print('RET1', options)
            return min(options)

    if len(multiples) < len(slices):
        options.append(total_cuts + (diners - total_produced))

    print('RET2', options)
    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000322b6c.PYTHON3,3320,103,428,Python,000000000019fef4,0000000000322b6c,00000000003172d1,xjcl,2020
434806,0000000000322739,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):
    print('trial', diners, target, slices)

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    options = []

    for sl_mul, sl_count in rle:

        old_total_cuts = total_cuts
        old_total_produced = total_produced

        total_cuts += sl_mul - 1  # N-1 cuts to cut into N pieces
        total_produced += sl_count * sl_mul

        print([sl_mul, sl_count], total_cuts, total_produced)


        # optimally divide the identical slices
        divide_into_n = math.ceil(diners / total_produced)
        cuts_for_division = total_cuts + diners - diners // divide_into_n
        # print('divide_into_n', divide_into_n, total_cuts + diners - diners // divide_into_n)

        options.append(cuts_for_division)

        if total_produced >= diners:
            options.append(old_total_cuts + (diners - old_total_produced))
            options.append(total_cuts)
            return min(options)

    if len(multiples) < len(slices):
        options.append(total_cuts + (diners - total_produced))

    return min(options)


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",0000000000322739.PYTHON3,3237,101,420,Python,000000000019fef4,0000000000322739,00000000003172d1,xjcl,2020
434807,000000000031fb91,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, itertools, math

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
man i'm doing REALLY good. i was even 16th on the leaderboard for a second

is the ideal slice size already in the input?
    no, e.g. [4] for 2 diners has solution [2 2]

somehow this reminds me of a past code jam problem also involving pancake
    the one where 9 made problems. somehow can't find it

boundaries
    we can always do it in d-1 cuts, even with a single slice
    i think other slices cannot improve the d-1 solution unless
        - they are the same size
        - they are an exact multiple
            e.g. [2 4 4] -> [2 2 2 2 2] in 2 instead of 3 cuts
            1 cut creates one target-size slice and
                if multiple also one for 'free'
            -> low multiples (doubles) are better
            -> N-times multiple: N-1 cuts to get free slice

so is the optimal size in the input if the case is not degenerate?
    [2 2] -> [1 1 1 1] in 2 cuts
    well it's half of that so i think my hypothesis is partly validated
    it might be a good idea to generate optimal slices using multiples
        and then test if it's  >= diners  later

'''

def run_length_encoding(d):
    return [(k, len(list(g))) for k,g in itertools.groupby(d)]

def trial(diners, target, slices):

    # list is implicitly sorted
    multiples = [slice // target for slice in slices if slice % target == 0]

    rle = run_length_encoding(multiples)
    total_cuts = 0
    total_produced = 0

    if rle[0][1] >= diners:
        return 0

    for sl_mul, sl_count in rle:

        old_total_cuts = total_cuts
        old_total_produced = total_produced

        total_cuts += sl_mul - 1  # N-1 cuts to cut into N pieces
        total_produced += sl_count * sl_mul

        if total_produced >= diners:
            return min(total_cuts, old_total_cuts + (diners - old_total_produced))

    print(target, multiples, rle)

    # optimally divide the identical slices
    divide_into_n = math.ceil(diners / total_produced)

    return total_cuts + diners - diners // divide_into_n


def run(data):
    diners, slices = data
    slices.sort()
    return min(
        min(
            trial(diners, slices[i], slices) for i in range(len(slices))
        ),
        diners - 1,
    )

#---------------------------------------------

def read_case():
    n, d = [int(k) for k in list(input().split())]
    return (d, [int(k) for k in list(input().split())])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000031fb91.PYTHON3,2842,91,394,Python,000000000019fef4,000000000031fb91,00000000003172d1,xjcl,2020
434808,000000000031ab82,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

'''
https://en.wikipedia.org/wiki/Benford%27s_law
'''

from collections import Counter

def run(data):
    leads = [d[1][0] for d in data]
    most_common = Counter(leads).most_common(9)
    one_thru_nine = ''.join([kv[0] for kv in most_common])

    for d in data:
        for c in d[1]:
            if c not in one_thru_nine:  # c is 0
                return c + one_thru_nine

#---------------------------------------------

def read_case():
    u = int(input())
    return [list(input().split()) for i in range(10000)]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000031ab82.PYTHON3,982,35,105,Python,000000000019fef4,000000000031ab82,00000000003179a1,xjcl,2020
434809,00000000003189fc,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...

#---------------------------------------------

def run(data):
    x, y, tour = data
    print(data)

    if x == y == 0:
        return 0

    for i in range(len(tour)):

        x, y = {
            'E': (x+1, y),
            'W': (x-1, y),
            'N': (x, y+1),
            'S': (x, y-1),
        }[tour[i]]

        print(i, x, y)

        if abs(x) + abs(y) <= i + 1:
            return i +1

    return 'IMPOSSIBLE'

#---------------------------------------------

def read_case():
    return [(int(k) if i in [0,1] else k) for i,k in enumerate(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",00000000003189fc.PYTHON3,985,41,114,Python,000000000019fef4,00000000003189fc,0000000000317409,xjcl,2020
494345,000000000033fd4f,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, math, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
calc vec for each 2-hole-combination (n^2)

but for each vec we also need the successor of each hole (n^4 !)

then simulate with every vec
    n^3 ...
    this doesn't solve hole assignment
'''

from copy import deepcopy

minus = lambda a, b: (a[0] - b[0], a[1] - b[1])
div = lambda a, b: (a[0] // b, a[1] // b)

def run(holes):
    print('case of', len(holes))
    vecs = dict()
    succ = dict()
    ans = 0
    succ_best = collections.defaultdict(lambda: float('inf'))

    for hole1 in holes:
        for hole2 in holes:
            if hole1 == hole2: continue

            vec = minus(hole2, hole1)
            dir = div(vec, math.gcd(*minus(hole2, hole1)) )

            vecs[(hole1, hole2)] = dir

            if (hole1, dir) in succ:
                if vec[0] < succ_best[(hole1, dir)]:
                    succ[(hole1, dir)] = hole2
                    succ_best[(hole1, dir)] = vec[0]
            else:
                succ[(hole1, dir)] = hole2

    pr()
    options = [dict()]

    def assign(holes, assignment_orig):

        if len(holes) <= 1:
            options.append(assignment_orig)
            return

        for i in range(len(holes) - 1):
            assignment = deepcopy(assignment_orig)
            assignment[holes[-1]] = holes[i]
            assignment[holes[i]] = holes[-1]
            assign(holes[:i] + holes[i+1:-1], assignment)

        assign(holes[:-1], assignment_orig)

    print('calcing assign now')
    assign(holes, dict())
    print('calcing assign done', len(options))

    best = 0
    for assignment in options:
        print('at assignment', assignment)

        for dir in list(vecs.values()) + [(1, 1)]:
            # print('at assignment', assignment, 'dir', dir)

            for hole in holes:

                score = 1
                seen = set()

                for _ in range(9):
                    if (hole, dir) not in succ:
                        break

                    if hole in seen:
                        break

                    seen.add(hole)
                    hole = succ[(hole, dir)]
                    score += 1

                    if hole in assignment:
                        hole = assignment[hole]
                        score += 1

                best = max(score, best)

    return best

#---------------------------------------------

def read_case():
    n = int(input())
    return [tuple([int(k) for k in list(input().split())]) for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033fd4f.PYTHON3,2996,110,312,Python,000000000019ffb9,000000000033fd4f,00000000003386d0,xjcl,2020
494346,000000000033fc0b,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, math, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
calc vec for each 2-hole-combination (n^2)

but for each vec we also need the successor of each hole (n^4 !)

then simulate with every vec
    n^3 ...
    this doesn't solve hole assignment
'''

from copy import deepcopy

minus = lambda a, b: (a[0] - b[0], a[1] - b[1])
div = lambda a, b: (a[0] // b, a[1] // b)

def run(holes):
    print('case of', len(holes))
    vecs = dict()
    succ = dict()
    ans = 0
    succ_best = collections.defaultdict(lambda: float('inf'))

    for hole1 in holes:
        for hole2 in holes:
            if hole1 == hole2: continue

            vec = minus(hole2, hole1)
            dir = div(vec, math.gcd(*minus(hole2, hole1)) )

            vecs[(hole1, hole2)] = dir

            if (hole1, dir) in succ:
                if vec[0] < succ_best[(hole1, dir)]:
                    succ[(hole1, dir)] = hole2
                    succ_best[(hole1, dir)] = vec[0]
            else:
                succ[(hole1, dir)] = hole2

    pr()
    options = [dict()]

    def assign(holes, assignment_orig):

        if len(holes) <= 1:
            options.append(assignment_orig)
            return

        for i in range(len(holes) - 1):
            assignment = deepcopy(assignment_orig)
            assignment[holes[-1]] = holes[i]
            assignment[holes[i]] = holes[-1]
            assign(holes[:i] + holes[i+1:-1], assignment)

        assign(holes[:-1], assignment_orig)

    print('calcing assign now')
    assign(holes, dict())
    print('calcing assign done', len(options))

    best = 0
    for assignment in options:
        print('at assignment', assignment)

        for dir in list(vecs.values()) + [(1, 1)]:
            # print('at assignment', assignment, 'dir', dir)

            for hole in holes:

                score = 1
                seen = set()

                for _ in range(9):
                    if (hole, dir) not in succ:
                        break

                    if hole in seen:
                        break

                    seen.add(hole)
                    hole = succ[(hole, dir)]
                    score += 1

                    if hole in assignment:
                        hole = assignment[hole]

                best = max(score, best)

    return best

#---------------------------------------------

def read_case():
    n = int(input())
    return [tuple([int(k) for k in list(input().split())]) for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033fc0b.PYTHON3,2961,109,309,Python,000000000019ffb9,000000000033fc0b,00000000003386d0,xjcl,2020
494347,000000000033fb6c,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, math, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
calc vec for each 2-hole-combination (n^2)

but for each vec we also need the successor of each hole (n^4 !)

then simulate with every vec
    n^3 ...
    this doesn't solve hole assignment
'''

from copy import deepcopy

minus = lambda a, b: (a[0] - b[0], a[1] - b[1])
div = lambda a, b: (a[0] // b, a[1] // b)

def run(holes):
    print('case of', len(holes))
    vecs = dict()
    succ = dict()
    ans = 0
    succ_best = collections.defaultdict(lambda: float('inf'))

    for hole1 in holes:
        for hole2 in holes:
            if hole1 == hole2: continue

            vec = minus(hole2, hole1)
            dir = div(vec, math.gcd(*minus(hole2, hole1)) )

            vecs[(hole1, hole2)] = dir

            if (hole1, dir) in succ:
                if vec[0] < succ_best[(hole1, dir)]:
                    succ[(hole1, dir)] = hole2
                    succ_best[(hole1, dir)] = vec[0]
            else:
                succ[(hole1, dir)] = hole2

    pr()
    options = [dict()]

    def assign(holes, assignment_orig):

        if len(holes) <= 1:
            options.append(assignment_orig)
            return

        for i in range(len(holes) - 1):
            assignment = deepcopy(assignment_orig)
            assignment[holes[-1]] = holes[i]
            assignment[holes[i]] = holes[-1]
            assign(holes[:i] + holes[i+1:-1], assignment)

        assign(holes[i+1:-1], assignment_orig)

    print('calcing assign now')
    assign(holes, dict())
    print('calcing assign done', len(options))

    best = 0
    for assignment in options:
        print('at assignment', assignment)

        for dir in list(vecs.values()) + [(1, 1)]:
            # print('at assignment', assignment, 'dir', dir)

            for hole in holes:

                score = 1
                seen = set()

                for _ in range(9):
                    if (hole, dir) not in succ:
                        break

                    if hole in seen:
                        break

                    seen.add(hole)
                    hole = succ[(hole, dir)]
                    score += 1

                    if hole in assignment:
                        hole = assignment[hole]

                best = max(score, best)

    return best

#---------------------------------------------

def read_case():
    n = int(input())
    return [tuple([int(k) for k in list(input().split())]) for i in range(n)]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033fb6c.PYTHON3,2964,109,309,Python,000000000019ffb9,000000000033fb6c,00000000003386d0,xjcl,2020
494348,000000000033dd79,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''

'''

def run(data):
    order, links = data

    latencies = sorted([(o, i) for i, o in enumerate(order) if o > 0], reverse=True)
    previouss = sorted([(o, i) for i, o in enumerate(order) if o < 0], reverse=True)

    delay = 0
    mapping = dict()
    index_shift = 0

    print('latencies', latencies)
    print('previouss', previouss)

    # for j, (po, pi) in enumerate(previouss):
    j = 0
    while j < len(previouss):
        # out of order, e.g. -1 -3 8 => -2 is missing (corresponds to 8)

        (po, pi) = previouss[j]
        print('element', j, 'from previous')

        if abs(po) > j + 1 + index_shift:
            print('case latencies', latencies)
            late = latencies.pop()
            delay = late[0]
            mapping[late[1]+2] = delay
            index_shift += 1

        else:
            print('case previous')
            delay += 1
            if j > 0 and previouss[j][0] == previouss[j-1][0]: delay -= 1
            mapping[pi+2] = delay
            j += 1


    while latencies:
        print('while latencies', latencies)
        late = latencies.pop()
        delay = late[0]
        mapping[late[1]+2] = delay

    mapping[1] = 0

    # mapping = dict()
    # for i, o in enumerate(order):
    #     mapping[i+2] = abs(o)
    # mapping[1] = 0

    answer = []
    pr()
    for link in links:
        fro, to = mapping[link[0]], mapping[link[1]]
        answer.append( max(1, abs(fro - to)) )
    pr()

    return ' '.join(map(str, answer))

#---------------------------------------------

def read_case():
    print('case')
    num_coms, num_links = [int(k) for k in list(input().split())]
    coms = [int(k) for k in list(input().split())]
    return (coms, [[int(k) for k in list(input().split())] for i in range(num_links)])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033dd79.PYTHON3,2320,84,272,Python,000000000019ffb9,000000000033dd79,000000000033871f,xjcl,2020
494349,000000000033da94,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''

'''

def run(data):
    order, links = data

    latencies = sorted([(o, i) for i, o in enumerate(order) if o > 0])
    previouss = sorted([(o, i) for i, o in enumerate(order) if o < 0], reverse=True)

    delay = 0
    mapping = dict()
    index_shift = 0

    print('latencies', latencies)
    print('previouss', previouss)

    # for j, (po, pi) in enumerate(previouss):
    j = 0
    while j < len(previouss):
        # out of order, e.g. -1 -3 8 => -2 is missing (corresponds to 8)

        (po, pi) = previouss[j]
        print('element', j, 'from previous')

        if abs(po) > j + 1 + index_shift:
            print('case latencies', latencies)
            late = latencies.pop(0)
            delay = late[0]
            mapping[late[1]+2] = delay
            index_shift += 1

        else:
            print('case previous')
            delay += 1
            if j > 0 and previouss[j][0] == previouss[j-1][0]: delay -= 1
            mapping[pi+2] = delay
            j += 1


    while latencies:
        print('while latencies', latencies)
        late = latencies.pop(0)
        delay = late[0]
        mapping[late[1]+2] = delay

    mapping[1] = 0

    # mapping = dict()
    # for i, o in enumerate(order):
    #     mapping[i+2] = abs(o)
    # mapping[1] = 0

    answer = []
    pr()
    for link in links:
        fro, to = mapping[link[0]], mapping[link[1]]
        answer.append( max(1, abs(fro - to)) )
    pr()

    return ' '.join(map(str, answer))

#---------------------------------------------

def read_case():
    print('case')
    num_coms, num_links = [int(k) for k in list(input().split())]
    coms = [int(k) for k in list(input().split())]
    return (coms, [[int(k) for k in list(input().split())] for i in range(num_links)])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033da94.PYTHON3,2308,84,271,Python,000000000019ffb9,000000000033da94,000000000033871f,xjcl,2020
494350,000000000033ca34,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''

'''

def run(data):
    order, links = data

    # mapping = collections.defaultdict(list)
    mapping = dict()
    for i, o in enumerate(order):
        # mapping[abs(o) - 1].append(i + 1)
        mapping[i+2] = abs(o)
    mapping[1] = 0

    answer = []
    pr()
    for link in links:
        fro, to = mapping[link[0]], mapping[link[1]]
        answer.append( max(1, abs(fro - to)) )
    pr()

    return ' '.join(map(str, answer))

#---------------------------------------------

def read_case():
    print('case')
    num_coms, num_links = [int(k) for k in list(input().split())]
    coms = [int(k) for k in list(input().split())]
    return (coms, [[int(k) for k in list(input().split())] for i in range(num_links)])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033ca34.PYTHON3,1269,45,137,Python,000000000019ffb9,000000000033ca34,000000000033871f,xjcl,2020
494351,000000000033cc17,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform, collections

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''

'''

def run(data):
    order, links = data

    # mapping = collections.defaultdict(list)
    mapping = dict()
    for i, o in enumerate(order):
        # mapping[abs(o) - 1].append(i + 1)
        mapping[i+2] = abs(o)
    mapping[1] = 0

    answer = []
    pr()
    for link in links:
        fro, to = mapping[link[0]], mapping[link[1]]
        answer.append( min(1, abs(fro - to)) )
    pr()

    return ' '.join(map(str, answer))

#---------------------------------------------

def read_case():
    print('case')
    num_coms, num_links = [int(k) for k in list(input().split())]
    coms = [int(k) for k in list(input().split())]
    return (coms, [[int(k) for k in list(input().split())] for i in range(num_links)])

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033cc17.PYTHON3,1269,45,137,Python,000000000019ffb9,000000000033cc17,000000000033871f,xjcl,2020
494352,000000000033c272,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
    1
    2
    3
    4 <- rounds_big
    5
        6
    7
        8

    1
    2
    3 <- rounds_big
    4
        5
    6
        7
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # sum of 1,2,3,4,.. and inverse
    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    # sum of 1,3,5,7,.. and inverse
    odd = lambda n:  2 * tri(n) - n  # same as n**2 actually!!
    invodd = lambda t:  int(t**.5)

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    assert big >= small

    # *** serve alternatively, starting at big

    # in this case we have  res = n*base + tri(n)
    #   res - n*base = tri(n)
    #   invtri(res - n*base)
    # note that we have base-1 tho (cos tri starts at 1 and now at base)
    # wait... we are trying to find our what n is
    # we also know that triangle number from lo to hi is  tri(hi) - tri(lo)
    # WAIT
    # 1. add low tri result back in
    # 2. get invtri number for whole tri
    # 3. subtract unneeded part

    # serve  rounds_big+1, rounds_big+3, ...  from big
    if False:
        rounds_alt_big = 0
        del1 = rounds_big + 1
        while big >= del1:
            print('alt: taking', del1, ' off big')
            big -= del1
            del1 += 2
            rounds_alt_big += 1


    if rounds_big % 2 == 1:
        rounds_alt_big = invtri( big//2 + tri(rounds_big//2) ) - rounds_big//2
        big += 2 * (-tri(rounds_big//2 + rounds_alt_big) + tri(rounds_big//2))
    else:
        rounds_alt_big = invodd( big + odd((rounds_big+1)//2) ) - (rounds_big+1)//2
        big += (-odd((rounds_big+1)//2 + rounds_alt_big) + odd((rounds_big+1)//2))


    # serve  rounds_big+2, rounds_big+4, ...  from small
    if rounds_big % 2 == 0:
        rounds_alt_small = invtri( small//2 + tri(rounds_big//2) ) - rounds_big//2
        small += 2 * (-tri(rounds_big//2 + rounds_alt_small) + tri(rounds_big//2))
    else:
        rounds_alt_small = invodd( small + odd((rounds_big+1)//2) ) - (rounds_big+1)//2
        small += (-odd((rounds_big+1)//2 + rounds_alt_small) + odd((rounds_big+1)//2))

    if False:
        rounds_alt_small = 0
        del2 = rounds_big + 2
        while small >= del2:
            print('alt: taking', del2, ' off small')
            small -= del2
            del2 += 2
            rounds_alt_small += 1

    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033c272.PYTHON3,4106,143,558,Python,000000000019ffb9,000000000033c272,00000000003384ea,xjcl,2020
494353,000000000033bbed,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
    1
    2
    3
    4 <- rounds_big
    5
        6
    7
        8

    1
    2
    3 <- rounds_big
    4
        5
    6
        7
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # sum of 1,2,3,4,.. and inverse
    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    # sum of 1,3,5,7,.. and inverse
    odd = lambda n:  2 * tri(n) - n  # same as n**2 actually!!
    invodd = lambda t:  int(t**.5)

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    assert big >= small

    # *** serve alternatively, starting at big

    # in this case we have  res = n*base + tri(n)
    #   res - n*base = tri(n)
    #   invtri(res - n*base)
    # note that we have base-1 tho (cos tri starts at 1 and now at base)
    # wait... we are trying to find our what n is
    # we also know that triangle number from lo to hi is  tri(hi) - tri(lo)
    # WAIT
    # 1. add low tri result back in
    # 2. get invtri number for whole tri
    # 3. subtract unneeded part

    # serve  rounds_big+1, rounds_big+3, ...  from big
    rounds_alt_big = 0
    del1 = rounds_big + 1
    while big >= del1:
        print('alt: taking', del1, ' off big')
        big -= del1
        del1 += 2
        rounds_alt_big += 1

    # serve  rounds_big+2, rounds_big+4, ...  from small
    if rounds_big % 2 == 0:
        rounds_alt_small = invtri( small//2 + tri(rounds_big//2) ) - rounds_big//2
        print('ras', rounds_alt_small, rounds_big)
        small += 2 * (-tri(rounds_big//2 + rounds_alt_small) + tri(rounds_big//2))
    else:
        rounds_alt_small = invodd( small + odd((rounds_big+1)//2) ) - (rounds_big+1)//2
        small += (-odd((rounds_big+1)//2 + rounds_alt_small) + odd((rounds_big+1)//2))

    if False:
        rounds_alt_small = 0
        del2 = rounds_big + 2
        while small >= del2:
            print('alt: taking', del2, ' off small')
            small -= del2
            del2 += 2
            rounds_alt_small += 1

    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033bbed.PYTHON3,3749,134,518,Python,000000000019ffb9,000000000033bbed,00000000003384ea,xjcl,2020
494354,000000000033b1d7,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
    1
    2
    3
    4 <- rounds_big
    5
        6
    7
        8

    1
    2
    3 <- rounds_big
    4
        5
    6
        7
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    assert big >= small

    # *** serve alternatively, starting at big

    # in this case we have  res = n*base + tri(n)
    #   res - n*base = tri(n)
    #   invtri(res - n*base)
    # note that we have base-1 tho (cos tri starts at 1 and now at base)
    # wait... we are trying to find our what n is
    # we also know that triangle number from lo to hi is  tri(hi) - tri(lo)
    # WAIT
    # 1. add low tri result back in
    # 2. get invtri number for whole tri
    # 3. subtract unneeded part

    # serve  rounds_big+1, rounds_big+3, ...  from big
    rounds_alt_big = 0
    del1 = rounds_big + 1
    while big >= del1:
        print('alt: taking', del1, ' off big')
        big -= del1
        del1 += 2
        rounds_alt_big += 1

    # serve  rounds_big+2, rounds_big+4, ...  from small
    if rounds_big % 2 == 0:
        rounds_alt_small = invtri( small//2 + tri(rounds_big//2) ) - rounds_big//2
        print('ras', rounds_alt_small, rounds_big)
        small += 2 * (-tri(rounds_big//2 + rounds_alt_small) + tri(rounds_big//2))
    else:
        rounds_alt_small = 0
        del2 = rounds_big + 2
        while small >= del2:
            print('alt: taking', del2, ' off small')
            small -= del2
            del2 += 2
            rounds_alt_small += 1

    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033b1d7.PYTHON3,3388,125,469,Python,000000000019ffb9,000000000033b1d7,00000000003384ea,xjcl,2020
494355,000000000033b75b,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
    1
    2
    3
    4 <- rounds_big
    5
        6
    7
        8

    1
    2
    3 <- rounds_big
    4
        5
    6
        7
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    assert big >= small

    # *** serve alternatively, starting at big

    # in this case we have  res = n*base + tri(n)
    #   res - n*base = tri(n)
    #   invtri(res - n*base)
    # note that we have base-1 tho (cos tri starts at 1 and now at base)
    # wait... we are trying to find our what n is
    # we also know that triangle number from lo to hi is  tri(hi) - tri(lo)
    # WAIT
    # 1. add low tri result back in
    # 2. get invtri number for whole tri
    # 3. subtract unneeded part

    # serve  rounds_big+1, rounds_big+3, ...  from big
    rounds_alt_big = 0
    del1 = rounds_big + 1
    while big >= del1:
        print('alt: taking', del1, ' off big')
        big -= del1
        del1 += 2
        rounds_alt_big += 1

    # serve  rounds_big+2, rounds_big+4, ...  from small
    # if rounds_big % 2 == 0:
    if False:
        rounds_alt_small = invtri( small//2 + tri(rounds_big)//2 ) - rounds_big
        print('ras', rounds_alt_small, rounds_big)
        small += 2 * (-tri(rounds_big//2 + rounds_alt_small) + tri(rounds_big//2))
    else:
        rounds_alt_small = 0
        del2 = rounds_big + 2
        while small >= del2:
            print('alt: taking', del2, ' off small')
            small -= del2
            del2 += 2
            rounds_alt_small += 1

    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033b75b.PYTHON3,3401,126,472,Python,000000000019ffb9,000000000033b75b,00000000003384ea,xjcl,2020
494356,000000000033b6af,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
    1
    2
    3
    4 <- rounds_big
    5
        6
    7
        8

    1
    2
    3 <- rounds_big
    4
        5
    6
        7
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    assert big >= small

    # *** serve alternatively, starting at big

    # in this case we have  res = n*base + tri(n)
    #   res - n*base = tri(n)
    #   invtri(res - n*base)
    # note that we have base-1 tho (cos tri starts at 1 and now at base)
    # wait... we are trying to find our what n is
    # we also know that triangle number from lo to hi is  tri(hi) - tri(lo)
    # WAIT
    # 1. add low tri result back in
    # 2. get invtri number for whole tri
    # 3. subtract unneeded part

    # serve  rounds_big+1, rounds_big+3, ...  from big
    rounds_alt_big = 0
    del1 = rounds_big + 1
    while big >= del1:
        print('alt: taking', del1, ' off big')
        big -= del1
        del1 += 2
        rounds_alt_big += 1

    # serve  rounds_big+2, rounds_big+4, ...  from small
    if rounds_big % 2 == 0:
        rounds_alt_small = invtri( small//2 + tri(rounds_big)//2 ) - rounds_big
        print('ras', rounds_alt_small, rounds_big)
        small += 2 * (-tri(rounds_big//2 + rounds_alt_small) + tri(rounds_big//2))
    else:
        rounds_alt_small = 0
        del2 = rounds_big + 2
        while small >= del2:
            print('alt: taking', del2, ' off small')
            small -= del2
            del2 += 2
            rounds_alt_small += 1

    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033b6af.PYTHON3,3385,125,469,Python,000000000019ffb9,000000000033b6af,00000000003384ea,xjcl,2020
494357,000000000033affd,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
    1
    2
    3
    4 <- rounds_big
    5
        6
    7
        8

    1
    2
    3 <- rounds_big
    4
        5
    6
        7
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    assert big >= small

    # *** serve alternatively, starting at big

    # in this case we have  res = n*base + tri(n)
    #   res - n*base = tri(n)
    #   invtri(res - n*base)
    # note that we have base-1 tho (cos tri starts at 1 and now at base)
    # wait... we are trying to find our what n is
    # we also know that triangle number from lo to hi is  tri(hi) - tri(lo)
    # WAIT
    # 1. add low tri result back in
    # 2. get invtri number for whole tri
    # 3. subtract unneeded part

    # serve  rounds_big+1, rounds_big+3, ...  from big
    rounds_alt_big = 0
    del1 = rounds_big + 1
    while big >= del1:
        print('alt: taking', del1, ' off big')
        big -= del1
        del1 += 2
        rounds_alt_big += 1

    # serve  rounds_big+2, rounds_big+4, ...  from small
    if rounds_big % 2 == 0:
        rounds_alt_small = invtri(small//2 + tri(rounds_big//2)) - rounds_big
        print('ras', rounds_alt_small, rounds_big)
        small += 2 * (-tri(rounds_big//2 + rounds_alt_small) + tri(rounds_big//2))
    else:
        rounds_alt_small = 0
        del2 = rounds_big + 2
        while small >= del2:
            print('alt: taking', del2, ' off small')
            small -= del2
            del2 += 2
            rounds_alt_small += 1

    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033affd.PYTHON3,3383,125,467,Python,000000000019ffb9,000000000033affd,00000000003384ea,xjcl,2020
494358,000000000033a486,"# usage:  (python3 a.py < a.in) > a.out
import time, sys, inspect, platform

print = lambda *a, **k: __builtins__.print(str(inspect.currentframe().f_back.f_lineno).rjust(4)+':',
    *a, file=sys.stderr, **k) if platform.node() in ['surfux', 'ssd'] else ...
pr = lambda: print(inspect.currentframe().f_back.f_locals)

#---------------------------------------------

'''
simulation too slow
    even tho triangle numbers -> 10**9 needed actually
    but still too many

do stacks just alernate after a point?
    don't think so, cos one stack just keeps growing

    let's say stacks start equal
    1       +1
        2   -1
    3       +2
        4   -2
    5       +3
        6   -3
    7       +4
        8   -4
    huh.
    so they do alternate after big stack has overtaken small stack
    -> serve from big stack until limit and then alternate
'''

def run(data):
    l, r = data
    small, big = min(l, r), max(l, r)

    # *** serve from big pile until equal height

    # tri = n * (n+1) / 2
    # tri = n^2 / 2 + n / 2
    # https://math.stackexchange.com/questions/2041988/how-to-get-inverse-of-formula-for-sum-of-integers-from-1-to-n/2041994
    tri = lambda n:  (n * (n+1)) // 2
    invtri = lambda t:  int( (2 * t + .25)**.5 - .5 )

    rounds_big = invtri(big - small)

    # take from left stack in case of a tie
    if l < r and big - tri(rounds_big) == small:
        rounds_big -= 1

    big -= tri(rounds_big)

    print('taking', big, 'off big', rounds_big)

    pr()

    # *** serve alternatively, starting at big

    # serve  rounds_big+1, rounds_big+3, ...  from big
    rounds_alt_big = 0
    del1 = rounds_big + 1
    while big >= del1:
        print('alt: taking', del1, ' off big')
        big -= del1
        del1 += 2
        rounds_alt_big += 1

    # serve  rounds_big+2, rounds_big+4, ...  from small
    rounds_alt_small = 0
    del2 = rounds_big + 2
    while small >= del2:
        print('alt: taking', del2, ' off small')
        small -= del2
        del2 += 2
        rounds_alt_small += 1

    pr()
    print('D', rounds_big, rounds_alt_big, rounds_alt_small)
    return ' '.join(map(str, [
        rounds_big + rounds_alt_big + rounds_alt_small,
        [big, small][l < r],
        [big, small][l >= r],
    ]))


#---------------------------------------------

def read_case():
    return [int(k) for k in list(input().split())]

for i in range(int(input())):
    outstr = 'Case #'+str(i+1)+': '+str(run(read_case()))
    print(outstr, ' @ t =', time.clock())
    __builtins__.print(outstr)
",000000000033a486.PYTHON3,2535,94,334,Python,000000000019ffb9,000000000033a486,00000000003384ea,xjcl,2020
2877,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 vowels = 'aeiou'
 
 def calcSingleTest(f):
     line = f.readline()
     name = line.split()[0]
     n = int(line.split()[1])
     l = len(name)
     if(l < n):
         return 0
     curCons = 0
     sum = 0
     startPoints = 0
     for pos in range(l):
         ch = name[pos]
         if ch in vowels:
             curCons = 0
         else:
             curCons += 1
 
         if curCons >= n:
             #startPoints += 1
             startPoints = pos - n + 2
             sum += pos - n + 2
         else:
             sum += startPoints
     return sum
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
",gcj/2013/2437488/SergGr/2751486/1/extracted/TaskA.py,1111,44,124,Python,2437488,1,2751486,SergGr,2013
2878,TaskA.py,"#inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 vowels = 'aeiou'
 
 def calcSingleTest(f):
     line = f.readline()
     name = line.split()[0]
     n = int(line.split()[1])
     l = len(name)
     if(l < n):
         return 0
     curCons = 0
     sum = 0
     startPoints = 0
     for pos in range(l):
         ch = name[pos]
         if ch in vowels:
             curCons = 0
         else:
             curCons += 1
 
         if curCons >= n:
             #startPoints += 1
             startPoints = pos - n + 2
             sum += pos - n + 2
         else:
             sum += startPoints
     return sum
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
",gcj/2013/2437488/SergGr/2751486/0/extracted/TaskA.py,1111,44,124,Python,2437488,0,2751486,SergGr,2013
2879,TaskB.py,"#inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-small-attempt4.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 def calcN(X, Y):
     s = abs(X) + abs(Y)
     n = int((2 * s + 0.25) ** 0.5 - 0.5)
     s2 = 0
     while True:
         s2 = n * (n + 1) / 2
         if (s2 >= s) and ((s2 - s) % 2 == 0):
             break
         n += 1
     print ""X={0}, Y={1}, s={2}, n={3}, s2={4}"".format(X, Y, s, n, s2)
     return (n, s2)
 
 # Y0 = 0!!!
 def calcSingleTest2(X0, Y0):
     X = abs(X0)
     Y = abs(Y0)
     s = abs(X) + abs(Y)
     n, s2 = calcN(X, Y)
     d = (s2 - s) / 2
     print ""X0={0}, Y0={1}, s={2}, n={3}, s2={4}, d={5}"".format(X0, Y0, s, n, s2, d)
     d1 = 0
     d2 = 0
     if d > n:
         d1 = d / 2 + 1
         d2 = d - d1
         print ""d = {0}, d1={1}, d2={2}"".format(d, d1, d2)
     x_list = []
     y_list = []
     xs = X
     #ys = Y
     ys = Y + d
 
     for i in xrange(n, 0, -1):
         if i == d or i == d1 or i == d2:
             y_list.append(-i)
             continue
         if xs >= i:
             xs -= i
             x_list.append(i)
         else:
             y_list.append(i)
             ys -= i
     pass
     #    for i in xrange(n, 0, -1):
     #        if i == d:
     #            if xs == i:
     #                d = -1
     #                d1 = i - 1
     #                d2 = 1
     #            else:
     #                y_list.append(-i)
     #                continue
     #        if i == d1 or i == d2:
     #            y_list.append(-i)
     #            continue
     #        if xs >= i:
     #            xs -= i
     #            x_list.append(i)
     #        else:
     #            y_list.append(i)
     #            ys -= i
 
     #    for i in xrange(n, 0, -1):
     #        if i == d or i == d1 or i == d2:
     #            y_list.append(-i)
     #            continue
     #        if xs >= i:
     #            xs -= i
     #            x_list.append(i)
     #        else:
     #            y_list.append(i)
     #            ys -= i
     #    print ""xs={0}, ys={1}"".format(xs, ys)
     #    if xs == 1:
     #        for i in xrange(x_list[0], 0, -1):
     #            if i not in x_list:
     #                x_pos = x_list.index(i + 1)
     #                y_pos = y_list.index(i)
     #                print x_list
     #                print y_list
     #                print 'swap {0}: {1} {2}; {3} {4}'.format(i, x_pos, x_list[x_pos], y_pos, y_list[y_pos])
     #                x_list[x_pos] = i
     #                y_list[y_pos] = i + 1
     #                break
 
     print ""xs={0}, ys={1}"".format(xs, ys)
     #print x_list
     #print y_list
     if xs != 0:
         print ""AAAAAAAAAA xs = "" + str(xs)
         raise ValueError(""AAAAAAAAAA xs = "" + str(xs))
     if ys != 0:
         print ""AAAAAAAAAA ys = "" + str(ys)
         raise ValueError(""AAAAAAAAAA ys = "" + str(ys))
 
     x_list.reverse()
     y_list.reverse()
     #print x_list
     #print y_list
 
     if X0 < 0:
         x_list = map(lambda x: -x, x_list)
     if Y0 < 0:
         y_list = map(lambda x: -x, y_list)
     print x_list
     print y_list
 
     return (n, x_list, y_list)
 
 
 def calcSingleTest(f):
     line = f.readline()
     X0 = int(line.split()[0])
     Y0 = int(line.split()[1])
     X = X0
     Y = Y0
     swap = (Y == 0)
     if swap:
         X, Y = Y, X
     pass
     #n, x_list, y_list = calcSingleTest2(X, Y)
     try:
         n, x_list, y_list = calcSingleTest2(X, Y)
     except ValueError:
         print ""BBBBBBBBBB fix error by swap""
         if swap:
             raise ValueError(""BBBBBBB already swap"")
         swap = True
         X, Y = Y, X
         n, x_list, y_list = calcSingleTest2(X, Y)
 
     if swap:
         y_list, x_list = x_list, y_list
     res_str = """"
     xt = 0
     yt = 0
     for i in xrange(1, n + 1):
         if i in x_list:
             xt += i
             res_str += 'E'
         elif -i in x_list:
             xt -= i
             res_str += 'W'
         elif i in y_list:
             yt += i
             res_str += 'N'
         elif -i in y_list:
             yt -= i
             res_str += 'S'
         else:
             print ""AAAAAAAAAA "" + str(i)
             raise ValueError(""AAAAAAAAAA "" + str(i))
     if xt != X0 or yt != Y0:
         print 'CCC: X={0}, Y={1}, xt={2}, yt={3}'.format(X, Y, xt, yt)
         raise ValueError(""CCCCCCC"")
     return res_str
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2437488/SergGr/2749486/1/extracted/TaskB.py,4973,179,661,Python,2437488,1,2749486,SergGr,2013
2880,TaskB.py,"#inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-small-attempt4.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 def calcN(X, Y):
     s = abs(X) + abs(Y)
     n = int((2 * s + 0.25) ** 0.5 - 0.5)
     s2 = 0
     while True:
         s2 = n * (n + 1) / 2
         if (s2 >= s) and ((s2 - s) % 2 == 0):
             break
         n += 1
     print ""X={0}, Y={1}, s={2}, n={3}, s2={4}"".format(X, Y, s, n, s2)
     return (n, s2)
 
 # Y0 = 0!!!
 def calcSingleTest2(X0, Y0):
     X = abs(X0)
     Y = abs(Y0)
     s = abs(X) + abs(Y)
     n, s2 = calcN(X, Y)
     d = (s2 - s) / 2
     print ""X0={0}, Y0={1}, s={2}, n={3}, s2={4}, d={5}"".format(X0, Y0, s, n, s2, d)
     d1 = 0
     d2 = 0
     if d > n:
         d1 = d / 2 + 1
         d2 = d - d1
         print ""d = {0}, d1={1}, d2={2}"".format(d, d1, d2)
     x_list = []
     y_list = []
     xs = X
     #ys = Y
     ys = Y + d
 
     for i in xrange(n, 0, -1):
         if i == d or i == d1 or i == d2:
             y_list.append(-i)
             continue
         if xs >= i:
             xs -= i
             x_list.append(i)
         else:
             y_list.append(i)
             ys -= i
     pass
     #    for i in xrange(n, 0, -1):
     #        if i == d:
     #            if xs == i:
     #                d = -1
     #                d1 = i - 1
     #                d2 = 1
     #            else:
     #                y_list.append(-i)
     #                continue
     #        if i == d1 or i == d2:
     #            y_list.append(-i)
     #            continue
     #        if xs >= i:
     #            xs -= i
     #            x_list.append(i)
     #        else:
     #            y_list.append(i)
     #            ys -= i
 
     #    for i in xrange(n, 0, -1):
     #        if i == d or i == d1 or i == d2:
     #            y_list.append(-i)
     #            continue
     #        if xs >= i:
     #            xs -= i
     #            x_list.append(i)
     #        else:
     #            y_list.append(i)
     #            ys -= i
     #    print ""xs={0}, ys={1}"".format(xs, ys)
     #    if xs == 1:
     #        for i in xrange(x_list[0], 0, -1):
     #            if i not in x_list:
     #                x_pos = x_list.index(i + 1)
     #                y_pos = y_list.index(i)
     #                print x_list
     #                print y_list
     #                print 'swap {0}: {1} {2}; {3} {4}'.format(i, x_pos, x_list[x_pos], y_pos, y_list[y_pos])
     #                x_list[x_pos] = i
     #                y_list[y_pos] = i + 1
     #                break
 
     print ""xs={0}, ys={1}"".format(xs, ys)
     #print x_list
     #print y_list
     if xs != 0:
         print ""AAAAAAAAAA xs = "" + str(xs)
         raise ValueError(""AAAAAAAAAA xs = "" + str(xs))
     if ys != 0:
         print ""AAAAAAAAAA ys = "" + str(ys)
         raise ValueError(""AAAAAAAAAA ys = "" + str(ys))
 
     x_list.reverse()
     y_list.reverse()
     #print x_list
     #print y_list
 
     if X0 < 0:
         x_list = map(lambda x: -x, x_list)
     if Y0 < 0:
         y_list = map(lambda x: -x, y_list)
     print x_list
     print y_list
 
     return (n, x_list, y_list)
 
 
 def calcSingleTest(f):
     line = f.readline()
     X0 = int(line.split()[0])
     Y0 = int(line.split()[1])
     X = X0
     Y = Y0
     swap = (Y == 0)
     if swap:
         X, Y = Y, X
     pass
     #n, x_list, y_list = calcSingleTest2(X, Y)
     try:
         n, x_list, y_list = calcSingleTest2(X, Y)
     except ValueError:
         print ""BBBBBBBBBB fix error by swap""
         if swap:
             raise ValueError(""BBBBBBB already swap"")
         swap = True
         X, Y = Y, X
         n, x_list, y_list = calcSingleTest2(X, Y)
 
     if swap:
         y_list, x_list = x_list, y_list
     res_str = """"
     xt = 0
     yt = 0
     for i in xrange(1, n + 1):
         if i in x_list:
             xt += i
             res_str += 'E'
         elif -i in x_list:
             xt -= i
             res_str += 'W'
         elif i in y_list:
             yt += i
             res_str += 'N'
         elif -i in y_list:
             yt -= i
             res_str += 'S'
         else:
             print ""AAAAAAAAAA "" + str(i)
             raise ValueError(""AAAAAAAAAA "" + str(i))
     if xt != X0 or yt != Y0:
         print 'CCC: X={0}, Y={1}, xt={2}, yt={3}'.format(X, Y, xt, yt)
         raise ValueError(""CCCCCCC"")
     return res_str
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2437488/SergGr/2749486/0/extracted/TaskB.py,4973,179,661,Python,2437488,0,2749486,SergGr,2013
13959,TaskB.py,"#inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcNLevel(N):
     if N == 1:
         return (1,1,0)
     i = 0
     while 2 * (i ** 2) - i < N:
         i += 1
     return (i, 2 * ((i-1) ** 2) - i-1 - N, 2 * (i ** 2) - i - N)
 
 print str(calcNLevel(4))
 
 
 def binSum(n, k):
     s = 0
     c = 1
     for i in range(0, k + 1):
         s += c
         c *= (n - i)
         c /= (i + 1)
     return s
 
 
 def binP(n, k):
     s = binSum(n, k)
     p2 = float(s) / 2 ** n
     return p2
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     X = int(line.split()[1])
     Y = int(line.split()[2])
     return calcSingleTest2(N, abs(X), Y)
 
     #N = 10
     #X = 3
     #Y = 1
     #X = 4
     #Y = 0
 
 
 def calcSingleTest2(N, X, Y):
     if X == 0 and Y == 0:
         return 1 if N > 0 else 0
     if N == 1:
         return 0
 
     (nLevel, nRest, nRest2) = calcNLevel(N)
     #print ""N={0}, nLevel={1}, nRest={2}, nRest2={3}"".format(N, nLevel, nRest, nRest2)
     pLevel = (abs(X) + Y) / 2 + 1
     pPos = Y
     #print ""X={0}, Y={1}, pLevel={2}, pPos={3}"".format(X, Y, pLevel, pPos)
     if pLevel < nLevel:
         return 1
     if pLevel > nLevel:
         return 0
 
     if nRest2 == 0:
         return 1
 
     if pPos == 2 * (pLevel - 1):
         return 1 if nRest2 == 0 else 0
     if nRest <= nLevel:
     #        s = binSum(nRest, pPos)
     #        p2 = 2 ** nRest
     #        p = 1 - float(s) / p2
     #        print ""s={0}, 2** = {1}, p = {2}"".format(s, p2, p)
     #        return p
         return 1 - binP(nRest, pPos)
     else:
         levelRest = nLevel - pPos - 1
         p = binP(nRest2 - 1, levelRest)
         #print ""p={0}, rest = {1}, levelRest = {2}"".format(p, nRest2 - 1, levelRest)
         return p
     return -1
 
 
 #print binSum(3, 4)
 #for N in xrange(2, 100):
 #    r = int((N + 2) ** 0.5)
 #    r2 = r * r - 3
 #    print ""N={0}, r={1}, r2={2}"".format(N, r, r2)
 
 for N in xrange(2, 21):
     print ""------------------------------------------""
     (nLevel, nRest, nRest2) = calcNLevel(N)
     #print ""N = "" + str(N)
     print ""N={0}, nLevel={1}, nRest={2}, nRest2={3}"".format(N, nLevel, nRest, nRest2)
     s = 0
     s2 = 0
     for Y in xrange(0, nLevel + 2):
         X = 2 * (nLevel - 1) - Y
         r = calcSingleTest2(N, X, Y)
         s += r
         if X > 0:
             s2 += 2 * r
         else:
             s2 += r
             #print ""N={0}, X={1}, Y={2}, r={3}"".format(N, X, Y, r)
         print ""X={1}, Y={2}, r={3}"".format(N, X, Y, r)
     print ""s={0}, s2 = {1}, nRest = {2}"".format(s, s2, nRest)
     if nRest != s2:
         print ""AAAAAAAAAAAAAAAAA""
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2434486/SergGr/2700486/0/extracted/TaskB.py,3216,125,473,Python,2434486,0,2700486,SergGr,2013
13960,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     size = int(line.split()[0])
     count = int(line.split()[0])
     line = f.readline()
     others = sorted(map(int, line.split()))
     print size
     print others
     if size == 1:
         return len(others)
     max = others[-1]
     results = []
     add = 0
     l = len(others)
     others.append(10**20) #
     for pos in xrange(len(others)):
         o = others[pos]
         if size > max:
             results.append(add)
             break
         if size > o:
             size += o
             continue
         results.append(add + l - pos)
         while size <= o:
             size = 2 * size - 1
             add += 1
         size += o
     print ""res:""
     print results
     results = sorted(results)
     print results
     return results[0]
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2434486/SergGr/2692487/1/extracted/TaskA.py,1375,54,144,Python,2434486,1,2692487,SergGr,2013
13961,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     size = int(line.split()[0])
     count = int(line.split()[0])
     line = f.readline()
     others = sorted(map(int, line.split()))
     print size
     print others
     if size == 1:
         return len(others)
     max = others[-1]
     results = []
     add = 0
     l = len(others)
     others.append(10**13) #
     for pos in xrange(len(others)):
         o = others[pos]
         if size > max:
             results.append(add)
             break
         if size > o:
             size += o
             continue
         results.append(add + l - pos)
         while size <= o:
             size = 2 * size - 1
             add += 1
         size += o
     print ""res:""
     print results
     results = sorted(results)
     print results
     return results[0]
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2434486/SergGr/2692487/0/extracted/TaskA.py,1375,54,144,Python,2434486,0,2692487,SergGr,2013
71747,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 N = 4
 XWon = ""X won""
 OWon = ""O won""
 Draw = ""Draw""
 NotCompleted = ""Game has not completed""
 
 def getXLine(data, x):
     for line in data:
         yield line[x]
 
 
 def getD1Line(data):
     x = 0
     for line in data:
         yield line[x]
         x += 1
 
 
 def getD2Line(data):
     x = 0
     l = len(data)
     for line in data:
         x += 1
         yield line[l - x]
 
 
 def checkLine(line, player):
     for c in line:
         if c != 'T' and c != player:
             return False
     return True
 
 
 def checkWin(data, player):
     for line in data:
         if checkLine(line, player):
             return True
 
     for x in xrange(N):
         if checkLine(getXLine(data, x), player):
             return True
 
     if checkLine(getD1Line(data), player):
         return True
 
     if checkLine(getD2Line(data), player):
         return True
 
     return False
 
 
 def calcSingleTest(f):
     data = []
     completed = True
     for y in xrange(N):
         line = f.readline()
         if line.find('.') != -1:
             completed = False
         data.append(line[:N]) #cut last \n
     f.readline()
     print data
     if checkWin(data, 'X'):
         return XWon
     if checkWin(data, 'O'):
         return OWon
 
     return Draw if completed else NotCompleted
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2270488/SergGr/2453486/1/extracted/TaskA.py,1818,86,205,Python,2270488,1,2453486,SergGr,2013
71748,TaskA.py,"#inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 N = 4
 XWon = ""X won""
 OWon = ""O won""
 Draw = ""Draw""
 NotCompleted = ""Game has not completed""
 
 def getXLine(data, x):
     for line in data:
         yield line[x]
 
 
 def getD1Line(data):
     x = 0
     for line in data:
         yield line[x]
         x += 1
 
 
 def getD2Line(data):
     x = 0
     l = len(data)
     for line in data:
         x += 1
         yield line[l - x]
 
 
 def checkLine(line, player):
     for c in line:
         if c != 'T' and c != player:
             return False
     return True
 
 
 def checkWin(data, player):
     for line in data:
         if checkLine(line, player):
             return True
 
     for x in xrange(N):
         if checkLine(getXLine(data, x), player):
             return True
 
     if checkLine(getD1Line(data), player):
         return True
 
     if checkLine(getD2Line(data), player):
         return True
 
     return False
 
 
 def calcSingleTest(f):
     data = []
     completed = True
     for y in xrange(N):
         line = f.readline()
         if line.find('.') != -1:
             completed = False
         data.append(line[:N]) #cut last \n
     f.readline()
     print data
     if checkWin(data, 'X'):
         return XWon
     if checkWin(data, 'O'):
         return OWon
 
     return Draw if completed else NotCompleted
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2013/2270488/SergGr/2453486/0/extracted/TaskA.py,1818,86,205,Python,2270488,0,2453486,SergGr,2013
71749,TaskC.py,"import time
 
 #inputFileName = ""test.in""
 #inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-large-1.in""
 inputFileName = ""C-large-2.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     a = int(line.split()[0])
     b = int(line.split()[1])
     return findAllGood3Cnt(a, b)
 
 
 def isPalindrome(x):
     strX = str(x)
     return strX == strX[::-1]
 
 
 def findAllGood(m):
     good = []
     for x in xrange(1, m):
         #if (x % 10000) == 0: print x
         #if (x % 10) == 0: continue
         strX = str(x)
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         sq1 = x1 * x1
         sq2 = x2 * x2
         if isPalindrome(sq1):
             good.append(sq1)
             #print str(x1) + "" - "" + str(sq1) + ""   "" + str(len(str(sq1)))
         if isPalindrome(sq2):
             good.append(sq2)
             #print str(x2) + "" - "" + str(sq2) + ""   "" + str(len(str(sq2)))
     return good
 
 
 def findAllGood2(a, b):
     good = []
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 good.append(x)
                 #good.append(x2)
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     #print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             #print ""s = "" + str(s)
             if checkAndAddStr(s):
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
     return good
 
 
 def findAllGood2Cnt(a, b):
     cntArr = [0, 0, 0]
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 cntArr[0] += 1
                 cntArr[1] = x
                 cntArr[2] = x2
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     #print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
     #        if(maxLen > 10):
     #            print ""len = {0} max = {1}, cnt = {2}, lastX = {3}"".format(l, maxLen, cntArr[0], cntArr)
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             #print ""s = "" + str(s)
             if checkAndAddStr(s):
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
     return cntArr[0]
 
 
 def findAllGood2Cnt2(a, b):
     cntArr = [0, 0, 0]
     good = []
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 #fileCache.write(str(x2) + ""\n"")
                 #good.append(x2)
                 cntArr[0] += 1
                 cntArr[1] = x
                 cntArr[2] = x2
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     if maxLen > 25: maxLen = 25
     #print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
     #        if(maxLen > 10):
     #            print ""len = {0} max = {1}, cnt = {2}, lastX = {3}"".format(l, maxLen, cntArr[0], cntArr)
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             cnt1 = len(filter(lambda c: c == '1', s))
             if cnt1 > 5: continue
             #print ""s = "" + str(s)
             if checkAndAddStr(s) and cnt1 <= 3:
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
                         #    return good
     return cntArr[0]
 
 
 #m0 = 220000
 #good0 = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L, 12102420121L, 12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L, 1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L, 4004009004004L, 100000020000001L, 100220141022001L, 102012040210201L, 102234363432201L, 121000242000121L, 121242363242121L, 123212464212321L, 123456787654321L, 400000080000004L, 10000000200000001L, 10002000300020001L, 10004000600040001L, 10020210401202001L, 10022212521222001L, 10024214841242001L, 10201020402010201L, 10203040504030201L, 10205060806050201L, 10221432623412201L, 10223454745432201L, 12100002420000121L, 12102202520220121L, 12104402820440121L, 12122232623222121L, 12124434743442121L, 12321024642012321L, 12323244744232321L, 12343456865434321L, 12345678987654321L, 40000000800000004L, 40004000900040004L, 1000000002000000001L, 1000220014100220001L, 1002003004003002001L, 1002223236323222001L, 1020100204020010201L, 1020322416142230201L, 1022123226223212201L, 1022345658565432201L, 1210000024200000121L, 1210242036302420121L, 1212203226223022121L, 1212445458545442121L, 1232100246420012321L, 1232344458544432321L, 1234323468643234321L, 4000000008000000004L, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]
 m0 = 2300000
 good0 = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201,
          104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L, 12102420121L,
          12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L,
          1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L,
          4004009004004L, 100000020000001L, 100220141022001L, 102012040210201L, 102234363432201L, 121000242000121L,
          121242363242121L, 123212464212321L, 123456787654321L, 400000080000004L, 10000000200000001L, 10002000300020001L,
          10004000600040001L, 10020210401202001L, 10022212521222001L, 10024214841242001L, 10201020402010201L,
          10203040504030201L, 10205060806050201L, 10221432623412201L, 10223454745432201L, 12100002420000121L,
          12102202520220121L, 12104402820440121L, 12122232623222121L, 12124434743442121L, 12321024642012321L,
          12323244744232321L, 12343456865434321L, 12345678987654321L, 40000000800000004L, 40004000900040004L,
          1000000002000000001L, 1000220014100220001L, 1002003004003002001L, 1002223236323222001L, 1020100204020010201L,
          1020322416142230201L, 1022123226223212201L, 1022345658565432201L, 1210000024200000121L, 1210242036302420121L,
          1212203226223022121L, 1212445458545442121L, 1232100246420012321L, 1232344458544432321L, 1234323468643234321L,
          4000000008000000004L, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L,
          100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L,
          100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L,
          102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L,
          102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L,
          102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L,
          121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L,
          121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L,
          123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L,
          400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L,
          10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L,
          10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L,
          10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L,
          10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L,
          12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L,
          12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L,
          40000000000800000000004L, 1000000000002000000000001L, 1000002000003000002000001L, 1000004000006000004000001L,
          1000020200104010020200001L, 1000022200125210022200001L, 1000024200148410024200001L, 1000200030004000300020001L,
          1000202030205020302020001L, 1000204030408040304020001L, 1000220232126212320220001L, 1000222232347432322220001L,
          1002001002004002001002001L, 1002003004005004003002001L, 1002005006008006005002001L, 1002021222306032221202001L,
          1002023224327234223202001L, 1002201232026202321022001L, 1002203234227224323022001L, 1002221454348434541222001L,
          1002223456569656543222001L, 1020100000204020000010201L, 1020102020205020202010201L, 1020104040208020404010201L,
          1020120402306032040210201L, 1020122422327232242210201L, 1020302030406040302030201L, 1020304050607060504030201L,
          1020322434528254342230201L, 1020324454749474544230201L, 1022121002226222001212201L, 1022123024227224203212201L,
          1022141424528254241412201L, 1022143446549456443412201L, 1022323232448442323232201L, 1022325254649464525232201L,
          1210000000024200000000121L, 1210002200025200022000121L, 1210004400028200044000121L, 1210022220126210222200121L,
          1210024420147410244200121L, 1210220032026202300220121L, 1210222232227222322220121L, 1210242254148414522420121L,
          1210244454369634544420121L, 1212201002226222001022121L, 1212203204227224023022121L, 1212223242528252423222121L,
          1212225444549454445222121L, 1212421234248424321242121L, 1212423436449446343242121L, 1232100000246420000012321L,
          1232102220247420222012321L, 1232122422348432242212321L, 1232124642369632464212321L, 1232322032448442302232321L,
          1232324252649462524232321L, 1234321002468642001234321L, 1234323224469644223234321L, 4000000000008000000000004L,
          4000004000009000004000004L, 100000000000020000000000001L, 100000220000141000022000001L,
          100002002010040010200200001L, 100002222012363210222200001L, 100020001200040002100020001L,
          100020221222161222122020001L, 100022003410262014300220001L, 100022223434585434322220001L,
          100200100020040020001002001L, 100200320240161042023002001L, 100202104032060230401202001L,
          100202324254383452423202001L, 100220121220262022121022001L, 100220341462383264143022001L,
          100222125432484234521222001L, 102010000002040200000010201L, 102010222202161202222010201L,
          102012022032060230220210201L, 102012244234383432442210201L, 102030201204060402102030201L,
          102030423426181624324030201L, 102032223434282434322230201L, 102212100022262220001212201L,
          102212322442383244223212201L, 102214124054282450421412201L, 102232321224484422123232201L,
          121000000000242000000000121L, 121000242000363000242000121L, 121002202210262012202200121L,
          121002444212585212444200121L, 121022001220262022100220121L, 121022243242383242342220121L,
          121024203630484036302420121L, 121220100022262220001022121L, 121220342242383242243022121L,
          121222304234282432403222121L, 121242121242484242121242121L, 123210000002464200000012321L,
          123210244202585202442012321L, 123212222232484232222212321L, 123232201224484422102232321L,
          123432100024686420001234321L, 400000000000080000000000004L]
 
 good1 = []
 with open('cache3.txt') as cacheF:
     good1 = map(int, cacheF.readlines())
 
 def binarySearch(l, x):
     a = 0
     b = len(l) - 1
     if(x < l[0]):
         return 0
     if(x > l[b]):
         return len(l)
     while a < b:
         mid = (a + b) // 2
         midval = l[mid]
         if x == midval:
             return mid
         elif a == mid:
             return a if midval > x else b
         elif midval < x:
             a = mid
         else:
             b = mid
     return a
 
 
 def findAllGood3(a, b):
     res2 = filter(lambda x: (a <= x) and (x <= b), good0)
     left = binarySearch(good1, a)
     right = binarySearch(good1, b)
     if good1[right] == b:
         right += 1
     res = right - left
     if res != len(res2):
         print ""!!!!! "" + str(res) + ""  "" + str((res2))
         #return res
     return  good1[left:right]
     #return filter(lambda x: (a <= x) and (x <= b), good0)
 
 def findAllGood3Cnt(a, b):
     res2 = filter(lambda x: (a <= x) and (x <= b), good0)
     left = binarySearch(good1, a)
     right = binarySearch(good1, b)
     if right < len(good1) and good1[right] == b:
         right += 1
     res = right - left
     return res
 
 
 #fileCache = open(""cache.txt"", 'w')
 
 #m = 220000
 #m = 220000
 #m = 2300000
 #good = findAllGood(m)
 #good = sorted(good)
 #print str(m) + "":  "" + str(len(good)) + ""  -  "" + str(good)
 #a = 1234321
 #b = 41002000000000
 #print '----------------------------------'
 #allCnts = []
 #totalCnt = 0
 #for p in xrange(0, 100, 2):
 #    a = 10 ** p
 #    b = 10 ** (p + 1)
 #    cnt = findAllGood2Cnt2(a, b)
 #    totalCnt += cnt
 #    allCnts.append(cnt)
 #    allCnts.append(0)
 #    #cntOld = findAllGood2Cnt(a, b)
 #    print ""{0}: a={1}, b={2}: total = {3} count = {4}"".format((time.time() - startTime), p, (p + 1), totalCnt, cnt)
 #    #print ""{0}: a={1}, b={2}: count = {3}, old = {4}"".format((time.time() - startTime), p, (p+1), cnt, cntOld)
 #    #print ""{0}: a={1}, b={2}: count = {3}"".format((time.time() - startTime), a, b, cnt)
 #    fileCache.flush()
 #print '----------------------------------'
 #print allCnts
 #print '----------------------------------'
 #fileCache.close()
 
 #fileCache = open(""cache.txt"", 'r')
 #allLines = fileCache.readlines()
 #fileCache.close()
 #allValues = map(int, allLines)
 #allValues = sorted(allValues)
 #fileCache2 = open(""cache3.txt"", 'w')
 #fileCache2.write(""\n"".join(map(str,allValues)))
 #fileCache2.close()
 
 
 sources = [
     22,
     212,
     1221,
     2112,
 
     1,
     111,
     1111,
     11111,
     111111,
     1111111,
     11111111,
     111111111,
     1234567890
 
 ]
 
 #a = 1
 #b = 10 ** 10
 ##print '----------------------------------'
 ##good2Cnt2 = findAllGood2Cnt2(a, b)
 ##print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good2Cnt2), sorted(good2Cnt2))
 #good2Cnt2 = findAllGood2Cnt2(a, b)
 #print ""{0}: a={1}, b={2}: count = {3}"".format((time.time() - startTime), a, b, good2Cnt2)
 #good2Cnt = findAllGood2Cnt(a, b)
 #print ""{0}: a={1}, b={2}: count = {3}"".format((time.time() - startTime), a, b, good2Cnt)
 #good2 = findAllGood2(a, b)
 #good2 = sorted(good2)
 #good3 = findAllGood3(a, b)
 #print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good2), good2)
 #print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good3), good3)
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '{0}:--------------------------------------------'.format((time.time() - startTime))
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
             #outF.write('Case #' + str(i) + "": "" + ('YES' if res else 'NO'))
 
 
 
 
",gcj/2013/2270488/SergGr/2463486/2/extracted/TaskC.py,19034,385,1625,Python,2270488,2,2463486,SergGr,2013
71750,TaskC.py,"import time
 
 #inputFileName = ""test.in""
 #inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 inputFileName = ""C-large-1.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     a = int(line.split()[0])
     b = int(line.split()[1])
     return findAllGood3Cnt(a, b)
 
 
 def isPalindrome(x):
     strX = str(x)
     return strX == strX[::-1]
 
 
 def findAllGood(m):
     good = []
     for x in xrange(1, m):
         #if (x % 10000) == 0: print x
         #if (x % 10) == 0: continue
         strX = str(x)
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         sq1 = x1 * x1
         sq2 = x2 * x2
         if isPalindrome(sq1):
             good.append(sq1)
             #print str(x1) + "" - "" + str(sq1) + ""   "" + str(len(str(sq1)))
         if isPalindrome(sq2):
             good.append(sq2)
             #print str(x2) + "" - "" + str(sq2) + ""   "" + str(len(str(sq2)))
     return good
 
 
 def findAllGood2(a, b):
     good = []
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 good.append(x)
                 #good.append(x2)
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     #print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             #print ""s = "" + str(s)
             if checkAndAddStr(s):
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
     return good
 
 
 def findAllGood2Cnt(a, b):
     cntArr = [0, 0, 0]
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 cntArr[0] += 1
                 cntArr[1] = x
                 cntArr[2] = x2
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     #print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
     #        if(maxLen > 10):
     #            print ""len = {0} max = {1}, cnt = {2}, lastX = {3}"".format(l, maxLen, cntArr[0], cntArr)
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             #print ""s = "" + str(s)
             if checkAndAddStr(s):
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
     return cntArr[0]
 
 
 def findAllGood2Cnt2(a, b):
     cntArr = [0, 0, 0]
     good = []
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 #fileCache.write(str(x2) + ""\n"")
                 #good.append(x2)
                 cntArr[0] += 1
                 cntArr[1] = x
                 cntArr[2] = x2
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     if maxLen > 25: maxLen = 25
     #print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
     #        if(maxLen > 10):
     #            print ""len = {0} max = {1}, cnt = {2}, lastX = {3}"".format(l, maxLen, cntArr[0], cntArr)
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             cnt1 = len(filter(lambda c: c == '1', s))
             if cnt1 > 5: continue
             #print ""s = "" + str(s)
             if checkAndAddStr(s) and cnt1 <= 3:
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
                         #    return good
     return cntArr[0]
 
 
 #m0 = 220000
 #good0 = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L, 12102420121L, 12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L, 1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L, 4004009004004L, 100000020000001L, 100220141022001L, 102012040210201L, 102234363432201L, 121000242000121L, 121242363242121L, 123212464212321L, 123456787654321L, 400000080000004L, 10000000200000001L, 10002000300020001L, 10004000600040001L, 10020210401202001L, 10022212521222001L, 10024214841242001L, 10201020402010201L, 10203040504030201L, 10205060806050201L, 10221432623412201L, 10223454745432201L, 12100002420000121L, 12102202520220121L, 12104402820440121L, 12122232623222121L, 12124434743442121L, 12321024642012321L, 12323244744232321L, 12343456865434321L, 12345678987654321L, 40000000800000004L, 40004000900040004L, 1000000002000000001L, 1000220014100220001L, 1002003004003002001L, 1002223236323222001L, 1020100204020010201L, 1020322416142230201L, 1022123226223212201L, 1022345658565432201L, 1210000024200000121L, 1210242036302420121L, 1212203226223022121L, 1212445458545442121L, 1232100246420012321L, 1232344458544432321L, 1234323468643234321L, 4000000008000000004L, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]
 m0 = 2300000
 good0 = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201,
          104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L, 12102420121L,
          12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L,
          1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L,
          4004009004004L, 100000020000001L, 100220141022001L, 102012040210201L, 102234363432201L, 121000242000121L,
          121242363242121L, 123212464212321L, 123456787654321L, 400000080000004L, 10000000200000001L, 10002000300020001L,
          10004000600040001L, 10020210401202001L, 10022212521222001L, 10024214841242001L, 10201020402010201L,
          10203040504030201L, 10205060806050201L, 10221432623412201L, 10223454745432201L, 12100002420000121L,
          12102202520220121L, 12104402820440121L, 12122232623222121L, 12124434743442121L, 12321024642012321L,
          12323244744232321L, 12343456865434321L, 12345678987654321L, 40000000800000004L, 40004000900040004L,
          1000000002000000001L, 1000220014100220001L, 1002003004003002001L, 1002223236323222001L, 1020100204020010201L,
          1020322416142230201L, 1022123226223212201L, 1022345658565432201L, 1210000024200000121L, 1210242036302420121L,
          1212203226223022121L, 1212445458545442121L, 1232100246420012321L, 1232344458544432321L, 1234323468643234321L,
          4000000008000000004L, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L,
          100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L,
          100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L,
          102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L,
          102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L,
          102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L,
          121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L,
          121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L,
          123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L,
          400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L,
          10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L,
          10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L,
          10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L,
          10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L,
          12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L,
          12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L,
          40000000000800000000004L, 1000000000002000000000001L, 1000002000003000002000001L, 1000004000006000004000001L,
          1000020200104010020200001L, 1000022200125210022200001L, 1000024200148410024200001L, 1000200030004000300020001L,
          1000202030205020302020001L, 1000204030408040304020001L, 1000220232126212320220001L, 1000222232347432322220001L,
          1002001002004002001002001L, 1002003004005004003002001L, 1002005006008006005002001L, 1002021222306032221202001L,
          1002023224327234223202001L, 1002201232026202321022001L, 1002203234227224323022001L, 1002221454348434541222001L,
          1002223456569656543222001L, 1020100000204020000010201L, 1020102020205020202010201L, 1020104040208020404010201L,
          1020120402306032040210201L, 1020122422327232242210201L, 1020302030406040302030201L, 1020304050607060504030201L,
          1020322434528254342230201L, 1020324454749474544230201L, 1022121002226222001212201L, 1022123024227224203212201L,
          1022141424528254241412201L, 1022143446549456443412201L, 1022323232448442323232201L, 1022325254649464525232201L,
          1210000000024200000000121L, 1210002200025200022000121L, 1210004400028200044000121L, 1210022220126210222200121L,
          1210024420147410244200121L, 1210220032026202300220121L, 1210222232227222322220121L, 1210242254148414522420121L,
          1210244454369634544420121L, 1212201002226222001022121L, 1212203204227224023022121L, 1212223242528252423222121L,
          1212225444549454445222121L, 1212421234248424321242121L, 1212423436449446343242121L, 1232100000246420000012321L,
          1232102220247420222012321L, 1232122422348432242212321L, 1232124642369632464212321L, 1232322032448442302232321L,
          1232324252649462524232321L, 1234321002468642001234321L, 1234323224469644223234321L, 4000000000008000000000004L,
          4000004000009000004000004L, 100000000000020000000000001L, 100000220000141000022000001L,
          100002002010040010200200001L, 100002222012363210222200001L, 100020001200040002100020001L,
          100020221222161222122020001L, 100022003410262014300220001L, 100022223434585434322220001L,
          100200100020040020001002001L, 100200320240161042023002001L, 100202104032060230401202001L,
          100202324254383452423202001L, 100220121220262022121022001L, 100220341462383264143022001L,
          100222125432484234521222001L, 102010000002040200000010201L, 102010222202161202222010201L,
          102012022032060230220210201L, 102012244234383432442210201L, 102030201204060402102030201L,
          102030423426181624324030201L, 102032223434282434322230201L, 102212100022262220001212201L,
          102212322442383244223212201L, 102214124054282450421412201L, 102232321224484422123232201L,
          121000000000242000000000121L, 121000242000363000242000121L, 121002202210262012202200121L,
          121002444212585212444200121L, 121022001220262022100220121L, 121022243242383242342220121L,
          121024203630484036302420121L, 121220100022262220001022121L, 121220342242383242243022121L,
          121222304234282432403222121L, 121242121242484242121242121L, 123210000002464200000012321L,
          123210244202585202442012321L, 123212222232484232222212321L, 123232201224484422102232321L,
          123432100024686420001234321L, 400000000000080000000000004L]
 
 good1 = []
 with open('cache3.txt') as cacheF:
     good1 = map(int, cacheF.readlines())
 
 def binarySearch(l, x):
     a = 0
     b = len(l) - 1
     if(x < l[0]):
         return 0
     if(x > l[b]):
         return len(l)
     while a < b:
         mid = (a + b) // 2
         midval = l[mid]
         if x == midval:
             return mid
         elif a == mid:
             return a if midval > x else b
         elif midval < x:
             a = mid
         else:
             b = mid
     return a
 
 
 def findAllGood3(a, b):
     res2 = filter(lambda x: (a <= x) and (x <= b), good0)
     left = binarySearch(good1, a)
     right = binarySearch(good1, b)
     if good1[right] == b:
         right += 1
     res = right - left
     if res != len(res2):
         print ""!!!!! "" + str(res) + ""  "" + str((res2))
         #return res
     return  good1[left:right]
     #return filter(lambda x: (a <= x) and (x <= b), good0)
 
 def findAllGood3Cnt(a, b):
     res2 = filter(lambda x: (a <= x) and (x <= b), good0)
     left = binarySearch(good1, a)
     right = binarySearch(good1, b)
     if good1[right] == b:
         right += 1
     res = right - left
     return res
 
 
 #fileCache = open(""cache.txt"", 'w')
 
 #m = 220000
 #m = 220000
 #m = 2300000
 #good = findAllGood(m)
 #good = sorted(good)
 #print str(m) + "":  "" + str(len(good)) + ""  -  "" + str(good)
 #a = 1234321
 #b = 41002000000000
 #print '----------------------------------'
 #allCnts = []
 #totalCnt = 0
 #for p in xrange(0, 100, 2):
 #    a = 10 ** p
 #    b = 10 ** (p + 1)
 #    cnt = findAllGood2Cnt2(a, b)
 #    totalCnt += cnt
 #    allCnts.append(cnt)
 #    allCnts.append(0)
 #    #cntOld = findAllGood2Cnt(a, b)
 #    print ""{0}: a={1}, b={2}: total = {3} count = {4}"".format((time.time() - startTime), p, (p + 1), totalCnt, cnt)
 #    #print ""{0}: a={1}, b={2}: count = {3}, old = {4}"".format((time.time() - startTime), p, (p+1), cnt, cntOld)
 #    #print ""{0}: a={1}, b={2}: count = {3}"".format((time.time() - startTime), a, b, cnt)
 #    fileCache.flush()
 #print '----------------------------------'
 #print allCnts
 #print '----------------------------------'
 #fileCache.close()
 
 #fileCache = open(""cache.txt"", 'r')
 #allLines = fileCache.readlines()
 #fileCache.close()
 #allValues = map(int, allLines)
 #allValues = sorted(allValues)
 #fileCache2 = open(""cache3.txt"", 'w')
 #fileCache2.write(""\n"".join(map(str,allValues)))
 #fileCache2.close()
 
 
 sources = [
     22,
     212,
     1221,
     2112,
 
     1,
     111,
     1111,
     11111,
     111111,
     1111111,
     11111111,
     111111111,
     1234567890
 
 ]
 
 #a = 1
 #b = 10 ** 10
 ##print '----------------------------------'
 ##good2Cnt2 = findAllGood2Cnt2(a, b)
 ##print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good2Cnt2), sorted(good2Cnt2))
 #good2Cnt2 = findAllGood2Cnt2(a, b)
 #print ""{0}: a={1}, b={2}: count = {3}"".format((time.time() - startTime), a, b, good2Cnt2)
 #good2Cnt = findAllGood2Cnt(a, b)
 #print ""{0}: a={1}, b={2}: count = {3}"".format((time.time() - startTime), a, b, good2Cnt)
 #good2 = findAllGood2(a, b)
 #good2 = sorted(good2)
 #good3 = findAllGood3(a, b)
 #print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good2), good2)
 #print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good3), good3)
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '{0}:--------------------------------------------'.format((time.time() - startTime))
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
             #outF.write('Case #' + str(i) + "": "" + ('YES' if res else 'NO'))
 
 
 
 
",gcj/2013/2270488/SergGr/2463486/1/extracted/TaskC.py,18978,384,1618,Python,2270488,1,2463486,SergGr,2013
71751,TaskC.py,"inputFileName = ""test.in""
 inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     a = int(line.split()[0])
     b = int(line.split()[1])
     cnt2 = findAllGood2Cnt(a, b)
     cnt3 = len(findAllGood3(a, b))
     if cnt3 <> cnt2:
         print ""!!!!!!!!!!a={0}, b={1}, cnt2={2}, cnt3={3}"".format(a, b, cnt2, cnt3)
     return cnt2
 
 
 def isPalindrome(x):
     strX = str(x)
     return strX == strX[::-1]
 
 
 def findAllGood(m):
     good = []
     for x in xrange(1, m):
         #if (x % 10000) == 0: print x
         #if (x % 10) == 0: continue
         strX = str(x)
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         sq1 = x1 * x1
         sq2 = x2 * x2
         if isPalindrome(sq1):
             good.append(sq1)
             #print str(x1) + "" - "" + str(sq1) + ""   "" + str(len(str(sq1)))
         if isPalindrome(sq2):
             good.append(sq2)
             #print str(x2) + "" - "" + str(sq2) + ""   "" + str(len(str(sq2)))
     return good
 
 
 def findAllGood2(a, b):
     good = []
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 good.append(x2)
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             #print ""s = "" + str(s)
             if checkAndAddStr(s):
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
     return good
 
 
 def findAllGood2Cnt(a, b):
     cntArr = [0]
 
     def checkAndAdd(x):
         x2 = x * x
         if isPalindrome(x2):
             if(a <= x2) and (x2 <= b):
                 cntArr[0] += 1
                 #print(x2)
             return True
         else:
             return False
 
     def checkAndAddStr(strX):
         str1 = strX[:-1] + strX[::-1]
         str2 = strX + strX[::-1]
         #print strX + "" - "" + str1 + "" - "" + str2
         x1 = int(str1)
         x2 = int(str2)
         r1 = checkAndAdd(x1)
         r2 = checkAndAdd(x2)
         return  r1 or r2
 
     checkAndAdd(3)
     minLen = len(str(a)) / 4
     if minLen < 1: minLen = 1
     maxLen = len(str(b)) / 4 + 1
     print 'a={0}, b={1}, minLen={2}, maxLen={3}'.format(a, b, minLen, maxLen)
     for l in xrange(minLen, maxLen + 1):
         if(maxLen > 10):
             print ""len = "" + str(l) + ""  max = "" + str(maxLen)
         for x in xrange(1 << (l - 1), 1 << l):
             s = ""{0:b}"".format(x)
             #print ""s = "" + str(s)
             if checkAndAddStr(s):
                 for pos in xrange(l):
                     if s[pos] == '1':
                         tmp = s[:pos] + '2' + s[pos + 1:]
                         #print ""tmp = "" + str(tmp)
                         checkAndAddStr(tmp)
     return cntArr[0]
 
 
 #m0 = 220000
 #good0 = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L, 12102420121L, 12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L, 1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L, 4004009004004L, 100000020000001L, 100220141022001L, 102012040210201L, 102234363432201L, 121000242000121L, 121242363242121L, 123212464212321L, 123456787654321L, 400000080000004L, 10000000200000001L, 10002000300020001L, 10004000600040001L, 10020210401202001L, 10022212521222001L, 10024214841242001L, 10201020402010201L, 10203040504030201L, 10205060806050201L, 10221432623412201L, 10223454745432201L, 12100002420000121L, 12102202520220121L, 12104402820440121L, 12122232623222121L, 12124434743442121L, 12321024642012321L, 12323244744232321L, 12343456865434321L, 12345678987654321L, 40000000800000004L, 40004000900040004L, 1000000002000000001L, 1000220014100220001L, 1002003004003002001L, 1002223236323222001L, 1020100204020010201L, 1020322416142230201L, 1022123226223212201L, 1022345658565432201L, 1210000024200000121L, 1210242036302420121L, 1212203226223022121L, 1212445458545442121L, 1232100246420012321L, 1232344458544432321L, 1234323468643234321L, 4000000008000000004L, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L, 100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L, 100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L, 102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L, 102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L, 102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L, 121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L, 121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L, 123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L, 400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L, 10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L, 10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L, 10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L, 10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L, 12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L, 12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L, 40000000000800000000004L]
 m0 = 2300000
 good0 = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201,
          104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001L, 10221412201L, 12102420121L,
          12345654321L, 40000800004L, 1000002000001L, 1002003002001L, 1004006004001L, 1020304030201L, 1022325232201L,
          1024348434201L, 1210024200121L, 1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L, 4000008000004L,
          4004009004004L, 100000020000001L, 100220141022001L, 102012040210201L, 102234363432201L, 121000242000121L,
          121242363242121L, 123212464212321L, 123456787654321L, 400000080000004L, 10000000200000001L, 10002000300020001L,
          10004000600040001L, 10020210401202001L, 10022212521222001L, 10024214841242001L, 10201020402010201L,
          10203040504030201L, 10205060806050201L, 10221432623412201L, 10223454745432201L, 12100002420000121L,
          12102202520220121L, 12104402820440121L, 12122232623222121L, 12124434743442121L, 12321024642012321L,
          12323244744232321L, 12343456865434321L, 12345678987654321L, 40000000800000004L, 40004000900040004L,
          1000000002000000001L, 1000220014100220001L, 1002003004003002001L, 1002223236323222001L, 1020100204020010201L,
          1020322416142230201L, 1022123226223212201L, 1022345658565432201L, 1210000024200000121L, 1210242036302420121L,
          1212203226223022121L, 1212445458545442121L, 1232100246420012321L, 1232344458544432321L, 1234323468643234321L,
          4000000008000000004L, 100000000020000000001L, 100002000030000200001L, 100004000060000400001L,
          100020201040102020001L, 100022201252102220001L, 100024201484102420001L, 100200120040021002001L,
          100202122050221202001L, 100204124080421402001L, 100220341262143022001L, 100222343474343222001L,
          102010002040200010201L, 102012022050220210201L, 102014042080240410201L, 102030405060504030201L,
          102032425272524230201L, 102212122262221212201L, 102214144272441412201L, 102232545484545232201L,
          102234567696765432201L, 121000000242000000121L, 121002200252002200121L, 121004400282004400121L,
          121022221262122220121L, 121024421474124420121L, 121220122262221022121L, 121222324272423222121L,
          121242363484363242121L, 121244565696565442121L, 123210002464200012321L, 123212222474222212321L,
          123232425484524232321L, 123234645696546432321L, 123432124686421234321L, 123434346696643434321L,
          400000000080000000004L, 400004000090000400004L, 10000000000200000000001L, 10000220001410002200001L,
          10002002100400120020001L, 10002222123632122220001L, 10020010200400201002001L, 10020230421612403202001L,
          10022014302620341022001L, 10022234545854543222001L, 10201000020402000010201L, 10201222221612222210201L,
          10203022140604122030201L, 10203244363836344230201L, 10221210222622201212201L, 10221432643834623412201L,
          10223234344844343232201L, 12100000002420000000121L, 12100242003630024200121L, 12102202302620320220121L,
          12102444325852344420121L, 12122010222622201022121L, 12122252443834425222121L, 12124214524842541242121L,
          12321000024642000012321L, 12321244225852244212321L, 12323222344844322232321L, 12343210246864201234321L,
          40000000000800000000004L, 1000000000002000000000001L, 1000002000003000002000001L, 1000004000006000004000001L,
          1000020200104010020200001L, 1000022200125210022200001L, 1000024200148410024200001L, 1000200030004000300020001L,
          1000202030205020302020001L, 1000204030408040304020001L, 1000220232126212320220001L, 1000222232347432322220001L,
          1002001002004002001002001L, 1002003004005004003002001L, 1002005006008006005002001L, 1002021222306032221202001L,
          1002023224327234223202001L, 1002201232026202321022001L, 1002203234227224323022001L, 1002221454348434541222001L,
          1002223456569656543222001L, 1020100000204020000010201L, 1020102020205020202010201L, 1020104040208020404010201L,
          1020120402306032040210201L, 1020122422327232242210201L, 1020302030406040302030201L, 1020304050607060504030201L,
          1020322434528254342230201L, 1020324454749474544230201L, 1022121002226222001212201L, 1022123024227224203212201L,
          1022141424528254241412201L, 1022143446549456443412201L, 1022323232448442323232201L, 1022325254649464525232201L,
          1210000000024200000000121L, 1210002200025200022000121L, 1210004400028200044000121L, 1210022220126210222200121L,
          1210024420147410244200121L, 1210220032026202300220121L, 1210222232227222322220121L, 1210242254148414522420121L,
          1210244454369634544420121L, 1212201002226222001022121L, 1212203204227224023022121L, 1212223242528252423222121L,
          1212225444549454445222121L, 1212421234248424321242121L, 1212423436449446343242121L, 1232100000246420000012321L,
          1232102220247420222012321L, 1232122422348432242212321L, 1232124642369632464212321L, 1232322032448442302232321L,
          1232324252649462524232321L, 1234321002468642001234321L, 1234323224469644223234321L, 4000000000008000000000004L,
          4000004000009000004000004L, 100000000000020000000000001L, 100000220000141000022000001L,
          100002002010040010200200001L, 100002222012363210222200001L, 100020001200040002100020001L,
          100020221222161222122020001L, 100022003410262014300220001L, 100022223434585434322220001L,
          100200100020040020001002001L, 100200320240161042023002001L, 100202104032060230401202001L,
          100202324254383452423202001L, 100220121220262022121022001L, 100220341462383264143022001L,
          100222125432484234521222001L, 102010000002040200000010201L, 102010222202161202222010201L,
          102012022032060230220210201L, 102012244234383432442210201L, 102030201204060402102030201L,
          102030423426181624324030201L, 102032223434282434322230201L, 102212100022262220001212201L,
          102212322442383244223212201L, 102214124054282450421412201L, 102232321224484422123232201L,
          121000000000242000000000121L, 121000242000363000242000121L, 121002202210262012202200121L,
          121002444212585212444200121L, 121022001220262022100220121L, 121022243242383242342220121L,
          121024203630484036302420121L, 121220100022262220001022121L, 121220342242383242243022121L,
          121222304234282432403222121L, 121242121242484242121242121L, 123210000002464200000012321L,
          123210244202585202442012321L, 123212222232484232222212321L, 123232201224484422102232321L,
          123432100024686420001234321L, 400000000000080000000000004L]
 #print(400000000000090000000000004L**0.5)
 #20000000000002
 #12345678901234
 #20000000000002
 print(int(400000000000090000000000004L ** 0.5))
 
 def findAllGood3(a, b):
     return filter(lambda x: (a <= x) and (x <= b), good0)
 
 #m = 220000
 #m = 220000
 #m = 2300000
 #good = findAllGood(m)
 #good = sorted(good)
 #print str(m) + "":  "" + str(len(good)) + ""  -  "" + str(good)
 #a = 1234321
 #b = 41002000000000
 a = 1
 b = 10 ** 10
 #print '----------------------------------'
 good2Cnt = findAllGood2Cnt(a, b)
 print ""a={0}, b={1}: count = {2}"".format(a, b, good2Cnt)
 good2 = findAllGood2(a, b)
 good2 = sorted(good2)
 good3 = findAllGood3(a, b)
 print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good2), good2)
 print ""a={0}, b={1}: count = {2}  -  {3}"".format(a, b, len(good3), good3)
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
             #outF.write('Case #' + str(i) + "": "" + ('YES' if res else 'NO'))
 
 
 
 
",gcj/2013/2270488/SergGr/2463486/0/extracted/TaskC.py,14653,234,1057,Python,2270488,0,2463486,SergGr,2013
71752,TaskB.py,"#inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 def minLine(list1, list2):
     return map(min, list1, list2)
 
 
 def maxLine(list1, list2):
     return map(max, list1, list2)
 
 
 def getXLine(data, x):
     for line in data:
         yield line[x]
 
 
 def calcSingleTest2(f):
     line = f.readline()
     N = int(line.split()[0])
     M = int(line.split()[1])
     #    print str(N) + ""  "" + str(M)
     data = []
     minY = []
     minX = [100500] * M
     maxY = []
     maxX = [0] * M
     for y in xrange(N):
         line = f.readline()
         dataLine = map(int, line.split())
         minX = minLine(minX, dataLine)
         minY.append(min(dataLine))
         maxX = maxLine(maxX, dataLine)
         maxY.append(max(dataLine))
         data.append(dataLine)
 
     for y in xrange(N):
         for x in xrange(M):
             #if (data[y][x] > minX[x]) and (data[y][x] > minY[y]):
             if (data[y][x] < maxX[x]) and (data[y][x] < maxY[y]):
                 return False
     return True
 
 
 def checkRow(data, y, x, M, N):
     d = data[y][x]
     for i in xrange(M):
         if i <> x:
             if data[y][i] > d:
                 return False
     return True
 
 
 def checkColumn(data, y, x, M, N):
     d = data[y][x]
     for i in xrange(N):
         if i <> y:
             if data[i][x] > d:
                 return False
     return True
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     M = int(line.split()[1])
     #    print str(N) + ""  "" + str(M)
     data = []
     for y in xrange(N):
         line = f.readline()
         dataLine = map(int, line.split())
         data.append(dataLine)
 
     for y in xrange(N):
         for x in xrange(M):
             if not(checkRow(data, y, x, M, N)) and not checkColumn(data, y, x, M, N):
                 return False
     return True
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest2(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, ('YES' if res else 'NO')))
             #outF.write('Case #' + str(i) + "": "" + ('YES' if res else 'NO'))
 
 
 
 
",gcj/2013/2270488/SergGr/2449486/1/extracted/TaskB.py,2504,96,288,Python,2270488,1,2449486,SergGr,2013
71753,TaskB.py,"#inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 inputFileName = ""B-small-attempt2.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 def minLine(list1, list2):
     return map(min, list1, list2)
 
 
 def maxLine(list1, list2):
     return map(max, list1, list2)
 
 
 def getXLine(data, x):
     for line in data:
         yield line[x]
 
 
 def calcSingleTest2(f):
     line = f.readline()
     N = int(line.split()[0])
     M = int(line.split()[1])
     #    print str(N) + ""  "" + str(M)
     data = []
     minY = []
     minX = [100500] * M
     maxY = []
     maxX = [0] * M
     for y in xrange(N):
         line = f.readline()
         dataLine = map(int, line.split())
         minX = minLine(minX, dataLine)
         minY.append(min(dataLine))
         maxX = maxLine(maxX, dataLine)
         maxY.append(max(dataLine))
         data.append(dataLine)
 
     for y in xrange(N):
         for x in xrange(M):
             #if (data[y][x] > minX[x]) and (data[y][x] > minY[y]):
             if (data[y][x] < maxX[x]) and (data[y][x] < maxY[y]):
                 return False
     return True
 
 
 def checkRow(data, y, x, M, N):
     d = data[y][x]
     for i in xrange(M):
         if i <> x:
             if data[y][i] > d:
                 return False
     return True
 
 
 def checkColumn(data, y, x, M, N):
     d = data[y][x]
     for i in xrange(N):
         if i <> y:
             if data[i][x] > d:
                 return False
     return True
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     M = int(line.split()[1])
     #    print str(N) + ""  "" + str(M)
     data = []
     for y in xrange(N):
         line = f.readline()
         dataLine = map(int, line.split())
         data.append(dataLine)
 
     for y in xrange(N):
         for x in xrange(M):
             if not(checkRow(data, y, x, M, N)) and not checkColumn(data, y, x, M, N):
                 return False
     return True
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest2(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, ('YES' if res else 'NO')))
             #outF.write('Case #' + str(i) + "": "" + ('YES' if res else 'NO'))
 
 
 
 
",gcj/2013/2270488/SergGr/2449486/0/extracted/TaskB.py,2473,95,285,Python,2270488,0,2449486,SergGr,2013
71754,TaskD.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""D-small-attempt0.in""
 #inputFileName = ""D-small-attempt1.in""
 #inputFileName = ""D-small-attempt2.in""
 inputFileName = ""D-small-attempt3.in""
 #inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     K = int(line.split()[0])
     N = int(line.split()[1])
     initKeysList = map(int, f.readline().split())
     #print initKeysList
     #initKeys = dict(itertools.groupby(initKeysList))
     initKeys = Counter(initKeysList)
     keyAvailable = initKeys.copy()
     keyRequired = Counter()
     #print initKeysList
     #print initKeys
     allChests = []
     for y in xrange(N):
         line = f.readline()
         dataLine = map(int, line.split())
         chest = (y, dataLine[0], dataLine[2:])
         keyRequired += Counter([dataLine[0]])
         keyAvailable += Counter(dataLine[2:])
         allChests.append(chest)
 
     keyRequired =  Counter(sorted(keyRequired.elements()))
     keyAvailable =  Counter(sorted(keyAvailable.elements()))
     keyRequiredList = sorted(((k, v) for k, v in keyRequired.iteritems()))
     keyAvailableList = sorted(((k, v) for k, v in keyAvailable.iteritems()))
     print ""Req = "" + str(keyRequiredList)
     print ""Avl = "" + str(keyAvailableList)
     #good = reduce(operator.and_, map(lambda r,a: r is None or r<=a,keyRequiredList, keyAvailableList))
     good = True
     for k, v in keyRequired.iteritems():
         a = keyAvailable[k]
         if a < v:
             good = False
     if not good:
         print ""Bad!!!""
         return ""IMPOSSIBLE""
         #print ""Dif = "" + str(keyAvailable - keyRequired)
 
 
     #print allChests
     allChestsIndices = range(N)
     solved = dict()
     empty = tuple([])
     solved[empty] = ([], initKeys)
     lastSolved = None
     someSolved = True
     for size in xrange(1, N + 1):
 #        if not someSolved:
 #            return ""IMPOSSIBLE""
         someSolved = False
         #print ""Solved = "" + str(solved)
         #print '--------------'
         for problem in itertools.combinations(allChestsIndices, size):
             lastSolved = None
             #print ""Solved = "" + str(solved)
             #print problem
             #list_problem = map(lambda pos: allChests[pos], list(problem))
             list_problem = list(problem)
             for pos in xrange(size, 0, -1):
                 # good order!
                 #(chestIndex, chestOpenKey, chestKeys) =  list_problem[pos - 1]
                 (chestIndex, chestOpenKey, chestKeys) = allChests[list_problem[pos - 1]]
                 subproblem = tuple(list_problem[:pos - 1] + list_problem[pos:])
                 if(subproblem in solved):
                     (subpath, subkeys) = solved[subproblem]
                     if(chestOpenKey in subkeys):
                         newKeys = subkeys.copy()
                         openKeys = Counter(chestKeys)
                         newKeys += openKeys
                         newKeys -= Counter([chestOpenKey])
                         #print subkeys
                         #print openKeys
                         #print newKeys
                         newPath = list(subpath)
                         newPath.append(chestIndex)
                         lastSolved = (tuple(newPath), newKeys)
                         someSolved = True
                         #print lastSolved
                         solved[problem] = (tuple(newPath), newKeys)
                         break
 
     print ""K = {0}, N = {1}, Solved size {2}"".format(K, N, len(solved))
     if not lastSolved:
         return ""IMPOSSIBLE""
     else:
         (path, keys) = lastSolved
         return ' '.join(map(lambda x: str(x + 1), path))
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2013/2270488/SergGr/2458486/0/extracted/TaskD.py,4557,119,415,Python,2270488,0,2458486,SergGr,2013
3024,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def parseBits(s):
     return map(int, s)
 
 
 def calcBits(bs, pos):
     cnt = 0
     for b in bs:
         if b[pos] == 1:
             cnt += 1
     return cnt
 
 
 def invertBits(bs, pos):
     copy = []
     for b0 in bs:
         b = b0[:]
         if b[pos] == 1:
             b[pos] = 0
         else:
             b[pos] = 1
         copy.append(b)
     return sorted(copy)
 
 
 
 def comp(sources, devices, pos, N):
     sources = sorted(sources)
     devices = sorted(devices)
     for x in xrange(N):
         s = sources[x][0:pos]
         d = devices[x][0:pos]
         if s != d:
             return False
     return True
 
 
 def test(sources, devices, sCnt, dCnt, pos, N, L):
     if pos >= L:
         sources = sorted(sources)
         devices = sorted(devices)
         if sources == devices:
             print ""Good""
             print sources
             print devices
             return 0
         else:
             return -1
     if sCnt[pos] == dCnt[pos]:
         if not comp(sources, devices, pos, N):
             return -1
         r = test(sources, devices, sCnt, dCnt, pos + 1, N, L)
         if r != -1:
             return r
     if sCnt[pos] + dCnt[pos] == N:
         copy = invertBits(sources, pos)
         if not comp(copy, devices, pos, N):
             return -1
         r = test(copy, devices, sCnt, dCnt, pos + 1, N, L)
         if r != -1:
             print ""Invert "" + str(pos)
             return r + 1
 
     return -1
 
 
 def testBF(sources0, devices0, sCnt, dCnt, pos, N, L):
     sources = sources0[:]
     devices = devices0[:]
     if pos >= L:
         sources = sorted(sources)
         devices = sorted(devices)
         #        print 'cmp'
         #        print sources
         #        print devices
         #        print str(sources == devices)
         if sources == devices:
         #            print ""Good""
         #            print sources
         #            print devices
             return 0
         else:
             return -1
 
     r = testBF(sources[:], devices[:], sCnt, dCnt, pos + 1, N, L)
     if r != -1:
         return r
 
 
     r = testBF(invertBits(sources, pos), devices[:], sCnt, dCnt, pos + 1, N, L)
     if r != -1:
     #        print ""Invert "" + str(pos)
         return r + 1
 
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     L = int(line.split()[1])
     line = f.readline()
     #print line
     sources = map(parseBits, line.split())
     #sources = line.split()
     line = f.readline()
     #print line
     devices = map(parseBits, line.split())
     #devices = line.split()
     print sources
     print devices
 
     sCnt = []
     dCnt = []
     for pos in xrange(L):
         sCnt.append(calcBits(sources, pos))
         dCnt.append(calcBits(devices, pos))
     print sCnt
     print dCnt
 
     for pos in xrange(L):
         if sCnt[pos] != dCnt[pos] and sCnt[pos] + dCnt[pos] != N:
             return ""NOT POSSIBLE""
 
     #r2 = testBF(sources[:], devices[:], sCnt, dCnt, 0, N, L)
     r = test(sources[:], devices[:], sCnt, dCnt, 0, N, L)
 #    if r != r2:
 #        print ""!!!!!! "" + str(r) + "" "" + str(r2)
     if r == -1:
         return ""NOT POSSIBLE""
     else:
         print ""Good "" + str(r)
         return r
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/2984486/SergGr/5634947029139456/1/extracted/TaskA.py,3931,156,464,Python,2984486,1,5634947029139456,SergGr,2014
3025,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def parseBits(s):
     return map(int, s)
 
 
 def calcBits(bs, pos):
     cnt = 0
     for b in bs:
         if b[pos] == 1:
             cnt += 1
     return cnt
 
 
 def invertBits(bs, pos):
     copy = []
     for b0 in bs:
         b = b0[:]
         if b[pos] == 1:
             b[pos] = 0
         else:
             b[pos] = 1
         copy.append(b)
     return sorted(copy)
 
 
 
 def comp(sources, devices, pos, N):
     sources = sorted(sources)
     devices = sorted(devices)
     for x in xrange(N):
         s = sources[x][0:pos]
         d = devices[x][0:pos]
         if s != d:
             return False
     return True
 
 
 def test(sources, devices, sCnt, dCnt, pos, N, L):
     if pos >= L:
         sources = sorted(sources)
         devices = sorted(devices)
         if sources == devices:
             print ""Good""
             print sources
             print devices
             return 0
         else:
             return -1
     if sCnt[pos] == dCnt[pos]:
 #        if not comp(sources, devices, pos, N):
 #            return -1
         r = test(sources, devices, sCnt, dCnt, pos + 1, N, L)
         if r != -1:
             return r
     if sCnt[pos] + dCnt[pos] == N:
         copy = invertBits(sources, pos)
         r = test(copy, devices, sCnt, dCnt, pos + 1, N, L)
         if r != -1:
             print ""Invert "" + str(pos)
             return r + 1
 
     return -1
 
 
 def testBF(sources0, devices0, sCnt, dCnt, pos, N, L):
     sources = sources0[:]
     devices = devices0[:]
     if pos >= L:
         sources = sorted(sources)
         devices = sorted(devices)
         #        print 'cmp'
         #        print sources
         #        print devices
         #        print str(sources == devices)
         if sources == devices:
         #            print ""Good""
         #            print sources
         #            print devices
             return 0
         else:
             return -1
 
     r = testBF(sources[:], devices[:], sCnt, dCnt, pos + 1, N, L)
     if r != -1:
         return r
 
 
     r = testBF(invertBits(sources, pos), devices[:], sCnt, dCnt, pos + 1, N, L)
     if r != -1:
     #        print ""Invert "" + str(pos)
         return r + 1
 
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     L = int(line.split()[1])
     line = f.readline()
     #print line
     sources = map(parseBits, line.split())
     #sources = line.split()
     line = f.readline()
     #print line
     devices = map(parseBits, line.split())
     #devices = line.split()
     print sources
     print devices
 
     sCnt = []
     dCnt = []
     for pos in xrange(L):
         sCnt.append(calcBits(sources, pos))
         dCnt.append(calcBits(devices, pos))
     print sCnt
     print dCnt
 
     for pos in xrange(L):
         if sCnt[pos] != dCnt[pos] and sCnt[pos] + dCnt[pos] != N:
             return ""NOT POSSIBLE""
 
     r2 = testBF(sources[:], devices[:], sCnt, dCnt, 0, N, L)
     r = test(sources[:], devices[:], sCnt, dCnt, 0, N, L)
     if r != r2:
         print ""!!!!!! "" + str(r) + "" "" + str(r2)
     if r == -1:
         return ""NOT POSSIBLE""
     else:
         print ""Good "" + str(r)
         return r
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/2984486/SergGr/5634947029139456/0/extracted/TaskA.py,3862,154,456,Python,2984486,0,5634947029139456,SergGr,2014
39743,TaskD.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""D-small-attempt0.in""
 #inputFileName = ""D-small-attempt1.in""
 #inputFileName = ""D-small-attempt2.in""
 #inputFileName = ""D-small-attempt3.in""
 inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 def calc(p1, p2):
     n = len(p1)
     i1 = 0
     i2 = 0
     cnt = 0
     while i1 < n and i2 < n:
         if p1[i1] > p2[i2]:
             i1 += 1
             i2 += 1
             cnt += 1
         else:
             i2 += 1
     return cnt
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     p1 = map(float, line.split())
     line = f.readline()
     p2 = map(float, line.split())
     p1.sort(reverse=True)
     p2.sort(reverse=True)
     print p1
     print p2
     w1 = calc(p1, p2)
     w2 = N - calc(p2, p1)
 
     return (w1, w2)
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1, r2 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1} {2}\n'.format(i, r1, r2))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/2974486/SergGr/5644738749267968/1/extracted/TaskD.py,1669,61,185,Python,2974486,1,5644738749267968,SergGr,2014
39744,TaskD.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 inputFileName = ""D-small-attempt0.in""
 #inputFileName = ""D-small-attempt1.in""
 #inputFileName = ""D-small-attempt2.in""
 #inputFileName = ""D-small-attempt3.in""
 #inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 def calc(p1, p2):
     n = len(p1)
     i1 = 0
     i2 = 0
     cnt = 0
     while i1 < n and i2 < n:
         if p1[i1] > p2[i2]:
             i1 += 1
             i2 += 1
             cnt += 1
         else:
             i2 += 1
     return cnt
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     p1 = map(float, line.split())
     line = f.readline()
     p2 = map(float, line.split())
     p1.sort(reverse=True)
     p2.sort(reverse=True)
     print p1
     print p2
     w1 = calc(p1, p2)
     w2 = N - calc(p2, p1)
 
     return (w1, w2)
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1, r2 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1} {2}\n'.format(i, r1, r2))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/2974486/SergGr/5644738749267968/0/extracted/TaskD.py,1669,61,185,Python,2974486,0,5644738749267968,SergGr,2014
39745,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     C0 = float(line.split()[0])
     F0 = float(line.split()[1])
     X0 = float(line.split()[2])
     S0 = 2
 
     #    k = 100000
     k = 1
     C = C0 * k
     F = F0 * k
     X = X0 * k
     S = S0 * k
     tf = C / F
 
     cs = S
     tt = 0
     et = (X - C) / cs
     while et > tf:
         tt += C / cs
         cs += F
         et = (X - C) / cs
     et0 = X / cs
     return et0 + tt
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/2974486/SergGr/5709773144064000/1/extracted/TaskB.py,1516,57,189,Python,2974486,1,5709773144064000,SergGr,2014
39746,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     C0 = float(line.split()[0])
     F0 = float(line.split()[1])
     X0 = float(line.split()[2])
     S0 = 2
 
     #    k = 100000
     k = 1
     C = C0 * k
     F = F0 * k
     X = X0 * k
     S = S0 * k
     tf = C / F
 
     cs = S
     tt = 0
     et = (X - C) / cs
     while et > tf:
         tt += C / cs
         cs += F
         et = (X - C) / cs
     et0 = X / cs
     return et0 + tt
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/2974486/SergGr/5709773144064000/0/extracted/TaskB.py,1516,57,189,Python,2974486,0,5709773144064000,SergGr,2014
39747,TaskC.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-small-attempt3.in""
 #inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     R = int(line.split()[0])
     C = int(line.split()[1])
     M = int(line.split()[2])
 
     s = R * C
     f = s - M
     if R == 1:
         return 'c' + '.' * (f - 1) + '*' * M
     elif C == 1:
         return ('c\n' + '.\n' * (f - 1) + '*\n' * M)[:-1] #cut finishing \n
     else:
         if f == 2 or f == 3:
             return ""Impossible""
         data = """"
         if f < C:
             f1 = (f + 1) / 2
             f2 = (f - f1)
             r1 = 'c' + '.' * (f1 - 1) + '*' * (C - f1)
             r2 = '.' * f2 + '*' * (C - f2)
             data += r1 + ""\n""
             data += r2 + ""\n""
             for y in xrange(R - 2):
                 row = '*' * C
                 data += row + ""\n""
         elif M < C:
             m1 = (M + 1) / 2
             m2 = (M - m1)
             for y in xrange(R - 2):
                 row = '.' * C
                 data += row + ""\n""
             r1 = '.' * (C - m1) + '*' * m1
             r2 = '.' * (C - m2) + '*' * m2
             data += r1 + ""\n""
             data += r2 + ""\n""
         else:
             left = f
             for y in xrange(R):
                 row = """"
                 for x in xrange(C):
                     row += (""."" if left > 0 else ""*"")
                     left -= 1
                 data += row + ""\n""
         data = 'c' + data[1:]
         return data[:-1] #cut finishing \n
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}:\n{1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/2974486/SergGr/5690574640250880/0/extracted/TaskC.py,2492,78,345,Python,2974486,0,5690574640250880,SergGr,2014
39748,TaskA.py,"#inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 N = 4
 XWon = ""X won""
 OWon = ""O won""
 Draw = ""Draw""
 NotCompleted = ""Game has not completed""
 
 def getXLine(data, x):
     for line in data:
         yield line[x]
 
 
 def getD1Line(data):
     x = 0
     for line in data:
         yield line[x]
         x += 1
 
 
 def getD2Line(data):
     x = 0
     l = len(data)
     for line in data:
         x += 1
         yield line[l - x]
 
 
 def checkLine(line, player):
     for c in line:
         if c != 'T' and c != player:
             return False
     return True
 
 
 def checkWin(data, player):
     for line in data:
         if checkLine(line, player):
             return True
 
     for x in xrange(N):
         if checkLine(getXLine(data, x), player):
             return True
 
     if checkLine(getD1Line(data), player):
         return True
 
     if checkLine(getD2Line(data), player):
         return True
 
     return False
 
 
 def calcSingleTest(f):
     data = []
     completed = True
     line = f.readline()
     a1 = int(line)
     c1 = []
     for y in range(4):
         line = f.readline()
         c1.append(map(int, line.split()))
 
     line = f.readline()
     a2 = int(line)
     c2 = []
     for y in range(4):
         line = f.readline()
         c2.append(map(int, line.split()))
 
     g1 = c1[a1-1]
     g2 = c2[a2-1]
     print g1
     print g2
     answ = set(g1) & set(g2)
     print answ
     l = len(answ)
     if l == 1:
         return list(answ)[0]
     elif l == 0:
         return ""Volunteer cheated!""
     else:
         return ""Bad magician!""
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/2974486/SergGr/5756407898963968/0/extracted/TaskA.py,2060,101,241,Python,2974486,0,5756407898963968,SergGr,2014
118229,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calDist(datas, x, N, avg):
     sum = 0
     for i in xrange(N):
         ch, cnt = datas[i][x]
         sum += abs(avg - cnt)
     return sum
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     lines = []
     shrunks = []
     datas = []
     bad = False
     for i in xrange(N):
         print line
         line = f.readline()
         lines.append(line)
         l = len(line)
         ch = line[0]
         cnt = 0
         shrunk = """"
         data = []
         for p in xrange(l):
             if line[p] == ch:
                 cnt += 1
             else:
                 shrunk += ch
                 data.append((ch, cnt))
                 cnt = 0
                 ch = line[p]
         shrunks.append(shrunk)
         datas.append(data)
         if shrunks[i] != shrunks[0]:
             bad = True
     if bad:
         return ""Fegla Won""
     print N
     print len(shrunks)
     print shrunks
     print datas
 
     game_sum = 0
     for x in xrange(len(datas[0])):
         sum = 0.0
         for i in xrange(N):
             ch, cnt = datas[i][x]
             sum += cnt
         avg = sum / N
         avg0 = int(avg)
         avg1 = avg0 + 1
         sum0 = calDist(datas, x, N, avg0)
         sum1 = calDist(datas, x, N, avg1)
         game_sum += min(sum0, sum1)
 
     return game_sum
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/2994486/SergGr/5751500831719424/1/extracted/TaskA.py,1973,81,219,Python,2994486,1,5751500831719424,SergGr,2014
118230,TaskA.py,"#inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calDist(datas, x, N, avg):
     sum = 0
     for i in xrange(N):
         ch, cnt = datas[i][x]
         sum += abs(avg - cnt)
     return sum
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     lines = []
     shrunks = []
     datas = []
     for i in xrange(N):
         line = f.readline()
         lines.append(line)
         l = len(line)
         ch = line[0]
         cnt = 0
         shrunk = """"
         data = []
         for p in xrange(l):
             if line[p] == ch:
                 cnt += 1
             else:
                 shrunk += ch
                 data.append((ch, cnt))
                 cnt = 0
                 ch = line[p]
         shrunks.append(shrunk)
         datas.append(data)
         if shrunks[i] != shrunks[0]:
             return ""Fegla Won""
     print shrunks
     print datas
 
     game_sum = 0
     for x in xrange(len(datas[0])):
         sum = 0.0
         for i in xrange(N):
             ch, cnt = datas[i][x]
             sum += cnt
         avg = sum / N
         avg0 = int(avg)
         avg1 = avg0 + 1
         sum0 = calDist(datas, x, N, avg0)
         sum1 = calDist(datas, x, N, avg1)
         game_sum += min(sum0, sum1)
 
     return game_sum
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/2994486/SergGr/5751500831719424/0/extracted/TaskA.py,1877,75,205,Python,2994486,0,5751500831719424,SergGr,2014
118231,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     A = int(line.split()[0])
     B = int(line.split()[1])
     K = int(line.split()[2])
     cnt = 0
     for a in xrange(A):
         for b in xrange(B):
             x = a & b
             if x < K:
                 cnt +=1
     return cnt
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/2994486/SergGr/5658282861527040/0/extracted/TaskB.py,1361,45,137,Python,2994486,0,5658282861527040,SergGr,2014
135630,TaskB.py,"import itertools
 import time
 from collections import defaultdict
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 MOD = 1000000007
 
 class ValidTrain:
     def __init__(self, t):
         self.start = t[0]
         self.end = t[-1]
         self.sames = dict()
 
 
 def fact(N):
     res = 1
     for x in xrange(1, N + 1):
         res *= x
         res %= MOD
     return res
 
 
 def shrinkSame(t):
     res = ''
     res += t[0]
     c = t[0]
     for x in xrange(1, len(t)):
         if t[x] == c:
             continue
         c = t[x]
         res += t[x]
     return res
 
 
 def testGood(s):
     cur = s[0]
     used = set()
     used.add(cur)
     for ch in s:
         if ch == cur:
             continue
         if ch in used:
             return False
         used.add(ch)
         cur = ch
     return True
 
 
 def calcSingleTest2(ts0):
     ts = []
     for t in ts0:
         ts.append(shrinkSame(t))
     cnt = 0
     for p in itertools.permutations(ts):
         s = ''
         for t in p:
             s += t
         if testGood(s):
             cnt += 1
 
     return cnt
 
 
 def calcSingleTest(f):
     line = f.readline()
     n = int(line)
     line = f.readline()
     ts = line.split()
     starts = dict()
     ends = dict()
     same = defaultdict(int)
     middles = dict()
     dif = list()
     print ts
     #r2 = calcSingleTest2(ts)
 
     for t in ts:
         s = t[0]
         e = t[-1]
         l = len(t)
         if s == e:
             for i in xrange(1, l - 1):
                 if t[i] != s:
                     return 0
             if s in same:
                 same[s] += 1
             else:
                 same[s] = 1
         else:
             if not testGood(t):
                 return 0
             dif.append(t)
             if s in starts:
                 return 0
             starts[s] = t
             if e in ends:
                 return 0
             ends[e] = t
             for i in xrange(1, l - 1):
                 if t[i] == s or t[i] == e:
                     continue
                 if t[i] in middles:
                     if middles[t[i]] != t:
                         return 0
                 else:
                     middles[t[i]] = t
     print starts
     print ends
     print middles
     print dif
     for t in ts:
         s = t[0]
         e = t[-1]
         if (s in middles and middles[s] != t) or (e in middles and (middles[e] != t)):
             return 0
 
     valids = list()
     used = set()
     used_b = set()
     for t0 in dif:
         if t0 in used:
             continue
         used.add(t0)
         v = list()
         v.append((t0, same[t0[0]], same[t0[-1]]))
         used_b.add(t0[0])
         used_b.add(t0[-1])
         t = t0
         while True:
             s = t[0]
             if s in ends:
                 t = ends[s]
                 if t in used:
                     return 0
                 used.add(t)
                 used_b.add(t[0])
                 v.append((t, same[t[0]], 1))
             else:
                 break
         v.reverse()
         t = t0
         while True:
             e = t[-1]
             if e in starts:
                 t = starts[e]
                 if t in used:
                     return 0
                 used.add(t)
                 used_b.add(t[-1])
                 v.append((t, 1, same[t[-1]]))
             else:
                 break
         print v
         valids.append(v)
 
     for s in same.keys():
         if s in used_b:
             continue
         valids.append([(s, same[s], 1)])
 
     print ""valids = {0}"".format(valids)
 
     res = 1
     for v in valids:
         for vt in v:
             (l, sc, ec) = vt
             res *= fact(sc)
             res *= fact(ec)
             res %= MOD
 
     res *= fact(len(valids))
     res %= MOD
 
 #    if res != r2:
 #        print ""!!!! AAAAAAA""
 
     return res % MOD
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/3004486/SergGr/5669245564223488/1/extracted/TaskB.py,4907,204,546,Python,3004486,1,5669245564223488,SergGr,2014
135631,TaskB.py,"import itertools
 import time
 from collections import defaultdict
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 MOD = 1000000007
 
 class ValidTrain:
     def __init__(self, t):
         self.start = t[0]
         self.end = t[-1]
         self.sames = dict()
 
 
 def fact(N):
     res = 1
     for x in xrange(1, N + 1):
         res *= x
         res %= MOD
     return res
 
 
 def shrinkSame(t):
     res = ''
     res += t[0]
     c = t[0]
     for x in xrange(1, len(t)):
         if t[x] == c:
             continue
         c = t[x]
         res += t[x]
     return res
 
 
 def testGood(s):
     cur = s[0]
     used = set()
     used.add(cur)
     for ch in s:
         if ch == cur:
             continue
         if ch in used:
             return False
         used.add(ch)
         cur = ch
     return True
 
 
 def calcSingleTest2(ts0):
     ts = []
     for t in ts0:
         ts.append(shrinkSame(t))
     cnt = 0
     for p in itertools.permutations(ts):
         s = ''
         for t in p:
             s += t
         if testGood(s):
             cnt += 1
 
     return cnt
 
 
 def calcSingleTest(f):
     line = f.readline()
     n = int(line)
     line = f.readline()
     ts = line.split()
     starts = dict()
     ends = dict()
     same = defaultdict(int)
     middles = dict()
     dif = list()
     print ts
     #r2 = calcSingleTest2(ts)
 
     for t in ts:
         s = t[0]
         e = t[-1]
         l = len(t)
         if s == e:
             for i in xrange(1, l - 1):
                 if t[i] != s:
                     return 0
             if s in same:
                 same[s] += 1
             else:
                 same[s] = 1
         else:
             if not testGood(t):
                 return 0
             dif.append(t)
             if s in starts:
                 return 0
             starts[s] = t
             if e in ends:
                 return 0
             ends[e] = t
             for i in xrange(1, l - 1):
                 if t[i] == s or t[i] == e:
                     continue
                 if t[i] in middles:
                     if middles[t[i]] != t:
                         return 0
                 else:
                     middles[t[i]] = t
     print starts
     print ends
     print middles
     print dif
     for t in ts:
         s = t[0]
         e = t[-1]
         if (s in middles and middles[s] != t) or (e in middles and (middles[e] != t)):
             return 0
 
     valids = list()
     used = set()
     used_b = set()
     for t0 in dif:
         if t0 in used:
             continue
         used.add(t0)
         v = list()
         v.append((t0, same[t0[0]], same[t0[-1]]))
         used_b.add(t0[0])
         used_b.add(t0[-1])
         t = t0
         while True:
             s = t[0]
             if s in ends:
                 t = ends[s]
                 if t in used:
                     return 0
                 used.add(t)
                 used_b.add(t[0])
                 v.append((t, same[t[0]], 1))
             else:
                 break
         v.reverse()
         t = t0
         while True:
             e = t[-1]
             if e in starts:
                 t = starts[e]
                 if t in used:
                     return 0
                 used.add(t)
                 used_b.add(t[-1])
                 v.append((t, 1, same[t[-1]]))
             else:
                 break
         print v
         valids.append(v)
 
     for s in same.keys():
         if s in used_b:
             continue
         valids.append([(s, same[s], 1)])
 
     print ""valids = {0}"".format(valids)
 
     res = 1
     for v in valids:
         for vt in v:
             (l, sc, ec) = vt
             res *= fact(sc)
             res *= fact(ec)
             res %= MOD
 
     res *= fact(len(valids))
     res %= MOD
 
 #    if res != r2:
 #        print ""!!!! AAAAAAA""
 
     return res % MOD
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/3004486/SergGr/5669245564223488/0/extracted/TaskB.py,4907,204,546,Python,3004486,0,5669245564223488,SergGr,2014
135632,TaskA.py,"from fractions import gcd
 
 #inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def log2Exact(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return -1
         p *= 2
     return -1
 
 
 def log2(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return i - 1
         p *= 2
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     p0 = int(line.split('/')[0])
     q0 = int(line.split('/')[1])
     g = gcd(p0, q0)
     p = p0 / g
     q = q0 / g
     print ""{0}/{1} {2} = {3}/{4}"".format(p0, q0, g, p, q)
     q2 = log2Exact(q)
     if p > q:
         return 'impossible'
     if q2 == -1:
         return 'impossible'
     if q2 > 40:
         return 'impossible'
     p2 = log2(p)
     return max(q2 - p2, 1)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/3004486/SergGr/5706278382862336/1/extracted/TaskA.py,1451,65,177,Python,3004486,1,5706278382862336,SergGr,2014
135633,TaskA.py,"from fractions import gcd
 
 #inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def log2Exact(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return -1
         p *= 2
     return -1
 
 
 def log2(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return i - 1
         p *= 2
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     p0 = int(line.split('/')[0])
     q0 = int(line.split('/')[1])
     g = gcd(p0, q0)
     p = p0 / g
     q = q0 / g
     print ""{0}/{1} {2} = {3}/{4}"".format(p0, q0, g, p, q)
     q2 = log2Exact(q)
     if p > q:
         return 'impossible'
     if q2 == -1:
         return 'impossible'
     if q2 > 40:
         return 'impossible'
     p2 = log2(p)
     return max(q2 - p2, 1)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/3004486/SergGr/5706278382862336/0/extracted/TaskA.py,1451,65,177,Python,3004486,0,5706278382862336,SergGr,2014
149122,TaskB.py,"import itertools
 import time
 from collections import defaultdict
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def sortWithCount(a):
     r = []
     n = len(a)
     r.append(0)
     cnt = 0
     for i in xrange(1, n):
         for j in xrange(i, 0, -1):
             if a[j] < a[j - 1]:
                 cnt += 1
                 a[j], a[j - 1] = a[j - 1], a[j]
         r.append(cnt)
     return r
 
 
 def calcSingleTest(f):
     line = f.readline()
     n = int(line)
     line = f.readline()
     a1 = map(int, line.split())
     a2 = list(reversed(map(int, line.split())))
     print a1
     print a2
     r1 = sortWithCount(a1)
     r2 = sortWithCount(a2)
     r3 = list(reversed(r2))
     print """"
     print r1
     print r2
     print """"
     print r3
     r = [x + y for x, y in zip(r1, r3)]
     print r
     return min(r)
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/3014486/SergGr/5721094409420800/0/extracted/TaskB.py,1828,66,204,Python,3014486,0,5721094409420800,SergGr,2014
149123,TaskC.py,"import itertools
 import random
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""C-small-practice.in""
 inputFileName = ""D-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-small-attempt3.in""
 #inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 MOD = 1000000007
 
 def make_trie(words):
     root = dict()
     cnt = 1
     for word in words:
         current_dict = root
         for letter in word:
             if not letter in current_dict:
                 cnt += 1
             current_dict = current_dict.setdefault(letter, {})
     return root, cnt
 
 cache = dict()
 
 def calc_trie_size(words):
     merged = ""|"".join(words)
     if merged in cache:
         return cache[merged]
     else:
         t, c = make_trie(words)
         cache[merged] = c
         return c
 
 
 def calcSingleTest(f):
     line = f.readline()
     M = int(line.split()[0])
     N = int(line.split()[1])
     w = []
     for i in xrange(M):
         line = f.readline()
         if line[-1] == '\n':
             line = line[:-1]
         w.append(line)
     print w
     t, c = make_trie(w)
     print t
     print c
 
     r = pow(N, M)
     print r
     max = -1
     max_cnt = 0
     for allp in xrange(r):
         w_a = []
         for i in xrange(N):
             w_a.append([])
         tmp = allp
         for i in xrange(M):
             p = tmp % N
             tmp /= N
             w_a[p].append(w[i])
         all_nonempty = True
         s = 0
         for i in xrange(N):
             if len(w_a[i]) == 0:
                 all_nonempty = False
                 break
             s += calc_trie_size(w_a[i])
         if not all_nonempty:
             continue
 
         if max < s:
             max = s
             max_cnt = 1
         elif max == s:
             max_cnt += 1
     return (max, max_cnt)
 
 with open(inputFileName) as inpF:
     random.seed(0)
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res, res_cnt = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1} {2}\n'.format(i, res, res_cnt))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2014/3014486/SergGr/5649687893770240/0/extracted/TaskC.py,2727,103,293,Python,3014486,0,5649687893770240,SergGr,2014
149124,TaskA.py,"from fractions import gcd
 
 #inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def log2Exact(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return -1
         p *= 2
     return -1
 
 
 def log2(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return i - 1
         p *= 2
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     X = int(line.split()[1])
     line = f.readline()
     s = map(int, line.split())
     X2 = X / 2
     s.sort()
     print s
     L = len(s)
     cnt = 0
     j = L - 1
     i = 0
     while i < j:
         s1 = s[i]
         if s1 > X2:
             break
         i += 1
         while s1 + s[j] > X and i < j:
             cnt += 1
             j -= 1
         if s1 + s[j] > X:
             break
         else:
             j -= 1
     return 1 + j + cnt
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/3014486/SergGr/5737429512224768/1/extracted/TaskA.py,1558,73,202,Python,3014486,1,5737429512224768,SergGr,2014
149125,TaskA.py,"from fractions import gcd
 
 #inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def log2Exact(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return -1
         p *= 2
     return -1
 
 
 def log2(x):
     p = 1
     for i in xrange(0, 50):
         if x == p:
             return i
         if x < p:
             return i - 1
         p *= 2
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     X = int(line.split()[1])
     line = f.readline()
     s = map(int, line.split())
     X2 = X / 2
     s.sort()
     print s
     L = len(s)
     cnt = 0
     j = L - 1
     i = 0
     while i < j:
         s1 = s[i]
         if s1 > X2:
             break
         i += 1
         while s1 + s[j] > X and i < j:
             cnt += 1
             j -= 1
         if s1 + s[j] > X:
             break
         else:
             j -= 1
     return 1 + j + cnt
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2014/3014486/SergGr/5737429512224768/0/extracted/TaskA.py,1558,73,202,Python,3014486,0,5737429512224768,SergGr,2014
11749,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 def calc(N, corners, sides):
     res = 0
     m = min(corners, N)
     if N > 0:
         N -= m
         res += 2 * m
     if N > 0:
         m = min(sides, N)
         res += 3 * m
         N -= m
     if N > 0:
         res += 4 * N
     return res
 
 
 def calcSingleTest(f):
     line = f.readline()
     R = int(line.split()[0])
     C = int(line.split()[1])
     N0 = int(line.split()[2])
     N = int(line.split()[2])
     if N <= (R * C + 1) / 2:
         return 0
 
     if min(R, C) == 1:
         L = max(R, C)
         if L % 2 == 1:
             return 2 * (N - (L + 1) / 2)
         else:
             return 1 + 2 * (N - 1 - L / 2)
 
     if R % 2 != 0 and C % 2 == 0:
         R, C = C, R
 
     res = 0
     N -= (R * C + 1) / 2
 
     if R % 2 == 0 or C % 2 == 0:
         corners = 2
         sides = R + C - 4
         return calc(N, corners, sides)
     else:
         corners = 0
         sides = R + C - 2
         r1 = calc(N, corners, sides)
         N2 = N0
         N2 -= (R * C - 1) / 2
         corners2 = 4
         sides2 = 2 * int(R / 2) + 2 * int(C / 2) - 4
         r2 = calc(N2, corners2, sides2)
         return min(r1, r2)
 
         #    if R % 2 == 0 and C % 2 == 0:
         #        corners = 2
         #        sides = R + C - 4
         #    elif R % 2 != 0 and C % 2 != 0:
         #        corners = 0
         #    else:
         #        corners = 2
 
         #    sides = 2 * int(R / 2) + 2 * int(C / 2) - corners - 2
 
 #    return res
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/8224486/SergGr/5769900270288896/1/extracted/TaskB.py,2554,95,394,Python,8224486,1,5769900270288896,SergGr,2015
11750,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 def calc(N, corners, sides):
     res = 0
     m = min(corners, N)
     if N > 0:
         N -= m
         res += 2 * m
     if N > 0:
         m = min(sides, N)
         res += 3 * m
         N -= m
     if N > 0:
         res += 4 * N
     return res
 
 
 def calcSingleTest(f):
     line = f.readline()
     R = int(line.split()[0])
     C = int(line.split()[1])
     N0 = int(line.split()[2])
     N = int(line.split()[2])
     if N <= (R * C + 1) / 2:
         return 0
 
     if min(R, C) == 1:
         L = max(R, C)
         if L % 2 == 1:
             return 2 * (N - (L + 1) / 2)
         else:
             return 1 + 2 * (N - 1 - L / 2)
 
     if R % 2 != 0 and C % 2 == 0:
         R, C = C, R
 
     res = 0
     N -= (R * C + 1) / 2
 
     if R % 2 == 0 or C % 2 == 0:
         corners = 2
         sides = R + C - 4
         return calc(N, corners, sides)
     else:
         corners = 0
         sides = R + C - 2
         r1 = calc(N, corners, sides)
         N2 = N0
         N2 -= (R * C - 1) / 2
         corners2 = 4
         sides2 = 2 * int(R / 2) + 2 * int(C / 2) - 4
         r2 = calc(N2, corners2, sides2)
         return min(r1, r2)
 
         #    if R % 2 == 0 and C % 2 == 0:
         #        corners = 2
         #        sides = R + C - 4
         #    elif R % 2 != 0 and C % 2 != 0:
         #        corners = 0
         #    else:
         #        corners = 2
 
         #    sides = 2 * int(R / 2) + 2 * int(C / 2) - corners - 2
 
 #    return res
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/8224486/SergGr/5769900270288896/0/extracted/TaskB.py,2555,95,394,Python,8224486,0,5769900270288896,SergGr,2015
11751,TaskC.py,"import itertools
 import random
 import time
 import operator
 #import collections
 from collections import Counter
 
 
 inputFileName = ""test.in""
 #inputFileName = ""C-small-1-attempt0.in""
 #inputFileName = ""C-small-1-attempt1.in""
 #inputFileName = ""C-small-1-attempt2.in""
 #inputFileName = ""C-small-1-attempt3.in""
 inputFileName = ""C-small-1-attempt4.in""
 
 
 #inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-small-attempt3.in""
 #inputFileName = ""C-large.in""
 #inputFileName = ""C-small-practice.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest2(f):
     line = f.readline()
     N = int(line)
     hs = []
     for i in xrange(N):
         line = f.readline()
         p = int(line.split()[0])
         c = int(line.split()[1])
         s0 = int(line.split()[2])
         for j in xrange(c):
             hs.append([p, s0 + j])
     print hs
     h1 = hs[0]
     h2 = hs[1]
     #    if h1[0] < h2[0]:
     #        h1, h2 = h2, h1
     L = 360
     t1 = (L - h1[0]) * h1[1]
     t2 = (L - h2[0]) * h2[1]
     dt1 = (0.0 + t1) / L
     dt2 = (0.0 + t2) / L
     if t2 < t1:
         h1, h2 = h2, h1
         t1, t2 = t2, t1
         dt1, dt2 = dt2, dt1
 
     print 't1 = {0}, t2 = {1}, t1+h1 = {2}, {3}'.format(dt1, dt2, dt1 + h1[1], h1[0])
     b1 = dt1 + h1[1] < dt2
     b2 = t1 + L * h1[1] < t2
     if b1 != b2:
         raise RuntimeError(""AAAAAAAAAAAA"")
     if t1 + L * h1[1] < t2:
         return 1
     else:
         return 0
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     hs = []
     for i in xrange(N):
         line = f.readline()
         p = int(line.split()[0])
         c = int(line.split()[1])
         s0 = int(line.split()[2])
         for j in xrange(c):
             hs.append([p, s0 + j])
     print hs
     h1 = hs[0]
     h2 = hs[1]
     L = 360
     s1 = h1[1]
 #    p11 = h1[0] + L / h1[1] * s1
     p21 = h2[0] + L / h2[1] * s1
     s2 = h2[1]
     p12 = h1[0] + L / h1[1] * s2
 #    p22 = h2[0] + L / h2[1] * s2
     b1 = p21 <= L
     b2 = p12 <= L
 
     t1 = (L - h1[0]) * h1[1]
     t2 = (L - h2[0]) * h2[1]
     dt1 = (0.0 + t1) / L
     dt2 = (0.0 + t2) / L
 
     if t2 < t1:
         print ""Switched""
         h1, h2 = h2, h1
         t1, t2 = t2, t1
         dt1, dt2 = dt2, dt1
 
     r1 = dt1 + h1[1] < dt2
     r2 = b1 and b2
 
     if b1 or b2:
         return 1
     else:
         return 0
 
 
 with open(inputFileName) as inpF:
     random.seed(0)
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
 
",gcj/2015/8224486/SergGr/5662291475300352/0/extracted/TaskC.py,3204,125,445,Python,8224486,0,5662291475300352,SergGr,2015
11752,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def findBest(x, allowReversed=True):
     if x < 20:
         return x
     digits = str(x)
     l = len(digits)
     p1 = int(digits[0:l / 2][::-1])
     p2 = int(digits[l / 2:l])
 
     return 1 + p1 + p2 + findBest(10 ** (l - 1) - 1)
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
 
     return findBest(N)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2015/8224486/SergGr/5688567749672960/0/extracted/TaskA.py,968,40,103,Python,8224486,0,5688567749672960,SergGr,2015
44597,TaskD.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 #inputFileName = ""D-small-attempt0.in""
 #inputFileName = ""D-small-attempt1.in""
 #inputFileName = ""D-small-attempt2.in""
 #inputFileName = ""D-small-attempt3.in""
 inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 FIT = 'GABRIEL'
 CANT_FIT = 'RICHARD'
 
 def calcSingleTest(f):
     line = f.readline()
     X = int(line.split()[0])
     R = int(line.split()[1])
     C = int(line.split()[2])
 
     if R * C % X != 0:
         return CANT_FIT
 
     # can worst L-shaped (right angle) be fitted?
     mi = min(R, C)
     if mi < (X + 1) / 2:
         return CANT_FIT
 
     # can worst I-shaped (straight) be fitted?
     ma = max(R, C)
     if ma < X:
         return CANT_FIT
 
     if X == 1:
         return FIT
     elif X == 2:
         return FIT
     elif X == 3:
         if mi == 1:
             return CANT_FIT
         return FIT
     elif X == 4:
         if mi == 2:
             return CANT_FIT
         return FIT
     elif X == 5:
         return FIT
     elif X == 6:
         # 6-omino is bad for 3xN
         # ##*
         # ##*
         # *##
         if mi <= 3:
             return CANT_FIT
         #you can fit everything into at least 6x4
         return FIT
     else: #if X >= 7:
         # 7-omino contains following one with a ""gap"":
         # ###
         # #*#
         # ##*
         return CANT_FIT
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, r1))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/6224486/SergGr/5658571765186560/1/extracted/TaskD.py,2185,82,263,Python,6224486,1,5658571765186560,SergGr,2015
44598,TaskD.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 
 #inputFileName = ""test.in""
 inputFileName = ""D-small-attempt0.in""
 #inputFileName = ""D-small-attempt1.in""
 #inputFileName = ""D-small-attempt2.in""
 #inputFileName = ""D-small-attempt3.in""
 #inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 FIT = 'GABRIEL'
 CANT_FIT = 'RICHARD'
 
 def calcSingleTest(f):
     line = f.readline()
     X = int(line.split()[0])
     R = int(line.split()[1])
     C = int(line.split()[2])
 
     if R * C % X != 0:
         return CANT_FIT
 
     # can worst L-shaped (right angle) be fitted?
     mi = min(R, C)
     if mi < (X + 1) / 2:
         return CANT_FIT
     # can worst I-shaped (straight) be fitted?
     ma = max(R, C)
     if ma < X :
         return CANT_FIT
 
     if X == 1:
         return FIT
     elif X == 2:
         return FIT
     elif X == 3:
         if mi == 1:
             return CANT_FIT
         return FIT
     elif X == 4:
         if mi == 2:
             return CANT_FIT
         return FIT
 
     if X >= 7:
         return CANT_FIT
     return CANT_FIT
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, r1))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/6224486/SergGr/5658571765186560/0/extracted/TaskD.py,1843,68,213,Python,6224486,0,5658571765186560,SergGr,2015
44599,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 from collections import OrderedDict
 
 
 #inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     line = f.readline()
     d = map(int, line.split())
     d = sorted(d, reverse=True)
     #    dc = Counter(d)
     #    du = list(sorted(dc.iterkeys(), reverse=True))
     ma = max(d)
     best = ma
     best_cut = 0
     for eat in xrange(1, ma):
         cnt = 0
         for p in d:
             cnt += int((p - 1) / eat)
         cur = eat + cnt
         if cur < best:
             best = cur
             best_cut = eat
 
     return best
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/6224486/SergGr/5686275109552128/1/extracted/TaskB.py,1607,55,173,Python,6224486,1,5686275109552128,SergGr,2015
44600,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 from collections import OrderedDict
 
 
 #inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     line = f.readline()
     d = map(int, line.split())
     d = sorted(d, reverse=True)
     #    dc = Counter(d)
     #    du = list(sorted(dc.iterkeys(), reverse=True))
     ma = max(d)
     best = ma
     best_cut = 0
     for eat in xrange(1, ma):
         cnt = 0
         for p in d:
             cnt += int((p - 1) / eat)
         cur = eat + cnt
         if cur < best:
             best = cur
             best_cut = eat
 
     return best
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/6224486/SergGr/5686275109552128/0/extracted/TaskB.py,1607,55,173,Python,6224486,0,5686275109552128,SergGr,2015
44601,TaskC.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 from itertools import repeat
 
 #inputFileName = ""test.in""
 
 #inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 
 #inputFileName = ""C-small-attempt3.in""
 inputFileName = ""C-small-attempt4.in""
 
 inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def crete_mul_dict():
     mul_dict0 = dict()
     mul_dict_1 = dict()
     mul_dict_1['1'] = '1'
     mul_dict_1['i'] = 'i'
     mul_dict_1['j'] = 'j'
     mul_dict_1['k'] = 'k'
     mul_dict0['1'] = mul_dict_1
 
     mul_dict_i = dict()
     mul_dict_i['1'] = 'i'
     mul_dict_i['i'] = '-1'
     mul_dict_i['j'] = 'k'
     mul_dict_i['k'] = '-j'
     mul_dict0['i'] = mul_dict_i
 
     mul_dict_j = dict()
     mul_dict_j['1'] = 'j'
     mul_dict_j['i'] = '-k'
     mul_dict_j['j'] = '-1'
     mul_dict_j['k'] = 'i'
     mul_dict0['j'] = mul_dict_j
 
     mul_dict_k = dict()
     mul_dict_k['1'] = 'k'
     mul_dict_k['i'] = 'j'
     mul_dict_k['j'] = '-i'
     mul_dict_k['k'] = '-1'
     mul_dict0['k'] = mul_dict_k
     return mul_dict0
 
 mul_dict = crete_mul_dict()
 
 allowed = dict()
 allowed['1'] = False
 allowed['i'] = False
 allowed['j'] = False
 allowed['k'] = False
 allowed['-1'] = False
 allowed['-i'] = False
 allowed['-j'] = False
 allowed['-k'] = False
 
 def mul(q1, q2):
     inv = allowed[q1] and allowed[q2]
 #    inv = False
     if q1[0] == '-':
         inv = not inv
         q1 = '' + q1[1]
     if q2[0] == '-':
         inv = not inv
         q2 = '' + q2[1]
     res = mul_dict[q1][q2]
     if inv:
         if res[0] == '-':
             res = '' + res[1]
         else:
             res = '-' + res
     return res
 
 
 def pow_q(q1, p):
     res = '1'
     i = 0
     while p > 0:
         if p % 2 == 0:
             q1 = mul(q1, q1)
             p /= 2
         else:
             res = mul(res, q1)
             p -= 1
     return res
 
 
 def eval_q(s):
     if len(s) == 0:
         raise RuntimeError(""CCCC"")
     res = '1'
     for m in s:
         res = mul(res, m)
     return res
 
 def calcSingleTest(f):
     line = f.readline()
     L = int(line.split()[0])
     X = int(line.split()[1])
     line = f.readline()[0:L]
 #    line = f.readline()[:-1]
 #    if L != len(line):
 #        raise RuntimeError(""AAAAAA"")
 
     line_res = eval_q(line)
     total_res = pow_q(line_res, X)
     print str(X) + ' * ' + line
     print line_res
     print 'total res = ' + total_res
     if len(line) == 1:
         return ""NO""
     if total_res != '-1':
         return ""NO""
     r = min(30, X)
 #    r = X
     base_line = ''.join(repeat(line, r))
     rest_line_res = '1' if X < r else pow_q(line_res, X - r)
     print base_line
     print rest_line_res
 
     res_i = '1'
     res_j = '1'
     #res_k = '1'
     pos_i = pos_j = -1
     base_len = len(base_line)
     for pos_i in xrange(0, base_len):
         res_i = mul(res_i, base_line[pos_i])
         if res_i == 'i':
             break
     pos_i += 1
     if base_len == pos_i:
         print '1 !!!'
         return ""NO""
 
     for pos_j in xrange(pos_i, base_len):
         res_j = mul(res_j, base_line[pos_j])
         if res_j == 'j':
             break
     pos_j += 1
     if base_len == pos_j:
         print '2 !!!'
         return ""NO""
 
     base_rest = base_line[pos_j:]
     base_rest_res = eval_q(base_rest)
     res_k = mul(base_rest_res, rest_line_res)
 
     print ""i = "" + eval_q(base_line[0:pos_i]) + "" - "" + base_line[0:pos_i]
     print ""j = "" + eval_q(base_line[pos_i:pos_j]) + "" - "" + base_line[pos_i:pos_j]
 
     if res_k != 'k':
         print '3 !!!!!!!!!!!!!!!!!!!!!!!!!'
         raise RuntimeError(""BBBBB"")
         return ""NO""
 
     #    print ""i = "" + eval_q(base_line[0:pos_i]) + "" - "" + base_line[0:pos_i]
     #    print ""j = "" + eval_q(base_line[pos_i:pos_j]) + "" - "" + base_line[pos_i:pos_j]
     return ""YES""
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/6224486/SergGr/5670465267826688/1/extracted/TaskC.py,4689,182,564,Python,6224486,1,5670465267826688,SergGr,2015
44602,TaskC.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 from itertools import repeat
 
 #inputFileName = ""test.in""
 #inputFileName = ""C-small-attempt0.in""
 #inputFileName = ""C-small-attempt1.in""
 #inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-small-attempt3.in""
 inputFileName = ""C-small-attempt4.in""
 
 #inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def crete_mul_dict():
     mul_dict0 = dict()
     mul_dict_1 = dict()
     mul_dict_1['1'] = '1'
     mul_dict_1['i'] = 'i'
     mul_dict_1['j'] = 'j'
     mul_dict_1['k'] = 'k'
     mul_dict0['1'] = mul_dict_1
 
     mul_dict_i = dict()
     mul_dict_i['1'] = 'i'
     mul_dict_i['i'] = '-1'
     mul_dict_i['j'] = 'k'
     mul_dict_i['k'] = '-j'
     mul_dict0['i'] = mul_dict_i
 
     mul_dict_j = dict()
     mul_dict_j['1'] = 'j'
     mul_dict_j['i'] = '-k'
     mul_dict_j['j'] = '-1'
     mul_dict_j['k'] = 'i'
     mul_dict0['j'] = mul_dict_j
 
     mul_dict_k = dict()
     mul_dict_k['1'] = 'k'
     mul_dict_k['i'] = 'j'
     mul_dict_k['j'] = '-i'
     mul_dict_k['k'] = '-1'
     mul_dict0['k'] = mul_dict_k
     return mul_dict0
 
 mul_dict = crete_mul_dict()
 
 allowed = dict()
 allowed['1'] = False
 allowed['i'] = False
 allowed['j'] = False
 allowed['k'] = False
 allowed['-1'] = False
 allowed['-i'] = False
 allowed['-j'] = False
 allowed['-k'] = False
 
 def mul(q1, q2):
     inv = allowed[q1] and allowed[q2]
 #    inv = False
     if q1[0] == '-':
         inv = not inv
         q1 = '' + q1[1]
     if q2[0] == '-':
         inv = not inv
         q2 = '' + q2[1]
     res = mul_dict[q1][q2]
     if inv:
         if res[0] == '-':
             res = '' + res[1]
         else:
             res = '-' + res
     return res
 
 
 def pow_q(q1, p):
     res = '1'
     for i in xrange(0, p):
         res = mul(res, q1)
     return res
 
 
 def eval_q(s):
     if len(s) == 0:
         raise RuntimeError(""CCCC"")
     res = '1'
     for m in s:
         res = mul(res, m)
     return res
 
 def calcSingleTest(f):
     line = f.readline()
     L = int(line.split()[0])
     X = int(line.split()[1])
     line = f.readline()[0:L]
 #    line = f.readline()[:-1]
 #    if L != len(line):
 #        raise RuntimeError(""AAAAAA"")
 
     line_res = eval_q(line)
     total_res = pow_q(line_res, X)
     print str(X) + ' * ' + line
     print line_res
     print 'total res = ' + total_res
     if len(line) == 1:
         return ""NO""
     if total_res != '-1':
         return ""NO""
     #r = min(30, X)
     r = X
     base_line = ''.join(repeat(line, r))
     rest_line_res = '1' if X < r else pow_q(line_res, X - r)
     print base_line
     print rest_line_res
 
     res_i = '1'
     res_j = '1'
     #res_k = '1'
     pos_i = pos_j = -1
     base_len = len(base_line)
     for pos_i in xrange(0, base_len):
         res_i = mul(res_i, base_line[pos_i])
         if res_i == 'i':
             break
     pos_i += 1
     if base_len == pos_i:
         print '1 !!!'
         return ""NO""
 
     for pos_j in xrange(pos_i, base_len):
         res_j = mul(res_j, base_line[pos_j])
         if res_j == 'j':
             break
     pos_j += 1
     if base_len == pos_j:
         print '2 !!!'
         return ""NO""
 
     base_rest = base_line[pos_j:]
     base_rest_res = eval_q(base_rest)
     res_k = mul(base_rest_res, rest_line_res)
 
     print ""i = "" + eval_q(base_line[0:pos_i]) + "" - "" + base_line[0:pos_i]
     print ""j = "" + eval_q(base_line[pos_i:pos_j]) + "" - "" + base_line[pos_i:pos_j]
 
     if res_k != 'k':
         print '3 !!!!!!!!!!!!!!!!!!!!!!!!!'
         raise RuntimeError(""BBBBB"")
         return ""NO""
 
     #    print ""i = "" + eval_q(base_line[0:pos_i]) + "" - "" + base_line[0:pos_i]
     #    print ""j = "" + eval_q(base_line[pos_i:pos_j]) + "" - "" + base_line[pos_i:pos_j]
     return ""YES""
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/6224486/SergGr/5670465267826688/0/extracted/TaskC.py,4572,174,544,Python,6224486,0,5670465267826688,SergGr,2015
44603,TaskA.py,"#inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     maxS = int(line.split()[0]) + 1
     s = map(int, line.split()[1])
     add = 0
     sum = 0
     for i in xrange(0, maxS):
         if s[i] == 0:
             continue
         if sum < i:
             add += i - sum
             sum = i
         sum += s[i]
 
     return add
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2015/6224486/SergGr/5639104758808576/1/extracted/TaskA.py,845,36,92,Python,6224486,1,5639104758808576,SergGr,2015
44604,TaskA.py,"#inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     maxS = int(line.split()[0]) + 1
     s = map(int, line.split()[1])
     add = 0
     sum = 0
     for i in xrange(0, maxS):
         if s[i] == 0:
             continue
         if sum < i:
             add += i - sum
             sum = i
         sum += s[i]
 
     return add
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2015/6224486/SergGr/5639104758808576/0/extracted/TaskA.py,845,36,92,Python,6224486,0,5639104758808576,SergGr,2015
115562,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     m = map(int, line.split())
     y = 0
     z = 0
     ma = 0
     for i in xrange(1, N):
         d = m[i - 1] - m[i]
         if d <= 0:
             continue
         if d > ma:
             ma = d
         y += d
         #        z += d
 
     copy = list(m)
     for i in xrange(1, N):
         if copy[i - 1] >= ma:
             z += ma
             copy[i - 1] -= ma
         else:
             z += copy[i - 1]
             copy[i - 1] = 0
 
         d = copy[i - 1] - m[i]
         if d <= 0:
             continue
         if d > ma:
             ma = d
         z += d
         #        z += d
 
     return y, z
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             resX, resY = calcSingleTest(inpF)
             outF.write('Case #{0}: {1} {2}\n'.format(i, resX, resY))
 
 
 
 
",gcj/2015/4224486/SergGr/6404600001200128/1/extracted/TaskA.py,1371,59,174,Python,4224486,1,6404600001200128,SergGr,2015
115563,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 #inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     m = map(int, line.split())
     y = 0
     z = 0
     ma = 0
     for i in xrange(1, N):
         d = m[i - 1] - m[i]
         if d <= 0:
             continue
         if d > ma:
             ma = d
         y += d
         #        z += d
 
     copy = list(m)
     for i in xrange(1, N):
         if copy[i - 1] >= ma:
             z += ma
             copy[i - 1] -= ma
         else:
             z += copy[i - 1]
             copy[i - 1] = 0
 
         d = copy[i - 1] - m[i]
         if d <= 0:
             continue
         if d > ma:
             ma = d
         z += d
         #        z += d
 
     return y, z
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             resX, resY = calcSingleTest(inpF)
             outF.write('Case #{0}: {1} {2}\n'.format(i, resX, resY))
 
 
 
 
",gcj/2015/4224486/SergGr/6404600001200128/0/extracted/TaskA.py,1372,59,174,Python,4224486,0,6404600001200128,SergGr,2015
115564,TaskB.py,"import itertools
 import time
 import operator
 #import collections
 from collections import Counter
 from fractions import gcd
 
 inputFileName = ""test.in""
 #inputFileName = ""B-small-attempt0.in""
 inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def my_gcd(li, start=0):
     if len(li) == start + 1:
         return li[start]
     elif len(li) == start + 2:
         return gcd(li[start], li[start + 1])
     else:
         return gcd(li[start], my_gcd(li, start + 1))
 
 
 def calcSingleTest(f):
     line = f.readline()
     B = int(line.split()[0])
     N0 = int(line.split()[1])
     line = f.readline()
     bs0 = map(int, line.split())
     g = my_gcd(bs0)
     bs = map(lambda x: x / g, bs0)
     l = reduce(lambda x, y: x * y, bs, 1)
     cs = map(lambda x: l / x, bs)
     cl = sum(cs)
     print bs
     print cs
     print cl
 
     bb = []
     for i in xrange(B):
         bb.append(0)
 
     N = N0 % cl
     if N == 0:
         N = cl
     res = -1
     cnt = 0
     ma = min(bs) * N
     print ma
     t = 0
     while t < ma:
         mi = min(bb)
         for i in xrange(0, B):
             if bb[i] > 0:
                 bb[i] -= mi
             if bb[i] == 0:
                 bb[i] = bs[i]
                 cnt += 1
                 if cnt == N:
                     return i + 1
         t += mi
 
     raise RuntimeError(""AAAAA "" + str(ma) + "" "" + str(t))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/4224486/SergGr/5765824346324992/0/extracted/TaskB.py,2230,83,274,Python,4224486,0,5765824346324992,SergGr,2015
132569,TaskC.py,"import itertools
 import random
 import time
 import operator
 #import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 #inputFileName = ""C-small-practice.in""
 
 #inputFileName = ""C-small-attempt0.in""
 inputFileName = ""C-small-attempt1.in""
 inputFileName = ""C-small-attempt2.in""
 #inputFileName = ""C-small-attempt3.in""
 #inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def list_powerset(lst):
     # the power set of the empty set has one element, the empty set
     result = [[]]
     for x in lst:
         result.extend([subset + [x] for subset in result])
     return result
 
 
 def canFit(v, ds):
     for d in list_powerset(ds):
         s = sum(d)
         if s == v:
             return True
     return False
 
 
 def calcSingleTest(f):
     line = f.readline()
     C = int(line.split()[0])
     D = int(line.split()[1])
     V = int(line.split()[2])
     line = f.readline()
     ds = map(int, line.split())
     ds0 = list(sorted(ds))
     ds = list(sorted(ds))
     print 'C={0}, D={1}, V={2}'.format(C, D, V)
     print ds
     if C != 1:
         return ""AAA""
     r = 0
 
     for s in xrange(V + 1):
         if not canFit(s, ds):
             print ""Adding "" + str(s)
             ds.append(s)
             ds = list(sorted(ds))
             r += 1
     return r
 
 
 with open(inputFileName) as inpF:
     random.seed(0)
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))",gcj/2015/4244486/SergGr/5646553574277120/0/extracted/TaskC.py,2057,75,223,Python,4244486,0,5646553574277120,SergGr,2015
132570,TaskB.py,"import itertools
 import time
 from collections import defaultdict
 import operator
 #import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 #inputFileName = ""B-small-attempt1.in""
 #inputFileName = ""B-small-attempt2.in""
 #inputFileName = ""B-small-attempt3.in""
 #inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 def countWord(str, w):
     lw = len(w)
     ls = len(str)
     cnt = 0
     for p in xrange(ls - lw + 1):
         good = True
         for i in xrange(lw):
             if str[i + p] != w[i]:
                 good = False
                 break
         if good:
             cnt += 1
     return cnt
 
 
 def genAllWords(ks, S):
     result = [""""]
     for i in xrange(S):
         new_res = []
         for x in ks:
             new_res.extend([oldWord + x for oldWord in result])
         result = new_res
     return result
 
 
 def calcSingleTest(f):
     line = f.readline()
     K = int(line.split()[0])
     L = int(line.split()[1])
     S = int(line.split()[2])
     line = f.readline()
     ks = line
     if ks[-1] == '\n':
         ks = ks[:-1]
     line = f.readline()
     tgt = line
     if tgt[-1] == '\n':
         tgt = tgt[:-1]
     if max(K, L, S) > 8:
         return ""AAAAAA""
 
     max_cnt = 0
     allWords = genAllWords(ks, S)
     wc = len(allWords)
     s = 0
     for str in allWords:
         cnt = countWord(str, tgt)
         if cnt > max_cnt:
             max_cnt = cnt
         s += cnt
 
     return (0.0 + wc * max_cnt - s) / wc
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
 
",gcj/2015/4244486/SergGr/5708284669460480/0/extracted/TaskB.py,2270,86,265,Python,4244486,0,5708284669460480,SergGr,2015
132571,TaskA.py,"from fractions import gcd
 
 inputFileName = ""test.in""
 #inputFileName = ""A-small-attempt0.in""
 #inputFileName = ""A-small-attempt1.in""
 inputFileName = ""A-small-attempt2.in""
 #inputFileName = ""A-small-attempt3.in""
 #inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 def solve0(N, x):
     if x == 0:
         return N
     if x == 1:
         return N + 1
     a = x / 2 + 1
     b = (x + 1) / 2
     r = []
     r11 = 1 + a + solve0(N - a, x - a)
     r12 = 1 + x - a + solve0(N - (x - a) - 1, a - 1)
     r.append(max(r11, r12))
     if b != a:
         r21 = 1 + b + solve0(N - b, x - b)
         r22 = 1 + x - b + solve0(N - (x - b) - 1, b - 1)
         r.append(max(r21, r22))
         #    r.append(1 + a + solve0(N, x - a))
     #    r.append(1 + x - a + solve0(N, a - 1))
     #    if b != a:
     #        r.append(1 + b + solve0(N, x - b))
     #        r.append(1 + x - b + solve0(N, b - 1))
     return min(r)
 
 
 def calcSingleTest(f):
     line = f.readline()
     R = int(line.split()[0])
     C = int(line.split()[1])
     W = int(line.split()[2])
     print 'R = {0}, C = {1}, W = {2}'.format(R, C, W)
     if W == 1:
         return R * C
     s = C / W  * (R - 1)
     o1 = C % W
     r = []
     if C > 2 * W:
         s += C / W - 1
 
     if C == W:
         r.append(C)
     elif o1 != 0:
         r1 = solve0(W, o1)
         r.append(r1)
     else:
         r1 = solve0(W, W)
         r.append(r1)
 
     if C > 2 * W:
         r2 = solve0(W, W - 1) - 1
         r.append(r2)
     s += min(r)
     return s
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 
 
 
",gcj/2015/4244486/SergGr/5640146288377856/0/extracted/TaskA.py,1926,76,311,Python,4244486,0,5640146288377856,SergGr,2015
9626,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     arr = []
     all_h = Counter()
     for i in xrange(2 * N - 1):
         line = f.readline()
         l = map(int, line.split())
         arr.append(l)
         all_h.update(l)
 
     odds = [k for (k, v) in all_h.iteritems() if v % 2 == 1]
     odds = list(sorted(odds))
     if len(odds) == N:
         return str.join(' ', map(str, odds))
 
     raise RuntimeError(""AAAAAA"")
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/4304486/SergGr/5630113748090880/1/extracted/TaskB.py,1593,54,172,Python,4304486,1,5630113748090880,SergGr,2016
9627,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     arr = []
     all_h = Counter()
     for i in xrange(2 * N - 1):
         line = f.readline()
         l = map(int, line.split())
         arr.append(l)
         all_h.update(l)
 
     odds = [k for (k, v) in all_h.iteritems() if v % 2 == 1]
     odds = list(sorted(odds))
     if len(odds) == N:
         return str.join(' ', map(str, odds))
 
     return 0
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/4304486/SergGr/5630113748090880/0/extracted/TaskB.py,1575,54,173,Python,4304486,0,5630113748090880,SergGr,2016
9628,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     s = line.translate(None, '\r\n')
     res = ''
     res += s[0]
     for c in s[1:]:
         if c >= res[0]:
             res = c + res
         else:
             res = res + c
     return res
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/4304486/SergGr/5631989306621952/1/extracted/TaskA.py,875,31,93,Python,4304486,1,5631989306621952,SergGr,2016
9629,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def calcSingleTest(f):
     line = f.readline()
     s = line.translate(None, '\r\n')
     res = ''
     res += s[0]
     for c in s[1:]:
         if c >= res[0]:
             res = c + res
         else:
             res = res + c
     return res
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/4304486/SergGr/5631989306621952/0/extracted/TaskA.py,877,31,94,Python,4304486,0,5631989306621952,SergGr,2016
9630,TaskC.py,"import threading
 import sys
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10**6)
 
 import itertools
 import random
 import time
 import operator
 # import collections
 from collections import Counter
 
 # from scipy.spatial import qhull
 # from scipy.spatial import ConvexHull
 # import numpy as np
 from math import *
 
 inputFileName = ""test.in""
 # inputFileName = ""C-small-practice.in""
 inputFileName = ""C-small-attempt0.in""
 inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 # inputFileName = ""C-small-attempt3.in""
 inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def brute_force(N, arr, all_fr):
     b = 1
     all = list(range(N))
 
     def check_order(order):
         ll = len(order)
         for x in xrange(ll):
             cur = order[x]
             left = order[(ll + x - 1) % ll]
             right = order[(x + 1) % ll]
             if left != arr[cur] and right != arr[cur]:
                 return False
         return True
 
     def check_length(l):
         for vs in itertools.combinations(all, l):
             for order in itertools.permutations(vs):
                 if check_order(order):
                     return True
         return False
 
     for l in xrange(2, N + 1):
         if check_length(l):
             b = l
     return b
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     arr = map(lambda x: x - 1, map(int, line.split()))
     all_fr = dict()
     for x in xrange(N):
         all_fr[x] = []
 
     for x in xrange(N):
         all_fr[arr[x]].append(x)
 
     order = []
     visited = set()
 
     def visit(v):
         if v in visited:
             return
         visited.add(v)
         visit(arr[v])
         order.insert(0, v)
         return
 
     for x in xrange(N):
         visit(x)
 
     s_comps = [-1] * N
     s_comps_count = [0] * N
 
     def assign(v, root):
         if s_comps[v] != -1:
             return
         s_comps_count[root] += 1
         s_comps[v] = root
         for v1 in all_fr[v]:
             assign(v1, root)
         return
 
     for x in order:
         assign(x, x)
 
     tails = [0] * N
     for x in order:
         c = s_comps[x]
         if s_comps_count[c] != 1:
             continue
         if tails[x] + 1 > tails[arr[x]]:
             tails[arr[x]] = tails[x] + 1
 
     good_comps = [xx for xx in xrange(0, N) if s_comps_count[xx] == 2]
     good_v = [vv for vv in xrange(0, N) if s_comps_count[s_comps[vv]] == 2]
 
     for x in good_v:
         c = s_comps[x]
         if c == x:
             continue
         else:
             tails[c] += tails[x]
 
     m = max(s_comps_count)
     s = 0
     for x in good_v:
         c = s_comps[x]
         if c == x:
             tails[x] += 2
             s += tails[x]
             tails[x] = -tails[x]
 
     print N
     print ""arr = "" + str(arr)
     print all_fr
     print order
     print ""cmp = "" + str(s_comps)
     print ""cnt = "" + str(s_comps_count)
     print good_comps
     print good_v
     print tails
     res = max(s, m)
     print ""res = {0}, max = {1}, sum = {2}"".format(res, m, s)
 
     # if True and (N < 10 or res < 10):
     if False:
         res2 = brute_force(N, arr, all_fr)
         if res != res2:
             print ""AAAAAA "" + "" res = "" + str(res) + "" res2 = "" + str(res2)
             raise RuntimeError(""AAAAAA "" + str(res) + "" res2 = "" + str(res2))
         else:
             print ""Good""
     else:
         print ""!!!Skip""
     return res
 
 
 def main():
     with open(inputFileName) as inpF:
         random.seed(0)
         with open(outputFileName, 'w') as outF:
             line = inpF.readline()
             testsCount = int(line)
             for i in xrange(1, testsCount + 1):
                 print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
                 res = calcSingleTest(inpF)
                 print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
                 print ' '
                 outF.write('Case #{0}: {1}\n'.format(i, res))
                 outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
 
 # sys.setrecursionlimit(8000)
 # thread = threading.Thread(target=main)
 # thread.start()
 main()
",gcj/2016/4304486/SergGr/5631572862566400/1/extracted/TaskC.py,4501,172,531,Python,4304486,1,5631572862566400,SergGr,2016
9631,TaskC.py,"import itertools
 import random
 import time
 import operator
 # import collections
 from collections import Counter
 
 # from scipy.spatial import qhull
 # from scipy.spatial import ConvexHull
 # import numpy as np
 from math import *
 
 inputFileName = ""test.in""
 # inputFileName = ""C-small-practice.in""
 inputFileName = ""C-small-attempt0.in""
 inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def brute_force(N, arr, all_fr):
     b = 1
     all = list(range(N))
 
     def check_order(order):
         ll = len(order)
         for x in xrange(ll):
             cur = order[x]
             left = order[(ll + x - 1) % ll]
             right = order[(x + 1) % ll]
             if left != arr[cur] and right != arr[cur]:
                 return False
         return True
 
     def check_length(l):
         for vs in itertools.combinations(all, l):
             for order in itertools.permutations(vs):
                 if check_order(order):
                     return True
         return False
 
     for l in xrange(2, N + 1):
         if check_length(l):
             b = l
     return b
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     arr = map(lambda x: x - 1, map(int, line.split()))
     all_fr = dict()
     for x in xrange(N):
         all_fr[x] = []
 
     for x in xrange(N):
         all_fr[arr[x]].append(x)
 
     order = []
     visited = set()
 
     def visit(v):
         if v in visited:
             return
         visited.add(v)
         visit(arr[v])
         order.insert(0, v)
         return
 
     for x in xrange(N):
         visit(x)
 
     s_comps = [-1] * N
     s_comps_count = [0] * N
 
     def assign(v, root):
         if s_comps[v] != -1:
             return
         s_comps_count[root] += 1
         s_comps[v] = root
         for v1 in all_fr[v]:
             assign(v1, root)
         return
 
     for x in order:
         assign(x, x)
 
     tails = [0] * N
     for x in order:
         c = s_comps[x]
         if s_comps_count[c] != 1:
             continue
         if tails[x] + 1 > tails[arr[x]]:
             tails[arr[x]] = tails[x] + 1
 
     good_comps = [xx for xx in xrange(0, N) if s_comps_count[xx] == 2]
     good_v = [vv for vv in xrange(0, N) if s_comps_count[s_comps[vv]] == 2]
 
     for x in good_v:
         c = s_comps[x]
         if c == x:
             continue
         else:
             tails[c] += tails[x]
 
     m = max(s_comps_count)
     s = 0
     for x in good_v:
         c = s_comps[x]
         if c == x:
             tails[x] += 2
             s += tails[x]
             tails[x] = -tails[x]
 
     print N
     print ""arr = "" + str(arr)
     print all_fr
     print order
     print ""cmp = "" + str(s_comps)
     print ""cnt = "" + str(s_comps_count)
     print good_comps
     print good_v
     print tails
     res = max(s, m)
     print ""res = {0}, max = {1}, sum = {2}"".format(res, m, s)
 
     # if True and (N < 10 or res < 10):
     if False:
         res2 = brute_force(N, arr, all_fr)
         if res != res2:
             print ""AAAAAA "" + "" res = "" + str(res) + "" res2 = "" + str(res2)
             raise RuntimeError(""AAAAAA "" + str(res) + "" res2 = "" + str(res2))
         else:
             print ""Good""
     else:
         print ""!!!Skip""
     return res
 
 
 with open(inputFileName) as inpF:
     random.seed(0)
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/4304486/SergGr/5631572862566400/0/extracted/TaskC.py,4177,160,504,Python,4304486,0,5631572862566400,SergGr,2016
72370,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 global MY_DEBUG
 MY_DEBUG = ""test.in"" == inputFileName
 
 """"""
 def test(x0):
     digits = set()
     x = x0
     while x % 10 == 0:
         x /= 10
     for m in xrange(1, 2000):
         # t = (m * x) % 1000
         t = m * x
         d1 = t % 10
         d2 = t / 10 % 10
         d3 = t / 100 % 10
         digits.add(d1)
         digits.add(d2)
         digits.add(d3)
         digits.add(t / 1000 % 10)
         if (len(digits) == 10):
             return (True, digits, m)
 
     return (False, digits, -1)
 
 
 mm = 0
 mmx = -1
 for x in xrange(1, 10000000):
     (r, d, m) = test(x)
     if m > mm:
         mm = m
         mmx = x
     if (not r):
         print ""Bad "" + str(x) + "" "" + str(d)
     if x % 10000 == 0:
         print ""Progress "" + str(x) + ' mm = ' + str(mm) + '  mmx = ' + str(mmx)
 """"""
 
 def calcSingleTest(f):
     line = f.readline()
     x = int(line)
     if x == 0:
         return 'INSOMNIA'
     digits = set()
     # for m in xrange(1, max(1000, 10 * x)):
     for m in xrange(1, 1000): #1000 seems to be more than enough
         # t = (m * x) % 1000
         t = m * x
         while t > 0:
             d = t % 10
             t /= 10
             digits.add(d)
 
         if len(digits) == 10:
             return m * x
     if MY_DEBUG:
         print '!!!!Bad ' + str(x)
     return 'INSOMNIA'
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/6254486/SergGr/5652388522229760/1/extracted/TaskA.py,1841,74,273,Python,6254486,1,5652388522229760,SergGr,2016
72371,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 global MY_DEBUG
 MY_DEBUG = ""test.in"" == inputFileName
 
 """"""
 def test(x0):
     digits = set()
     x = x0
     while x % 10 == 0:
         x /= 10
     for m in xrange(1, 2000):
         # t = (m * x) % 1000
         t = m * x
         d1 = t % 10
         d2 = t / 10 % 10
         d3 = t / 100 % 10
         digits.add(d1)
         digits.add(d2)
         digits.add(d3)
         digits.add(t / 1000 % 10)
         if (len(digits) == 10):
             return (True, digits, m)
 
     return (False, digits, -1)
 
 
 mm = 0
 mmx = -1
 for x in xrange(1, 10000000):
     (r, d, m) = test(x)
     if m > mm:
         mm = m
         mmx = x
     if (not r):
         print ""Bad "" + str(x) + "" "" + str(d)
     if x % 10000 == 0:
         print ""Progress "" + str(x) + ' mm = ' + str(mm) + '  mmx = ' + str(mmx)
 """"""
 
 def calcSingleTest(f):
     line = f.readline()
     x = int(line)
     if x == 0:
         return 'INSOMNIA'
     digits = set()
     # for m in xrange(1, max(1000, 10 * x)):
     for m in xrange(1, 1000): #1000 seems to be more than enough
         # t = (m * x) % 1000
         t = m * x
         while t > 0:
             d = t % 10
             t /= 10
             digits.add(d)
 
         if len(digits) == 10:
             return m * x
     if MY_DEBUG:
         print '!!!!Bad ' + str(x)
     return 'INSOMNIA'
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/6254486/SergGr/5652388522229760/0/extracted/TaskA.py,1843,74,274,Python,6254486,0,5652388522229760,SergGr,2016
72372,TaskD.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 # inputFileName = ""D-small-attempt0.in""
 # inputFileName = ""D-small-attempt1.in""
 # inputFileName = ""D-small-attempt2.in""
 # inputFileName = ""D-small-attempt3.in""
 inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     K = int(line.split()[0])
     C = int(line.split()[1])
     S = int(line.split()[2])
     if C == 1:
         if S < K:
             return 'IMPOSSIBLE'
         else:
             return ' '.join(map(str, xrange(1, K + 1)))
 
     base = K ** (C - 1)
     r = int((K + 1) / 2)
     if S < r:
         return 'IMPOSSIBLE'
     else:
         res = []
         for i in xrange(0, r):
             j = K - i
             res.append(i * base + j)
         return ' '.join(map(str, res))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, r1))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/6254486/SergGr/5636311922769920/1/extracted/TaskD.py,1609,55,179,Python,6254486,1,5636311922769920,SergGr,2016
72373,TaskD.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 # inputFileName = ""D-small-attempt0.in""
 inputFileName = ""D-small-attempt1.in""
 # inputFileName = ""D-small-attempt2.in""
 # inputFileName = ""D-small-attempt3.in""
 # inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     K = int(line.split()[0])
     C = int(line.split()[1])
     S = int(line.split()[2])
     if C == 1:
         if S < K:
             return 'IMPOSSIBLE'
         else:
             return ' '.join(map(str, xrange(1, K + 1)))
 
     base = K ** (C - 1)
     r = int((K + 1) / 2)
     if S < r:
         return 'IMPOSSIBLE'
     else:
         res = []
         for i in xrange(0, r):
             j = K - i
             res.append(i * base + j)
         return ' '.join(map(str, res))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, r1))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/6254486/SergGr/5636311922769920/0/extracted/TaskD.py,1609,55,179,Python,6254486,0,5636311922769920,SergGr,2016
72374,TaskC.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from itertools import repeat
 
 inputFileName = ""test.in""
 inputFileName = ""test2.in""
 
 # inputFileName = ""C-small-attempt0.in""
 # inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-small-attempt4.in""
 
 inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcPrimesFaster(N):
     max_odd = N / 2 + 1
     half_odds = [True] * max_odd
     for half in xrange(1, int(N ** 0.5 + 0.5) / 2 + 1):
         if half_odds[half]:
             prime = 2 * half + 1
             for j in range(2 * half * (half + 1), max_odd, prime):
                 half_odds[j] = False
     res = [2]
     res.extend([2 * i + 1 for i in xrange(1, max_odd) if half_odds[i]])
     return res
 
 
 def calcPrimes(N):
     primes = [2, 3, 5]
     for x in xrange(7, N / 2 * 2, 2):
         found = False
         for p in primes:
             if x % p == 0:
                 found = True
                 break
         if not found:
             primes.append(x)
     return primes
 
 
 def convert(s, base):
     res = 0
     cur = 1
     for c in reversed(s):
         if c == '1':
             res += cur
         cur *= base
     return res
 
 
 def checkPrime(x, primes):
     for p in primes:
         if x % p == 0:
             if x == p:
                 return -1
             return p
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     J = int(line.split()[1])
     primes = calcPrimesFaster(10 ** 5)
     # primes = calcPrimes(10 ** 5)
     print ""Primes = "" + str(len(primes))
     res = []
     all = 0
     goodCnt = 0
     for i in xrange(0, 2 ** (N - 2)):
         all += 1
         rl = []
         s = ((""{0:0"" + str(N - 2) + ""b}"").format(i))
         s = '1' + s + '1'
         good = True
         for b in xrange(2, 11):
             v = convert(s, b)
             p = checkPrime(v, primes)
             if p == -1:
                 good = False
                 break
             else:
                 rl.append(p)
         if good:
             goodCnt += 1
             res.append((s, rl))
             if len(res) >= J:
                 break
 
     def convert_line(t):
         s, rl = t
         return s + ' ' + ' '.join(map(str, rl))
         # return s
         # return s + ' ' + '; '.join(map(lambda (x, i): str(convert(s, i)) + ' / ' + str(x) + ' = ' + str(convert(s, i) % x), zip(rl, xrange(2, 11))))
 
     print ""all = {0}, good = {1}, p = {2}"".format(all, goodCnt, float(goodCnt) / all)
     return '\n' + '\n'.join(map(convert_line, res))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/6254486/SergGr/5738606668808192/1/extracted/TaskC.py,3433,123,445,Python,6254486,1,5738606668808192,SergGr,2016
72375,TaskC.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from itertools import repeat
 
 inputFileName = ""test.in""
 
 inputFileName = ""C-small-attempt0.in""
 # inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-small-attempt4.in""
 
 # inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcPrimes(N):
     primes = [2, 3, 5]
     for x in xrange(7, N / 2 * 2, 2):
         found = False
         for p in primes:
             if x % p == 0:
                 found = True
                 break
         if not found:
             primes.append(x)
     return primes
 
 
 def convert(s, base):
     res = 0
     cur = 1
     for c in reversed(s)    :
         if c == '1':
             res += cur
         cur *= base
     return res
 
 
 def checkPrime(x, primes):
     for p in primes:
         if x % p == 0:
             if x == p:
                 return -1
             return p
     return -1
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     J = int(line.split()[1])
     primes = calcPrimes(10 ** 4)
     res = []
     for i in xrange(0, 2 ** (N - 2)):
         rl = []
         s = ((""{0:0"" + str(N - 2) + ""b}"").format(i))
         s = '1' + s + '1'
         good = True
         for b in xrange(2, 11):
             v = convert(s, b)
             p = checkPrime(v, primes)
             if p == -1:
                 good = False
                 break
             else:
                 rl.append(p)
         if good:
             res.append((s, rl))
             if len(res) >= J:
                 break
 
     def conver_line(t):
         s, rl = t
         return s + ' ' + ' '.join(map(str, rl))
         # return s + ' ' + '; '.join(map(lambda (x, i): str(convert(s, i)) + ' / ' + str(x) + ' = ' + str(convert(s, i) % x), zip(rl, xrange(2, 11))))
 
     return '\n' + '\n'.join(map(conver_line, res))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/6254486/SergGr/5738606668808192/0/extracted/TaskC.py,2723,101,334,Python,6254486,0,5738606668808192,SergGr,2016
72376,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from collections import OrderedDict
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line0 = f.readline()
     line = filter(lambda c: c == '-' or c == '+', line0)
     last = line[0]
     cnt = 0
     for c in line:
         if c != last:
             cnt += 1
             last = c
     if last == '-':
         cnt += 1
 
     return cnt
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/6254486/SergGr/5634697451274240/1/extracted/TaskB.py,1393,48,153,Python,6254486,1,5634697451274240,SergGr,2016
72377,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from collections import OrderedDict
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line0 = f.readline()
     line = filter(lambda c: c == '-' or c == '+', line0)
     last = line[0]
     cnt = 0
     for c in line:
         if c != last:
             cnt += 1
             last = c
     if last == '-':
         cnt += 1
 
     return cnt
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/6254486/SergGr/5634697451274240/0/extracted/TaskB.py,1395,48,154,Python,6254486,0,5634697451274240,SergGr,2016
186574,TaskA.py,"import threading
 import sys
 from  collections import Counter
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 # ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 #
 
 def calcSingleTest(f):
     line = f.readline()
 
     d_raw = [""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
     d_list = map(lambda x: Counter(x), d_raw)
     # [ ""ONE"", ,    ""NINE""]
     # z=>zero
     # w=>two
     # u=>four
     # g=>eight
     # x=>""SIX""
     #########
     # s=>""SEVEN""
     # v=>""FIVE""
     # t=>""THREE""
     # o=>one
     # i => nine
     d_rev = [
         ('Z', 0),
         ('W', 2),
         ('U', 4),
         ('G', 8),
         ('X', 6),
         #########
         ('S', 7),
         ('V', 5),
         ('T', 3),
         ('O', 1),
         ('I', 9)
     ]
 
     s = line.translate(None, '\r\n')
     l_cnt = Counter(s)
     print l_cnt
     print d_list
 
     res = [''] * 10
     for (l, d) in d_rev:
         c = l_cnt[l]
         res[d] = str(d) * c
         d_l = d_list[d]
         for ad in d_l:
             l_cnt[ad] = l_cnt[ad] - c * d_l[ad]
 
     for k,v in l_cnt.iteritems():
         if v!= 0:
             print ""!!!!!!!!!!!!!!!!""
             print l_cnt
 
     return ''.join(res)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/11254486/SergGr/5648941810974720/1/extracted/TaskA.py,1982,80,224,Python,11254486,1,5648941810974720,SergGr,2016
186575,TaskA.py,"import threading
 import sys
 from  collections import Counter
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 # ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 #
 
 def calcSingleTest(f):
     line = f.readline()
 
     d_raw = [""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""]
     d_list = map(lambda x: Counter(x), d_raw)
     # [ ""ONE"", ,    ""NINE""]
     # z=>zero
     # w=>two
     # u=>four
     # g=>eight
     # x=>""SIX""
     #########
     # s=>""SEVEN""
     # v=>""FIVE""
     # t=>""THREE""
     # o=>one
     # i => nine
     d_rev = [
         ('Z', 0),
         ('W', 2),
         ('U', 4),
         ('G', 8),
         ('X', 6),
         #########
         ('S', 7),
         ('V', 5),
         ('T', 3),
         ('O', 1),
         ('I', 9)
     ]
 
     s = line.translate(None, '\r\n')
     l_cnt = Counter(s)
     print l_cnt
     print d_list
 
     res = [''] * 10
     for (l, d) in d_rev:
         c = l_cnt[l]
         res[d] = str(d) * c
         d_l = d_list[d]
         for ad in d_l:
             l_cnt[ad] = l_cnt[ad] - c * d_l[ad]
         print (l, d, c)
         print res
         print l_cnt
 
     return ''.join(res)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/11254486/SergGr/5648941810974720/0/extracted/TaskA.py,1930,78,222,Python,11254486,0,5648941810974720,SergGr,2016
186576,TaskB.py,"import threading
 import sys
 from  collections import Counter
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 # inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def replace_char(s, i, c):
     return s[:i] + c + s[(i + 1):]
 
 
 def find_bigger(l, s1, s2, start):
     b1 = True
     b2 = True
     for i in xrange(start + 1, l):
         c1 = s1[i]
         c2 = s2[i]
         if c1 == '?' and c2 == '?':
             continue
         if c1 != '?' and c2 != '?':
             if c1 == c2:
                 return (-1, False)
 
 
 def calcSingleTest2(f):
     line = f.readline()
     s1_orig = line.split()[0]
     s2_orig = line.split()[1]
     s1 = s1_orig
     s2 = s2_orig
     s10 = s1 + '0'
     s20 = s2 + '0'
     print s1
     print s2
     l = len(s1)
 
     bigger = -1
     for i in xrange(l):
         c1 = s10[i]
         c2 = s20[i]
         # c1n = s10[i + 1]
         # c2n = s20[i + 1]
         if c1 == c2:
             if c1 == '?':
                 if bigger == -1:
                     s1 = replace_char(s1, i, '0')
                     s2 = replace_char(s2, i, '0')
                 elif bigger == 1:
                     s1 = replace_char(s1, i, '0')
                     s2 = replace_char(s2, i, '9')
                 elif bigger == 2:
                     s1 = replace_char(s1, i, '9')
                     s2 = replace_char(s2, i, '0')
         elif c1 == '?':
             if bigger == -1:
                 continue
             s1 = replace_char(s1, i, c2)
         elif c2 == '?':
             s2 = replace_char(s2, i, c1)
         else:
             bigger = 1 if c1 > c2 else 2
 
     # return s1 + ' ' + s2
     return '\n' + s1_orig + ' ' + s2_orig + '\n' + s1 + ' ' + s2
 
 
 def calcSingleTest(f):
     line = f.readline()
     s1_orig = line.split()[0]
     s2_orig = line.split()[1]
     s1 = s1_orig
     s2 = s2_orig
     print s1
     print s2
     l = len(s1)
 
     s10 = s1[::-1]
     s20 = s2[::-1]
     (s11, s21) = (s10, s20)
     (s12, s22) = (s10, s20)
 
     for i in xrange(l):
         c1 = s10[i]
         c2 = s20[i]
 
         d0 = abs(int(s10[:i][::-1]) - int(s20[:i][::-1])) if i > 0 else 0
         d1 = int(s11[:i][::-1]) - int(s21[:i][::-1]) if i > 0 else 0
         d2 = int(s22[:i][::-1]) - int(s12[:i][::-1]) if i > 0 else 0  # minus!
         p10 = 10 ** i
         # s10,s20
         if c1 != '?' and c2 != '?':
             if c1 < c2:
                 (s10, s20) = (s11, s21)
             elif c1 > c2:
                 (s10, s20) = (s12, s22)
         else:
             (s1n, s2n) = (s10, s20)
 
             if d0 > p10 - d1:
                 if (c2 == '?') and (c1 != '9'):
                     d0 = p10 - d1
                     (s1n, s2n) = (s11, s21)
                     if c1 == '?':
                         s1n = replace_char(s1n, i, '0')
                     s2n = replace_char(s2n, i, str(int(s1n[i]) + 1))
                 elif (c1 == '?') and (c2 != '0'):
                     d0 = p10 - d1
                     (s1n, s2n) = (s11, s21)
                     if c2 == '?':
                         s2n = replace_char(s2n, i, '1')
                     s1n = replace_char(s1n, i, str(int(s2n[i]) - 1))
 
             if d0 > p10 - d2:
                 if (c1 == '?') and (c2 != '9'):
                     d0 = p10 - d2
                     (s1n, s2n) = (s12, s22)
                     if c2 == '?':
                         s2n = replace_char(s2n, i, '0')
                     s1n = replace_char(s1n, i, str(int(s2n[i]) + 1))
                 elif (c2 == '?') and (c1 != '0'):
                     d0 = p10 - d2
                     (s1n, s2n) = (s12, s22)
                     if c1 == '?':
                         s1n = replace_char(s1n, i, '1')
                     s2n = replace_char(s2n, i, str(int(s1n[i]) - 1))
             (s10, s20) = (s1n, s2n)
             if s10[i] == '?' and s20[i] == '?':
                 s10 = replace_char(s10, i, '0')
                 s20 = replace_char(s20, i, '0')
             elif s10[i] == '?':
                 s10 = replace_char(s10, i, s20[i])
             elif s20[i] == '?':
                 s20 = replace_char(s20, i, s10[i])
 
         # s11,s12,s21,s22
         if c1 == '?':
             s11 = replace_char(s11, i, '9')
             s12 = replace_char(s12, i, '0')
         if c2 == '?':
             s21 = replace_char(s21, i, '0')
             s22 = replace_char(s22, i, '9')
 
     s1 = s10[::-1]
     s2 = s20[::-1]
     return s1 + ' ' + s2
     # return '\n' + s1_orig + ' ' + s2_orig + '\n' + s1 + ' ' + s2
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/11254486/SergGr/5695413893988352/0/extracted/TaskB.py,5728,183,740,Python,11254486,0,5695413893988352,SergGr,2016
210115,TaskB.py,"import threading
 import sys
 from  collections import Counter
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def bruteForce(B, M):
     e = B * (B - 1) / 2
 
     for p in xrange(1, 2 ** e):
         cs = [0] * B
         cs[0] = 1
         # print '--------------------------'
         for i in xrange(1, B):
             for j in xrange(i):
                 edgeIndex = i * (i - 1) / 2 + j
                 if 2 ** edgeIndex & p != 0:
                     cs[i] += cs[j]
                     # print (i, j)
                     # print (j, i)
         if cs[B - 1] == M:
             # print ""{0:b}"".format(p)
             # print(cs)
             m = []
             for y in xrange(0, B - 1):
                 row = [0] * B
                 m.append(row)
                 for x in xrange(y + 1, B):
                     i = x
                     j = y
                     edgeIndex = i * (i - 1) / 2 + j
                     if 2 ** edgeIndex & p != 0:
                         row[x] = 1
             m.append([0] * B)
 
             # s = '\n'.join(map(lambda r: ' '.join(map(str, r)), m))
             s = '\n'.join(map(lambda r: ''.join(map(str, r)), m))
             return s
     return ''
 
 
 def calcSingleTest(f):
     line = f.readline()
     B = int(line.split()[0])
     M = int(line.split()[1])
     if M > 2 ** B:
         return 'IMPOSSIBLE'
     bruteRes = bruteForce(B, M)
     if len(bruteRes) == 0:
         print (B, M)
         return 'IMPOSSIBLE'
     return 'POSSIBLE' + '\n' + bruteRes
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2016/4314486/SergGr/5744014401732608/0/extracted/TaskB.py,2750,89,329,Python,4314486,0,5744014401732608,SergGr,2016
210116,TaskA.py,"import threading
 import sys
 from  collections import Counter
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 # ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 #
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     sens0 = map(int, line.split())
     print sens0
     chars = map(lambda c: chr(ord('A') + c), xrange(N))
     sens = (zip(sens0, chars))
     sens = list(sorted(sens, key=lambda (c, l): -c))
     print sens
 
     (c1, l1) = sens[0]
     (c2, l2) = sens[1]
     rest = sens[2:]
     print rest
     res = []
 
     for x in xrange(c1 - c2):
         res.append(l1)
 
     for (c, l) in rest:
         while c > 1:
             res.append(l + l)
             c -= 2
         if c == 1:
             res.append(l)
 
     for x in xrange(c2):
         res.append(l1 + l2)
 
     print ""Res = "" + str(res)
     return ' '.join(res)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/4314486/SergGr/5753053697277952/1/extracted/TaskA.py,1637,62,188,Python,4314486,1,5753053697277952,SergGr,2016
210117,TaskA.py,"import threading
 import sys
 from  collections import Counter
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 # ""ZERO"", ""ONE"", ""TWO"", ""THREE"", ""FOUR"", ""FIVE"", ""SIX"", ""SEVEN"", ""EIGHT"", ""NINE""
 #
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
     line = f.readline()
     sens0 = map(int, line.split())
     print sens0
     chars = map(lambda c: chr(ord('A') + c), xrange(N))
     sens = (zip(sens0, chars))
     sens = list(sorted(sens, key=lambda (c, l): -c))
     print sens
 
     (c1, l1) = sens[0]
     (c2, l2) = sens[1]
     rest = sens[2:]
     print rest
     res = []
 
     for x in xrange(c1 - c2):
         res.append(l1)
 
     for (c, l) in rest:
         while c > 1:
             res.append(l + l)
             c -= 2
         if c == 1:
             res.append(l)
 
     for x in xrange(c2):
         res.append(l1 + l2)
 
     print ""Res = "" + str(res)
     return ' '.join(res)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2016/4314486/SergGr/5753053697277952/0/extracted/TaskA.py,1639,62,189,Python,4314486,0,5753053697277952,SergGr,2016
210118,TaskC.py,"import threading
 import sys
 # Increase max stack size from 8MB to 512MB
 # resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
 sys.setrecursionlimit(10 ** 6)
 
 import itertools
 import random
 import time
 import operator
 import collections
 from collections import Counter
 
 # from scipy.spatial import qhull
 # from scipy.spatial import ConvexHull
 # import numpy as np
 from math import *
 
 inputFileName = ""test.in""
 # inputFileName = ""C-small-practice.in""
 inputFileName = ""C-small-attempt0.in""
 inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def check(gs, K):
     jp = collections.defaultdict(int)
     ps = collections.defaultdict(int)
     js = collections.defaultdict(int)
     for (j, p, s) in gs:
         jp[(j, p)] = jp[(j, p)] + 1
         if jp[(j, p)] > K:
             return False
         ps[(p, s)] += 1
         if ps[(p, s)] > K:
             return False
         js[(j, s)] += 1
         if js[(j, s)] > K:
             return False
     return True
 
 
 def bruteForce(J, P, S, K):
     js = list(xrange(1, J + 1))
     ps = list(xrange(1, P + 1))
     ss = list(xrange(1, S + 1))
     all = list(itertools.product(js, ps, ss))
     N = len(all)
     em = len(js) * len(ps) * min(K, len(ss))
 
     for m in xrange(em, 0, -1):
         for cur in itertools.combinations(all, m):
             # print(cur)
             if check(cur, K):
                 return (m, cur)
     pass
     # b = []
     # m = 0
     # for bm in xrange(0, 2 ** N + 1):
     #     cur = []
     #     p = 1
     #     for i in xrange(N):
     #         if p & bm != 0:
     #             cur.append(all[i])
     #         p *= 2
     #
     #     if len(cur) > m and (K >= len(js) * len(ps) or check(cur, K)):
     #         # print cur
     #         m = len(cur)
     #         b = cur
     # return (m, b)
 
 
 def calcSingleTest(f):
     line = f.readline()
     arr = map(int, line.split())
     K = arr[3]
     gs = arr[:3]
 
     print str(gs) + "" "" + str(K)
 
     (m, b) = bruteForce(gs[0], gs[1], gs[2], K)
     return str(m) + '\n' + '\n'.join(map(lambda (j, p, s): str(j) + ' ' + str(p) + ' ' + str(s), b))
 
 
 def main():
     with open(inputFileName) as inpF:
         random.seed(0)
         with open(outputFileName, 'w') as outF:
             line = inpF.readline()
             testsCount = int(line)
             for i in xrange(1, testsCount + 1):
                 print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
                 res = calcSingleTest(inpF)
                 print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
                 print ' '
                 outF.write('Case #{0}: {1}\n'.format(i, res))
                 outF.flush()
 
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
 
 main()
",gcj/2016/4314486/SergGr/5708921029263360/0/extracted/TaskC.py,3077,110,390,Python,4314486,0,5708921029263360,SergGr,2016
4108,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def check1(N, rec, kit):
     v = kit
     q1 = (10 * v) / (9 * rec)
     q2 = (10 * v) / (11 * rec)
     if (q2 * 11 * rec) < (10 * v):
         q2 += 1
     if (q1 < q2):
         return False
 
     return True
 
 
 def check2(N, rec, kit1, kit2):
     kits = [kit1, kit2]
     if not check1(N, rec[0], kits[0]):
         return False
     if not check1(N, rec[1], kits[1]):
         return False
 
     qmi = -10000000
     qma = 10000000
 
     for i in xrange(N):
         v = kits[i]
         r = rec[i]
         q1 = (10 * v) / (9 * r)
         q2 = (10 * v) / (11 * r)
         if (q2 * 11 * r) < (10 * v):
             q2 += 1
 
         if (q1 < qma):
             qma = q1
         if (q2 > qmi):
             qmi = q2
 
     return (qmi <= qma)
 
 
 def check(N, rec, kits):
     qmi = -10000000
     qma = 10000000
 
     for i in xrange(N):
         v = kits[i]
         r = rec[i]
         q1 = (10 * v) / (9 * r)
         q2 = (10 * v) / (11 * r)
         if (q2 * 11 * r) < (10 * v):
             q2 += 1
 
         if q1 < qma:
             qma = q1
         if q2 > qmi:
             qmi = q2
 
     return (qmi <= qma)
 
 
 def solve2dumb(N, P, rec, arr):
     a = arr[0]
     b = arr[1]
     maxCnt = 0
     for bb in itertools.permutations(b):
         cnt = 0
         for i in xrange(P):
             if check2(N, rec, a[i], bb[i]):
                 cnt += 1
         if cnt > maxCnt:
             if maxCnt != 0:
                 print ""!!!!!!!!!!!! old = {0}, new = {1}"".format(maxCnt, cnt)
             print bb
             maxCnt = cnt
 
     return maxCnt
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     P = int(line.split()[1])
     rec = []
     line = f.readline()
     rec = map(int, line.split())
     arr = []
     for i in xrange(N):
         line = f.readline()
         a = map(int, line.split())
         a.sort()
         arr.append(a)
     print rec
     print '-----'
     print '\n'.join(map(str, arr))
     print '-----'
 
     if N == 1:
         cnt = 0
         a = arr[0]
         for i in xrange(P):
             if check1(N, rec[0], a[i]):
                 cnt += 1
         return cnt
     else:
         pos = [0] * N
         cnt = 0
         qq1 = [-10000000] * N
         qq2 = [10000000] * N
         end = False
         while True:
             qmi = -10000000
             qma = 10000000
 
             for i in xrange(N):
                 if pos[i] >= P:
                     end = True
                     break
                 v = arr[i][pos[i]]
                 r = rec[i]
                 q1 = (10 * v) / (9 * r)
                 q2 = (10 * v) / (11 * r)
                 if (q2 * 11 * r) < (10 * v):
                     q2 += 1
 
                 qq1[i] = q1
                 qq2[i] = q2
                 if q1 < qma:
                     qma = q1
                 if q2 > qmi:
                     qmi = q2
             if end:
                 break
             if (qmi <= qma):
                 cnt += 1
                 qq1 = [-10000000] * N
                 qq2 = [10000000] * N
                 for i in xrange(N):
                     pos[i] += 1
             else:
                 for i in xrange(N):
                     if (qq1[i] < qmi):
                         pos[i] += 1
 
         # if N == 2:
         #     dumbRes = solve2dumb(N, P, rec, arr)
 
         return cnt
 
     return -1
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/5304486/SergGr/5697460110360576/1/extracted/TaskB.py,4555,184,596,Python,5304486,1,5697460110360576,SergGr,2017
4109,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def check(N, rec, kit):
     for i in xrange(N):
         v = kit[i]
         r = rec[i]
         q = v / r
         if (10 * v > 11 * q * r) or (10 * v < 9 * q * r):
             return False
 
     return True
 
 
 def check1(N, rec, kit):
     v = kit
     q1 = (10 * v) / (9 * rec)
     q2 = (10 * v) / (11 * rec)
     if (q2 * 11 * rec) < (10 * v):
         q2 += 1
     if (q1 < q2):
         return False
 
     return True
 
 
 def check2(N, rec, kit1, kit2):
     kits = [kit1, kit2]
     if not check1(N, rec[0], kits[0]):
         return False
     if not check1(N, rec[1], kits[1]):
         return False
 
     qmi = -10000000
     qma = 10000000
 
     for i in xrange(N):
         v = kits[i]
         r = rec[i]
         q1 = (10 * v) / (9 * r)
         q2 = (10 * v) / (11 * r)
         if (q2 * 11 * r) < (10 * v):
             q2 += 1
 
         if (q1 < qma):
             qma = q1
         if (q2 > qmi):
             qmi = q2
 
     return (qmi <= qma)
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     P = int(line.split()[1])
     rec = []
     line = f.readline()
     rec = map(int, line.split())
     arr = []
     for i in xrange(N):
         line = f.readline()
         a = map(int, line.split())
         a.sort()
         arr.append(a)
     print rec
     print '-----'
     print '\n'.join(map(str, arr))
 
     if N == 1:
         cnt = 0
         a = arr[0]
         for i in xrange(P):
             if check1(N, rec[0], a[i]):
                 cnt += 1
         return cnt
     elif (N == 2):
         a = arr[0]
         b = arr[1]
         maxCnt = 0
         for bb in itertools.permutations(b):
             cnt = 0
             a = arr[0]
             for i in xrange(P):
                 if check2(N, rec, a[i], bb[i]):
                     cnt += 1
             if cnt > maxCnt:
                 maxCnt = cnt
 
         return maxCnt
 
     return -1
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/5304486/SergGr/5697460110360576/0/extracted/TaskB.py,3076,126,404,Python,5304486,0,5697460110360576,SergGr,2017
4110,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def fill(arr, ch, x0, y0, x1, y1):
     for y in xrange(y0, y1 + 1):
         for x in xrange(x0, x1 + 1):
             arr[y][x] = ch
 
 
 def calcSingleTest(f):
     line = f.readline()
     R = int(line.split()[0])
     C = int(line.split()[1])
     arr = []
 
     for r in xrange(R):
         line = f.readline().strip()
         arr.append(list(line))
 
     x0 = 0
     y0 = 0
     for y in xrange(R):
         x0 = 0
         xma = -1
         for x in xrange(1, C + 1):
             if arr[y][C - x] != '?':
                 xma = C - x
                 break
         if (xma == -1):
             continue
         for x in xrange(C):
             if arr[y][x] == '?':
                 continue
             ch = arr[y][x]
             if x == xma:
                 fill(arr, ch, x0, y0, C - 1, y)
             else:
                 fill(arr, ch, x0, y0, x, y)
                 x0 = x + 1
         y0 = y + 1
 
     if arr[R - 1][0] == '?':
         for x in xrange(C):
             for y in xrange(R - 2, -1, -1):
                 if arr[y][x] != '?':
                     ch = arr[y][x]
                     for y1 in xrange(y + 1, R):
                         arr[y1][x] = ch
                     break
 
     return '\n' + '\n'.join(map(lambda rr: ''.join(rr), arr))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2017/5304486/SergGr/5760761888505856/1/extracted/TaskA.py,1909,68,227,Python,5304486,1,5760761888505856,SergGr,2017
4111,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 
 def fill(arr, ch, x0, y0, x1, y1):
     for y in xrange(y0, y1 + 1):
         for x in xrange(x0, x1 + 1):
             arr[y][x] = ch
 
 
 def calcSingleTest(f):
     line = f.readline()
     R = int(line.split()[0])
     C = int(line.split()[1])
     arr = []
 
     for r in xrange(R):
         line = f.readline().strip()
         arr.append(list(line))
 
     x0 = 0
     y0 = 0
     for y in xrange(R):
         x0 = 0
         xma = -1
         for x in xrange(1, C + 1):
             if arr[y][C - x] != '?':
                 xma = C - x
                 break
         if (xma == -1):
             continue
         for x in xrange(C):
             if arr[y][x] == '?':
                 continue
             ch = arr[y][x]
             if x == xma:
                 fill(arr, ch, x0, y0, C - 1, y)
             else:
                 fill(arr, ch, x0, y0, x, y)
                 x0 = x + 1
         y0 = y + 1
 
     if (arr[R - 1][0] == '?'):
         for x in xrange(C):
             for y in xrange(R - 2, -1, -1):
                 if arr[y][x] != '?':
                     ch = arr[y][x]
                     for y1 in xrange(y + 1, R):
                         arr[y1][x] = ch
                     break
 
     return '\n' + '\n'.join(map(lambda rr: ''.join(rr), arr))
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2017/5304486/SergGr/5760761888505856/0/extracted/TaskA.py,1913,68,228,Python,5304486,0,5760761888505856,SergGr,2017
18608,TaskA.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 # inputFileName = ""test.in""
 # inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     P = int(line.split()[1])
     line = f.readline()
     g = map(int, line.split())
     m = map(lambda x: x % P, g)
     c = Counter(m)
     res = c[0]
     if (P == 2):
         res += (c[1] + 1) / 2
     elif (P == 3):
         c1 = c[1]
         c2 = c[2]
         mi = min(c1, c2)
         ma = max(c1, c2)
         res += mi + (ma - mi + 2) / 3
     elif (P == 4):
         print c
 
         c1 = c[1]
         c2 = c[2]
         c3 = c[3]
         res += c2 / 2
         c2 = c2 % 2
         mi = min(c1, c3)
         res += mi
         c1 -= mi
         c3 -= mi
         ma = max(c1, c3)
         if (c2 != 0):
             res += 1
             res += (ma + 1) / 4
         else:
             res += (ma + 3) / 4
 
         print res
     else:
         raise AssertionError(""AAAA "" + str(N))
 
     return res
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/5314486/SergGr/5700919488413696/1/extracted/TaskA.py,1828,75,241,Python,5314486,1,5700919488413696,SergGr,2017
18609,TaskA.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-small-attempt1.in""
 # inputFileName = ""A-small-attempt2.in""
 # inputFileName = ""A-small-attempt3.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     P = int(line.split()[1])
     line = f.readline()
     g = map(int, line.split())
     m = map(lambda x: x % P, g)
     c = Counter(m)
     res = c[0]
     if (P == 2):
         res += (c[1] + 1) / 2
         return res
     elif (P == 3):
         c1 = c[1]
         c2 = c[2]
         mi = min(c1, c2)
         ma = max(c1, c2)
         res += mi + (ma - mi + 2) / 3
         return res
     else:
         raise AssertionError(""AAAA "" + str(N))
 
     return 0
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/5314486/SergGr/5700919488413696/0/extracted/TaskA.py,1468,57,177,Python,5314486,0,5700919488413696,SergGr,2017
18610,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 # inputFileName = ""test.in""
 # inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcHard(N, C, tcp):
     rides = 0
     proms = 0
 
     mr = 0
     s = 0
     ss = []
     for i in xrange(0, N):
         ss.append(0)
         for j in xrange(0, C):
             ss[i] += tcp[j][i]
         s += ss[i]
 
         r = 0 if s == 0 else (s - 1) / (i + 1) + 1
         if r > mr:
             mr = r
     rides = mr
 
     for i in xrange(1, N):
         if ss[i] > mr:
             proms += ss[i] - mr
     return (rides, proms)
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     C = int(line.split()[1])
     M = int(line.split()[2])
     arr = []
 
     cc = [0] * C
     tcp = []
     for i in xrange(C):
         tcp.append([0] * N)
 
     for i in xrange(M):
         line = f.readline()
         p = int(line.split()[0])
         b = int(line.split()[1])
         tcp[b - 1][p - 1] += 1
         cc[b - 1] += 1
 
     print cc
     if N <= 10:
         print ""----------""
         for i in xrange(C):
             print tcp[i]
     else:
         agg = dict()
         for i in xrange(C):
             cnt = Counter()
             empty = True
             for j in xrange(N):
                 if (tcp[i][j] != 0) or N <= 10:
                     empty = False
                     cnt[j] = tcp[i][j]
             # agg[i] = Counter(tcp[i])
             agg[i] = cnt
             if (not empty):
                 print cnt
     rides = 0
     proms = 0
     if (C == 2):
         r0 = max(cc[0], cc[1])
         r1 = tcp[0][0] + tcp[1][0]
         mr = max(r0, r1)
         rides = mr
         half = mr / 2
         for i in xrange(1, N):
             s = tcp[0][i] + tcp[1][i]
             if s > mr:
                 if (proms != 0):
                     raise AssertionError(""AAA "" + str(proms))
                 proms = s - mr
 
         pass
     else:
         rides, proms = calcHard(N, C, tcp)
 
     return ""{0} {1}"".format(rides, proms)
 
 
 # print(calcHard(4, 6, [
 #     [0, 100, 0, 0],
 #     [0, 100, 0, 0],
 #     [50, 0, 50, 0],
 #     [50, 0, 50, 0],
 #     [0, 0, 0, 100],
 #     [0, 0, 0, 100],
 # ]))
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/5314486/SergGr/5687148430753792/1/extracted/TaskB.py,3232,127,417,Python,5314486,1,5687148430753792,SergGr,2017
18611,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from fractions import gcd
 from random import randint
 import random
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     C = int(line.split()[1])
     M = int(line.split()[2])
     arr = []
 
     cc = [0] * C
     tcp = []
     for i in xrange(C):
         tcp.append([0] * N)
 
     for i in xrange(M):
         line = f.readline()
         p = int(line.split()[0])
         b = int(line.split()[1])
         tcp[b - 1][p - 1] += 1
         cc[b - 1] += 1
 
     print cc
     print tcp
     agg = dict()
 
     # print tcp
     for i in xrange(C):
         agg[i] = Counter(tcp[i])
         print agg[i]
     rides = 0
     proms = 0
     if (C == 2):
         r0 = max(cc[0], cc[1])
         r1 = tcp[0][0] + tcp[1][0]
         mr = max(r0, r1)
         rides = mr
         half = mr / 2
         for i in xrange(1, N):
             s = tcp[0][i] + tcp[1][i]
             if s > mr:
                 if (proms != 0):
                     raise AssertionError(""AAA "" + str(proms))
                 proms = s - mr
 
         pass
     else:
         raise AssertionError(""AAA "" + str(N))
 
     return ""{0} {1}"".format(rides, proms)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/5314486/SergGr/5687148430753792/0/extracted/TaskB.py,2241,84,260,Python,5314486,0,5687148430753792,SergGr,2017
59369,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from collections import OrderedDict
 
 inputFileName = ""test.in""
 # inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def isTidy(n):
     s = str(n)
     ch = s[0]
 
     for i in xrange(1, len(s)):
         nCh = s[i]
         if (nCh < ch):
             return False
         ch = nCh
     return True
 
 
 def findTidyDumb(n):
     for x in xrange(n, 0, -1):
         if isTidy(x):
             return x
     return 0
 
 
 def findTidySmart(n):
     s = str(n)
     res = 0
     p10 = 1
     d = int(s[len(s) - 1])
     for i in xrange(len(s) - 2, -1, -1):
         nD = int(s[i])
         if nD > d:
             d = 9
             nD -= 1
             res = 10 * p10 - 1
         else:
             res += int(d) * p10
         d = nD
         p10 *= 10
     res += int(d) * p10
     return res
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
 
     smart = findTidySmart(N)
     if (N < 10000):
         dumb = findTidyDumb(N)
         if dumb != smart:
             raise AssertionError(""N = {0}, smart = {1}, dumb = {2}"".format(N, smart, dumb))
 
     return smart
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
 
 if 1 == 0:
     for N in xrange(1, 1000000):
         smart = findTidySmart(N)
         dumb = findTidyDumb(N)
         if N % 1000 == 0:
             print ""Progress = {0}"".format(N)
         if dumb != smart:
             raise AssertionError(""N = {0}, smart = {1}, dumb = {2}"".format(N, smart, dumb))
",gcj/2017/3264486/SergGr/5633382285312000/1/extracted/TaskB.py,2397,93,289,Python,3264486,1,5633382285312000,SergGr,2017
59370,TaskB.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from collections import OrderedDict
 
 inputFileName = ""test.in""
 inputFileName = ""B-small-attempt0.in""
 # inputFileName = ""B-small-attempt1.in""
 # inputFileName = ""B-small-attempt2.in""
 # inputFileName = ""B-small-attempt3.in""
 # inputFileName = ""B-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def isTidy(n):
     s = str(n)
     ch = s[0]
 
     for i in xrange(1, len(s)):
         nCh = s[i]
         if (nCh < ch):
             return False
         ch = nCh
     return True
 
 
 def findTidyDumb(n):
     for x in xrange(n, 0, -1):
         if isTidy(x):
             return x
     return 0
 
 
 def findTidySmart(n):
     s = str(n)
     res = 0
     p10 = 1
     d = int(s[len(s) - 1])
     for i in xrange(len(s) - 2, -1, -1):
         nD = int(s[i])
         if nD > d:
             d = 9
             nD -= 1
             res = 10 * p10 - 1
         else:
             res += int(d) * p10
         d = nD
         p10 *= 10
     res += int(d) * p10
     return res
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line)
 
     smart = findTidySmart(N)
     if (N < 10000):
         dumb = findTidyDumb(N)
         if dumb != smart:
             raise AssertionError(""N = {0}, smart = {1}, dumb = {2}"".format(N, smart, dumb))
 
     return smart
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
 
 if 1 == 0:
     for N in xrange(1, 1000000):
         smart = findTidySmart(N)
         dumb = findTidyDumb(N)
         if N % 1000 == 0:
             print ""Progress = {0}"".format(N)
         if dumb != smart:
             raise AssertionError(""N = {0}, smart = {1}, dumb = {2}"".format(N, smart, dumb))
",gcj/2017/3264486/SergGr/5633382285312000/0/extracted/TaskB.py,2397,93,289,Python,3264486,0,5633382285312000,SergGr,2017
59371,TaskD.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 
 inputFileName = ""test.in""
 inputFileName = ""D-small-attempt0.in""
 # inputFileName = ""D-small-attempt1.in""
 # inputFileName = ""D-small-attempt2.in""
 # inputFileName = ""D-small-attempt3.in""
 # inputFileName = ""D-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     M = int(line.split()[1])
     mm = []
     R1 = ['.'] * N
     for i in xrange(M):
         line = f.readline()
         mt = line.split()[0]
         r = int(line.split()[1]) - 1
         c = int(line.split()[2]) - 1
         mm.append((mt, r, c))
         R1[c] = mt
 
     print ''.join(R1)
     ans = []
     sc = 3 * N - 2 if N > 1 else 2
     x2 = -1
     for i in xrange(N - 1):
         if R1[i] == '.':
             ans.append(('+', 1, (i + 1)))
         elif R1[i] == '+':
             pass
         elif R1[i] == 'o':
             x2 = i
         elif R1[i] == 'x':
             ans.append(('o', 1, (i + 1)))
             x2 = i
 
     if x2 == -1:
         x2 = N - 1
         if R1[N - 1] != 'o':
             ans.append(('o', 1, N))
     else:
         if R1[N - 1] != '+':
             ans.append(('+', 1, N))
 
     for i in xrange(1, N - 1):
         ans.append(('+', N, (i + 1)))
 
     for i in xrange(0, x2):
         ans.append(('x', (N - i), (i + 1)))
     for i in xrange(x2 + 1, N):
         ans.append(('x', (i - x2 + 1), (i + 1)))
 
     strAns = ""{0} {1}"".format(sc, len(ans))
     for a in ans:
         strAns += ""\n{0} {1} {2}"".format(a[0], a[1], a[2])
     return strAns
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             r1 = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, r1))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/3264486/SergGr/5719854539603968/0/extracted/TaskD.py,2357,83,295,Python,3264486,0,5719854539603968,SergGr,2017
59372,TaskA.py,"inputFileName = ""test.in""
 # inputFileName = ""A-small-attempt0.in""
 inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 global MY_DEBUG
 MY_DEBUG = ""test.in"" == inputFileName
 
 
 def calcSingleTest(f):
     line = f.readline()
     pc = list(line.split("" "")[0])
     k = int(line.split("" "")[1])
     cnt = 0
     l = len(pc)
     for i in xrange(l - k + 1):
         if pc[i] == '-':
             cnt += 1
             for j in xrange(k):
                 pc[i + j] = '+' if pc[i + j] == '-' else '-'
 
     for j in xrange(k):
         if pc[-j] == '-':
             return 'IMPOSSIBLE'
     return str(cnt)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2017/3264486/SergGr/5736519012712448/1/extracted/TaskA.py,994,36,116,Python,3264486,1,5736519012712448,SergGr,2017
59373,TaskA.py,"inputFileName = ""test.in""
 inputFileName = ""A-small-attempt0.in""
 # inputFileName = ""A-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 global MY_DEBUG
 MY_DEBUG = ""test.in"" == inputFileName
 
 
 def calcSingleTest(f):
     line = f.readline()
     pc = list(line.split("" "")[0])
     k = int(line.split("" "")[1])
     cnt = 0
     l = len(pc)
     for i in xrange(l - k + 1):
         if pc[i] == '-':
             cnt += 1
             for j in xrange(k):
                 pc[i + j] = '+' if pc[i + j] == '-' else '-'
 
     for j in xrange(k):
         if pc[-j] == '-':
             return 'IMPOSSIBLE'
     return str(cnt)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------------------------------------------'
             res = calcSingleTest(inpF)
             outF.write('Case #{0}: {1}\n'.format(i, res))
",gcj/2017/3264486/SergGr/5736519012712448/0/extracted/TaskA.py,994,36,116,Python,3264486,0,5736519012712448,SergGr,2017
59374,TaskC.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from itertools import repeat
 import bisect
 
 inputFileName = ""test.in""
 
 # inputFileName = ""C-small-1-attempt0.in""
 # inputFileName = ""C-small-1-attempt1.in""
 
 # inputFileName = ""C-small-2-attempt0.in""
 
 # inputFileName = ""C-small-attempt0.in""
 # inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-small-attempt4.in""
 
 inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def dumb(N, K):
     BIG_VALUE = 2 * 10 ** 18
     st = [0] * (N + 1)
     st[-1] = 1
     ll = [-1] * N
     rr = [N] * N
     mm = [(-1, -1)] * N
 
     for i in xrange(0, N):
         l = i - ll[i] - 1
         r = rr[i] - i - 1
         mm[i] = (max(l, r), min(l, r))
 
     answers = []
 
     bestI = 0
     dbgCnt = 0
     last_dbgCnt = 0
     last_time = startTime
     lastBestI = N + 1
     lastBest = (-1, -1)
     for k in xrange(K):
         foundSame = False
 
         for i in xrange(lastBestI + 1, N):
             cur = mm[i]
             if st[i] == 1:
                 continue
             if cur == lastBest:
                 bestI = i
                 foundSame = True
                 break
 
         if not foundSame:
             bestI = 0
             best = (-1, -1)
             for i in xrange(N):
                 cur = mm[i]
                 if st[i] == 1:
                     continue
                 if (cur[1] > best[1]) or (cur[1] == best[1] and cur[0] > best[0]):
                     bestI = i
                     best = cur
 
         st[bestI] = 1
 
         answers.append((k + 1, bestI + 1, best[0], best[1]))
         for i in xrange(bestI + 1, N):
             if ll[i] < bestI:
                 dbgCnt += 1
                 ll[i] = bestI
                 l = i - ll[i] - 1
                 r = rr[i] - i - 1
                 mm[i] = (max(l, r), min(l, r))
             else:
                 break
 
         for i in xrange(bestI - 1, -1, -1):
             if rr[i] > bestI:
                 dbgCnt += 1
                 rr[i] = bestI
                 l = i - ll[i] - 1
                 r = rr[i] - i - 1
                 mm[i] = (max(l, r), min(l, r))
             else:
                 break
         pass
         lastBestI = bestI
         lastBest = best
         if (1 == 0) and (((k % 100 == 0) and k < 1000) or (k % 5000 == 0)):
             curTime = time.time()
             print ""{0:06.2f} / {7:04.2f}: k = {1:05d}, dbgCnt = {2:08d} {3:.3f} {4:.3f} {5:.5f} {6:05d}, best = {8}"".format(
                 (curTime - startTime), k, dbgCnt,
                 float(dbgCnt) / (k + 1), float(dbgCnt) / N,
                 float(dbgCnt) / (k + 1) / N,
                 (dbgCnt - last_dbgCnt),
                 (curTime - last_time),
                 best)
             last_dbgCnt = dbgCnt
             last_time = curTime
 
     # bestI = 0
     # best = mm[bestI]
     # for i in xrange(1, N):
     #     cur = mm[i]
     #     if (cur[1] > best[1]) or (cur[1] == best[1] and cur[0] > best[0]):
     #         bestI = i
     #         best = cur
 
     # print ""\n"".join(map(str, answers))
 
     return mm[bestI]
 
 
 def smart(N, K):
     qi = [N]
     q = dict()
     q[N] = 1
 
     k = K
     while k > 0:
 
         s = qi.pop(-1)
         c = q[s]
         if c < k:
             k -= c
             s1 = (s - 1) / 2
             s2 = s / 2
             if s1 not in q:
                 bisect.insort(qi, s1)
                 q[s1] = c
             else:
                 q[s1] += c
 
             if s2 not in q:
                 bisect.insort(qi, s2)
                 q[s2] = c
             else:
                 q[s2] += c
         else:
             return (s / 2, (s - 1) / 2)
 
     return (-1, -1)
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     K = int(line.split()[1])
 
     if K > N / 2 + 1 and 1 == 0:
         x, y = (0, 0)
     else:
         x, y = r2 = smart(N, K)
         # r1 = dumb(N, K)
         # if r2 != r1:
         #     raise AssertionError(""N = {0}, K = {1}, dumb = {2}, smart = {3}"".format(N, K, r1, r2))
     return ""{0} {1}"".format(x, y)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/3264486/SergGr/5654742835396608/2/extracted/TaskC.py,4973,183,651,Python,3264486,2,5654742835396608,SergGr,2017
59375,TaskC.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from itertools import repeat
 import bisect
 
 inputFileName = ""test.in""
 
 # inputFileName = ""C-small-1-attempt0.in""
 # inputFileName = ""C-small-1-attempt1.in""
 
 inputFileName = ""C-small-2-attempt0.in""
 
 # inputFileName = ""C-small-attempt0.in""
 # inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-small-attempt4.in""
 
 # inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def dumb(N, K):
     BIG_VALUE = 2 * 10 ** 18
     st = [0] * (N + 1)
     st[-1] = 1
     ll = [-1] * N
     rr = [N] * N
     mm = [(-1, -1)] * N
 
     for i in xrange(0, N):
         l = i - ll[i] - 1
         r = rr[i] - i - 1
         mm[i] = (max(l, r), min(l, r))
 
     answers = []
 
     bestI = 0
     dbgCnt = 0
     last_dbgCnt = 0
     last_time = startTime
     lastBestI = N + 1
     lastBest = (-1, -1)
     for k in xrange(K):
         foundSame = False
 
         for i in xrange(lastBestI + 1, N):
             cur = mm[i]
             if st[i] == 1:
                 continue
             if cur == lastBest:
                 bestI = i
                 foundSame = True
                 break
 
         if not foundSame:
             bestI = 0
             best = (-1, -1)
             for i in xrange(N):
                 cur = mm[i]
                 if st[i] == 1:
                     continue
                 if (cur[1] > best[1]) or (cur[1] == best[1] and cur[0] > best[0]):
                     bestI = i
                     best = cur
 
         st[bestI] = 1
 
         answers.append((k + 1, bestI + 1, best[0], best[1]))
         for i in xrange(bestI + 1, N):
             if ll[i] < bestI:
                 dbgCnt += 1
                 ll[i] = bestI
                 l = i - ll[i] - 1
                 r = rr[i] - i - 1
                 mm[i] = (max(l, r), min(l, r))
             else:
                 break
 
         for i in xrange(bestI - 1, -1, -1):
             if rr[i] > bestI:
                 dbgCnt += 1
                 rr[i] = bestI
                 l = i - ll[i] - 1
                 r = rr[i] - i - 1
                 mm[i] = (max(l, r), min(l, r))
             else:
                 break
         pass
         lastBestI = bestI
         lastBest = best
         if (1 == 0) and (((k % 100 == 0) and k < 1000) or (k % 5000 == 0)):
             curTime = time.time()
             print ""{0:06.2f} / {7:04.2f}: k = {1:05d}, dbgCnt = {2:08d} {3:.3f} {4:.3f} {5:.5f} {6:05d}, best = {8}"".format(
                 (curTime - startTime), k, dbgCnt,
                 float(dbgCnt) / (k + 1), float(dbgCnt) / N,
                 float(dbgCnt) / (k + 1) / N,
                 (dbgCnt - last_dbgCnt),
                 (curTime - last_time),
                 best)
             last_dbgCnt = dbgCnt
             last_time = curTime
 
     # bestI = 0
     # best = mm[bestI]
     # for i in xrange(1, N):
     #     cur = mm[i]
     #     if (cur[1] > best[1]) or (cur[1] == best[1] and cur[0] > best[0]):
     #         bestI = i
     #         best = cur
 
     # print ""\n"".join(map(str, answers))
 
     return mm[bestI]
 
 
 def smart(N, K):
     qi = [N]
     q = dict()
     q[N] = 1
 
     k = K
     while k > 0:
 
         s = qi.pop(-1)
         c = q[s]
         if c < k:
             k -= c
             s1 = (s - 1) / 2
             s2 = s / 2
             if s1 not in q:
                 bisect.insort(qi, s1)
                 q[s1] = c
             else:
                 q[s1] += c
 
             if s2 not in q:
                 bisect.insort(qi, s2)
                 q[s2] = c
             else:
                 q[s2] += c
         else:
             return (s / 2, (s - 1) / 2)
 
     return (-1, -1)
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     K = int(line.split()[1])
 
     if K > N / 2 + 1 and 1 == 0:
         x, y = (0, 0)
     else:
         x, y = r2 = smart(N, K)
         # r1 = dumb(N, K)
         # if r2 != r1:
         #     raise AssertionError(""N = {0}, K = {1}, dumb = {2}, smart = {3}"".format(N, K, r1, r2))
     return ""{0} {1}"".format(x, y)
 
 
 for N in range(1000, 1000):
     for K in range(1, N + 1):
         x, y = r1 = dumb(N, K)
         r2 = smart(N, K)
         if r2 != r1:
             raise AssertionError(""N = {0}, K = {1}, dumb = {2}, smart = {3}"".format(N, K, r1, r2))
     if N % 100 == 0:
         print ""Passed {0} tests"".format(N)
 
 print ""Passed all tests""
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/3264486/SergGr/5654742835396608/1/extracted/TaskC.py,5309,194,708,Python,3264486,1,5654742835396608,SergGr,2017
59376,TaskC.py,"import itertools
 import time
 import operator
 # import collections
 from collections import Counter
 from itertools import repeat
 
 inputFileName = ""test.in""
 
 # inputFileName = ""C-small-1-attempt0.in""
 inputFileName = ""C-small-1-attempt1.in""
 
 # inputFileName = ""C-small-attempt0.in""
 # inputFileName = ""C-small-attempt1.in""
 # inputFileName = ""C-small-attempt2.in""
 
 # inputFileName = ""C-small-attempt3.in""
 # inputFileName = ""C-small-attempt4.in""
 
 # inputFileName = ""C-large.in""
 outputFileName = inputFileName[:-3] + "".out""
 
 startTime = time.time()
 print startTime
 
 
 def dumb(N, K):
     BIG_VALUE = 2 * 10 ** 18
     st = [0] * (N + 1)
     st[-1] = 1
     # mi = [0] * N
     # ma = [0] * N
     ll = [-1] * N
     rr = [N] * N
     mm = [(-1, -1)] * N
     # for i in xrange(0, N):
     #     l = i
     #     r = N - i - 1
     #     mi[i] = min(l, r)
     #     ma[i] = max(l, r)
 
 
     for i in xrange(0, N):
         l = i - ll[i] - 1
         r = rr[i] - i - 1
         # mi[i] = min(l, r)
         # ma[i] = max(l, r)
         mm[i] = (max(l, r), min(l, r))
 
     bestI = 0
     for k in xrange(K):
         bestI = 0
         best = (-1, -1)
         for i in xrange(N):
             cur = mm[i]
             if st[i] == 1:
                 continue
             if (cur[1] > best[1]) or (cur[1] == best[1] and cur[0] > best[0]):
                 bestI = i
                 best = cur
         st[bestI] = 1
         for i in xrange(bestI + 1, N):
             if ll[i] < bestI:
                 ll[i] = bestI
                 l = i - ll[i] - 1
                 r = rr[i] - i - 1
                 mm[i] = (max(l, r), min(l, r))
             else:
                 break
         pass
         for i in xrange(bestI - 1, -1, -1):
             if rr[i] > bestI:
                 rr[i] = bestI
                 l = i - ll[i] - 1
                 r = rr[i] - i - 1
                 mm[i] = (max(l, r), min(l, r))
             else:
                 break
         pass
 
     # bestI = 0
     # best = mm[bestI]
     # for i in xrange(1, N):
     #     cur = mm[i]
     #     if (cur[1] > best[1]) or (cur[1] == best[1] and cur[0] > best[0]):
     #         bestI = i
     #         best = cur
 
     return mm[bestI]
 
 
 def calcSingleTest(f):
     line = f.readline()
     N = int(line.split()[0])
     K = int(line.split()[1])
 
     if K > N / 2 + 1 and 1 == 0:
         x, y = (0, 0)
     else:
         x, y = dumb(N, K)
     return ""{0} {1}"".format(x, y)
 
 
 with open(inputFileName) as inpF:
     with open(outputFileName, 'w') as outF:
         line = inpF.readline()
         testsCount = int(line)
         for i in xrange(1, testsCount + 1):
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             res = calcSingleTest(inpF)
             print '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime))
             print ' '
             outF.write('Case #{0}: {1}\n'.format(i, res))
             outF.flush()
 
 print ""Finished!!!! Total time = {0}"".format((time.time() - startTime))
",gcj/2017/3264486/SergGr/5654742835396608/0/extracted/TaskC.py,3144,117,432,Python,3264486,0,5654742835396608,SergGr,2017
10013,000000000004a469.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""
    if sum(cnts) != C:
        dbg_print(""IMPOSSIBLE sum {0} != {1}"".format(C, sum(cnts)))
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue

        end = start + c

        right = i - start + 1
        left = end - i
        cc = max(left, right)
        # cc = c
        # if not (start <= i < end):
        #     cc += 1
        if cc > ma:
            ma = cc
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma - 1):
            # for i in xrange(ma ):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i - 1][i] = '/'

        if 1 == 1:
            for i in xrange(ma - 1):
                m = ms[i]
                for j in xrange(C - 1):
                    if m[j] == '\\' and m[j + 1] == '/':
                        raise RuntimeError(""AAAAA"")

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        dbg_print(ms)

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3847,153,542,Python,7706,000000000004a469,00000000000459f2,SergGr,2018
10014,000000000004a4a0.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""
    if sum(cnts) != C:
        dbg_print(""IMPOSSIBLE sum {0} != {1}"".format(C, sum(cnts)))
        return ""IMPOSSIBLE""

    # start = 0
    # ma2 = 0
    # out = [['.'] * C]
    # for i in xrange(C):
    #     c = cnts[i]
    #     if c == 0:
    #         continue
    #     end = start + c
    #     cc = 0
    #     for j in xrange(c - 1, start - 1, -1):
    #         cc += 1
    #         if len(out) <= cc:
    #             out.append(['.'] * C)
    #         out[cc][j] = '\\'
    #         pass
    #     start = end
    # dbg_print(""out\n"" + '\n'.join(map(lambda l: ''.join(l), out)))
    # dbg_print(""----"")

    ranges = []
    start = 0
    ma = 0
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue

        end = start + c

        right = i - start + 1
        left = end - i
        cc = max(left, right)
        # cc = c
        # if not (start <= i < end):
        #     cc += 1
        if cc > ma:
            ma = cc
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma - 1):
            # for i in xrange(ma ):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i - 1][i] = '/'

        if 1 == 1:
            for i in xrange(ma - 1):
                m = ms[i]
                for j in xrange(C - 1):
                    if m[j] == '\\' and m[j + 1] == '/':
                        raise RuntimeError(""AAAAA"")

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        # dbg_print(ms)
        dbg_print('\n'.join(map(lambda m: ''.join(m), ms)))

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4559,172,625,Python,7706,000000000004a4a0,00000000000459f2,SergGr,2018
10015,0000000000049dd4.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""
    if sum(cnts) != C:
        dbg_print(""IMPOSSIBLE sum {0} != {1}"".format(C, sum(cnts)))
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue

        end = start + c

        right = i - start + 1
        left = end - i
        cc = max(left, right)
        # cc = c
        # if not (start <= i < end):
        #     cc += 1
        if cc > ma:
            ma = cc
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma - 1):
            # for i in xrange(ma ):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i - 1][i] = '/'

        if 1 == 1:
            for i in xrange(ma - 1):
                m = ms[i]
                for j in xrange(C - 1):
                    if m[j] == '\\' and m[j + 1] == '/':
                        raise RuntimeError(""AAAAA"")

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        dbg_print(ms)

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3999,153,542,Python,7706,0000000000049dd4,00000000000459f2,SergGr,2018
10016,00000000000498d6.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""
    if sum(cnts) != C:
        dbg_print(""IMPOSSIBLE sum {0} != {1}"".format(C, sum(cnts)))
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue

        end = start + c
        cc = c
        if not (start <= i < end):
            cc += 1
        if cc > ma:
            ma = cc
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma - 1):
            # for i in xrange(ma ):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i - 1][i] = '/'

        if 1 == 1:
            for i in xrange(ma - 1):
                m = ms[i]
                for j in xrange(C - 1):
                    if m[j] == '\\' and m[j + 1] == '/':
                        raise RuntimeError(""AAAAA"")

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        dbg_print(ms)

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3905,149,523,Python,7706,00000000000498d6,00000000000459f2,SergGr,2018
10017,0000000000049723.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""
    if sum(cnts) != C:
        dbg_print(""IMPOSSIBLE sum {0} != {1}"".format(C, sum(cnts)))
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue
        if c > ma:
            ma = c
        end = start + c
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i - 1][i] = '/'

        if 1 == 1:
            for i in xrange(ma):
                m = ms[i]
                for j in xrange(C - 1):
                    if m[j] == '\\' and m[j + 1] == '/':
                        raise RuntimeError(""AAAAA"")

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        dbg_print(ms)

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3783,144,500,Python,7706,0000000000049723,00000000000459f2,SergGr,2018
10018,000000000004934f.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""
    if sum(cnts) != C:
        dbg_print(""IMPOSSIBLE sum {0} != {1}"".format(C, sum(cnts)))
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue
        if c > ma:
            ma = c
        end = start + c
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i - 1][i] = '/'

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        dbg_print(ms)

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3548,137,471,Python,7706,000000000004934f,00000000000459f2,SergGr,2018
10019,0000000000049224.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0 or sum(cnts) != C:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue
        if c > ma:
            ma = c
        end = start + c
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    # if ma > 1:
    #     m = ''
    #     for (c, s, e) in ranges:
    #         if s < c:
    #             m += '\\' * (c - s)
    #         if s <= c <= e:
    #             m += '.'
    #         if c < e:
    #             m += '/' * (e - c - 1)
    #     m += '\n'
    #     res += m * ma
    if ma > 1:
        # m = '.' * C + '\n'
        # m = '.' * C

        # m = ['.'] * C
        # ms = [m] * ma
        ms = []
        for i in xrange(ma):
            m = ['.'] * C
            ms.append(m)

        # for (c, s, e) in ranges:
        #     if s < c:
        #         m += '\\' * (c - s)
        #     if s <= c <= e:
        #         m += '.'
        #     if c < e:
        #         m += '/' * (e - c - 1)
        # m += '\n'
        # res += m * ma

        for (c, s, e) in ranges:
            for i in range(s, c):
                ms[i - s][i] = '\\'
            for i in range(e - 1, c, -1):
                ms[e - i][i] = '/'

        res += '\n'.join(map(lambda m: ''.join(m), ms)) + '\n'
        dbg_print(ms)

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3440,134,461,Python,7706,0000000000049224,00000000000459f2,SergGr,2018
10020,0000000000048e0b.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue
        if c > ma:
            ma = c
        end = start + c
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    if ma > 1:
        m = ''
        for (c, s, e) in ranges:
            if s < c:
                m += '\\' * (c - s)
            if s <= c <= e:
                m += '.'
            if c < e:
                m += '/' * (e - c - 1)
        m += '\n'
        res += m * ma

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2629,105,309,Python,7706,0000000000048e0b,00000000000459f2,SergGr,2018
10021,0000000000048c3f.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    C = int(line.split()[0])
    line = f.readline()
    cnts = map(int, line.split())
    dbg_print(""C = {0}, cnts = {1}"".format(C, cnts))
    if cnts[0] == 0 or cnts[C - 1] == 0:
        dbg_print(""IMPOSSIBLE"")
        return ""IMPOSSIBLE""

    ranges = []
    start = 0
    ma = 0
    # for c in cnts:
    for i in xrange(C):
        c = cnts[i]
        if c == 0:
            continue
        if c > ma:
            ma = c
        end = start + c
        ranges.append((i, start, end))
        start = end

    dbg_print(ranges)

    res = str(ma) + ""\n""
    if ma > 1:
        m = ''
        for (c, s, e) in ranges:
            if s < c:
                m += '\\' * (c - s)
            if s <= c <= e:
                m += ' '
            if c < e:
                m += '/' * (e - c - 1)
        m += '\n'
        res += m * ma

    res += '.' * C
    return res


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2629,105,310,Python,7706,0000000000048c3f,00000000000459f2,SergGr,2018
10022,000000000004866c.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def maxConnected(coords):
    # sc = set(coords)
    # copy = set(coords)
    # groups = []
    # used = set()

    sc = set(coords)
    # sc = set()
    # for c in coords:
    #     sc.add(c)
    # dbg_print(coords)
    # dbg_print(sc)

    best = []
    used = set()
    comps = []
    for c in coords:
        if c in used:
            continue
        # used.add(c)
        comp = []
        q = Queue.Queue()
        q.put(c)
        while not q.empty():
            next = q.get()
            if next in used:
                continue
            used.add(next)
            if next in sc:
                comp.append(next)

            def offer(dx, dy):
                n1 = (next[0] + dx, next[1] + dy)
                if n1 in sc and n1 not in used:
                    q.put(n1)

            pass
            offer(1, 0)
            offer(-1, 0)
            offer(0, 1)
            offer(0, -1)
            pass

        comps.append(comp)
        if len(comp) > len(best):
            best = comp
            # dbg_print(best)
    # dbg_print(comps)

    return len(best)


# sc = set(coords)
# merged = dict()
#
# def trymerge(c0, c1):
#     if c1 in merged:
#         l0 = merged[c0]
#         l1 = merged[c1]
#         if l0[0] != l1[0]:
#             pass
#
# for c in coords:
#     if not c in merged:
#         merged[c] = [c, set(c)]
#
#     trymerge(c, (c[0] + 1, c[1]))
#     trymerge(c, (c[0] - 1, c[1]))
#     trymerge(c, (c[0], c[1] + 1))
#     trymerge(c, (c[0], c[1] - 1))
#
#     # if c in used:
#     #     continue
#     # cur = set(c)
#     # used.add(c)
#


def calcSingleTest(f):
    line = f.readline()
    R = int(line.split()[0])
    C = int(line.split()[1])
    grid = []
    for i in xrange(R):
        line = f.readline()
        row = line.strip()
        grid.append(row)

    dbg_print(grid)

    R2 = 4 * R
    C2 = 4 * C

    def get4(i, j):
        if i >= R2 or j >= C2:
            return 'Q'  # fake
        else:
            return grid[i / 4][j / 4]

    matches = set()
    best = 1
    for rs in xrange(R2):
        for cs in xrange(C2):
            cur_match = []
            for i in xrange(R):
                for j in xrange(C):
                    c1 = grid[i][j]
                    c2 = get4(rs + i, cs + j)
                    if c1 == c2:
                        cur_match.append((i, j))
            tu = tuple(cur_match)

            cur_len = len(cur_match)
            if cur_len > best and tu not in matches:
                cur_mac = maxConnected(cur_match)
                if cur_mac > best:
                    best = cur_mac
                # dbg_print(tu)
                # dbg_print(cur_mac)
                matches.add(tu)

    if len(matches) == 0:  # can it be so? probably for R = C  = 1
        dbg_print(""Early exit"")
        return 1

    # dbg_print(matches)
    return best


# for subset in all_subsets([1, 2, 3, 4]):
#       print(subset)

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4763,195,552,Python,7706,000000000004866c,00000000000459f4,SergGr,2018
10023,00000000000468da.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def all_subsets2(ss):
    return chain(*map(lambda x: combinations(ss, x), range(0, len(ss) + 1)))


# def get_power_set(s):
def all_subsets(s):
    power_set = [set()]

    for element in s:
        new_sets = []
        for subset in power_set:
            new_sets.append(subset | {element})
        power_set.extend(new_sets)

    return power_set


def fastCheck(grid, oldBad, excluding):
    bad = filter(lambda x: x not in excluding, oldBad)
    le = len(bad)
    for i in xrange(le - 1):
        base = bad[i]
        for j in xrange(i + 1, le):
            cur = bad[j]
            if (base[0] == cur[0] or base[1] == cur[1]) and grid[base[0]][base[1]] == grid[cur[0]][cur[1]]:
                return False
    return True


def findBad(grid, N, excluding):
    bad = set()
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (i, j)
            if coord in excluding:
                continue
            color = grid[i][j]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (j, i)
            if coord in excluding:
                continue
            color = grid[j][i]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    return list(bad)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    grid = []
    for i in xrange(N):
        line = f.readline()
        row = map(int, line.split())
        grid.append(row)

    dbg_print(grid)

    bad = findBad(grid, N, set())
    dbg_print(bad)

    # best = -1
    best = 2 * N * N
    # for ss in all_subsets(bad):
    check = sorted(all_subsets(bad), key=lambda s: len(s))
    # dbg_print(check)
    for ss in check:
        cur = len(ss)
        if cur >= best:
            break
            # continue
        # b1 = fastCheck(grid, bad, ss)
        if fastCheck(grid, bad, ss):
            best = cur
            break
        # b1 = findBad(grid, N, ss)
        # if len(b1) == 0:
        #     if cur < best:
        #         best = cur
        #         # dbg_print(ss)

    return best


# for subset in all_subsets([1, 2, 3, 4]):
#       print(subset)

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4202,161,448,Python,7706,00000000000468da,0000000000045875,SergGr,2018
10025,00000000000465f1.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def all_subsets2(ss):
    return chain(*map(lambda x: combinations(ss, x), range(0, len(ss) + 1)))


# def get_power_set(s):
def all_subsets(s):
    power_set = [set()]

    for element in s:
        new_sets = []
        for subset in power_set:
            new_sets.append(subset | {element})
        power_set.extend(new_sets)

    return power_set


def findBad(grid, N, excluding):
    bad = set()
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (i, j)
            if coord in excluding:
                continue
            color = grid[i][j]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (j, i)
            if coord in excluding:
                continue
            color = grid[j][i]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    return list(bad)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    grid = []
    for i in xrange(N):
        line = f.readline()
        row = map(int, line.split())
        grid.append(row)

    dbg_print(grid)

    bad = findBad(grid, N, set())
    dbg_print(bad)

    # best = -1
    best = 2 * N * N
    # for ss in all_subsets(bad):
    check = sorted(all_subsets(bad), key=lambda s: len(s))
    # dbg_print(check)
    for ss in check:
        cur = len(ss)
        if cur >= best:
            break
            # continue
        b1 = findBad(grid, N, ss)
        if len(b1) == 0:
            if cur < best:
                best = cur
                # dbg_print(ss)

    return best


# for subset in all_subsets([1, 2, 3, 4]):
#       print(subset)

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3678,145,378,Python,7706,00000000000465f1,0000000000045875,SergGr,2018
10026,0000000000046389.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def all_subsets2(ss):
    return chain(*map(lambda x: combinations(ss, x), range(0, len(ss) + 1)))

#def get_power_set(s):
def all_subsets(s):
    power_set = [set()]

    for element in s:
        new_sets = []
        for subset in power_set:
            new_sets.append(subset | {element})
        power_set.extend(new_sets)

    return power_set



def findBad(grid, N, excluding):
    bad = set()
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (i, j)
            if coord in excluding:
                continue
            color = grid[i][j]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (j, i)
            if coord in excluding:
                continue
            color = grid[j][i]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    return list(bad)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    grid = []
    for i in xrange(N):
        line = f.readline()
        row = map(int, line.split())
        grid.append(row)

    dbg_print(grid)

    bad = findBad(grid, N, set())
    dbg_print(bad)

    best = -1
    for ss in all_subsets(bad):
        if best != -1 and len(ss) >= best:
            continue
        b1 = findBad(grid, N, ss)
        if len(b1) == 0:
            if best == -1 or len(ss) < best:
                best = len(ss)
                #dbg_print(ss)
            #break

    return best

# for subset in all_subsets([1, 2, 3, 4]):
#       print(subset)

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3559,139,359,Python,7706,0000000000046389,0000000000045875,SergGr,2018
10027,0000000000046366.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def all_subsets2(ss):
    return chain(*map(lambda x: combinations(ss, x), range(0, len(ss) + 1)))

#def get_power_set(s):
def all_subsets(s):
    power_set = [set()]

    for element in s:
        new_sets = []
        for subset in power_set:
            new_sets.append(subset | {element})
        power_set.extend(new_sets)

    return power_set



def findBad(grid, N, excluding):
    bad = set()
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (i, j)
            if coord in excluding:
                continue
            color = grid[i][j]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (j, i)
            if coord in excluding:
                continue
            color = grid[j][i]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    return list(bad)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    grid = []
    for i in xrange(N):
        line = f.readline()
        row = map(int, line.split())
        grid.append(row)

    dbg_print(grid)

    bad = findBad(grid, N, set())
    dbg_print(bad)

    best = -1
    for ss in all_subsets(bad):
        if best != -1 and len(ss) >= best:
            continue
        b1 = findBad(grid, N, ss)
        if len(b1) == 0:
            if best == -1 or len(ss) < best:
                best = len(ss)
                #dbg_print(ss)
            break

    return best

# for subset in all_subsets([1, 2, 3, 4]):
#       print(subset)

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3558,139,359,Python,7706,0000000000046366,0000000000045875,SergGr,2018
10028,00000000000460a7.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def all_subsets(s):
    power_set = [set()]

    for element in s:
        new_sets = []
        for subset in power_set:
            new_sets.append(subset | {element})
        power_set.extend(new_sets)

    return power_set


def findBad(grid, N, excluding):
    bad = set()
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (i, j)
            if coord in excluding:
                continue
            color = grid[i][j]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (j, i)
            if coord in excluding:
                continue
            color = grid[j][i]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    return list(bad)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    grid = []
    for i in xrange(N):
        line = f.readline()
        row = map(int, line.split())
        grid.append(row)

    dbg_print(grid)

    bad = findBad(grid, N, set())
    dbg_print(bad)

    best = -1
    for ss in all_subsets(bad):
        b1 = findBad(grid, N, ss)
        if len(b1) == 0:
            best = len(ss)
            break

    return best


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3214,128,318,Python,7706,00000000000460a7,0000000000045875,SergGr,2018
10029,0000000000045e5f.PYTHON,"import itertools
from itertools import chain, combinations
import time
import operator
import Queue
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""C-small-attempt0.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def all_subsets(ss):
    return chain(*map(lambda x: combinations(ss, x), range(0, len(ss) + 1)))


def findBad(grid, N, excluding):
    bad = set()
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (i, j)
            if coord in excluding:
                continue
            color = grid[i][j]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    for i in xrange(N):
        seen = dict()
        for j in xrange(N):
            coord = (j, i)
            if coord in excluding:
                continue
            color = grid[j][i]
            if color in seen:
                bad.add(coord)
                bad.add(seen[color])
            else:
                seen[color] = coord
    return list(bad)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    grid = []
    for i in xrange(N):
        line = f.readline()
        row = map(int, line.split())
        grid.append(row)

    dbg_print(grid)

    bad = findBad(grid, N, set())
    dbg_print(bad)

    best = -1
    for ss in all_subsets(bad):
        b1 = findBad(grid, N, ss)
        if len(b1) == 0:
            best = len(ss)
            break

    return best


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3077,120,307,Python,7706,0000000000045e5f,0000000000045875,SergGr,2018
49001,000000000003b6ff.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def bruteForce(N, votes):
    used = sum(votes)
    rest = N - used
    expVotes = votes[:]
    for i in xrange(rest):
        expVotes.append(0)
    le = len(expVotes)
    dbg_print(expVotes)

    add = [0] * le
    add[0] = rest
    best = -1
    dbg_cnt = 0
    while True:
        sumVotes = map(lambda kv: kv[0] + kv[1], zip(expVotes, add))
        cur = 0
        for v in sumVotes:
            p = (200 * v / N + 1) / 2
            cur += p

        dbg_cnt += 1
        if dbg_cnt % 10000 == 0:
            dbg_print(
                '{0} {1} add = {2}, sum = {3}, p = {4}'.format(dbg_cnt, (time.time() - startTime), add, sumVotes, cur))
            # dbg_print('add = {0}, sum = {1}, p = {2}'.format(add, sumVotes, cur))
        if cur > best:
            best = cur

        if add[-1] == rest:
            break
        for i in xrange(le - 2, -1, -1):
            if add[i] != 0:
                add[i] -= 1
                add[i + 1] += 1
                for j in xrange(i + 2, le):
                    add[i + 1] += add[j]
                    add[j] = 0
                break

        # time.sleep(0.01)

    return best


def calcNeedCnt(v, N, baseCnt):
    half = (N + 1) / 2
    r = (100 * v) % N
    if r == 0:
        return 0
    elif r >= half:
        return 0
    else:
        return half - r
    # left = -N
    # right = 0
    # base = 200 * (v - 1)
    # cnt = -1
    # while cnt <= baseCnt:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N <= base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # return cnt


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    L = int(line.split()[1])
    line = f.readline()
    votes = map(int, line.split())
    votesP = map(lambda v: (100 * v) % N, votes)
    used = sum(votes)
    rest0 = N - used
    rest = N - used
    dbg_print(""N = {0}, votes = {1}"".format(N, votes))
    if 100 % N == 0:
        dbg_print('Simple case N = {0}'.format(N))
        return 100
    if 1 == 2:
        return bruteForce(N, votes)
    dbg_print(votesP)
    cnt = 1 + calcNeedCnt(1, N, N + 1)
    # left = -N
    # right = 0
    # base = 0
    # cnt = 0
    # while True:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N < base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # dbg_print('N = {0}, cnt = {1}, base = {2}, r = {3}'.format(N, cnt, base, float(100 * cnt) / N))
    dbg_print('N = {0}, cnt = {1}, r = {2}'.format(N, cnt, float(100 * cnt) / N))
    needed = map(lambda v: (100 * v % N, calcNeedCnt(v, N, cnt)), votes)
    dbg_print(needed)
    sortedNeeded = list(sorted(needed, key=lambda p: p[1]))
    dbg_print(sortedNeeded)
    lost = 0
    gained = 0
    for v, n in sortedNeeded:
        if n > cnt:
            lost += v
            continue
        if n <= rest:
            if v != 0:
                gained += N - n - v
                rest -= n
        else:
            lost += v
            pass
            # res -= n
    # res += rest / cnt
    # return res
    gained += (N - cnt) * (rest / cnt)
    lost += rest % cnt
    dbg_print('gained = {0}, lost = {1}'.format(gained, lost))
    dif0 = gained - lost
    dif = (abs(dif0) + (N - 1)) / N
    if dif0 < 0:
        dif = -dif

    dbg_print('dif = {0}'.format(dif))
    return 100 + dif


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,5288,196,729,Python,7764,000000000003b6ff,0000000000036601,SergGr,2018
49002,000000000003b7ff.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def bruteForce(N, votes):
    used = sum(votes)
    rest = N - used
    expVotes = votes[:]
    for i in xrange(rest):
        expVotes.append(0)
    le = len(expVotes)
    dbg_print(expVotes)

    add = [0] * le
    add[0] = rest
    best = -1
    dbg_cnt = 0
    while True:
        sumVotes = map(lambda kv: kv[0] + kv[1], zip(expVotes, add))
        cur = 0
        for v in sumVotes:
            p = (200 * v / N + 1) / 2
            cur += p

        dbg_cnt += 1
        if dbg_cnt % 10000 == 0:
            dbg_print('{0} {1} add = {2}, sum = {3}, p = {4}'.format(dbg_cnt, (time.time() - startTime), add, sumVotes, cur))
            # dbg_print('add = {0}, sum = {1}, p = {2}'.format(add, sumVotes, cur))
        if cur > best:
            best = cur

        if add[-1] == rest:
            break
        for i in xrange(le - 2, -1, -1):
            if add[i] != 0:
                add[i] -= 1
                add[i + 1] += 1
                for j in xrange(i + 2, le):
                    add[i + 1] += add[j]
                    add[j] = 0
                break

        # time.sleep(0.01)

    return best


def calcNeedCnt(v, N, baseCnt):
    half = (N + 1) / 2
    r = (100 * v) % N
    if r == 0:
        return 0
    elif r >= half:
        return 0
    else:
        return half - r
    # left = -N
    # right = 0
    # base = 200 * (v - 1)
    # cnt = -1
    # while cnt <= baseCnt:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N <= base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # return cnt


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    L = int(line.split()[1])
    line = f.readline()
    votes = map(int, line.split())
    votesP = map(lambda v: (100 * v) % N, votes)
    used = sum(votes)
    rest0 = N - used
    rest = N - used
    dbg_print(""N = {0}, votes = {1}"".format(N, votes))
    if 100 % N == 0:
        dbg_print('Simple case N = {0}'.format(N))
        return 100
    if 1 == 2:
        return bruteForce(N, votes)
    dbg_print(votesP)
    cnt = 1 + calcNeedCnt(1, N, N + 1)
    # left = -N
    # right = 0
    # base = 0
    # cnt = 0
    # while True:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N < base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # dbg_print('N = {0}, cnt = {1}, base = {2}, r = {3}'.format(N, cnt, base, float(100 * cnt) / N))
    dbg_print('N = {0}, cnt = {1}, r = {2}'.format(N, cnt, float(100 * cnt) / N))
    needed = map(lambda v: (100 * v % N, calcNeedCnt(v, N, cnt)), votes)
    dbg_print(needed)
    sortedNeeded = list(sorted(needed, key=lambda p: p[1]))
    dbg_print(sortedNeeded)
    lost = 0
    gained = 0
    for v, n in sortedNeeded:
        if n > cnt:
            lost += v
            continue
        if n <= rest:
            if v != 0:
                gained += N - n - v
                rest -= n
        else:
            lost += v
            pass
            # res -= n
    # res += rest / cnt
    # return res
    gained += (rest / cnt) * cnt
    lost += rest % cnt
    dbg_print('gained = {0}, lost = {1}'.format(gained, lost))
    dif0 = gained - lost
    dif = (abs(dif0) + (N - 1)) / N
    if dif0 < 0:
        dif = -dif

    dbg_print('dif = {0}'.format(dif))
    return 100 + dif


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,5264,195,726,Python,7764,000000000003b7ff,0000000000036601,SergGr,2018
49003,000000000003b429.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def bruteForce(N, votes):
    used = sum(votes)
    rest = N - used
    expVotes = votes[:]
    for i in xrange(rest):
        expVotes.append(0)
    le = len(expVotes)
    dbg_print(expVotes)

    add = [0] * le
    add[0] = rest
    best = -1
    dbg_cnt = 0
    while True:
        sumVotes = map(lambda kv: kv[0] + kv[1], zip(expVotes, add))
        cur = 0
        for v in sumVotes:
            p = (200 * v / N + 1) / 2
            cur += p

        dbg_cnt += 1
        if dbg_cnt % 10000 == 0:
            dbg_print('{0} {1} add = {2}, sum = {3}, p = {4}'.format(dbg_cnt, (time.time() - startTime), add, sumVotes, cur))
            # dbg_print('add = {0}, sum = {1}, p = {2}'.format(add, sumVotes, cur))
        if cur > best:
            best = cur

        if add[-1] == rest:
            break
        for i in xrange(le - 2, -1, -1):
            if add[i] != 0:
                add[i] -= 1
                add[i + 1] += 1
                for j in xrange(i + 2, le):
                    add[i + 1] += add[j]
                    add[j] = 0
                break

        # time.sleep(0.01)

    return best


def calcNeedCnt(v, N, baseCnt):
    half = (N + 1) / 2
    r = (100 * v) % N
    if r == 0:
        return 0
    elif r >= half:
        return 0
    else:
        return half - r
    # left = -N
    # right = 0
    # base = 200 * (v - 1)
    # cnt = -1
    # while cnt <= baseCnt:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N <= base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # return cnt


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    L = int(line.split()[1])
    line = f.readline()
    votes = map(int, line.split())
    votesP = map(lambda v: (100 * v) % N, votes)
    used = sum(votes)
    rest0 = N - used
    rest = N - used
    dbg_print(""N = {0}, votes = {1}"".format(N, votes))
    if 100 % N == 0:
        dbg_print('Simple case N = {0}'.format(N))
        return 100
    if 1 == 2:
        return bruteForce(N, votes)
    dbg_print(votesP)
    cnt = 1 + calcNeedCnt(1, N, N + 1)
    # left = -N
    # right = 0
    # base = 0
    # cnt = 0
    # while True:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N < base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # dbg_print('N = {0}, cnt = {1}, base = {2}, r = {3}'.format(N, cnt, base, float(100 * cnt) / N))
    dbg_print('N = {0}, cnt = {1}, r = {2}'.format(N, cnt, float(100 * cnt) / N))
    needed = map(lambda v: (100 * v % N, calcNeedCnt(v, N, cnt)), votes)
    dbg_print(needed)
    sortedNeeded = list(sorted(needed, key=lambda p: p[1]))
    dbg_print(sortedNeeded)
    lost = 0
    gained = 0
    for v, n in sortedNeeded:
        if n > cnt:
            lost += v
            continue
        if n <= rest:
            if v != 0:
                gained += N - n - v
                rest -= n
        else:
            lost += v
            pass
            # res -= n
    # res += rest / cnt
    # return res
    gained += rest / cnt
    lost += rest % cnt
    dbg_print('gained = {0}, lost = {1}'.format(gained, lost))
    dif0 = gained - lost
    dif = (abs(dif0) + (N - 1)) / N
    if dif0 < 0:
        dif = -dif

    dbg_print('dif = {0}'.format(dif))
    return 100 + dif


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,5256,195,724,Python,7764,000000000003b429,0000000000036601,SergGr,2018
49004,000000000003a0bb.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def bruteForce(N, votes):
    used = sum(votes)
    rest = N - used
    expVotes = votes[:]
    for i in xrange(rest):
        expVotes.append(0)
    le = len(expVotes)
    dbg_print(expVotes)

    add = [0] * le
    add[0] = rest
    best = -1
    while True:
        sumVotes = map(lambda kv: kv[0] + kv[1], zip(expVotes, add))
        cur = 0
        for v in sumVotes:
            p = (200 * v / N + 1) / 2
            cur += p

        # dbg_print('add = {0}, sum = {1}, p = {2}'.format(add, sumVotes, cur))
        if cur > best:
            best = cur

        if add[-1] == rest:
            break
        for i in xrange(le - 2, -1, -1):
            if add[i] != 0:
                add[i] -= 1
                add[i + 1] += 1
                for j in xrange(i + 2, le):
                    add[i + 1] += add[j]
                    add[j] = 0
                break

        # time.sleep(0.01)

    return best


def calcNeedCnt(v, N, baseCnt):
    half = (N + 1) / 2
    r = (100 * v) % N
    if r == 0:
        return 0
    elif r >= half:
        return 0
    else:
        return half - r
    # left = -N
    # right = 0
    # base = 200 * (v - 1)
    # cnt = -1
    # while cnt <= baseCnt:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N <= base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # return cnt


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    L = int(line.split()[1])
    line = f.readline()
    votes = map(int, line.split())
    votesP = map(lambda v: (100 * v) % N, votes)
    used = sum(votes)
    rest0 = N - used
    rest = N - used
    dbg_print(""N = {0}, votes = {1}"".format(N, votes))
    if 100 % N == 0:
        dbg_print('Simple case N = {0}'.format(N))
        return 100
    if 1 == 1:
        return bruteForce(N, votes)
    dbg_print(votesP)
    cnt = 1 + calcNeedCnt(1, N, N + 1)
    # left = -N
    # right = 0
    # base = 0
    # cnt = 0
    # while True:
    #     base += 200
    #     cnt += 1
    #     while left + 2 * N < base:
    #         left += 2 * N
    #     while right <= base:
    #         right += 2 * N
    #     if right - left <= N:
    #         break
    # dbg_print('N = {0}, cnt = {1}, base = {2}, r = {3}'.format(N, cnt, base, float(100 * cnt) / N))
    dbg_print('N = {0}, cnt = {1}, r = {2}'.format(N, cnt, float(100 * cnt) / N))
    needed = map(lambda v: (100 * v % N, calcNeedCnt(v, N, cnt)), votes)
    dbg_print(needed)
    sortedNeeded = list(sorted(needed, key=lambda p: p[1]))
    dbg_print(sortedNeeded)
    lost = 0
    gained = 0
    for v, n in sortedNeeded:
        if n > cnt:
            lost += v
            continue
        if n <= rest:
            if v != 0:
                gained += N - n - v
                rest -= n
        else:
            lost += v
            pass
            # res -= n
    # res += rest / cnt
    # return res
    gained += rest / cnt
    lost += rest % cnt
    dbg_print('gained = {0}, lost = {1}'.format(gained, lost))
    return 100 + (gained - lost) / N


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print(
            '--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4925,185,675,Python,7764,000000000003a0bb,0000000000036601,SergGr,2018
49005,0000000000039359.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    signs = []
    mn = []
    for i in xrange(N):
        line = f.readline()
        d = int(line.split()[0])
        a = int(line.split()[1])
        b = int(line.split()[2])
        signs.append((d, a, b))
        mn.append((d + a, d - b))

    dbg_print(signs)
    dbg_print(mn)
    if N == 1:
        return ""1 1""

    longest = -2
    cnt = 0
    FAKE = 10 ** 10
    # lastMNP_M = (FAKE, FAKE, FAKE)
    # lastMNP_N = (FAKE, FAKE, FAKE)
    lastBadM = -1
    lastBadN = -1

    for i in xrange(N):
        if i + longest > N + 1:
            break
        lem = -1
        le = -1
        # fix m
        if i >= lastBadM:
            m = mn[i][0]
            n = None
            le = 1
            for j in xrange(i + 1, N):
                if mn[j][0] == m:
                    le += 1
                else:
                    if n is None:
                        n = mn[j][1]
                        lastBadM = j
                        le += 1
                    elif n == mn[j][1]:
                        le += 1
                    else:
                        # lastMNP_M = (m, n, j)
                        break

            if le > longest:
                longest = le
                cnt = 1
            elif le == longest:
                cnt += 1
            lem = le

        # fix n
        if i >= lastBadN:
            m = None
            n = mn[i][1]
            le = 1
            for j in xrange(i + 1, N):
                if mn[j][1] == n:
                    le += 1
                else:
                    if m is None:
                        m = mn[j][0]
                        lastBadN = j
                        le += 1
                    elif m == mn[j][0]:
                        le += 1
                    else:
                        # lastMNP_N = (m, n, j)
                        break
            if le > longest:
                longest = le
                cnt = 1
            elif le == longest and le != lem:
                cnt += 1

    return ""{0} {1}"".format(longest, cnt)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3996,148,436,Python,7764,0000000000039359,000000000003675b,SergGr,2018
49006,0000000000038694.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    signs = []
    mn = []
    for i in xrange(N):
        line = f.readline()
        d = int(line.split()[0])
        a = int(line.split()[1])
        b = int(line.split()[2])
        signs.append((d, a, b))
        mn.append((d + a, d - b))

    dbg_print(signs)
    dbg_print(mn)
    if N == 1:
        return ""1 1""

    longest = -1
    cnt = 0
    for i in xrange(N):
        # fix m
        m = mn[i][0]
        n = None
        le = 1
        for j in xrange(i + 1, N):
            if mn[j][0] == m:
                le += 1
            else:
                if n is None:
                    n = mn[j][1]
                    le += 1
                elif n == mn[j][1]:
                    le += 1
                else:
                    break
        if le > longest:
            longest = le
            cnt = 1
        elif le == longest:
            cnt += 1

        lem = le
        # fix n
        m = None
        n = mn[i][1]
        le = 1
        for j in xrange(i + 1, N):
            if mn[j][1] == n:
                le += 1
            else:
                if m is None:
                    m = mn[j][0]
                    le += 1
                elif m == mn[j][0]:
                    le += 1
                else:
                    break
        if le > longest:
            longest = le
            cnt = 1
        elif le == longest and le != lem:
            cnt += 1

    return ""{0} {1}"".format(longest, cnt)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3386,131,372,Python,7764,0000000000038694,000000000003675b,SergGr,2018
78651,0000000000035516.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def simple(N, P, base, mi, ma):
    si = base
    sa = base
    best = base
    # for i in xrange(N):
    #     if (si + mi) > P:
    #         return sa
    #     si += mi
    #     sa += ma
    #     if sa >= P:
    #         return P
    for i in xrange(N):
        si += mi
        sa += ma
        if sa < P:
            best = sa
        if si <= P and P <= sa:
            best = P
    return best
    # return -2


def solveReal(N, P, base, mia, maa):
    ranges = [[base, base]]
    for i in xrange(N):
        mi = mia[i]
        ma = maa[i]
        newranges = map(lambda r: [r[0] + mi, r[1] + ma], ranges)
        merged = []
        j = 0
        k = 0
        le = len(ranges)
        cur = ranges[0] if ranges[0][0] < newranges[0][0] else newranges[0]
        while j < le and k < le:
            nextR = []
            if ranges[j][0] < newranges[k][0]:
                nextR = ranges[j]
                j += 1
            else:
                nextR = newranges[k]
                k += 1
            if nextR[0] <= cur[1]:
                cur[1] = max(cur[1], nextR[1])
            else:
                merged.append(cur)
                cur = nextR

        while j < le:
            nextR = ranges[j]
            j += 1
            if nextR[0] < cur[1]:
                cur[1] = max(cur[1], nextR[1])
            else:
                merged.append(cur)
                cur = nextR
        while k < le:
            nextR = newranges[k]
            k += 1
            if nextR[0] < cur[1]:
                cur[1] = max(cur[1], nextR[1])
            else:
                merged.append(cur)
                cur = nextR
        merged.append(cur)
        ranges = merged
    dbg_print('ranges = {0}'.format(ranges))
    best = 0
    for r in ranges:
        if r[0] <= P and P <= r[1]:
            # best = P
            dbg_print(""Exact match: {0} in {1]"".format(P, r))
            return P
        if r[1] < P:
            best = P
    return best


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    P = int(line.split()[1])
    cookies = []

    mia = []
    maa = []
    mis = 0
    mas = 0
    base = 0
    for i in xrange(N):
        line = f.readline()
        w = int(line.split()[0])
        h = int(line.split()[1])
        base += 2 * (w + h)
        mi = 2 * min(w, h)
        ma = 2 * (w * w + h * w) ** 0.5
        mia.append(mi)
        mis += mi
        maa.append(ma)
        mas += ma

    dbg_print('P = {0}, base = {1}, mis = {2}, mas = {3}'.format(P, base, 2 * mis, 2 * mas))
    dbg_print(mia)
    dbg_print(maa)

    if P == base:
        return P
    # elif P > base + mas:
    #     return base + mas

    if 1 == 2:
        return simple(N, P, base, mia[0], maa[0])
    else:
        return solveReal(N, P, base, mia, maa)

    # return -1


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4742,182,574,Python,0000000000007883,0000000000035516,000000000003005a,SergGr,2018
78652,0000000000034e46.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def simple(N, P, base, mi, ma):
    si = base
    sa = base
    best = base
    # for i in xrange(N):
    #     if (si + mi) > P:
    #         return sa
    #     si += mi
    #     sa += ma
    #     if sa >= P:
    #         return P
    for i in xrange(N):
        si += mi
        sa += ma
        if sa < P:
            best = sa
        if si <= P and P <= sa:
            best = P
    return best
    # return -2


def solveReal(N, P, base, mia, maa):
    ranges = [[base, base]]
    for i in xrange(N):
        mi = mia[i]
        ma = maa[i]
        newranges = map(lambda r: [r[0] + mi, r[1] + ma], ranges)
        merged = []
        j = 0
        k = 0
        le = len(ranges)
        cur = ranges[0] if ranges[0][0] < newranges[0][0] else newranges[0]
        while j < le and k < le:
            nextR = []
            if ranges[j][0] < newranges[k][0]:
                nextR = ranges[j]
                j += 1
            else:
                nextR = newranges[k]
                k += 1
            if nextR[0] < cur[1]:
                cur[1] = max(cur[1], nextR[1])
            else:
                merged.append(cur)
                cur = nextR

        while j < le:
            nextR = ranges[j]
            j += 1
            if nextR[0] < cur[1]:
                cur[1] = max(cur[1], nextR[1])
            else:
                merged.append(cur)
                cur = nextR
        while k < le:
            nextR = newranges[k]
            k += 1
            if nextR[0] < cur[1]:
                cur[1] = max(cur[1], nextR[1])
            else:
                merged.append(cur)
                cur = nextR
        ranges = merged
    dbg_print(ranges)
    return -3


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    P = int(line.split()[1])
    cookies = []

    mia = []
    maa = []
    mis = 0
    mas = 0
    base = 0
    for i in xrange(N):
        line = f.readline()
        w = int(line.split()[0])
        h = int(line.split()[1])
        base += 2 * (w + h)
        mi = 2 * min(w, h)
        ma = 2 * (w * w + h * w) ** 0.5
        mia.append(mi)
        mis += mi
        maa.append(ma)
        mas += ma

    dbg_print('P = {0}, base = {1}, mis = {2}, mas = {3}'.format(P, base, 2 * mis, 2 * mas))
    dbg_print(mia)
    dbg_print(maa)

    if P == base:
        return P
    # elif P > base + mas:
    #     return base + mas

    if 1 == 1:
        return simple(N, P, base, mia[0], maa[0])
    else:
        return solveReal(N, P, base, mia, maa)

    # return -1


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4462,173,537,Python,0000000000007883,0000000000034e46,000000000002fff7,SergGr,2018
78653,00000000000344a8.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def simple(N, P, base, mi, ma):
    si = base
    sa = base
    best = base
    # for i in xrange(N):
    #     if (si + mi) > P:
    #         return sa
    #     si += mi
    #     sa += ma
    #     if sa >= P:
    #         return P
    for i in xrange(N):
        si += mi
        sa += ma
        if sa < P:
            best = sa
        if si <= P and P <= sa:
            best = P
    return best
    # return -2


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    P = int(line.split()[1])
    cookies = []

    mia = []
    maa = []
    mis = 0
    mas = 0
    base = 0
    for i in xrange(N):
        line = f.readline()
        w = int(line.split()[0])
        h = int(line.split()[1])
        base += 2 * (w + h)
        mi = 2 * min(w, h)
        ma = 2 * (w * w + h * w) ** 0.5
        mia.append(mi)
        mis += mi
        maa.append(ma)
        mas += ma

    dbg_print('P = {0}, base = {1}, mis = {2}, mas = {3}'.format(P, base, 2 * mis, 2 * mas))
    dbg_print(mia)
    dbg_print(maa)

    if P == base:
        return P
    # elif P > base + mas:
    #     return base + mas

    if 1 == 1:
        return simple(N, P, base, mia[0], maa[0])

    return -1


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3081,125,385,Python,0000000000007883,00000000000344a8,000000000002fff7,SergGr,2018
78655,0000000000033edf.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def simple(N, P, base, mi, ma):
    si = base
    sa = base
    best = base
    # for i in xrange(N):
    #     if (si + mi) > P:
    #         return sa
    #     si += mi
    #     sa += ma
    #     if sa >= P:
    #         return P
    for i in xrange(N):
        si += mi
        sa += ma
        if sa < P:
            best = sa
        if si <= P and P <= sa:
            best = P
    return best
    # return -2


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    P = int(line.split()[1])
    cookies = []

    mia = []
    maa = []
    mis = 0
    mas = 0
    base = 0
    for i in xrange(N):
        line = f.readline()
        w = int(line.split()[0])
        h = int(line.split()[1])
        base += 2 * (w + h)
        mi = 2 * min(w, h)
        ma = 2 * (w * w + h * w) ** 0.5
        mia.append(mi)
        mis += mi
        maa.append(ma)
        mas += ma

    dbg_print('P = {0}, base = {1}, mis = {2}, mas = {3}'.format(P, base, 2 * mis, 2 * mas))
    dbg_print(mia)
    dbg_print(maa)

    if P == base:
        return P
    elif P > base + mas:
        return base + mas

    if 1 == 1:
        return simple(N, P, base, mia[0], maa[0])

    return -1


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3077,125,383,Python,0000000000007883,0000000000033edf,000000000002fff7,SergGr,2018
78656,0000000000033713.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def simple(N, P, base, mi, ma):
    si = base
    sa = base
    for i in xrange(N):
        if (si + mi) > P:
            return sa
        si += mi
        sa += ma
        if sa >= P:
            return P
    return 0


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    P = int(line.split()[1])
    cookies = []

    mia = []
    maa = []
    mis = 0
    mas = 0
    base = 0
    for i in xrange(N):
        line = f.readline()
        w = int(line.split()[0])
        h = int(line.split()[1])
        base += 2 * (w + h)
        mi = 2 * min(w, h)
        ma = 2 * (w * w + h * w) ** 0.5
        mia.append(mi)
        mis += mi
        maa.append(ma)
        mas += ma

    dbg_print('P = {0}, base = {1}, mis = {2}, mas = {3}'.format(P, base, 2 * mis, 2 * mas))
    dbg_print(mia)
    dbg_print(maa)

    if P == base:
        return P
    elif P > base + mas:
        return base + mas

    if 1 == 1:
        return simple(N, P, base, mia[0], maa[0])

    return -1


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2867,116,342,Python,0000000000007883,0000000000033713,000000000002fff7,SergGr,2018
78658,0000000000033193.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def partitions(n, I=1):
    yield (n,)
    for i in range(I, n // 2 + 1):
        for p in partitions(n - i, i):
            yield (i,) + p


def bruteForce(R, B, C, cahiers):
    best = 10 ** 30

    cc = min(R, C)
    for bss in partitions(B):
        bs = list(bss)
        dbg_print(bs)
        le = len(bs)
        if le > cc:
            continue
        # for cs in itertools.combinations(cahiers, le):
        for cs in itertools.permutations(cahiers, le):
            curWorst = 0
            good = True
            for i in xrange(le):
                if (bs[i] > cs[i][0]):
                    good = False
                    break
                cur = bs[i] * cs[i][1] + cs[i][2]
                if curWorst < cur:
                    curWorst = cur
            if good and curWorst < best:
                dbg_print(""best: sum = {2} bs = {0}, cs = {1}"".format(bs, cs, curWorst))
                best = curWorst

    # for r in xrange(1, min(R, C) + 1):
    #     s = [0] * r
    #     s[0] = B
    #     while True:
    #         cur = 0

    return best


def calcSingleTest(f):
    line = f.readline()
    R = int(line.split()[0])
    B = int(line.split()[1])
    C = int(line.split()[2])
    cashiers = []
    for i in xrange(C):
        line = f.readline()
        m = int(line.split()[0])
        s = int(line.split()[1])
        p = int(line.split()[2])
        cashiers.append((m, s, p))

    dbg_print('B = {0}, R = {1}, C = {2}'.format(B, R, C))
    dbg_print('cs = {0}'.format(cashiers))

    return bruteForce(R, B, C, cashiers)
    # return 'OK'


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3433,125,382,Python,0000000000007883,0000000000033193,000000000002fff6,SergGr,2018
78659,000000000003197e.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    R = int(line.split()[0])
    C = int(line.split()[1])
    HC = int(line.split()[2])
    VC = int(line.split()[3])
    cake = []

    pieces = (HC + 1) * (VC + 1)
    totalCount = 0
    for i in xrange(R):
        line = f.readline()
        row = []
        for j in xrange(C):
            row.append(1 if line[j] == '@' else 0)
        totalCount += sum(row)
        dbg_print(row)
        cake.append(row)
    dbg_print('---------')

    dbg_print(totalCount)
    # dbg_print(cake)
    if totalCount == 0:
        return 'POSSIBLE'

    if totalCount % pieces != 0:
        return 'IMPOSSIBLE'

    hcount = totalCount / (HC + 1)
    vcount = totalCount / (VC + 1)
    pcount = totalCount / (VC + 1) / (HC + 1)
    hcuts = []
    vcuts = []
    hcnt = 0
    vcnt = 0
    dbg_print('pieces = {0} totalCount = {1} hcount = {2}, vcount = {3}'.format(pieces, totalCount, hcount, vcount))
    for i in xrange(R):
        for j in xrange(C):
            if cake[i][j] == 1:
                hcnt += 1
                if hcnt == hcount:
                    hcuts.append(i)
                    hcnt = 0

    for j in xrange(C):
        for i in xrange(R):
            if cake[i][j] == 1:
                vcnt += 1
                if vcnt == vcount:
                    vcuts.append(j)
                    vcnt = 0

    dbg_print(hcuts)
    dbg_print(vcuts)
    uhcuts = list(sorted(set(hcuts)))
    uvcuts = list(sorted(set(vcuts)))
    # dbg_print(uhcuts)
    # dbg_print(HC)
    # dbg_print(uvcuts)
    # dbg_print(VC)
    if (len(uhcuts) != HC + 1) or (len(uvcuts) != VC + 1):
        return 'IMPOSSIBLE'

    uhcuts.append(-1)
    uhcuts = list(sorted(uhcuts))
    uvcuts.append(-1)
    uvcuts = list(sorted(uvcuts))

    for ii in xrange(HC + 1):
        for jj in xrange(VC + 1):
            cnt = 0
            for i in xrange(uhcuts[ii] + 1, uhcuts[ii + 1] + 1):
                for j in xrange(uvcuts[jj] + 1, uvcuts[jj + 1] + 1):
                    if cake[i][j] == 1:
                        cnt += 1
            if cnt != pcount:
                dbg_print('cnt {4}, {5} bad range {0}-{1}/{2}-{3}'.format(uhcuts[ii], uhcuts[ii + 1], uvcuts[jj],
                                                                          uvcuts[jj + 1], cnt, pcount))
                return 'IMPOSSIBLE'
    # return 'IMPOSSIBLE'
    return 'POSSIBLE'


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3973,143,443,Python,0000000000007883,000000000003197e,000000000003005a,SergGr,2018
78660,00000000000317ab.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    P = int(line.split()[1])
    cookies = []
    mis = 0
    mas = 0
    for i in xrange(N):
        line = f.readline()
        w = int(line.split()[0])
        h = int(line.split()[1])
        # mi = min(w, h)
        # ma = max(w, h)
        maa = (w * w + h * w) ** 0.5
        mis += w + h
        mas += maa + w + h
    dbg_print('P = {0}, mis = {1}, mas = {2}'.format(P, 2 * mis, 2 * mas))
    return P if P < 2 * mas else 2 * mas

    # return -1


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2281,87,275,Python,0000000000007883,00000000000317ab,000000000002fff7,SergGr,2018
96326,0000000000015e36.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
import collections
from collections import OrderedDict
from collections import defaultdict
import bisect
import heapq
import math

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""D-small-attempt0.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def formatPoint(p):
    return ""{0} {1} {2}"".format(p[0], p[1], p[2])


def solveSimple(A):
    ps = [(0.5, 0, 0), (0, 0.5, 0), (0, 0, 0.5)]
    sinAlpha2 = (A * A - 1)
    alpha2 = math.asin(sinAlpha2)
    alpha = alpha2 / 2.0
    ps = [
        (0.5 * math.cos(alpha), 0.5 * math.sin(alpha), 0),
        (-0.5 * math.sin(alpha), 0.5 * math.cos(alpha), 0),
        (0, 0, 0.5)
    ]
    return ps


def calcSingleTest(f):
    line = f.readline()
    A = float(line)
    ps = solveSimple(A)
    sps = map(formatPoint, ps)
    return ""\n{0}\n{1}\n{2}"".format(sps[0], sps[1], sps[2])


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2351,91,251,Python,00000000000000cb,0000000000015e36,00000000000079cc,SergGr,2018
96327,0000000000013ed0.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def runSingleTest(inpF, outF):
    line = inpF.readline()
    A = int(line)
    S = 1000  # 2 to 999
    area = []
    for step in xrange(S + 1):
        area.append([0] * (S + 1))

    maxX = 3
    maxY = 3
    xt = 2
    yt = 2
    totalArea = -10  # to be sure that when we stop - everything is OK
    for step in xrange(1001):  # 1000 tries
        print(""{0} {1}"".format(xt, yt), file=outF)
        line = inpF.readline()
        xa = int(line.split()[0])
        ya = int(line.split()[1])
        if xa < 0 and ya < 0:
            dbg_print('failed case after {0}'.format(step))
            raise RuntimeError('failed case after {0}'.format(step))
        elif xa == 0 and ya == 0:
            dbg_print('finish case after {0}'.format(step))
            break

        if area[ya][xa] == 0:
            area[ya][xa] = 1
            totalArea += 1

            if xa == xt - 1 and totalArea < A:
                while area[yt - 1][xt - 1] + area[yt][xt - 1] + area[yt + 1][xt - 1] == 3:
                    dbg_print('Moving xt up {0} => {1}'.format(xt, xt + 1))
                    xt += 1

            if xa > maxX: maxX = xa
            if ya > maxY: maxY = ya
            dbg_print(""After step {0} area = {1}/{2}"".format(step, totalArea, totalArea + 10))
            for y in xrange(maxY + 1):
                dbg_print(area[y + 1][1:maxX + 1])
        else:
            dbg_print(""No changes after {0} area = {1}/{2}"".format(step, totalArea, totalArea + 10))


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4089,135,436,Python,00000000000000cb,0000000000013ed0,0000000000007a30,SergGr,2018
96330,000000000001354e.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def runSingleTest(inpF, outF):
    line = inpF.readline()
    A = int(line)
    S = 1000  # 2 to 999
    area = []
    for step in xrange(S + 1):
        area.append([0] * (S + 1))

    maxX = 3
    maxY = 3
    xt = 2
    yt = 2
    totalArea = -10 # to be sure that when we stop - everything is OK
    for step in xrange(1000):  # 1000 tries
        print(""{0} {1}"".format(xt, yt), file=outF)
        line = inpF.readline()
        xa = int(line.split()[0])
        ya = int(line.split()[1])
        if xa <= 0 and ya <= 0:
            dbg_print('finish case after %d'.format(step))
            break

        if area[ya][xa] == 0:
            area[ya][xa] = 1
            totalArea += 1

            if xa == xt - 1 and totalArea < A:
                prevCol = area[yt-1][xa] + area[yt][xa] + area[yt+1][xa]
                if prevCol == 3:
                    xt += 1

            if xa > maxX: maxX = xa
            if ya > maxY: maxY = ya
            dbg_print(""After step {0}"".format(step))
            for y in xrange(maxY + 1):
                dbg_print(area[y + 1][1:maxX + 1])
        else:
            dbg_print(""No changes"")


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3755,132,387,Python,00000000000000cb,000000000001354e,0000000000007a30,SergGr,2018
96337,0000000000008060.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    arr = map(int, line.split())
    even = arr[0::2]
    odd = arr[1::2]
    dbg_print(arr)
    dbg_print(even)
    dbg_print(odd)
    even = sorted(even)
    odd = sorted(odd)
    dbg_print(even)
    dbg_print(odd)
    cur = even[0]
    prev = -1
    for i in xrange(1, len(arr)):
        prev = cur
        if i % 2 == 0:
            cur = even[i / 2]
        else:
            cur = odd[i / 2]
        if prev > cur:
            return i - 1

    return 'OK'


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2287,92,250,Python,00000000000000cb,0000000000008060,00000000000079cb,SergGr,2018
96338,0000000000007eb1.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    D = int(line.split()[0])
    cmds = line.split()[1]
    cs = [0, 0]
    pows = [0, 1]

    i = 1
    total = 0
    p = 1
    for ch in cmds:
        if ch == 'S':
            cs[i] += 1
            total += p
        elif ch == 'C':
            i += 1
            cs.append(0)
            pows.append(p)
            p *= 2 # after append!

    dbg_print(cs)
    dbg_print(total)

    if total < D:
        return 0
    elif sum(cs) > D:
        return 'IMPOSSIBLE'

    res = 0
    while total > D:
        while cs[i] == 0:
            i -= 1
        res += 1
        total -= pows[i]
        cs[i] -= 1
        cs[i-1] += 1


    # return 'IMPOSSIBLE'
    return res

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2403,101,263,Python,00000000000000cb,0000000000007eb1,0000000000007966,SergGr,2018
256735,0000000000006b22.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
import collections
from collections import OrderedDict
from collections import defaultdict
import bisect
import heapq

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    K = int(line.split()[1])
    # ranges = [(N, 1)]
    rangesSize = [-N]
    ranges = defaultdict(lambda: 0)
    ranges[N] = 1
    size = -1
    mi = -1
    ma = -1
    totalCnt = 0
    while totalCnt < K:
        size = -heapq.heappop(rangesSize)
        cnt = ranges[size]
        totalCnt += cnt
        # mi = size / 2
        # ma = (size + 1) / 2
        mi = (size - 1) / 2
        ma = (size) / 2
        if not mi in ranges:
            heapq.heappush(rangesSize, -mi)
        if not ma in ranges:
            heapq.heappush(rangesSize, -ma)
        del ranges[size]
        ranges[mi] += cnt
        ranges[ma] += cnt
        # dbg_print(""{1} - {0}/{3} - {2}"".format(totalCnt, ranges, rangesSize, K))

    # mi = size / 2
    # ma = (size + 1) / 2

    return ""{0} {1}"".format(ma, mi)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2786,103,313,Python,0000000000000130,0000000000006b22,0000000000000652,SergGr,2018
256736,00000000000065d4.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    D = int(line.split()[0])
    N = int(line.split()[1])
    hs = []
    tm = 0
    for i in xrange(N):
        line = f.readline()

        pos = int(line.split()[0])
        speed = int(line.split()[1])
        hs.append((pos, speed))
        t = float(D - pos) / speed
        if (t > tm):
            tm = t
    dbg_print(hs)
    dbg_print(tm)

    return float(D) / tm


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2250,86,231,Python,0000000000000130,00000000000065d4,0000000000000524,SergGr,2018
256737,00000000000063bb.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])
# MY_DEBUG = False

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    dbg_print(spc)

    # return res
    return res[:-1]



def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)


dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2513,100,285,Python,0000000000000130,00000000000063bb,00000000000004c0,SergGr,2018
256738,00000000000064e3.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])
MY_DEBUG = False

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    dbg_print(spc)


    return res



def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)


dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2492,100,282,Python,0000000000000130,00000000000064e3,00000000000004c0,SergGr,2018
256739,000000000000645d.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])
# MY_DEBUG = False

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    dbg_print(spc)


    return res



def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)


dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2492,100,282,Python,0000000000000130,000000000000645d,00000000000004c0,SergGr,2018
256740,0000000000006294.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
print startTime


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    return res



def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)


dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2447,96,278,Python,0000000000000130,0000000000006294,00000000000004c0,SergGr,2018
256741,0000000000006456.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
print startTime


def calcSingleTest(f):
    if 1 == 1:
        return ' '
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    return res


with open(inputFileName) as inpF:
    with open(outputFileName, 'w') as outF:
        line = inpF.readline()
        testsCount = int(line)
        for i in xrange(1, testsCount + 1):
            dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
            res = calcSingleTest(inpF)
            dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
            dbg_print(' ')
            outF.write('Case #{0}: {1}\n'.format(i, res))
            outF.flush()

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2302,88,265,Python,0000000000000130,0000000000006456,00000000000004c0,SergGr,2018
256742,0000000000006372.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
print startTime


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    return res


with open(inputFileName) as inpF:
    with open(outputFileName, 'w') as outF:
        line = inpF.readline()
        testsCount = int(line)
        for i in xrange(1, testsCount + 1):
            dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
            res = calcSingleTest(inpF)
            dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
            dbg_print(' ')
            outF.write('Case #{0}: {1}\n'.format(i, res))
            outF.flush()

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2268,86,258,Python,0000000000000130,0000000000006372,00000000000004c0,SergGr,2018
256743,000000000000632f.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None
inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}\n'.format(s))


startTime = time.time()
print startTime


def calcSingleTest(f):
    line = f.readline()
    N = int(line)
    line = f.readline()
    sc = map(int, line.split())

    res = """"

    spc = sorted(zip(sc, map(lambda i: chr(ord('A') + i), range(N))), key=lambda kv: -kv[0])
    spc = list(map(lambda kv: [kv[0], kv[1]], spc))
    dbg_print(spc)
    while spc[0][0] > spc[1][0]:
        res += spc[0][1] + ' '
        spc[0][0] -= 1

    for i in xrange(2, N):
        while spc[i][0] >= 2:
            res += spc[i][1] + spc[i][1] + ' '
            spc[i][0] -= 1
        if spc[i][0] > 0:
            res += spc[i][1] + ' '
            spc[i][0] -= 1

    while spc[0][0] > 0:
        res += spc[0][1] + spc[1][1] + ' '
        spc[0][0] -= 1
        spc[1][0] -= 1

    return res


with open(inputFileName) as inpF:
    with open(outputFileName, 'w') as outF:
        line = inpF.readline()
        testsCount = int(line)
        for i in xrange(1, testsCount + 1):
            dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
            res = calcSingleTest(inpF)
            dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
            dbg_print(' ')
            outF.write('Case #{0}: {1}\n'.format(i, res))
            outF.flush()

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2333,84,256,Python,0000000000000130,000000000000632f,00000000000004c0,SergGr,2018
256744,0000000000005299.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo'])

logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


startTime = time.time()
dbg_print(startTime)


def runSingleTest(inpF, outF):
    line = inpF.readline()
    a_exc = int(line.split()[0])
    b_inc = int(line.split()[1])
    line = inpF.readline()
    n = int(line)
    for i in xrange(n):
        guess = (a_exc + b_inc + 1) / 2
        print(guess, file=outF)
        # outF.flush()
        line = inpF.readline_safe()
        if 'CORRECT' == line:
            return
        elif 'TOO_SMALL' == line:
            a_exc = guess + 1
        elif 'TOO_BIG' == line:
            b_inc = guess - 1
        else:
            dbg_print(""Unexpected line '{0}'"".format(line))
            raise RuntimeError(""Unexpected line '{0}'"".format(line))
    raise RuntimeError(""AAAAA"")


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3016,112,293,Python,0000000000000130,0000000000005299,0000000000000523,SergGr,2018
16068,000000000014ccbe.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18
a14 = 2 ** 14
a11 = 2 ** 11
a9 = 2 ** 9

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


# def runSingleTest(inpF, outF):
def runSingleTest(inpF, outF):
    # line = inpF.readline()

    for i in xrange(19):
        print(""{0} {1}"".format(i + 1, 100), file=outF)

    for i in xrange(20, 100):
        print(""{0} {1}"".format(i % 19 + 1, 1), file=outF)

    # 100
    print(""{0} {1}"".format(20, 100), file=outF)
    dbg_print(""AAA {0}"".format((time.time() - startTime)))
    # resp = inpF.readline().strip()

    # guess = ""ABCDE""

    # guess_str = """".join(map(str, guess))
    #
    # dbg_print(""Guess = "" + guess_str)
    # print(guess_str, file=outF)
    # success = inpF.readline().strip()
    # dbg_print(""Success: "" + success)
    # return success == '1' or success == 'Y'
    return True

class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF
        self.line_cnt = 0

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        if ""\n"" in str:
            self.line_cnt += 1
            dbg_print(""Writing '{0}' #{1}"".format(str.replace(""\n"", ""\\n""), self.line_cnt))
        else:
            dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))

        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        outF.line_cnt = 0
        success = runSingleTest(inpF, outF)
        # success = runSingleTest(inpF, outF, F)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3942,148,441,Python,0000000000051679,000000000014ccbe,00000000001461c8,SergGr,2019
16069,000000000014a063.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd
from fractions import Fraction

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def cmp_fr(a, b):
    if a > b:
        return 1
    elif a == b:
        return 0
    else:
        return -1
    # if a[0] * b[1] == a[1] * b[0]:
    #     return 0
    # elif a[0] * b[1] > a[1] * b[0]:
    #     return 1
    # else:
    #     return -1


def flip_fr(a):
    return Fraction(numerator=a.denominator, denominator=a.numerator)
    # return (a[1], a[0])


def find_farey(tgt_low, tgt_hi):
    le = Fraction(numerator=0, denominator=1)
    ri = Fraction(numerator=1, denominator=1)
    if cmp_fr(ri, tgt_low) > 0 and cmp_fr(ri, tgt_hi) < 0:
        return ri

    while True:
        m = Fraction(numerator=le.numerator + ri.numerator, denominator=le.denominator + ri.denominator)
        if cmp_fr(m, tgt_low) > 0 and cmp_fr(m, tgt_hi) < 0:
            return m
        if cmp_fr(m, tgt_hi) >= 0:
            ri = m
        else:
            le = m


def calcSingleTest(f):
    line = f.readline()
    N, = [int(x) for x in line.split()]

    pairs = []
    for i in xrange(N):
        line = f.readline()
        C, J = [int(x) for x in line.split()]
        pairs.append((C, J))

    # c/j
    # low < (c,j) < hi
    cj = Fraction(numerator=1, denominator=2 * 10 ** 9)
    jc = Fraction(numerator=2 * 10 ** 9, denominator=1)

    for i in xrange(N):
        c1, j1 = pairs[i]
        for jj in xrange(i + 1, N):
            c2, j2 = pairs[jj]
            if c2 <= c1 and j2 <= j1:
                dbg_print(""impossible i = {0}, j = {1}, c1 = {2}, j1 = {3}, c2 = {4}, j2 = {5}"".format(i, jj, c1, j1, c2, j2))
                return ""IMPOSSIBLE""
            if c2 >= c1 and j2 >= j1:
                continue
            dc = c2 - c1
            dj = j2 - j1
            if dc > 0:
                # dc * C > -dj * J
                # C/J > -dj / dc
                cur = Fraction(numerator=-dj, denominator=dc)
                if cmp_fr(cur, cj) > 0:
                    cj = cur
            else:
                # -dc * C < dj * J
                # C/J < dj/(-dc)
                cur = Fraction(numerator=dj, denominator=-dc)
                if cmp_fr(cur, jc) < 0:
                    jc = cur

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))

    if cmp_fr(cj, jc) >= 0:
        return ""IMPOSSIBLE""

    if cj.numerator < cj.denominator:
        ans = find_farey(cj, jc)
    else:
        ans_f = find_farey(flip_fr(jc), flip_fr(cj))
        ans = flip_fr(ans_f)
    dbg_print(""ans = {0}"".format(ans))
    # return ""{0} {1}"".format(ans[0], ans[1])
    return ""{0} {1}"".format(ans.numerator, ans.denominator)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4338,157,525,Python,0000000000051679,000000000014a063,0000000000146184,SergGr,2019
16070,0000000000149c22.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd
from fractions import Fraction

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def cmp_fr(a, b):
    if a > b:
        return 1
    elif a == b:
        return 0
    else:
        return -1
    # if a[0] * b[1] == a[1] * b[0]:
    #     return 0
    # elif a[0] * b[1] > a[1] * b[0]:
    #     return 1
    # else:
    #     return -1


def flip_fr(a):
    return Fraction(numerator=a.denominator, denominator=a.numerator)
    # return (a[1], a[0])


def find_farey(tgt_low, tgt_hi):
    le = (0, 1)
    ri = (1, 1)
    if cmp_fr(ri, tgt_low) > 0 and cmp_fr(ri, tgt_hi) < 0:
        return ri

    while True:
        m = Fraction(numerator=le[0] + ri[0], denominator=le[1] + ri[1])
        if cmp_fr(m, tgt_low) > 0 and cmp_fr(m, tgt_hi) < 0:
            return m
        if cmp_fr(m, tgt_hi) >= 0:
            ri = m
        else:
            le = m


def calcSingleTest(f):
    line = f.readline()
    N, = [int(x) for x in line.split()]

    pairs = []
    for i in xrange(N):
        line = f.readline()
        C, J = [int(x) for x in line.split()]
        pairs.append((C, J))

    # c/j
    # low < (c,j) < hi
    cj = Fraction(numerator=1, denominator=2 * 10 ** 9)
    jc = Fraction(numerator=2 * 10 ** 9, denominator=1)

    for i in xrange(N):
        c1, j1 = pairs[i]
        for jj in xrange(i + 1, N):
            c2, j2 = pairs[jj]
            if c2 <= c1 and j2 <= j1:
                dbg_print(""impossible i = {0}, j = {1}, c1 = {2}, j1 = {3}, c2 = {4}, j2 = {5}"".format(i, jj, c1, j1, c2, j2))
                return ""IMPOSSIBLE""
            if c2 >= c1 and j2 >= j1:
                continue
            dc = c2 - c1
            dj = j2 - j1
            if dc > 0:
                # dc * C > -dj * J
                # C/J > -dj / dc
                cur = Fraction(numerator=-dj, denominator=dc)
                if cmp_fr(cur, cj) > 0:
                    cj = cur
            else:
                # -dc * C < dj * J
                # C/J < dj/(-dc)
                cur = Fraction(numerator=dj, denominator=-dc)
                if cmp_fr(cur, jc) < 0:
                    jc = cur

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))

    if cmp_fr(cj, jc) >= 0:
        return ""IMPOSSIBLE""

    if cj.numerator < cj.denominator:
        ans = find_farey(cj, jc)
    else:
        ans_f = find_farey(flip_fr(jc), flip_fr(cj))
        ans = flip_fr(ans_f)
    dbg_print(""ans = {0}"".format(ans))
    # return ""{0} {1}"".format(ans[0], ans[1])
    return ""{0} {1}"".format(ans.numerator, ans.denominator)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4246,157,525,Python,0000000000051679,0000000000149c22,0000000000146184,SergGr,2019
16071,0000000000149c78.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def cmp_fr(a, b):
    if a[0] * b[1] == a[1] * b[0]:
        return 0
    elif a[0] * b[1] > a[1] * b[0]:
        return 1
    else:
        return -1


def flip_fr(a):
    return (a[1], a[0])


def find_farey(tgt_low, tgt_hi):
    le = (0, 1)
    ri = (1, 1)
    if cmp_fr(ri, tgt_low) > 0 and cmp_fr(ri, tgt_hi) < 0:
        return ri

    while True:
        m = (le[0] + ri[0], le[1] + ri[1])
        if cmp_fr(m, tgt_low) > 0 and cmp_fr(m, tgt_hi) < 0:
            return m
        if cmp_fr(m, tgt_hi) >= 0:
            ri = m
        else:
            le = m


def calcSingleTest(f):
    line = f.readline()
    N, = [int(x) for x in line.split()]

    pairs = []
    for i in xrange(N):
        line = f.readline()
        C, J = [int(x) for x in line.split()]
        pairs.append((C, J))

    # c/j
    # low < (c,j) < hi
    cj = (1, 2 * 10 ** 9)
    jc = (2 * 10 ** 9, 1)

    for i in xrange(N):
        c1, j1 = pairs[i]
        for jj in xrange(i + 1, N):
            c2, j2 = pairs[jj]
            if c2 <= c1 and j2 <= j1:
                dbg_print(""impossible i = {0}, j = {1}, c1 = {2}, j1 = {3}, c2 = {4}, j2 = {5}"".format(i, jj, c1, j1, c2, j2))
                return ""IMPOSSIBLE""
            if c2 >= c1 and j2 >= j1:
                continue
            dc = c2 - c1
            dj = j2 - j1
            if dc > 0:
                dj = -dj
                cur = (dc, dj)
                # dc > -dj
                if cur[0] * cj[1] > cur[1] * cj[0]:
                    cj = cur
                # # -dj < dc
                # if cur[0] * hi[1] < cur[1] * hi[0]:
                #     hi = cur
            else:
                dc = -dc
                cur = (dc, dj)
                # dc < -dj
                if cur[1] * jc[0] > cur[0] * jc[1]:
                    jc = cur

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))
    g1 = gcd(cj[0], cj[1])
    cj = (cj[0] / g1, cj[1] / g1)

    g2 = gcd(jc[0], jc[1])
    jc = (jc[0] / g2, jc[1] / g2)

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))

    if cj[0] * jc[1] >= cj[1] * jc[0]:
        return ""IMPOSSIBLE""

    if cj[0] < cj[1]:
        ans = find_farey(cj, jc)
    else:
        ans_f = find_farey(flip_fr(jc), flip_fr(cj))
        ans = flip_fr(ans_f)
    dbg_print(""ans = {0}"".format(ans))
    return ""{0} {1}"".format(ans[0], ans[1])


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4100,158,537,Python,0000000000051679,0000000000149c78,0000000000146184,SergGr,2019
16072,00000000001495ad.PYTHON,"import sys
import time
import itertools
from fractions import gcd
from fractions import Fraction

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def cmp_fr(a, b):
    if a > b:
        return 1
    elif a == b:
        return 0
    else:
        return -1
    # if a[0] * b[1] == a[1] * b[0]:
    #     return 0
    # elif a[0] * b[1] > a[1] * b[0]:
    #     return 1
    # else:
    #     return -1


def flip_fr(a):
    return (a[1], a[0])


def find_farey(tgt_low, tgt_hi):
    le = (0, 1)
    ri = (1, 1)
    if cmp_fr(ri, tgt_low) > 0 and cmp_fr(ri, tgt_hi) < 0:
        return ri

    while True:
        m = (le[0] + ri[0], le[1] + ri[1])
        if cmp_fr(m, tgt_low) > 0 and cmp_fr(m, tgt_hi) < 0:
            return m
        if cmp_fr(m, tgt_hi) >= 0:
            ri = m
        else:
            le = m


def check_order(N, pairs):
    cj = Fraction(numerator=1, denominator=2 * 10 ** 9)
    jc = Fraction(numerator=2 * 10 ** 9, denominator=1)

    for i in xrange(N):
        c1, j1 = pairs[i]
        for jj in xrange(i + 1, N):
            c2, j2 = pairs[jj]
            if c2 <= c1 and j2 <= j1:
                return False
            if c2 >= c1 and j2 >= j1:
                continue
            dc = c2 - c1
            dj = j2 - j1
            if dc > 0:
                # dc * C > -dj * J
                # C/J > -dj / dc
                cur = Fraction(numerator=-dj, denominator=dc)
                if cmp_fr(cur, cj) > 0:
                    cj = cur
            else:
                # -dc * C < dj * J
                # C/J < dj/(-dc)
                cur = Fraction(numerator=dj, denominator=-dc)
                if cmp_fr(cur, jc) < 0:
                    jc = cur

    # dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))

    if cmp_fr(cj, jc) >= 0:
        return False

    return True


def calcSingleTest(f):
    line = f.readline()
    N, = [int(x) for x in line.split()]

    pairs = []
    for i in xrange(N):
        line = f.readline()
        C, J = [int(x) for x in line.split()]
        pairs.append((C, J))

    cnt = 0

    check_order(4, [(1, 1), (2, 1), (1, 2), (3, 1)])

    for p in itertools.permutations(pairs):
        if check_order(N, p):
            # dbg_print(""Good = {0}"".format(p))
            cnt += 1

    dbg_print(""Cnt = {0}"".format(cnt))
    return cnt


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3725,152,470,Python,0000000000051679,00000000001495ad,0000000000146183,SergGr,2019
16073,0000000000148391.PYTHON,"import sys
import time
import itertools
from fractions import gcd
from fractions import Fraction

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def cmp_fr(a, b):
    if a > b:
        return 1
    elif a == b:
        return 0
    else:
        return -1
    # if a[0] * b[1] == a[1] * b[0]:
    #     return 0
    # elif a[0] * b[1] > a[1] * b[0]:
    #     return 1
    # else:
    #     return -1


def flip_fr(a):
    return (a[1], a[0])


def find_farey(tgt_low, tgt_hi):
    le = (0, 1)
    ri = (1, 1)
    if cmp_fr(ri, tgt_low) > 0 and cmp_fr(ri, tgt_hi) < 0:
        return ri

    while True:
        m = (le[0] + ri[0], le[1] + ri[1])
        if cmp_fr(m, tgt_low) > 0 and cmp_fr(m, tgt_hi) < 0:
            return m
        if cmp_fr(m, tgt_hi) >= 0:
            ri = m
        else:
            le = m


def check_order(N, pairs):
    cj = Fraction(numerator=1, denominator=2 * 10 ** 9)
    jc = Fraction(numerator=2 * 10 ** 9, denominator=1)

    for i in xrange(N):
        c1, j1 = pairs[i]
        for jj in xrange(i + 1, N):
            c2, j2 = pairs[jj]
            if c2 <= c1 and j2 <= j1:
                return False
            if c2 >= c1 and j2 >= j1:
                continue
            dc = c2 - c1
            dj = j2 - j1
            if dc > 0:
                # dc > -dj
                cur = Fraction(numerator=dc, denominator=-dj)
                if cmp_fr(cur, cj) > 0:
                    cj = cur
            else:
                # dc < -dj
                cur = Fraction(numerator=-dc, denominator=dj)
                if cmp_fr(cur, jc) < 0:
                    jc = cur

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))

    if cmp_fr(cj, jc) >= 0:
        return False

    return True


def calcSingleTest(f):
    line = f.readline()
    N, = [int(x) for x in line.split()]

    pairs = []
    for i in xrange(N):
        line = f.readline()
        C, J = [int(x) for x in line.split()]
        pairs.append((C, J))

    cnt = 0

    for p in itertools.permutations(pairs):
        if check_order(N, p):
            cnt += 1

    return cnt


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3500,146,435,Python,0000000000051679,0000000000148391,0000000000146183,SergGr,2019
16074,0000000000147ebf.PYTHON,"import sys
import time
import itertools
from fractions import gcd

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)

def cmp_fr(a, b):
    if a[0] * b[1] == a[1] * b[0]:
        return 0
    elif a[0] * b[1] > a[1] * b[0]:
        return 1
    else:
        return -1


def flip_fr(a):
    return (a[1], a[0])


def find_farey(tgt_low, tgt_hi):
    le = (0, 1)
    ri = (1, 1)
    if cmp_fr(ri, tgt_low) > 0 and cmp_fr(ri, tgt_hi) < 0:
        return ri

    while True:
        m = (le[0] + ri[0], le[1] + ri[1])
        if cmp_fr(m, tgt_low) > 0 and cmp_fr(m, tgt_hi) < 0:
            return m
        if cmp_fr(m, tgt_hi) >= 0:
            ri = m
        else:
            le = m


def check_order(N, pairs):
    cj = (1, 2 * 10 ** 9)
    jc = (2 * 10 ** 9, 1)

    for i in xrange(N):
        c1, j1 = pairs[i]
        for jj in xrange(i + 1, N):
            c2, j2 = pairs[jj]
            if c2 <= c1 and j2 <= j1:
                # dbg_print(""impossible i = {0}, j = {1}, c1 = {2}, j1 = {3}, c2 = {4}, j2 = {5}"".format(i, jj, c1, j1, c2, j2))
                return False
            if c2 >= c1 and j2 >= j1:
                continue
            dc = c2 - c1
            dj = j2 - j1
            if dc > 0:
                dj = -dj
                cur = (dc, dj)
                # dc > -dj
                if cur[0] * cj[1] > cur[1] * cj[0]:
                    cj = cur
                # # -dj < dc
                # if cur[0] * hi[1] < cur[1] * hi[0]:
                #     hi = cur
            else:
                dc = -dc
                cur = (dc, dj)
                # dc < -dj
                if cur[1] * jc[0] > cur[0] * jc[1]:
                    jc = cur

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))
    g1 = gcd(cj[0], cj[1])
    cj = (cj[0] / g1, cj[1] / g1)

    g2 = gcd(jc[0], jc[1])
    jc = (jc[0] / g2, jc[1] / g2)

    dbg_print(""cj = {0}, jc = {1}"".format(cj, jc))

    if cj[0] * jc[1] >= cj[1] * jc[0]:
        return False

    return True


def calcSingleTest(f):
    line = f.readline()
    N, = [int(x) for x in line.split()]

    pairs = []
    for i in xrange(N):
        line = f.readline()
        C, J = [int(x) for x in line.split()]
        pairs.append((C, J))

    cnt = 0

    for p in itertools.permutations(pairs):
        if check_order(N, p):
            cnt += 1

    return cnt


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3744,151,499,Python,0000000000051679,0000000000147ebf,0000000000146183,SergGr,2019
64330,000000000012ddc6.PYTHON,"import sys
import time

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def check_dir(ppx, x0):
    cnt_left = 0
    cnt_right = 0
    cnt_good = 0
    cnt_bad = 0
    for x, dx in ppx:
        if dx == 0:
            pass
            # if x0 == x:
            #     cnt += 1
            # else:
            #     cnt -= 1
        elif dx > 0:
            cnt_right += 1
            if x < x0:
                cnt_good += 1
            else:
                cnt_bad += 1
        else:
            cnt_left += 1
            if x > x0:
                cnt_good += 1
            else:
                cnt_bad += 1

    return (cnt_good > cnt_bad, cnt_left > cnt_right)


def find_best(ppx, Q):
    if len(ppx) == 0:
        return 0
    if check_dir(ppx, 0) <= 0:
        return 0

    l = 0
    r = Q
    cnt = 0
    while l < r:
        x = (l + r + 1) / 2
        cnt += 1
        d = check_dir(ppx, x)
        if cnt > 100:
            dbg_print(ppx)
            dbg_print((l, r, x, d))
            raise AssertionError(""Infinite loop "" + str(ppx))
        if d <= 0:
            r = x
        else:
            l = x
    return l


def find_best2(xsl, xsr, Q):
    cur = 0
    for i in xrange(1, Q+1):
        cur += xsl[i]
        cur -= xsr[i]
    cur -= xsr[0]

    best = cur
    best_x = 0
    for i in xrange(1, Q+1):
        cur += xsr[i - 1]
        cur -= xsl[i]
        # cur -= xsr[i]
        if cur > best:
            best = cur
            best_x = i
    return best_x


def calcSingleTest(f):
    line = f.readline().strip()
    P, Q = [int(x) for x in line.split()]
    ppl = []
    ppx = []
    ppy = []
    xsl = [0] * (Q + 2)
    xsr = [0] * (Q + 2)
    ysl = [0] * (Q + 2)
    ysr = [0] * (Q + 2)
    for i in xrange(P):
        line = f.readline().strip()
        x = int(line.split()[0])
        y = int(line.split()[1])
        d = line.split()[2]
        dx, dy = map_dir(d)
        ppl.append((x, y, dx, dy))
        # if dx != 0:
        ppx.append((x, dx))
        # if dy != 0:
        ppy.append((y, dy))
        # xs[x] += dx
        # ys[y] += dy
        if dx > 0:
            xsr[x] += 1
        elif dx < 0:
            xsl[x] += 1
        if dy > 0:
            ysr[y] += 1
        elif dy < 0:
            ysl[y] += 1

    dbg_print(ppl)
    # dbg_print(xs)
    # dbg_print(ys)

    # best = (-1, -1)
    # best_cnt = -1
    # for x0 in xrange(Q + 1):
    #     for y0 in xrange(Q + 1):
    #         cnt = 0
    #         for x, y, dx, dy in ppl:
    #             if dx != 0 and x0 != x and (x0 - x) * dx > 0:
    #                 cnt += 1
    #             elif dy != 0 and y0 != y and (y0 - y) * dy > 0:
    #                 cnt += 1
    #         if cnt > best_cnt:
    #             best = (x0, y0)
    #             best_cnt = cnt
    #         elif cnt == best_cnt and (x0 < best[0] or (x0 == best[0] and y0 < best[1])):
    #             best = (x0, y0)
    #             best_cnt = cnt

    # x1 = find_best(ppx, Q)
    # y1 = find_best(ppy, Q)

    x1 = find_best2(xsl, xsr, Q)
    y1 = find_best2(ysl, ysr, Q)

    return ""{0} {1}"".format(x1, y1)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4761,202,667,Python,0000000000051706,000000000012ddc6,000000000012295c,SergGr,2019
64331,000000000012d9bc.PYTHON,"import sys
import time

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def check_dir(ppx, x0):
    cnt_left = 0
    cnt_right = 0
    cnt_good = 0
    cnt_bad = 0
    for x, dx in ppx:
        if dx == 0:
            pass
            # if x0 == x:
            #     cnt += 1
            # else:
            #     cnt -= 1
        elif dx > 0:
            cnt_right += 1
            if x < x0:
                cnt_good += 1
            else:
                cnt_bad += 1
        else:
            cnt_left += 1
            if x > x0:
                cnt_good += 1
            else:
                cnt_bad += 1

    return (cnt_good > cnt_bad, cnt_left > cnt_right)


def find_best(ppx, Q):
    if len(ppx) == 0:
        return 0
    if check_dir(ppx, 0) <= 0:
        return 0

    l = 0
    r = Q
    cnt = 0
    while l < r:
        x = (l + r + 1) / 2
        cnt += 1
        d = check_dir(ppx, x)
        if cnt > 100:
            dbg_print(ppx)
            dbg_print((l, r, x, d))
            raise AssertionError(""Infinite loop "" + str(ppx))
        if d <= 0:
            r = x
        else:
            l = x
    return l


def find_best2(xsl, xsr, Q):
    cur = 0
    for i in xrange(1, Q):
        cur += xsl[i]
        cur -= xsr[i]
    cur -= xsr[0]

    best = cur
    best_x = 0
    for i in xrange(1, Q):
        cur += xsr[i - 1]
        cur -= xsl[i]
        # cur -= xsr[i]
        if cur > best:
            best = cur
            best_x = i
    return best_x


def calcSingleTest(f):
    line = f.readline().strip()
    P, Q = [int(x) for x in line.split()]
    ppl = []
    ppx = []
    ppy = []
    xsl = [0] * (Q + 2)
    xsr = [0] * (Q + 2)
    ysl = [0] * (Q + 2)
    ysr = [0] * (Q + 2)
    for i in xrange(P):
        line = f.readline().strip()
        x = int(line.split()[0])
        y = int(line.split()[1])
        d = line.split()[2]
        dx, dy = map_dir(d)
        ppl.append((x, y, dx, dy))
        # if dx != 0:
        ppx.append((x, dx))
        # if dy != 0:
        ppy.append((y, dy))
        # xs[x] += dx
        # ys[y] += dy
        if dx > 0:
            xsr[x] += 1
        elif dx < 0:
            xsl[x] += 1
        if dy > 0:
            ysr[y] += 1
        elif dy < 0:
            ysl[y] += 1

    dbg_print(ppl)
    # dbg_print(xs)
    # dbg_print(ys)

    # best = (-1, -1)
    # best_cnt = -1
    # for x0 in xrange(Q + 1):
    #     for y0 in xrange(Q + 1):
    #         cnt = 0
    #         for x, y, dx, dy in ppl:
    #             if dx != 0 and x0 != x and (x0 - x) * dx > 0:
    #                 cnt += 1
    #             elif dy != 0 and y0 != y and (y0 - y) * dy > 0:
    #                 cnt += 1
    #         if cnt > best_cnt:
    #             best = (x0, y0)
    #             best_cnt = cnt
    #         elif cnt == best_cnt and (x0 < best[0] or (x0 == best[0] and y0 < best[1])):
    #             best = (x0, y0)
    #             best_cnt = cnt

    # x1 = find_best(ppx, Q)
    # y1 = find_best(ppy, Q)

    x1 = find_best2(xsl, xsr, Q)
    y1 = find_best2(ysl, ysr, Q)

    return ""{0} {1}"".format(x1, y1)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4757,202,667,Python,0000000000051706,000000000012d9bc,000000000012295c,SergGr,2019
64332,0000000000129289.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N, K = [int(x) for x in line.split()]

    line = f.readline()
    c = [int(x) for x in line.split()]
    line = f.readline()
    d = [int(x) for x in line.split()]

    cnt = 0
    for l in xrange(N):
        for r in xrange(l, N):
            best_c = -1
            best_d = -1
            for i in xrange(l, r + 1):
                if c[i] > best_c:
                    best_c = c[i]
                if d[i] > best_d:
                    best_d = d[i]
            if abs(best_c - best_d) <= K:
                cnt += 1

    return cnt


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2365,91,266,Python,0000000000051706,0000000000129289,0000000000122838,SergGr,2019
64333,0000000000128751.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18
a14 = 2 ** 14
a11 = 2 ** 11
a9 = 2 ** 9

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


# def runSingleTest(inpF, outF):
def runSingleTest(inpF, outF, W):
    # line = inpF.readline()

    resps = []

    # 1 <= i <= 6
    # 0 <= Ri <= 100

    # print('1', file=outF)
    # line = inpF.readline().strip()
    # resps.append(int(line))
    #
    # print('6', file=outF)
    # line = inpF.readline().strip()
    # resps.append(int(line))

    # print(""1"", file=outF)
    # line = inpF.readline().strip()
    # resps.append(int(line))
    # print(str(a56), file=outF)
    print(""56"", file=outF)
    line = inpF.readline().strip()
    resps.append(int(line))
    # print(str(a220), file=outF)
    print(""220"", file=outF)
    line = inpF.readline().strip()
    resps.append(int(line))
    # for d in xrange(2, 7):
    #     print(str(d * 7), file=outF)
    #     line = inpF.readline().strip()
    #     resps.append(int(line))

    guess = [0] * 6

    t = resps[1]
    guess[3] = t / a55
    t = t % a55
    guess[4] = t / a44
    t = t % a44
    guess[5] = t / a36

    t = resps[0]
    guess[0] = t / a56
    t = t % a56
    guess[1] = t / a28
    t = t % a28
    t -= guess[3] * a14
    t -= guess[4] * a11
    t -= guess[5] * a9
    guess[2] = t / a18

    dbg_print(guess)
    guess_str = "" "".join(map(str, guess))

    dbg_print(""Guess = "" + guess_str)
    print(guess_str, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, W = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        # success = runSingleTest(inpF, outF)
        success = runSingleTest(inpF, outF, W)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4423,177,526,Python,0000000000051706,0000000000128751,0000000000122837,SergGr,2019
64334,0000000000128077.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


# def runSingleTest(inpF, outF):
def runSingleTest(inpF, outF, W):
    # line = inpF.readline()

    resps = []

    # 1 <= i <= 6
    # 0 <= Ri <= 100

    # print('1', file=outF)
    # line = inpF.readline().strip()
    # resps.append(int(line))
    #
    # print('6', file=outF)
    # line = inpF.readline().strip()
    # resps.append(int(line))

    # print(""1"", file=outF)
    # line = inpF.readline().strip()
    # resps.append(int(line))
    # print(str(a56), file=outF)
    print(""56"", file=outF)
    line = inpF.readline().strip()
    resps.append(int(line))
    # print(str(a220), file=outF)
    print(""220"", file=outF)
    line = inpF.readline().strip()
    resps.append(int(line))
    # for d in xrange(2, 7):
    #     print(str(d * 7), file=outF)
    #     line = inpF.readline().strip()
    #     resps.append(int(line))

    guess = [0] * 6

    t = resps[0]
    guess[0] = t / a56
    t = t % a56
    guess[1] = t / a28
    t = t % a28
    guess[2] = t / a18

    t = resps[1]
    guess[3] = t / a55
    t = t % a55
    guess[4] = t / a44
    t = t % a44
    guess[5] = t / a36

    dbg_print(guess)
    guess_str = "" "".join(map(str, guess))

    dbg_print(""Guess = "" + guess_str)
    print(guess_str, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, W = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        # success = runSingleTest(inpF, outF)
        success = runSingleTest(inpF, outF, W)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4312,171,496,Python,0000000000051706,0000000000128077,0000000000122837,SergGr,2019
64335,0000000000124b58.PYTHON,"import sys
import time

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest(f):
    line = f.readline().strip()
    P, Q = [int(x) for x in line.split()]
    ppl = []
    # xs = [0] * Q
    # ys = [0] * Q
    for i in xrange(P):
        line = f.readline().strip()
        x = int(line.split()[0])
        y = int(line.split()[1])
        d = line.split()[2]
        dx, dy = map_dir(d)
        ppl.append((x, y, dx, dy))
        # xs[x] += dx
        # ys[y] += dy

    dbg_print(ppl)
    # dbg_print(xs)
    # dbg_print(ys)

    best = (-1, -1)
    best_cnt = -1
    for x0 in xrange(Q+1):
        for y0 in xrange(Q+1):
            cnt = 0
            for x, y, dx, dy in ppl:
                if dx != 0 and x0 != x and (x0 - x) * dx > 0:
                    cnt += 1
                elif dy != 0 and y0 != y and (y0 - y) * dy > 0:
                    cnt += 1
            if cnt > best_cnt:
                best = (x0, y0)
                best_cnt = cnt
            elif cnt == best_cnt and (x0 < best[0] or (x0 == best[0] and y0 < best[1])):
                best = (x0, y0)
                best_cnt = cnt

    return ""{0} {1}"".format(best[0], best[1])


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2834,109,354,Python,0000000000051706,0000000000124b58,000000000012295c,SergGr,2019
64336,00000000001249b9.PYTHON,"import sys
import time

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest(f):
    line = f.readline().strip()
    P, Q = [int(x) for x in line.split()]
    ppl = []
    # xs = [0] * Q
    # ys = [0] * Q
    for i in xrange(P):
        line = f.readline().strip()
        x = int(line.split()[0])
        y = int(line.split()[1])
        d = line.split()[2]
        dx, dy = map_dir(d)
        ppl.append((x, y, dx, dy))
        # xs[x] += dx
        # ys[y] += dy

    dbg_print(ppl)
    # dbg_print(xs)
    # dbg_print(ys)

    best = (-1, -1)
    best_cnt = -1
    for x0 in xrange(Q):
        for y0 in xrange(Q):
            cnt = 0
            for x, y, dx, dy in ppl:
                if dx != 0 and x0 != x and (x0 - x) * dx > 0:
                    cnt += 1
                elif dy != 0 and y0 != y and (y0 - y) * dy > 0:
                    cnt += 1
            if cnt > best_cnt:
                best = (x0, y0)
                best_cnt = cnt
            elif cnt == best_cnt and (x0 < best[0] or (x0 == best[0] and y0 < best[1])):
                best = (x0, y0)
                best_cnt = cnt

    return ""{0} {1}"".format(best[0], best[1])


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2830,109,354,Python,0000000000051706,00000000001249b9,000000000012295c,SergGr,2019
64337,00000000001242ef.PYTHON,"import sys
import time

# import collections

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest(f):
    line = f.readline().strip()
    P, Q = [int(x) for x in line.split()]
    ppl = []
    # xs = [0] * Q
    # ys = [0] * Q
    for i in xrange(P):
        line = f.readline().strip()
        x = int(line.split()[0])
        y = int(line.split()[1])
        d = line.split()[2]
        dx, dy = map_dir(d)
        ppl.append((x, y, dx, dy))
        # xs[x] += dx
        # ys[y] += dy

    #dbg_print(ppl)
    # dbg_print(xs)
    # dbg_print(ys)

    best = None
    best_cnt = -1
    for x0 in xrange(Q):
        for y0 in xrange(Q):
            cnt = 0
            for x, y, dx, dy in ppl:
                if dx != 0 and x0 != x and (x0 - x) * dx > 0:
                    cnt += 1
                elif dy != 0 and y0 != y and (y0 - y) * dy > 0:
                    cnt += 1
            if cnt > best_cnt:
                best = (x0, y0)
                best_cnt = cnt

    return ""{0} {1}"".format(best[0], best[1])


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2675,106,330,Python,0000000000051706,00000000001242ef,000000000012295c,SergGr,2019
139638,00000000000f264d.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    # m = 2 ** (F - 1)
    m = 1024
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
        print(all[step], file=outF)
        line = inpF.readline().strip()
        resps.append(line)

    bad_bits = []
    resp_pos = 0
    resp_len = len(resps[0])
    for test_pos in xrange(N):
        good = True
        for j in xrange(F):
            if resps[j][resp_pos] != all[j][test_pos]:
                good = False
                dbg_print(""Bad at {0}"".format(test_pos))
                break
        if good:
            resp_pos += 1
            if resp_pos >= resp_len:
                dbg_print(""Final good at {0}"".format(test_pos))
                for j in xrange(test_pos + 1, N):
                    bad_bits.append(j)
                break
        else:
            bad_bits.append(test_pos)
            if len(bad_bits) == B:
                break

    # guess = ""1 2 3""
    guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        success = runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4222,159,440,Python,51705,00000000000f264d,00000000000881de,SergGr,2019
139639,00000000000f0346.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
        print(all[step], file=outF)
        line = inpF.readline().strip()
        resps.append(line)

    bad_bits = []
    resp_pos = 0
    resp_len = len(resps[0])
    for test_pos in xrange(N):
        good = True
        for j in xrange(F):
            if resps[j][resp_pos] != all[j][test_pos]:
                good = False
                dbg_print(""Bad at {0}"".format(test_pos))
                break
        if good:
            resp_pos += 1
            if resp_pos >= resp_len:
                dbg_print(""Final good at {0}"".format(test_pos))
                for j in xrange(test_pos + 1, N):
                    bad_bits.append(j)
                break
        else:
            bad_bits.append(test_pos)
            if len(bad_bits) == B:
                break

    # guess = ""1 2 3""
    guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        success = runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,4207,158,436,Python,51705,00000000000f0346,00000000000881de,SergGr,2019
139640,00000000000efc69.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
        print(all[step], file=outF)
        line = inpF.readline_safe()
        resps.append(line)

    bad_bits = []
    resp_pos = 0
    for test_pos in xrange(N):
        good = True
        #for j in xrange(F):
        #    if resps[j][resp_pos] != all[j][test_pos]:
        #        good = False
        #        break
        if good:
            resp_pos += 1
        else:
            bad_bits.append(test_pos)
            if len(bad_bits) == B:
                break

    guess = ""1 2 3""
    # guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        success = runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0}, bad count = {1}"".format(goodCount, badCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3891,151,413,Python,51705,00000000000efc69,00000000000881de,SergGr,2019
139641,00000000000ef977.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
        print(all[step], file=outF)
        line = inpF.readline_safe()
        resps.append(line)

    bad_bits = []
    resp_pos = 0
    for test_pos in xrange(N):
        good = True
        for j in xrange(F):
            if resps[j][resp_pos] != all[j][test_pos]:
                good = False
                break
        if good:
            resp_pos += 1
        else:
            bad_bits.append(test_pos)
            if len(bad_bits) == B:
                break

    # guess = ""1 2 3""
    guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        success = runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0}, bad count = {1}"".format(goodCount, badCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3887,151,410,Python,51705,00000000000ef977,00000000000881de,SergGr,2019
139642,00000000000ef507.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
         print(all[step], file=outF)
         line = inpF.readline_safe()
         resps.append(line)
    
    # bad_bits = []
    # resp_pos = 0
    # for test_pos in xrange(N):
    #     good = True
    #     for j in xrange(F):
    #         if resps[j][resp_pos] != all[j][test_pos]:
    #             good = False
    #             break
    #     if good:
    #         resp_pos += 1
    #     else:
    #         bad_bits.append(test_pos)
    #         if len(bad_bits) == B:
    #             break

    guess = ""1 2 3 4 5 6 7 8 9 10 11 12 13 14 15""
    # guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not runSingleTest(inpF, outF):
            break
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3737,144,411,Python,51705,00000000000ef507,00000000000881de,SergGr,2019
139643,00000000000ef5d1.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    #all = buildTestStrings(F, N)
    resps = []
    # for step in range(F):
    #     print(all[step], file=outF)
    #     line = inpF.readline_safe()
    #     resps.append(line)
    #
    # bad_bits = []
    # resp_pos = 0
    # for test_pos in xrange(N):
    #     good = True
    #     for j in xrange(F):
    #         if resps[j][resp_pos] != all[j][test_pos]:
    #             good = False
    #             break
    #     if good:
    #         resp_pos += 1
    #     else:
    #         bad_bits.append(test_pos)
    #         if len(bad_bits) == B:
    #             break

    guess = ""1 2 3 4 5 6 7 8 9 10 11 12 13 14 15""
    # guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline()
    dbg_print(""Success: "" + success)
    return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not runSingleTest(inpF, outF):
            break
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3744,144,416,Python,51705,00000000000ef5d1,00000000000881de,SergGr,2019
139644,00000000000ef3a0.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    #all = buildTestStrings(F, N)
    resps = []
    # for step in range(F):
    #     print(all[step], file=outF)
    #     line = inpF.readline_safe()
    #     resps.append(line)
    #
    # bad_bits = []
    # resp_pos = 0
    # for test_pos in xrange(N):
    #     good = True
    #     for j in xrange(F):
    #         if resps[j][resp_pos] != all[j][test_pos]:
    #             good = False
    #             break
    #     if good:
    #         resp_pos += 1
    #     else:
    #         bad_bits.append(test_pos)
    #         if len(bad_bits) == B:
    #             break

    guess = ""1 2 3""
    # guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline()
    dbg_print(""Success: "" + success)


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3662,142,397,Python,51705,00000000000ef3a0,00000000000881de,SergGr,2019
139645,00000000000ef096.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    # for step in range(F):
    #     print(all[step], file=outF)
    #     line = inpF.readline_safe()
    #     resps.append(line)
    #
    # bad_bits = []
    # resp_pos = 0
    # for test_pos in xrange(N):
    #     good = True
    #     for j in xrange(F):
    #         if resps[j][resp_pos] != all[j][test_pos]:
    #             good = False
    #             break
    #     if good:
    #         resp_pos += 1
    #     else:
    #         bad_bits.append(test_pos)
    #         if len(bad_bits) == B:
    #             break

    guess = ""1 2 3""
    # guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline()
    dbg_print(""Success: "" + success)


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3661,142,397,Python,51705,00000000000ef096,00000000000881de,SergGr,2019
139647,00000000000eee09.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
        print(all[step], file=outF)
        line = inpF.readline_safe()
        resps.append(line)

    bad_bits = []
    resp_pos = 0
    for test_pos in xrange(N):
        good = True
        for j in xrange(F):
            if resps[j][resp_pos] != all[j][test_pos]:
                good = False
                break
        if good:
            resp_pos += 1
        else:
            bad_bits.append(test_pos)
            if len(bad_bits) == B:
                break

    # guess = ""1 2 3""
    guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline()
    dbg_print(""Success: "" + success)


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3620,142,378,Python,51705,00000000000eee09,00000000000881de,SergGr,2019
139648,00000000000ee7ba.PYTHON,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)


def buildTestStrings(F, N):
    all = []
    m = 2 ** (F - 1)
    for i in range(F):
        p = 2 ** i
        r = m / p
        s = ''
        for j in xrange(r):
            s += '0' * p
            s += '1' * p
        # dbg_print(s)
        all.append(s[0:N])
    return all


def runSingleTest(inpF, outF):
    line = inpF.readline()
    N, B, F = [int(x) for x in line.split()]

    all = buildTestStrings(F, N)
    resps = []
    for step in range(F):
        print(all[step], file=outF)
        line = inpF.readline_safe()
        resps.append(line)

    bad_bits = []
    resp_pos = 0
    for test_pos in xrange(N):
        good = True
        for j in xrange(F):
            if resps[j][resp_pos] != all[j][test_pos]:
                good = False
                break
        if good:
            resp_pos += 1
        else:
            bad_bits.append(test_pos)

    # guess = ""1 2 3""
    guess = ' '.join([str(x) for x in bad_bits])

    dbg_print(""Guess = "" + guess)
    print(guess, file=outF)
    success = inpF.readline()
    dbg_print(""Success: "" + success)


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        runSingleTest(inpF, outF)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,3563,140,373,Python,51705,00000000000ee7ba,00000000000881de,SergGr,2019
139649,00000000000dd8e5.PYTHON,"import sys

f = sys.stdin
outF = sys.stdout
T = int(f.readline())
for t in xrange(T):
    N = int(f.readline())
    inp = f.readline().strip();
    res = inp.replace('S','Q').replace('E','S').replace('Q','E')
    outF.write('Case #{0}: {1}\n'.format(t+1, res))",,260,10,28,Python,51705,00000000000dd8e5,00000000000881da,SergGr,2019
139650,00000000000b9d86.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N, L = [int(x) for x in line.split()]
    line = f.readline()
    data = [int(x) for x in line.split()]

    cur = 0

    for i in xrange(L - 1):
        if data[i] != data[i + 1]:
            v = gcd(data[i], data[i + 1])
            cur = data[i] / v
            for j in xrange(i , 0, -1):
                cur = data[i] / cur
            break

    dbg_print(cur)
    v2 = gcd(data[0], data[1])
    cur2 = data[0] / v2
    dbg_print(cur2)

    digits = []
    for i in range(L):
        digits.append(cur)
        cur = data[i] / cur
    digits.append(cur)

    su = list(sorted(set(digits)))
    decode = dict()
    for i in xrange(len(su)):
        decode[su[i]] = chr(ord('A') + i)

    out = ''
    for i in xrange(len(digits)):
        out += decode[digits[i]]

    return out


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2611,105,297,Python,51705,00000000000b9d86,000000000008830b,SergGr,2019
139651,00000000000b9c3a.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N, L = [int(x) for x in line.split()]
    line = f.readline()
    data = [int(x) for x in line.split()]

    cur = 0

    for i in xrange(L - 1):
        if data[i] != data[i + 1]:
            v = gcd(data[i], data[i + 1])
            cur = data[i] / v
            for j in xrange(i , 0, -1):
                cur = data[i] / cur
            break

    dbg_print(cur)
    v2 = gcd(data[0], data[1])
    cur = data[0] / v2
    dbg_print(cur2)

    digits = []
    for i in range(L):
        digits.append(cur)
        cur = data[i] / cur
    digits.append(cur)

    su = list(sorted(set(digits)))
    decode = dict()
    for i in xrange(len(su)):
        decode[su[i]] = chr(ord('A') + i)

    out = ''
    for i in xrange(L):
        out += decode[digits[i]]

    return out


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2600,105,297,Python,51705,00000000000b9c3a,000000000008830b,SergGr,2019
139652,00000000000b9af0.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N, L = [int(x) for x in line.split()]
    line = f.readline()
    data = [int(x) for x in line.split()]

    cur = 0

    for i in xrange(L - 1):
        if data[i] != data[i + 1]:
            v = gcd(data[i], data[i + 1])
            cur = data[i] / v
            for j in xrange(i , 0, -1):
                cur = data[i] / cur
            break

    dbg_print(cur)
    v2 = gcd(data[0], data[1])
    cur2 = data[0] / v2
    dbg_print(cur2)

    digits = []
    for i in range(L):
        digits.append(cur)
        cur = data[i] / cur
    digits.append(cur)

    su = list(sorted(set(digits)))
    decode = dict()
    for i in xrange(len(su)):
        decode[su[i]] = chr(ord('A') + i)

    out = ''
    for i in xrange(L):
        out += decode[digits[i]]

    return out


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,2601,105,297,Python,51705,00000000000b9af0,000000000008830b,SergGr,2019
139653,00000000000b87cd.PYTHON,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    o1 = ''
    o2 = ''
    one = '1'
    zero = ''
    for c in line:
        if c != '4':
            o1 += c
            o2 += zero
        else:
            o1 += '3'
            o2 += one
            zero = '0'

    dbg_print(line)
    dbg_print(o1)
    dbg_print(o2)
    return o1 + "" "" + o2


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",,1937,81,212,Python,51705,00000000000b87cd,0000000000088231,SergGr,2019
144613,00000000002984d7,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N, K = map(int, line.split())

    row0 = list(range(1, N + 1))
    rows = []
    r = row0
    for i in range(N):
        rows.append(r)
        r = r[1:] + r[:1]

    for rs in itertools.permutations(rows):
        sum = 0
        for i in range(N):
            sum += rs[i][i]
        if sum == K:
            res = ""POSSIBLE\n""
            lines = ["" "".join([str(v) for v in r]) for r in rs]
            res += ""\n"".join(lines)
            return res

    row0 = list(range(N + 1, 1, -1))
    rows = []
    r = row0
    for i in range(N):
        rows.append(r)
        r = r[1:] + r[:1]

    for rs in itertools.permutations(rows):
        sum = 0
        for i in range(N):
            sum += rs[i][i]
        if sum == K:
            res = ""POSSIBLE\n""
            lines = ["" "".join([str(v) for v in r]) for r in rs]
            res += ""\n"".join(lines)
            return res

    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000002984d7.PYTHON,2701,105,310,Python,000000000019fd27,00000000002984d7,0000000000209aa0,SergGr,2020
144614,0000000000297726,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N, K = map(int, line.split())

    row0 = list(range(1, N + 1))
    rows = []
    r = row0
    for i in range(N):
        rows.append(r)
        r = r[1:] + r[:1]

    for rs in itertools.permutations(rows):
        sum = 0
        for i in range(N):
            sum += rs[i][i]
        if sum == K:
            res = ""POSSIBLE\n""
            lines = ["" "".join([str(v) for v in r]) for r in rs]
            res += ""\n"".join(lines)
            return res


    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000297726.PYTHON,2274,89,249,Python,000000000019fd27,0000000000297726,0000000000209aa0,SergGr,2020
144615,000000000026445c,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N = int(line)
    tasks = []
    for i in range(N):
        s, e = map(int, f.readline().split())
        tasks.append((s, e, i))
    tasks = list(sorted(tasks, key=lambda x: x[0]))
    Cend = 0
    Jend = 0
    assignment = [''] * N
    try:
        for (s, e, i) in tasks:
            if s >= Cend:
                try:
                    assignment[i] = ""C""
                    Cend = e
                except ee:
                    return ""IMPOSSIBLE""
            elif s >= Jend:
                try:
                    assignment[i] = ""J""
                    Jend = e
                except ee:
                    return ""IMPOSSIBLE""
            else:
                return ""IMPOSSIBLE""
    except ee:
        return ""IMPOSSIBLE2""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000026445c.PYTHON,2618,99,269,Python,000000000019fd27,000000000026445c,000000000020bdf9,SergGr,2020
144616,000000000026449d,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N = int(line)
    tasks = []
    for i in range(N):
        s, e = map(int, f.readline().split())
        tasks.append((s, e, i))
    tasks = list(sorted(tasks, key=lambda x: x[0]))
    Cend = 0
    Jend = 0
    assignment = [''] * N
    try:
        for (s, e, i) in tasks:
            if s >= Cend:
                try:
                    assignment[i] = ""C""
                    Cend = e
                except ee:
                    return ""IMPOSSIBLE""
            elif s >= Jend:
                try:
                    assignment[i] = ""J""
                    Jend = e
                except ee:
                    return ""IMPOSSIBLE""
            else:
                return ""IMPOSSIBLE""
    except ee:
        return ""IMPOSSIBLE""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000026449d.PYTHON,2617,99,269,Python,000000000019fd27,000000000026449d,000000000020bdf9,SergGr,2020
144617,000000000026425e,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N = int(line)
    tasks = []
    for i in range(N):
        s, e = map(int, f.readline().split())
        tasks.append((s, e, i))
    tasks = list(sorted(tasks, key=lambda x: x[0]))
    Cend = 0
    Jend = 0
    assignment = [''] * N
        for (s, e, i) in tasks:
            if s >= Cend:
                try:
                    assignment[i] = ""C""
                    Cend = e
                except ee:
                    return ""IMPOSSIBLE""
            elif s >= Jend:
                try:
                    assignment[i] = ""J""
                    Jend = e
                except ee:
                    return ""IMPOSSIBLE""
            else:
                return ""IMPOSSIBLE""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000026425e.PYTHON,2565,96,264,Python,000000000019fd27,000000000026425e,000000000020bdf9,SergGr,2020
144618,0000000000263fbc,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N = int(line)
    tasks = []
    for i in range(N):
        s, e = map(int, f.readline().split())
        tasks.append((s, e, i))
    tasks = list(sorted(tasks, key=lambda x: x[0]))
    Cend = 0
    Jend = 0
    assignment = [''] * N
        for (s, e, i) in tasks:
            if s >= Cend:
                try:
                    assignment[i] = ""C""
                    Cend = e
                except ee:
                    return ""IMPOSSIBLE""
            elif s >= Jend:
                assignment[i] = ""J""
                Jend = e
            else:
                return ""IMPOSSIBLE""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000263fbc.PYTHON,2469,93,259,Python,000000000019fd27,0000000000263fbc,000000000020bdf9,SergGr,2020
144619,0000000000263d43,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N = int(line)
    tasks = []
    for i in range(N):
        s, e = map(int, f.readline().split())
        tasks.append((s, e, i))
    tasks = list(sorted(tasks, key=lambda x: x[0]))
    Cend = 0
    Jend = 0
    assignment = [''] * N
        for (s, e, i) in tasks:
            if s >= Cend:
                assignment[i] = ""C""
                Cend = e
            elif s >= Jend:
                assignment[i] = ""J""
                Jend = e
            else:
                return ""IMPOSSIBLE""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000263d43.PYTHON,2373,90,254,Python,000000000019fd27,0000000000263d43,000000000020bdf9,SergGr,2020
144620,0000000000263c7d,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    N = int(line)
    tasks = []
    for i in range(N):
        s, e = map(int, f.readline().split())
        tasks.append((s, e, i))
    tasks = list(sorted(tasks, key=lambda x: x[0]))
    Cend = 0
    Jend = 0
    assignment = [''] * N
    try:
        for (s, e, i) in tasks:
            if s >= Cend:
                assignment[i] = ""C""
                Cend = e
            elif s >= Jend:
                assignment[i] = ""J""
                Jend = e
            else:
                return ""IMPOSSIBLE""
    except e:
        return ""IMPOSSIBLE""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000263c7d.PYTHON,2424,93,259,Python,000000000019fd27,0000000000263c7d,000000000020bdf9,SergGr,2020
144621,0000000000262fae,"            assignment[i] = ""J""
            Jend = e
        else:
            # impossible = True
            return ""IMPOSSIBLE""

    # if impossible:
    #     return ""IMPOSSIBLE""
    return """".join(assignment)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000262fae.PYTHON,1050,33,96,Python,000000000019fd27,0000000000262fae,000000000020bdf9,SergGr,2020
144622,00000000002614d6,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline().strip()
    l2 = """"
    open = 0
    last = 0
    for c in line:
        v = int(c)
        if last > v:
            for i in range(v, last):
                l2 += "")""
            open -= (last - v)
        if open < v:
            for i in range(open, v):
                l2 += ""(""
            open = v
        l2 += c
        last = v

    for i in range(open):
        l2 += "")""

    return l2


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000002614d6.PYTHON,2179,88,245,Python,000000000019fd27,00000000002614d6,0000000000209a9f,SergGr,2020
144623,000000000025f44a,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    N = int(line.split()[0])
    matr = []
    tr = 0
    rcnt = 0
    colcnt = 0
    for i in range(N):
        line = f.readline()
        arr = map(int, line.split())
        tr += arr[i]
        if len(set(arr)) != N:
            rcnt += 1
        matr.append(arr)

    for i in range(N):
        col = []
        for j in range(N):
            col.append(matr[j][i])
        if len(set(col)) != N:
            colcnt += 1

    return ""{0} {1} {2}"".format(tr, rcnt,colcnt)

def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000025f44a.PYTHON,2107,84,227,Python,000000000019fd27,000000000025f44a,000000000020993c,SergGr,2020
390097,0000000000306cc8,"from __future__ import print_function
import sys
import time
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18
a14 = 2 ** 14
a11 = 2 ** 11
a9 = 2 ** 9

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


def runSingleTest0(inpF, outF, A, B):
    for x in range(-5, 6):
        for y in range(-5, 6):
            print(""{0} {1}"".format(x, y), file=outF)
            line = inpF.readline().strip()
            if ""CENTER"" == line:
                return True
    return False


def test(inpF, outF, x, y):
    print(""{0} {1}"".format(x, y), file=outF)
    line = inpF.readline().strip()
    if ""CENTER"" == line:
        raise ImportError(""AAA"")
    good = ""HIT"" == line
    return good


def bisect_lr(inpF, outF, xl0, xr0, y):
    xl = xl0
    xr = xr0
    while xl + 1 < xr:
        x = (xl + xr) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            xr = x
        else:
            xl = x
    return xr


def bisect_rl(inpF, outF, xl0, xr0, y):
    xl = xl0
    xr = xr0
    while xl + 1 < xr:
        x = (xl + xr) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            xl = x
        else:
            xr = x
    return xl


def bisect_bt(inpF, outF, yb0, yt0, x):
    yt = yt0
    yb = yb0
    while yb + 1 < yt:
        y = (yb + yt) / 2
        hit = test(inpF, outF, x, y)
        if not hit:
            yb = y
        else:
            yt = y
    return yt


def bisect_tb(inpF, outF, yb0, yt0, x):
    yt = yt0
    yb = yb0
    while yb + 1 < yt:
        y = (yb + yt) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            yb = y
        else:
            yt = y
    return yb


# def runSingleTest(inpF, outF):
def runSingleTest(inpF, outF, A, B):
    R = A

    S = 10 ** 9
    centers = [0, -S, -S // 2, -S // 3, -S // 4,
               S // 4, S // 3, S // 2, S]

    try:
        xc = 0
        yc = 0
        for x, y in itertools.product(centers, repeat=2):
            if test(inpF, outF, x, y):
                xc = x
                yc = y
                break

        xl0 = bisect_lr(inpF, outF, -S, xc, yc)
        xr0 = bisect_rl(inpF, outF, xc, S, yc)
        yb0 = bisect_bt(inpF, outF, -S, yc, xc)
        yt0 = bisect_tb(inpF, outF, yc, S, xc)
        dbg_print(""x0 = {0} ; {1}"".format(xl0, xr0))
        dbg_print(""y0 = {0} ; {1}"".format(yb0, yt0))
        x0 = (xl0 + xr0) / 2
        y0 = (yt0 + yb0) / 2
        test(inpF, outF, x0, y0)
        for x in range(x0 - 2, x0 + 3):
            for y in range(y0 - 2, y0 + 3):
                test(inpF, outF, x, y)
    except ImportError:
        return True

    return False

    # guess = [x, y]
    # dbg_print(guess)
    # guess_str = "" "".join(map(str, guess))
    #
    # dbg_print(""Guess = "" + guess_str)
    # print(guess_str, file=outF)
    # success = inpF.readline().strip()
    # dbg_print(""Success: "" + success)
    # return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF
        self.cnt = 0

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing {1} '{0}'"".format(str.replace(""\n"", ""\\n""), self.cnt))
        if (""\n"" in str):
            self.cnt += 1
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, A, B = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        outF.cnt = 1
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        # success = runSingleTest(inpF, outF)
        success = runSingleTest(inpF, outF, A, B)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000306cc8.PYTHON,5838,236,768,Python,000000000019fef2,0000000000306cc8,00000000002d5b63,SergGr,2020
390098,000000000030681f,"from __future__ import print_function
import sys
import time
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18
a14 = 2 ** 14
a11 = 2 ** 11
a9 = 2 ** 9

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


def runSingleTest0(inpF, outF, A, B):
    for x in range(-5, 6):
        for y in range(-5, 6):
            print(""{0} {1}"".format(x, y), file=outF)
            line = inpF.readline().strip()
            if ""CENTER"" == line:
                return True
    return False


def test(inpF, outF, x, y):
    print(""{0} {1}"".format(x, y), file=outF)
    line = inpF.readline().strip()
    if ""CENTER"" == line:
        raise ImportError(""AAA"")
    good = ""HIT"" == line
    return good


def bisect_lr(inpF, outF, xl0, xr0, y):
    xl = xl0
    xr = xr0
    while xl + 1 < xr:
        x = (xl + xr) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            xr = x
        else:
            xl = x
    return xr


def bisect_rl(inpF, outF, xl0, xr0, y):
    xl = xl0
    xr = xr0
    while xl + 1 < xr:
        x = (xl + xr) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            xl = x
        else:
            xr = x
    return xl


def bisect_bt(inpF, outF, yb0, yt0, x):
    yt = yt0
    yb = yb0
    while yb + 1 < yt:
        y = (yb + yt) / 2
        hit = test(inpF, outF, x, y)
        if not hit:
            yb = y
        else:
            yt = y
    return yt


def bisect_tb(inpF, outF, yb0, yt0, x):
    yt = yt0
    yb = yb0
    while yb + 1 < yt:
        y = (yb + yt) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            yb = y
        else:
            yt = y
    return yb


# def runSingleTest(inpF, outF):
def runSingleTest(inpF, outF, A, B):
    R = A

    S = 10 ** 9
    centers = [0, -S, -S // 2, -S // 3,
               S // 3, S // 2, S]

    try:

        xc = 0
        yc = 0
        for x, y in itertools.product(centers, repeat=2):
            if test(inpF, outF, x, y):
                xc = x
                yc = y
                break

        xl0 = bisect_lr(inpF, outF, -S, xc, yc)
        xr0 = bisect_rl(inpF, outF, xc, S, yc)
        yb0 = bisect_bt(inpF, outF, -S, yc, xc)
        yt0 = bisect_tb(inpF, outF, yc, S, xc)
        dbg_print(""x0 = {0} ; {1}"".format(xl0, xr0))
        dbg_print(""y0 = {0} ; {1}"".format(yb0, yt0))
        x0 = (xl0 + xr0) / 2
        y0 = (yt0 + yb0) / 2
        test(inpF, outF, x0, y0)
        for x in range(x0 - 2, x0 + 3):
            for y in range(y0 - 2, y0 + 3):
                test(inpF, outF, x, y)
    except ImportError:
        return True

    return False

    # guess = [x, y]
    # dbg_print(guess)
    # guess_str = "" "".join(map(str, guess))
    #
    # dbg_print(""Guess = "" + guess_str)
    # print(guess_str, file=outF)
    # success = inpF.readline().strip()
    # dbg_print(""Success: "" + success)
    # return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF
        self.cnt = 0

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing {1} '{0}'"".format(str.replace(""\n"", ""\\n""), self.cnt))
        if (""\n"" in str):
            self.cnt += 1
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, A, B = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        outF.cnt = 1
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        # success = runSingleTest(inpF, outF)
        success = runSingleTest(inpF, outF, A, B)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000030681f.PYTHON,5822,237,762,Python,000000000019fef2,000000000030681f,00000000002d5b63,SergGr,2020
390099,00000000003050c5,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18
a14 = 2 ** 14
a11 = 2 ** 11
a9 = 2 ** 9

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


def runSingleTest0(inpF, outF, A, B):
    for x in range(-5, 6):
        for y in range(-5, 6):
            print(""{0} {1}"".format(x, y), file=outF)
            line = inpF.readline().strip()
            if ""CENTER"" == line:
                return True
    return False


def test(inpF, outF, x, y):
    print(""{0} {1}"".format(x, y), file=outF)
    line = inpF.readline().strip()
    if ""CENTER"" == line:
        raise ImportError(""AAA"")
    good = ""HIT"" == line
    return good


def bisect_lr(inpF, outF, xl0, xr0, y):
    xl = xl0
    xr = xr0
    while xl + 1 < xr:
        x = (xl + xr) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            xr = x
        else:
            xl = x
    return xr


def bisect_rl(inpF, outF, xl0, xr0, y):
    xl = xl0
    xr = xr0
    while xl + 1 < xr:
        x = (xl + xr) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            xl = x
        else:
            xr = x
    return xl


def bisect_bt(inpF, outF, yb0, yt0, x):
    yt = yt0
    yb = yb0
    while yb + 1 < yt:
        y = (yb + yt) / 2
        hit = test(inpF, outF, x, y)
        if not hit:
            yb = y
        else:
            yt = y
    return yt


def bisect_tb(inpF, outF, yb0, yt0, x):
    yt = yt0
    yb = yb0
    while yb + 1 < yt:
        y = (yb + yt) / 2
        hit = test(inpF, outF, x, y)
        if hit:
            yb = y
        else:
            yt = y
    return yb


# def runSingleTest(inpF, outF):
def runSingleTest(inpF, outF, A, B):
    R = A

    try:
        S = 10 ** 9
        xl0 = bisect_lr(inpF, outF, -S, 0, 0)
        xr0 = bisect_rl(inpF, outF, 0, S, 0)
        yb0 = bisect_bt(inpF, outF, -S, 0, 0)
        yt0 = bisect_tb(inpF, outF, 0, S, 0)
        dbg_print(""x0 = {0} ; {1}"".format(xl0, xr0))
        dbg_print(""y0 = {0} ; {1}"".format(yb0, yt0))
        x0 = (xl0 + xr0) / 2
        y0 = (yt0 + yb0) / 2
        test(inpF, outF, x0, y0)
    except ImportError:
        return True

    return False

    # guess = [x, y]
    # dbg_print(guess)
    # guess_str = "" "".join(map(str, guess))
    #
    # dbg_print(""Guess = "" + guess_str)
    # print(guess_str, file=outF)
    # success = inpF.readline().strip()
    # dbg_print(""Success: "" + success)
    # return success == '1'


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF
        self.cnt = 0

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing {1} '{0}'"".format(str.replace(""\n"", ""\\n""), self.cnt))
        if (""\n"" in str):
            self.cnt += 1
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, A, B = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        outF.cnt = 1
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        # success = runSingleTest(inpF, outF)
        success = runSingleTest(inpF, outF, A, B)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000003050c5.PYTHON,5406,221,697,Python,000000000019fef2,00000000003050c5,00000000002d5b63,SergGr,2020
390100,0000000000300e2a,"from __future__ import print_function
import sys
import time

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

inputFileName = None
outputFileName = None

# inputFileName = ""test.in""
# inputFileName = ""A-small-attempt0.in""
# inputFileName = ""A-large.in""

if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""

import platform

global MY_DEBUG
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])


def dbg_print(s):
    if MY_DEBUG:
        logF.write('{0}\n'.format(s))
        logF.flush()


logF = None
if MY_DEBUG:
    logF = open(""run.log"", 'w')

startTime = time.time()
dbg_print(startTime)

a220 = 2 ** 220
a56 = 2 ** 56
a28 = 2 ** 28
a18 = 2 ** 18
a14 = 2 ** 14
a11 = 2 ** 11
a9 = 2 ** 9

a55 = 2 ** 55
a44 = 2 ** 44
a36 = 2 ** 36


# def runSingleTest(inpF, outF):
def runSingleTest1(inpF, outF, A, B):
    R = A

    cnt = 0
    x = -10 ** 9
    y = 0
    while True:
        cnt += 1
        print(""{0} {1}"".format(x, y), file=outF)
        line = inpF.readline().strip()
        if ""CENTER"" == line:
            return True
        good = ""HIT"" == line
        if good:
            dbg_print(""Found hit at {0} {1}"".format(x, y))
            break
        x += 1

        cnt += 1
        print(""{0} {1}"".format(x, y + 1), file=outF)
        line = inpF.readline().strip()
        if ""CENTER"" == line:
            return True
        good = ""HIT"" == line

    guess = [x, y]
    dbg_print(guess)
    guess_str = "" "".join(map(str, guess))

    dbg_print(""Guess = "" + guess_str)
    print(guess_str, file=outF)
    success = inpF.readline().strip()
    dbg_print(""Success: "" + success)
    return success == '1'


def runSingleTest(inpF, outF, A, B):
    for x in range(-5, 6):
        for y in range(-5, 6):
            print(""{0} {1}"".format(x, y), file=outF)
            line = inpF.readline().strip()
            if ""CENTER"" == line:
                return True
    return False


class InpFWrapper:
    def __init__(self, inpF):
        self.inpF = inpF

    def readline(self):
        line = self.inpF.readline()
        dbg_print(""Read line is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line

    def readline_safe(self):
        line = self.inpF.readline()
        dbg_print(""Read line safe is '{0}'"".format(line.replace(""\r"", ""\\r"").replace(""\n"", ""\\n"")))
        return line[0:-1] if (line[-1] == '\n') else line


class OutFWrapper:
    def __init__(self, outF):
        self.outF = outF

    def __getattr__(self, name):
        # dbg_print('Accessing {0}'.format(name))
        return getattr(self.outF, name)

    def write(self, str):
        dbg_print(""Writing '{0}'"".format(str.replace(""\n"", ""\\n"")))
        self.outF.write(str)
        self.outF.flush()


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
        # dbg_print('before sleep')
        # time.sleep(10)
        # dbg_print('after sleep')
    inpF = InpFWrapper(inpF)
    outF = OutFWrapper(outF)
    line = inpF.readline()
    # testsCount = int(line)
    testsCount, A, B = [int(x) for x in line.split()]
    # testsCount, N, M = 1, 7, 1000000
    goodCount = 0
    badCount = 0
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        # success = runSingleTest(inpF, outF)
        success = runSingleTest(inpF, outF, A, B)
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        if not success:
            badCount += 1
            break
        else:
            goodCount += 1
    dbg_print(""Good count = {0} of {2}, bad count = {1}"".format(goodCount, badCount, testsCount))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000300e2a.PYTHON,4193,162,478,Python,000000000019fef2,0000000000300e2a,00000000002d5b63,SergGr,2020
390101,00000000002fd152,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest0(f):
    line = f.readline().strip()
    TX, TY = [int(x) for x in line.split()]

    maxN = 9
    # maxN = 5
    sizes = [2 ** i for i in range(maxN)]
    dirs = [('N', 0, 1), ('S', 0, -1), ('E', 1, 0), ('W', -1, 0)]
    bestPath = None
    bestLen = len(sizes) + 1
    for cur_dirs in itertools.product(dirs, repeat=len(sizes)):
        x = y = 0
        path = """"
        step = 1
        cnt = 0
        for d in cur_dirs:
            path += d[0]
            x += step * d[1]
            y += step * d[2]
            step *= 2
            cnt += 1
            # if x == TX and y == TY and path != bestPath:
            #     print path
            if cnt <= bestLen:
                if x == TX and y == TY:
                    bestPath = path
                    bestLen = cnt
            else:
                break

        # print dir
    if bestPath is not None:
        return bestPath

    return ""IMPOSSIBLE""


def try_match(t, vals, dirs):
    cur = 0
    out = []
    for v in reversed(vals):
        if cur < t:
            cur += v
            out.append((v, dirs[0]))
        else:
            out.append((v, dirs[1]))
            cur -= v
    return out if cur == t else None


def calcSingleTest(f):
    line = f.readline().strip()
    TX, TY = [int(x) for x in line.split()]

    maxN = 9
    # maxN = 5
    bestPath = None
    bestLen = maxN + 2
    lastLen = -1
    while bestLen != lastLen:
        lastLen = bestLen
        for cur_dirs in itertools.product([True, False], repeat=bestLen - 1):
            xs = []
            ys = []
            x = y = 0
            path = """"
            step = 1
            cnt = 0
            for d in cur_dirs:
                if d:
                    xs.append(step)
                else:
                    ys.append(step)
                mx = try_match(TX, xs, ""EW"")
                my = try_match(TY, ys, ""NS"")
                if mx != None and my != None:
                    m = list(sorted(mx + my, key=lambda t: t[0]))
                    path = ''.join([t[1] for t in m])
                    bestPath = path
                    bestLen = len(bestPath)
                    break
                step *= 2

        # print dir
    if bestPath is not None:
        return bestPath

    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000002fd152.PYTHON,4060,160,498,Python,000000000019fef2,00000000002fd152,00000000002d5b62,SergGr,2020
390102,00000000002f95c8,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest(f):
    line = f.readline().strip()
    TX, TY = [int(x) for x in line.split()]

    # maxN = 9
    maxN = 5
    sizes = [2 ** i for i in range(maxN)]
    dirs = [('N', 0, 1), ('S', 0, -1), ('E', 1, 0), ('W', -1, 0)]
    bestPath = None
    bestLen = len(sizes) + 1
    for cur_dirs in itertools.product(dirs, repeat=len(sizes)):
        x = y = 0
        path = """"
        step = 1
        cnt = 0
        for d in cur_dirs:
            path += d[0]
            x += step * d[1]
            y += step * d[2]
            step *= 2
            cnt += 1
            if cnt <= bestLen:
                if x == TX and y == TY:
                    bestPath = path
                    bestLen = cnt
            else:
                break

        # print dir
    if bestPath is not None:
        return bestPath

    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000002f95c8.PYTHON,2615,105,315,Python,000000000019fef2,00000000002f95c8,00000000002d5b62,SergGr,2020
390103,00000000002f9550,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest(f):
    line = f.readline().strip()
    TX, TY = [int(x) for x in line.split()]

    maxN = 9
    # maxN = 5
    sizes = [2 ** i for i in range(maxN)]
    dirs = [('N', 0, 1), ('S', 0, -1), ('E', 1, 0), ('W', -1, 0)]
    bestPath = None
    bestLen = len(sizes) + 1
    for cur_dirs in itertools.product(dirs, repeat=len(sizes)):
        x = y = 0
        path = """"
        step = 1
        cnt = 0
        for d in cur_dirs:
            path += d[0]
            x += step * d[1]
            y += step * d[2]
            step *= 2
            cnt += 1
            if cnt <= bestLen:
                if x == TX and y == TY:
                    bestPath = path
                    bestLen = cnt
            else:
                break

        # print dir
    if bestPath is not None:
        return bestPath

    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000002f9550.PYTHON,2615,105,315,Python,000000000019fef2,00000000002f9550,00000000002d5b62,SergGr,2020
390104,00000000002f936e,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['SergGrs-MBP', 'HOMEPC3', 'lenovo-think'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest(f):
    line = f.readline().strip()
    TX, TY = [int(x) for x in line.split()]

    sizes = [2 ** i for i in range(9)]
    dirs = [('N', 0, 1), ('S', 0, -1), ('E', 1, 0), ('W', -1, 0)]
    bestPath = None
    bestLen = len(sizes) + 1
    for cur_dirs in itertools.product(dirs, repeat=len(sizes)):
        x = y = 0
        path = """"
        step = 1
        cnt = 0
        for d in cur_dirs:
            path += d[0]
            x += step * d[1]
            y += step * d[2]
            step *= 2
            cnt += 1
            if cnt <= bestLen:
                if x == TX and y == TY:
                    bestPath = path
                    bestLen = cnt
            else:
                break

        # print dir
    if bestPath is not None:
        return bestPath

    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",00000000002f936e.PYTHON,2584,103,308,Python,000000000019fef2,00000000002f936e,00000000002d5b62,SergGr,2020
496067,000000000033f421,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
from collections import defaultdict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MacBook-Pro',
                                                                'SergGrs-MacBook-Pro.local'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcDxDy(p0, p1):
    x0, y0 = p0
    x1, y1 = p1
    dx = x1 - x0
    dy = y1 - y0
    g = gcd(dx, dy)
    dx1 = dx / g
    dy1 = dy / g
    if dx1 < 0:
        dx1, dy1 = -dx1, -dy1
    return dx1, dy1


def calcSingleTest1(N, points):
    if N <= 4:
        return N
    best = 4
    for order in itertools.permutations(points):
        p00 = order[1]
        p01 = order[2]
        cur = 3
        dx0, dy0 = calcDxDy(p00, p01)
        for i in range(3, N, 2):
            cur += 1
            p1 = order[i]
            if i + 1 == N:
                break
            p2 = order[i + 1]
            dx, dy = calcDxDy(p1, p2)
            if dx == dx0 and dy == dy0:
                cur += 2
        # if N % 2 == 1 and cur == N - 1:
        #     return N
        if cur > best:
            best = cur

    if best > N:
        best = N
    return best


def calcSingleTest0(N, points):
    # lines = defaultdict(default_factory=lambda qqq: 0)
    # lines = Counter()
    lines = defaultdict(set)
    dirs = Counter()
    dirs_lines = defaultdict(set)
    for i in range(N - 1):
        x0, y0 = points[i]
        for j in range(i + 1, N):
            x1, y1 = points[j]
            dx = x1 - x0
            dy = y1 - y0
            g = gcd(dx, dy)
            dx1 = dx / g
            dy1 = dy / g
            if dx1 < 0:
                dx1, dy1 = -dx1, -dy1
            c = dy1 * x1 + dx1 * y1
            l = (dy1, dx1, c)
            dir = (dy1, dx1)
            lines[l].add((i, x0, y0))
            lines[l].add((j, x1, y1))
            dirs[dir] += 1
            dirs_lines[dir].add(l)

    if MY_DEBUG:
        dbg_print(N)
        dbg_print(dirs)
        dbg_print(lines)
        dbg_print(dirs_lines)

    best = 2
    for dir in dirs:
        cur = 2
        has_odd = False
        for l in dirs_lines[dir]:
            cnt = len(lines[l])
            has_odd = (cnt % 2 == 1)
            cur += (cnt // 2) * 2
        if has_odd:
            cur += 1
        if cur > best:
            best = cur
    if best > N:
        best = N
    return best


def calcSingleTest(f):
    line = f.readline()
    # N = [int(x) for x in line.split()]
    N = int(line)

    points = []
    for i in range(N):
        line = f.readline()
        x, y = [int(zzz) for zzz in line.split()]
        points.append((x, y))

    # return calcSingleTest0(N, points)
    return calcSingleTest1(N, points)


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000033f421.PYTHON,4352,173,548,Python,000000000019ffb9,000000000033f421,00000000003386d0,SergGr,2020
496068,000000000033e1ed,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
from collections import defaultdict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MacBook-Pro',
                                                                'SergGrs-MacBook-Pro.local'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    # N = [int(x) for x in line.split()]
    N = int(line)

    points = []
    for i in range(N):
        line = f.readline()
        x, y = [int(zzz) for zzz in line.split()]
        points.append((x, y))

    # lines = defaultdict(default_factory=lambda qqq: 0)
    # lines = Counter()
    lines = defaultdict(set)
    dirs = Counter()
    dirs_lines = defaultdict(set)
    for i in range(N - 1):
        x0, y0 = points[i]
        for j in range(i + 1, N):
            x1, y1 = points[j]
            dx = x1 - x0
            dy = y1 - y0
            g = gcd(dx, dy)
            dx1 = dx / g
            dy1 = dy / g
            if dx1 < 0:
                dx1, dy1 = -dx1, -dy1
            c = dy1 * x1 + dx1 * y1
            l = (dy1, dx1, c)
            dir = (dy1, dx1)
            lines[l].add((i, x0, y0))
            lines[l].add((j, x1, y1))
            dirs[dir] += 1
            dirs_lines[dir].add(l)

    if MY_DEBUG:
        dbg_print(N)
        dbg_print(dirs)
        dbg_print(lines)
        dbg_print(dirs_lines)

    best = 2
    for dir in dirs:
        cur = 2
        has_odd = False
        for l in dirs_lines[dir]:
            cnt = len(lines[l])
            has_odd = (cnt % 2 == 1)
            cur += (cnt // 2) * 2
        if has_odd:
            cur += 1
        if cur > best:
            best = cur
    if best > N:
        best = N
    return best


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000033e1ed.PYTHON,3378,127,389,Python,000000000019ffb9,000000000033e1ed,00000000003386d0,SergGr,2020
496069,000000000033dcd7,"import itertools
import time
import operator
# import collections
from collections import Counter
from collections import OrderedDict
from collections import defaultdict
import bisect
from fractions import gcd

import sys

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MacBook-Pro',
                                                                'SergGrs-MacBook-Pro.local'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""B-small-attempt0.in""
# inputFileName = ""B-small-attempt1.in""
# inputFileName = ""B-small-attempt2.in""
# inputFileName = ""B-small-attempt3.in""
# inputFileName = ""B-large.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def calcSingleTest(f):
    line = f.readline()
    # N = [int(x) for x in line.split()]
    N = int(line)

    points = []
    for i in range(N):
        line = f.readline()
        x, y = [int(zzz) for zzz in line.split()]
        points.append((x, y))

    # lines = defaultdict(default_factory=lambda qqq: 0)
    # lines = Counter()
    lines = defaultdict(set)
    dirs = Counter()
    dirs_lines = defaultdict(set)
    for i in range(N - 1):
        x0, y0 = points[i]
        for j in range(i + 1, N):
            x1, y1 = points[j]
            dx = x1 - x0
            dy = y1 - y0
            g = gcd(dx, dy)
            dx1 = dx / g
            dy1 = dy / g
            if dx1 < 0:
                dx1, dy1 = -dx1, -dy1
            c = dy1 * x1 + dx1 * y1
            l = (dy1, dx1, c)
            dir = (dy1, dx1)
            lines[l].add((i, x0, y0))
            lines[l].add((j, x1, y1))
            dirs[dir] += 1
            dirs_lines[dir].add(l)

    if MY_DEBUG:
        dbg_print(N)
        dbg_print(dirs)
        dbg_print(lines)
        dbg_print(dirs_lines)

    best = 2
    for dir in dirs:
        cur = 2
        for l in dirs_lines[dir]:
            cnt = len(lines[l])
            cur += ((cnt + 1) // 2) * 2
        if cur > best:
            best = cur
    if best > N:
        best = N
    return best


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000033dcd7.PYTHON,3282,123,376,Python,000000000019ffb9,000000000033dcd7,00000000003386d0,SergGr,2020
496070,000000000033c195,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
# print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MacBook-Pro',
                                                                'SergGrs-MacBook-Pro.local'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def findSteps(dif, next, step):
    n = 2 * next - step
    x0 = ((n ** 2 + 8 * dif * step) ** 0.5 - n) / 2 / step
    x = int(x0)
    s = x * (2 * next + (x - 1) * step) / 2
    return x, s


def subLeft(l, r, cnt):
    dif = l - r
    next = cnt + 1
    if dif <= next:
        return l - next, r, cnt + 1

    # n = 2 * next - 1
    # x0 = ((n ** 2 + 8 * dif) ** 0.5 - n) / 2
    # x = int(x0)
    # s = x * (2 * next + x - 1) / 2
    x, s = findSteps(dif, next, 1)
    return l - s, r, cnt + x


def subBoth(l, r, cnt):
    next = cnt + 1
    if (l < r) or (l - r >= next):
        return l, r, cnt

    xl, sl = findSteps(l, next, 2)
    xr, sr = findSteps(r, next + 1, 2)
    xr1 = xr - 1
    if xr1 <= 0:
        return l, r, cnt
    sr1 = xr1 * (2 * (next + 1) + (xr1 - 1) * 2) / 2
    sl1 = xr1 * (2 * next + (xr1 - 1) * 2) / 2
    return l - sl1, r - sr1, cnt + 2 * xr1


def calcSingleTest1(L, R):
    l, r = L, R
    cnt = 0
    while True:
        next = cnt + 1
        if l < next and r < next:
            break
        l, r, cnt = subBoth(l, r, cnt)
        next = cnt + 1
        if l < next and r < next:
            break
        if l >= r:
            l, r, cnt = subLeft(l, r, cnt)
        else:
            # l, r, cnt = subRight(l, r, cnt)
            r, l, cnt = subLeft(r, l, cnt)

    return ""{0} {1} {2}"".format(cnt, l, r)
    # return ""IMPOSSIBLE""


def calcSingleTest0(L, R):
    l, r = L, R
    cnt = 0
    while True:
        d = cnt + 1
        if l >= r:
            if l < d:
                break
            else:
                l -= d
        else:
            if r < d:
                break
            else:
                r -= d
        cnt += 1

    return ""{0} {1} {2}"".format(cnt, l, r)
    # return ""IMPOSSIBLE""


def calcSingleTest(f):
    if 1 == 2:
        for i in xrange(100):
            for j in xrange(100):
                a1 = calcSingleTest1(i, j)
                a2 = calcSingleTest0(i, j)
                if a1 != a2:
                    print ""{0},{1}: '{2}' != '{3}'"".format(i, j, a1, a2)
        print ""All fine""
    line = f.readline().strip()

    L, R = [int(x) for x in line.split()]
    return calcSingleTest1(L, R)

    # return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000033c195.PYTHON,3850,155,573,Python,000000000019ffb9,000000000033c195,00000000003384ea,SergGr,2020
496071,000000000033b967,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
# print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MacBook-Pro',
                                                                'SergGrs-MacBook-Pro.local'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def findSteps(dif, next, step):
    n = 2 * next - step
    x0 = ((n ** 2 + 8 * dif * step) ** 0.5 - n) / 2 / step
    x = int(x0)
    s = x * (2 * next + (x - 1) * step) / 2
    return x, s


def subLeft(l, r, cnt):
    dif = l - r
    next = cnt + 1
    if dif <= next:
        return l - next, r, cnt + 1

    # n = 2 * next - 1
    # x0 = ((n ** 2 + 8 * dif) ** 0.5 - n) / 2
    # x = int(x0)
    # s = x * (2 * next + x - 1) / 2
    x, s = findSteps(dif, next, 1)
    return l - s, r, cnt + x


def subBoth(l, r, cnt):
    next = cnt + 1
    if (l < r) or (l - r > 2 * next):
        return l, r, cnt

    xl, sl = findSteps(l, next, 2)
    xr, sr = findSteps(r, next + 1, 2)
    sl1 = xr * (2 * next + (xr - 1) * 2) / 2
    return l - sl1, r - sr, cnt + 2 * xr


def calcSingleTest(f):
    line = f.readline().strip()
    L, R = [int(x) for x in line.split()]

    l, r = L, R
    cnt = 0
    while True:
        next = cnt + 1
        if l < next and r < next:
            break
        l, r, cnt = subBoth(l, r, cnt)
        next = cnt + 1
        if l < next and r < next:
            break
        if l >= r:
            l, r, cnt = subLeft(l, r, cnt)
        else:
            # l, r, cnt = subRight(l, r, cnt)
            r, l, cnt = subLeft(r, l, cnt)

    return ""{0} {1} {2}"".format(cnt, l, r)
    # return ""IMPOSSIBLE""


def calcSingleTest0(f):
    line = f.readline().strip()
    L, R = [int(x) for x in line.split()]

    # l, r, swap = (L, R, False) if L >= R else (R, L, True)
    l, r = L, R
    cnt = 0
    while True:
        d = cnt + 1
        if l >= r:
            if l < d:
                break
            else:
                l -= d
        else:
            if r < d:
                break
            else:
                r -= d
        cnt += 1

    return ""{0} {1} {2}"".format(cnt, l, r)
    # return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000033b967.PYTHON,3489,141,527,Python,000000000019ffb9,000000000033b967,00000000003384ea,SergGr,2020
496072,0000000000339f03,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
# print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MacBook-Pro', 'SergGrs-MacBook-Pro.local'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)



def calcSingleTest(f):
    line = f.readline().strip()
    L, R = [int(x) for x in line.split()]

    # l, r, swap = (L, R, False) if L >= R else (R, L, True)
    l, r = L, R
    cnt = 0
    while True:
        d = cnt + 1
        if l >= r:
            if l < d:
                break
            else:
                l -= d
        else:
            if r < d:
                break
            else:
                r -= d
        cnt += 1

    return ""{0} {1} {2}"".format(cnt, l, r)
    # return ""IMPOSSIBLE""



def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",0000000000339f03.PYTHON,2089,85,234,Python,000000000019ffb9,0000000000339f03,00000000003384ea,SergGr,2020
496073,000000000033a07b,"import sys
import time

import collections
import itertools

# Increase max stack size from 8MB to 512MB
# resource.setrlimit(resource.RLIMIT_STACK, (2**29,-1))
sys.setrecursionlimit(10 ** 6)

import platform

global MY_DEBUG
# MY_DEBUG = False
# print platform.node()
MY_DEBUG = platform.node().lower() in map(lambda s: s.lower(), ['HOMEPC3', 'lenovo-think', 'SergGrs-MBP'])

inputFileName = None
outputFileName = None

if MY_DEBUG:
    inputFileName = ""test.in""
# inputFileName = ""A-small-attempt1.in""
if inputFileName is not None:
    outputFileName = inputFileName[:-3] + "".out""


def dbg_print(s):
    if MY_DEBUG:
        print ('{0}'.format(s))


startTime = time.time()
dbg_print(startTime)


def map_dir(ch):
    if ch == 'N':
        return (0, 1)
    elif ch == 'S':
        return (0, -1)
    elif ch == 'W':
        return (-1, 0)
    elif ch == 'E':
        return (1, 0)
    else:
        raise AssertionError(""Bad char '"" + ch + ""'"")


def calcSingleTest0(f):
    line = f.readline().strip()
    L, R = [int(x) for x in line.split()]

    # l, r, swap = (L, R, False) if L >= R else (R, L, True)
    l, r = L, R
    cnt = 0
    while True:
        d = cnt + 1
        if l >= r:
            if l < d:
                break
            else:
                l -= d
        else:
            if r < d:
                break
            else:
                r -= d
        cnt += 1

    return ""{0} {1} {2}"".format(cnt, l, r)
    # return ""IMPOSSIBLE""


def try_match(t, vals, dirs):
    cur = 0
    out = []
    for v in reversed(vals):
        if cur < t:
            cur += v
            out.append((v, dirs[0]))
        else:
            out.append((v, dirs[1]))
            cur -= v
    return out if cur == t else None


def calcSingleTest(f):
    line = f.readline().strip()
    TX, TY = [int(x) for x in line.split()]

    maxN = 32
    # maxN = 5
    bestPath = None
    bestLen = maxN + 2
    lastLen = -1
    while bestLen != lastLen:
        lastLen = bestLen
        for cur_dirs in itertools.product([True, False], repeat=bestLen - 1):
            xs = []
            ys = []
            x = y = 0
            path = """"
            step = 1
            cnt = 0
            for d in cur_dirs:
                if d:
                    xs.append(step)
                else:
                    ys.append(step)
                mx = try_match(TX, xs, ""EW"")
                my = try_match(TY, ys, ""NS"")
                if mx != None and my != None:
                    m = list(sorted(mx + my, key=lambda t: t[0]))
                    path = ''.join([t[1] for t in m])
                    bestPath = path
                    bestLen = len(bestPath)
                    break
                step *= 2

        # print dir
    if bestPath is not None:
        return bestPath

    return ""IMPOSSIBLE""


def myMain(inpF, outF):
    if (MY_DEBUG):
        dbg_print('input = {0}, out = {1}'.format(inputFileName, outputFileName))
    line = inpF.readline()
    testsCount = int(line)
    for i in xrange(1, testsCount + 1):
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))
        res = calcSingleTest(inpF)
        outF.write('Case #{0}: {1}\n'.format(i, res))
        outF.flush()
        dbg_print('--------  {0}/{1} {2} --------------------------'.format(i, testsCount, (time.time() - startTime)))


if inputFileName is not None:
    with open(inputFileName) as inpF:
        with open(outputFileName, 'w') as outF:
            myMain(inpF, outF)
else:
    myMain(sys.stdin, sys.stdout)

dbg_print(""Finished!!!! Total time = {0}"".format((time.time() - startTime)))
",000000000033a07b.PYTHON,3659,149,439,Python,000000000019ffb9,000000000033a07b,00000000003384ea,SergGr,2020
